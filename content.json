{"meta":{"title":"Jon's Blog","subtitle":"Cease to struggle and you cease to live. - Thomas Carlyle","description":"","author":"Jon","url":"https://noteforme.github.io","root":"/"},"pages":[{"title":"categories","date":"2017-08-01T05:08:13.000Z","updated":"2021-08-19T11:11:44.326Z","comments":false,"path":"categories/index.html","permalink":"https://noteforme.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-08T02:14:45.000Z","updated":"2021-08-19T11:11:44.326Z","comments":false,"path":"tags/index.html","permalink":"https://noteforme.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2024-10-01T12:10:00.000Z","updated":"2024-10-01T12:11:12.633Z","comments":false,"path":"about/index.html","permalink":"https://noteforme.github.io/about/index.html","excerpt":"","text":"title: aboutlayout: about这里写关于页的正文，支持 Markdown, HTML"}],"posts":[{"title":"os_mit","slug":"os-mit","date":"2025-03-22T12:25:52.000Z","updated":"2025-03-22T12:59:56.127Z","comments":true,"path":"2025/03/22/os-mit/","link":"","permalink":"https://noteforme.github.io/2025/03/22/os-mit/","excerpt":"","text":"MIT OS environmenthttps://hub.docker.com/r/calvinhaynes412/mit6.s081 https://docs.docker.com/reference/cli/docker/container/ 1234docker pull calvinhaynes412/mit6.s081:v1.3.1git clone git@github.com:BlogForMe/20labs.gitdocker run -p 8848:8848 --name=mit6.s081 -u 0:0 -v &quot;/home/m/20labs:/mit6.s081&quot; calvinhaynes412/mit6.s081:v1.3.1 本地用户浏览器访问 http://localhost:8848/ 密码： mit6s081. 服务器端用户浏览器访问http:&#x2F;&#x2F;&lt;服务器公网ip&gt;:8848&#x2F; 密码： mit6s081. https://docs.docker.com/reference/cli/docker/container/ run docker 1234docker container ls -a//hodocker container start cf5ce745d947 https://hub.docker.com/search?q=s081&amp;architecture=amd64","categories":[{"name":"OS","slug":"OS","permalink":"https://noteforme.github.io/categories/OS/"}],"tags":[]},{"title":"C-Pointer","slug":"C-Pointer","date":"2025-03-09T14:01:06.000Z","updated":"2025-03-10T00:48:40.098Z","comments":true,"path":"2025/03/09/C-Pointer/","link":"","permalink":"https://noteforme.github.io/2025/03/09/C-Pointer/","excerpt":"","text":"1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char buf[512]; // Buffer to hold our modified path. char *p; // Pointer used to manipulate buf. char path[] = &quot;folder&quot;; // Original path. // Copy the string &quot;folder&quot; into buf. strcpy(buf, path); // Set pointer p to the end of the string in buf. p = buf + strlen(buf); // Append a &#x27;/&#x27; character at the current position and then increment p. *p++ = &#x27;/&#x27;; // Append the null terminator to complete the string. *p = &#x27;\\0&#x27;; // Output the modified string. printf(&quot;Modified path: %s\\n&quot;, buf); return 0;&#125; output: Modified path: folder/","categories":[{"name":"CPP","slug":"CPP","permalink":"https://noteforme.github.io/categories/CPP/"}],"tags":[]},{"title":"Docker_Config","slug":"Docker-Config","date":"2025-02-16T14:33:52.000Z","updated":"2025-03-22T14:43:55.060Z","comments":true,"path":"2025/02/16/Docker-Config/","link":"","permalink":"https://noteforme.github.io/2025/02/16/Docker-Config/","excerpt":"","text":"PROXYImage proxyhttps://docs.docker.com/engine/daemon/proxy/ vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 1234567&#123; &quot;proxies&quot;: &#123; &quot;http-proxy&quot;: &quot;http://127.0.0.1:13658&quot;, &quot;https-proxy&quot;: &quot;http://127.0.0.1:13658&quot;, &quot;no-proxy&quot;: &quot;*.test.example.com,.example.org,127.0.0.0/8&quot; &#125;&#125; sudo mkdir -p &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf 1234[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:7897&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7897&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.1,docker-registry.example.com,.corp&quot; IMAGE1docker images traefik v2.11 d7d7095a482f 2 weeks ago 178MBphpmyadmin latest 834a66ad6967 3 weeks ago 570MBhello-world latest 74cc54e27dc4 3 weeks ago 10.1kBmysql 8.0 6616596982ed 3 weeks ago 764MBdocker&#x2F;welcome-to-docker latest c1f619b6477e 15 months ago 18.6MB 1docker rmi traefik:v2.11 Untagged: traefik:v2.11Deleted: sha256:d7d7095a482f62a90d32807bd051fbd28763eaf0085ebe210dd2d4b3bf3e9660 IMAGE ID 1docker rmi 834a66ad6967 Untagged: phpmyadmin:latestUntagged: phpmyadmin@sha256:b8e9de0186fe7e12e3a9565432c9faf6e8f0ec0f78f07bc3625910fd130afb99 Containerhttps://docs.docker.com/reference/cli/docker/container/ 1docker run -p 8848:8848 --name=mit6.s081 -u 0:0 -v &quot;/home/m/20labs:/mit6.s081&quot; calvinhaynes412/mit6.s081:v1.3.1 https://docs.docker.com/reference/cli/docker/container/ run docker 1234docker container ls -a//hodocker container start cf5ce745d947 https://hub.docker.com/r/calvinhaynes412/mit6.s081 https://hub.docker.com/search?q=s081&amp;architecture=amd64 123docker container exec -it b66e8a0c279a /bin/bashdocker run --rm -it -v /home/m/aosp8:/aosp sabdelkader/aosp 当前主机 &#x2F; docker容器内的目录","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"C_MAKEFILE","slug":"C-MAKEFILE","date":"2025-02-04T13:57:48.000Z","updated":"2025-02-12T13:53:45.841Z","comments":true,"path":"2025/02/04/C-MAKEFILE/","link":"","permalink":"https://noteforme.github.io/2025/02/04/C-MAKEFILE/","excerpt":"","text":"GCCCourse resources 12. Compilation and Makefiles https://cse.msu.edu/~cse251/ code.c 1234567891011#include &lt;stdio.h&gt; #include &lt;math.h&gt;#define NumIter 5int main() &#123;int i;for (i=1; i&lt;=NumIter; i++) printf(&quot;PI^%d is %f\\n&quot;, i,i);return 0;&#125; Preprocessing Removes preprocessor directives (commands that start with #) Producescode.i Don’tusedirectly 1gcc -E code.c &gt; code.i output: code.i Compiling Convertssourcecodetomachinelanguagewithunresolveddirectives Producesthecode.obinary 1gcc -o code.o -c code.i output: code.o Linking Createsmachinelanguageexectutable Producesthecodebinarybylinkingwiththemathlibrary(‐lm) 1gcc -lm -o code code.o output: code -c (Compile only) i think it equals gcc -E and gcc - o Purpose: Tells GCC to compile the source code into an object file (.o or .obj), but not to link it. Usage: This is used when you want to compile source files without producing an executable, typically to be linked later in a separate step. Example : 1bash Copygcc -c myfile.c 1This will produce an object file myfile.o 1without linking. Makefilehttps://www.gnu.org/software/make/manual/make.html Make&#x2F;make.md · 无限十三年&#x2F;CPP - Gitee.com https://www.bilibili.com/video/BV1Bv4y1J7QT hello.cpp 1234567#include &lt;stdio.h&gt;int main() &#123; // Print &quot;Hello, World!&quot; to the console printf(&quot;Hello, World!\\n&quot;); return 0;&#125; MakeFile 12hello: hello.cpp g++ hello.cpp -o hello make","categories":[{"name":"CPP","slug":"CPP","permalink":"https://noteforme.github.io/categories/CPP/"}],"tags":[]},{"title":"AOSP_LOG","slug":"AOSP-LOG","date":"2025-01-12T03:12:40.000Z","updated":"2025-01-27T00:00:36.929Z","comments":true,"path":"2025/01/12/AOSP-LOG/","link":"","permalink":"https://noteforme.github.io/2025/01/12/AOSP-LOG/","excerpt":"","text":"而如果选择学习C++，则非常推荐你学习Standford的CS106B&#x2F;CS106X. https://hackway.org/docs/cs/map/#-c%E6%88%96java 安卓巴士Android系统定制十八-修改系统APP后进行编译-科技-高清完整正版视频在线观看-优酷 安卓巴士Android系统定制十九-Dalvik&amp;ART的区别及ODEX文件介绍-教育-高清完整正版视频在线观看-优酷 安卓巴士Android系统定制二十-编译时odex化的原因-教育-高清完整正版视频在线观看-优酷 安卓巴士Android系统定制二十一-修改Calclator.apk代码并运行-教育-高清完整正版视频在线观看-优酷 安卓巴士Android系统定制二十二-Framework定制及Mac环境介绍-教育-高清完整正版视频在线观看-优酷 安卓巴士Android系统定制二十五-liblog.so(native层）的修改与编译-科技-高清完整正版视频在线观看-优酷 time: 8:00 123456789source build/envsetup.shmake systemimagemm -B // clean firstly then build /home/m/ANDROID12/out/target/product/generic/system/app/ FILE Permission 安卓巴士android系统定制四常见Linux命令介绍-下-教育-高清完整正版视频在线观看-优酷 start flow 启动流程 AOSP下的系统开发第一个方向：以前是搞android应用开发，现在负责系统application开发，这样就会上手非常 - 掘金 在packages&#x2F;apps找到需要修改的相应app。在该app目录中是属于java的部分，与android应用的开发语言相同。但是与平常的app在androidstudio编写不同，在源码环境中，需要利用编辑器来进行编辑。并且在源码中的编译就需要利用make编译系统进行编译。源码的编译是以模块进行。利用mm命令进行编译。编译完成之后，会生成odex以及apk。与普通的apk的结构不同，系统编译生成的application分成了两部分： apk包括了签名，资源，AndroidMannifest清单文件,资源的二进制文件。 而原本的classes.dex则被放在了odex这一部分中。 为什么apk分成了两个文件，这就是Dalvik与art虚拟机的区别：Dalvik：JIT(just in time)实时编译,运行的时候将字节码翻译成机器码,所运行的目标文件与硬件平台无关,app运行效率低ART:AOT(Ahead of time)预先编译,运行前将字节码翻译成机器码,所运行的目标文件(oat)与硬件平台相关.app运行效率高。但会占用空间。APK安装所需时间增加 2.1 odex是干什么的 Dalvik时代：apk运行的时候，会把apk的classes.dex解压出来并通过dexopt优化为.odex文件,缓存在&#x2F;data&#x2F;dalvik-cache目录下,提高后续执行的效率。这也是android被诟病的比较卡。 ART时代：apk安装的时候，会把apk的classes.dex解压后,通过dex2oat工具转化为.odex文件(ELF格式，与Dalvik时代的.odex文件完全不同，只是为了和以前的Dalvik时代的命名相同，内容完全不同),存储在apk所在目录的oat目录下。用空间换时间 2.2 为什么在源码环境编译生成了odex文件ROM：apk，jar，bin，so等组成优点: 降低系统更新后启动的时间：未做odex的Rom，首次开机的过程会执行odex操作。编译时做，开机时候就不用做了 减少在设备上进行odex操作所造成的空间浪费：编译时进行dexopt&#x2F;dex2oat，会直接将apk资源与代码拆开。如果在设备上安装时进行dexopt&#x2F;dex2oat,apk的大小不会减少,但又会多一个odex文件占据磁盘空间 缺点: 增加开发的编译时间 不能直接执行apk的install操作,需要将apk和odex都sync到设备上 2.2.1 如何在开发阶段关闭dex2oat 在当前module的Android.mk里增加: LOCAL_DEX_PREOAT = false 在build&#x2F;core&#x2F;main.mk中关闭所有module的dex优化: 链接：https://juejin.cn/post/6872647317393145864 Application changechange App CalenderAllInOneActivity 12345@Overrideprotected void onCreate(Bundle icicle) &#123; super.onCreate(icicle); Log.wtf(TAG, &quot;jon app developer&quot;);&#125; replace app1adb install -r &#x27;/home/m/ANDROID12/out/target/product/emulator_x86_64/product/app/Calendar/Calendar.apk&#x27; check logs1234adb shellemulator_x86_64:/ # logcat -s &quot;AllInOneActivity&quot;--------- beginning of main01-21 21:22:29.426 1914 1914 E AllInOneActivity: jon app develope Framework change","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"English-Grammar","slug":"English-Grammar","date":"2024-11-17T13:45:28.000Z","updated":"2024-11-17T13:48:09.274Z","comments":true,"path":"2024/11/17/English-Grammar/","link":"","permalink":"https://noteforme.github.io/2024/11/17/English-Grammar/","excerpt":"","text":"will vs be going to课程老师说 be going to 表示现在发生的事情 arrangement : use present continuous for prediction : use will&#x2F;won’t for intention : use going to","categories":[],"tags":[]},{"title":"Deutsch","slug":"Deutsch","date":"2024-11-16T00:49:30.000Z","updated":"2024-11-16T15:06:57.409Z","comments":true,"path":"2024/11/16/Deutsch/","link":"","permalink":"https://noteforme.github.io/2024/11/16/Deutsch/","excerpt":"","text":"RESOURCES &amp; LINKS MENTIONED IN THIS VIDEO: 职场社交平台&#x2F;Professionals online platformXingLinkedin 在线求职平台&#x2F;Online job platformindeed.comstepstone.demonster.destellenanzeigen.dejobware.dejobboerse.arbeitsagentur.degehalt.deglassdoor.commake-it-in-germany.com&#x2F;de&#x2F;jobs.dejobs.meinestadt.deyourfirm.dejobvector.de更针对在校生、应届生&#x2F;Target group: students, fresh graduates:connecticum.dekarriere.unicum.destudentenjobs24.deberufsstart.destudentjob.deabsolventa.deabsolventen.jobs 德國找工作實習10大渠道近30個平台無保留分享|How to find a job in Germany+10channels+30platforms - YouTube","categories":[],"tags":[]},{"title":"sprintboot","slug":"sprintboot","date":"2024-11-02T07:50:50.000Z","updated":"2024-11-03T14:25:39.992Z","comments":true,"path":"2024/11/02/sprintboot/","link":"","permalink":"https://noteforme.github.io/2024/11/02/sprintboot/","excerpt":"","text":"黑马程序员SpringBoot教程https://www.bilibili.com/video/BV1Lq4y1J77x 入门 pom依赖 12345678910111213141516171819&lt;!--SpringBoot工程需要继承的父工程--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!--web开发的起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;———————————————— 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：https://blog.csdn.net/qq_45966440/article/details/120450302 ide 自动导入依赖不是上面的，会有问题.","categories":[],"tags":[{"name":"BE","slug":"BE","permalink":"https://noteforme.github.io/tags/BE/"}]},{"title":"BEACKEND","slug":"BEACKEND","date":"2024-10-01T10:08:19.000Z","updated":"2024-10-07T15:05:49.556Z","comments":true,"path":"2024/10/01/BEACKEND/","link":"","permalink":"https://noteforme.github.io/2024/10/01/BEACKEND/","excerpt":"","text":"GitHub - chaofengdev&#x2F;shangting-lease: 尚庭公寓完整源码 https://gitee.com/tglx/hello-mp.git hong 项目经验，开源项目 https://www.bilibili.com/video/BV1yJ411S7Wu root pwd : 12345678 MYBATIS PLUS CREATE project 数据库 https://www.bilibili.com/video/BV1At421K7gP MyBatisX plugin https://www.bilibili.com/video/BV1At421K7gP?p=65 通用map 自定义map mapping xml config https://www.bilibili.com/video/BV1At421K7gP redis https://www.bilibili.com/video/BV1At421K7gP?p=78 后台管理系统开发 https://www.bilibili.com/video/BV1At421K7gP?p=85 maven 依赖和继承 https://www.bilibili.com/video/BV1At421K7gP?p=85","categories":[],"tags":[]},{"title":"DesignPatterns_State","slug":"DesignPatterns-State","date":"2024-07-04T07:57:26.000Z","updated":"2024-09-15T12:50:36.981Z","comments":true,"path":"2024/07/04/DesignPatterns-State/","link":"","permalink":"https://noteforme.github.io/2024/07/04/DesignPatterns-State/","excerpt":"","text":"This structure may look similar to the Strategy pattern, but there’s one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other. 1.","categories":[],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/tags/DesignPattern/"}]},{"title":"glide","slug":"glide","date":"2024-07-03T05:51:25.000Z","updated":"2024-09-15T09:30:38.862Z","comments":true,"path":"2024/07/03/glide/","link":"","permalink":"https://noteforme.github.io/2024/07/03/glide/","excerpt":"","text":"QuestionThis article has many flowcharts to introduce the principleshttps://mp.weixin.qq.com/s/ZjKkTJ5GpP8e2BnttiJEiAhttps://juejin.cn/post/6882536990400020494 Glide使用什么缓存机制LRUcache底层实现 glide和OkHttp的任务调度是怎么实现的（比如同时发起很多请求）自己去实现图片库，怎么做？Glide内存缓存如何控制大小？ https://juejin.cn/post/6956090846470995975 bitmap decodehttps://juejin.cn/post/6844904161327185927https://juejin.cn/post/6994669144490639368#heading-4 Glide Flowhttps://mp.weixin.qq.com/s/oSXDYhc_t4xhAVCfADxXfghttps://juejin.cn/post/7083367492810686472https://blog.csdn.net/weixin_43298955/article/details/118661784https://www.bilibili.com/video/BV1gq4y1n7wq?p=4https://www.jianshu.com/p/48d9e4d5d75d According to this picture, the image acquisition process is first from Active Resource, then from Memory cache, and then from Disk cache. sequenceDiagram Status.WAITING_FOR_SIZELoading an image flow for the first time from the network sequenceDiagram RequestBuilder ->> RequestManager : track() RequestBuilder ->> RequestTracker : runRequest() RequestBuilder ->> SingleRequest : begin() alt status.WAITING_FOR_SIZE SingleRequest ->> SingleRequest : onSizeReady() SingleRequest ->> Engine : load() alt no memoryResource Engine ->> Engine : waitForExistingOrStartNewJob() Engine ->> Engine : build() Engine ->> DecodeJob : run() DecodeJob ->> DecodeJob : runWrapped() INITIALIZE DecodeJob ->> DecodeJob : getNextStage(INITIALIZE) DecodeJob ->> DecodeJob : getNextGenerator(),runGenerators() DecodeJob ->> ResourceCacheGenerator : startNext() loop stage == Stage.SOURCE DecodeJob ->> DecodeJob : reschedule(SWITCH_TO_SOURCE_SERVICE) end DecodeJob ->> DecodeJob : run() DecodeJob ->> DecodeJob : runWrapped(),runGenerators() DecodeJob ->> SourceGenerator : startNext() SourceGenerator ->> SourceGenerator : startNextLoad(loadData) SourceGenerator ->> MultiModelLoader : loadData(loadData) MultiModelLoader ->> HttpUrlFetcher : loadData(loadData) HttpUrlFetcher -->> MultiModelLoader : callback.onDataReady(data) MultiModelLoader -->> SourceGenerator : callback.onDataReady(data) SourceGenerator -->> SourceGenerator : onDataReadyInternal() SourceGenerator -->> DecodeJob : reschedule(SWITCH_TO_SOURCE_SERVICE) DecodeJob ->> DecodeJob : run() DecodeJob ->> DecodeJob : runWrapped(),runGenerators() DecodeJob ->> DecodeJob : startNext() DecodeJob ->> SourceGenerator : startNext() SourceGenerator ->> SourceGenerator : startNextLoad(loadData) SourceGenerator ->> DataCacheGenerator : sourceCacheGenerator.startNext() DataCacheGenerator ->> ByteBufferFileLoader : loadData(helper.getPriority(), this) ByteBufferFileLoader -->> DataCacheGenerator : onDataReady(result) DataCacheGenerator -->> SourceGenerator : onDataFetcherReady() SourceGenerator -->> DecodeJob : onDataFetcherReady() DecodeJob ->> DecodeJob : decodeFromRetrievedData() DecodeJob ->> DecodeJob : decodeFromData(),notifyEncodeAndRelease() DecodeJob ->> DecodeJob : notifyComplete() DecodeJob ->> EngineJob : onResourceReady(),notifyCallbacksOfResult() EngineJob ->> CallResourceReady : run(),notifyCallbacksOfResult(cb) CallResourceReady -->> EngineJob : callCallbackOnResourceReady(cb) EngineJob -->> SingleRequest : onResourceReady(cb) SingleRequest ->> ImageViewTarget : target.onResourceReady(result) ImageViewTarget ->> ImageViewTarget : setResourceInternal() ImageViewTarget ->> DrawableImageViewTarget : setResource() end end What should be noted here is that I looked at the source code. After getting the image from the Internet, it will not go directly to the active resource, nor will it be displayed directly on the ImageView. Instead, it will be saved to the disk and then read from the disk. I saw this Bind lifecycleOld lifecycle architecture new lifecycle architectureThe Glide library for Android indeed underwent significant changes in its architecture. As of Glide version 4.x, Glide has moved away from using RequestManagerFragment for lifecycle management. Instead, Glide now uses LifecycleListener interfaces and RequestManagerRetriever to more efficiently manage the lifecycle of requests. Here is a brief overview of the changes: Glide 4.x and Lifecycle Management Lifecycle Integration:Glide now directly integrates with Android’s lifecycle components (Activity, Fragment, Application), which simplifies the lifecycle management of requests. Glide automatically pauses and resumes requests based on the lifecycle events. LifecycleListeners:Glide uses LifecycleListener interfaces to handle lifecycle events. These listeners are registered with the Android components (Activities and Fragments), and they notify Glide when to start, stop, or recycle requests. Advantages of the New Approach Improved Lifecycle Handling: Glide now more accurately handles the lifecycle of requests, reducing the chances of memory leaks or unnecessary work. Simplified API: The new API is more intuitive and easier to use, thanks to the integration with Android’s lifecycle components. https://www.bilibili.com/video/BV1Qy4y1s7Gh?p=15 LifeCycle flow UML sequenceDiagram autonumber Glide ->> RequestManagerRetriever : get(FragmentActivity) RequestManagerRetriever ->> LifecycleRequestManagerRetriever : getOrCreate(getLifecycle()) LifecycleRequestManagerRetriever ->> LifecycleLifecycle: constructor(lifecycle) LifecycleLifecycle ->> LifecycleRegistry : lifecycle.addObserver(this) LifecycleRequestManagerRetriever ->> RequestManager : build(getLifecycle) RequestManager ->> DefaultConnectivityMonitor : ConnectivityMonitor Note over RequestManager , DefaultConnectivityMonitor : network connection monitor LifecycleRegistry -->> LifecycleLifecycle : onStart() LifecycleRegistry -->> LifecycleLifecycle : onStop() LifecycleRegistry -->> LifecycleLifecycle : onDestroy() LifecycleLifecycle ->> RequestManager : onStart() Note right of RequestManager : resumeRequests() LifecycleLifecycle ->> RequestManager : onStop() Note right of RequestManager : pauseRequests() LifecycleLifecycle ->> RequestManager : onDestroy() connective lifecycle UML classDiagram %% Creator class ConnectivityMonitorFactory { + someOperation() + factoryMethod(): ConnectivityMonitor } %% concreate factory class DefaultConnectivityMonitorFactory { +createProduct(): Product } class ConnectivityMonitor { interface +operation(): void } %% concreate product class DefaultConnectivityMonitor %% concreate product class NullConnectivityMonitor ConnectivityMonitor RequestBuilder : into() RequestBuilder ->> RequestManager : track() RequestBuilder ->> RequestTracker : runRequest() RequestTracker ->> SingleRequest : begin() SingleRequest ->> SingleRequest : onSizeReady(overrideWidth, overrideHeight) SingleRequest ->> Engine : load() Engine ->> Engine : loadFromMemory() Engine ->> Engine : loadFromActiveResources(key) Note right of Engine : Active Resource Engine ->> Engine : loadFromCache(key) Note right of Engine : Memory Cache Engine ->> DecodeJob : runWrapped(),runGenerators() Engine ->> DataCacheGenerator : currentGenerator.startNext() DataCacheGenerator ->> ByteBufferFileLoader : loadData(helper.getPriority(), this) ByteBufferFileLoader -->> DataCacheGenerator : onDataReady(result) DataCacheGenerator -->> SourceGenerator : onDataFetcherReady() SourceGenerator -->> DecodeJob : onDataFetcherReady() DecodeJob ->> DecodeJob : decodeFromRetrievedData() DecodeJob ->> DecodeJob : decodeFromData(),notifyEncodeAndRelease() DecodeJob ->> DecodeJob : notifyComplete() DecodeJob ->> EngineJob : onResourceReady(),notifyCallbacksOfResult() EngineJob -->> Engine : onEngineJobComplete() Note right of Engine : activeResources.activate() EngineJob ->> CallResourceReady : run(),notifyCallbacksOfResult(cb) CallResourceReady -->> EngineJob : callCallbackOnResourceReady(cb) EngineJob -->> SingleRequest : onResourceReady(cb) SingleRequest ->> ImageViewTarget : target.onResourceReady(result) ImageViewTarget ->> ImageViewTarget : setResourceInternal() ImageViewTarget ->> DrawableImageViewTarget : setResource() step8 : get Active Resourcesstep9 : get Memery Cachestep20 : Read from disk cache and then put into active resources. KEYIn Java, the equals and hashCode methods are used to compare objects and manage how objects are stored in certain collections like HashMap and HashSet. equals MethodThe equals method determines whether two objects are equal. By default, the equals method in the Object class compares the memory addresses of the objects (i.e., whether they are the same instance). However, it is common to override this method to provide a meaningful equality check based on the object’s state (i.e., its fields). hashCode MethodThe hashCode method returns an integer hash code representation of the object. The contract between equals and hashCode is that if two objects are equal according to the equals method, they must have the same hash code. However, two objects with the same hash code do not necessarily have to be equal. Identifying an ObjectWhen you override the equals and hashCode methods properly, they can be used to uniquely identify an object in certain collections. Here’s how: Equality Check: When you use collections like HashSet or keys in HashMap, the equals method is used to check if an object already exists in the collection. Hash Code: The hashCode method is used by hash-based collections (like HashMap and HashSet) to efficiently locate a bucket in which the object might be stored. Proper implementation of hashCode ensures that objects are distributed evenly across the buckets, reducing the number of collisions and improving performance. Example Implementation12345678910111213141516171819public class Person &#123; private String name; private int age; // Constructor, getters, and setters @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Person person = (Person) obj; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; Key Points Consistency: Ensure that equals and hashCode are consistent. If equals returns true for two objects, hashCode must return the same value for both. Non-Equal Objects: It is acceptable for non-equal objects to have the same hash code, though this can degrade the performance of hash-based collections. equal objects cannot have different hash codes Consistent with equals: If two objects are equal according to the equals method, they must have the same hash code. Self-Consistency: If an object is compared to itself, the equals method must return true, and the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. Non-Equal Objects: If two objects are not equal according to the equals method, it is not required that they have different hash codes. However, different hash codes for non-equal objects can improve the performance of hash-based collections. if two Person objects have the same name and age, they are considered equal. Consequently, their hash codes will also be the same because the hashCode method uses these fields to compute the hash code. Key Points Consistency Requirement: Equal objects must have the same hash code to ensure that hash-based collections (like HashMap and HashSet) function correctly. Implementation: The hashCode method should use the same fields that are used in the equals method to ensure consistency. Efficiency: While it is not required for unequal objects to have different hash codes, it is beneficial for the performance of hash-based collections. Violating this contract by allowing equal objects to have different hash codes can lead to unexpected behavior in collections like HashMap and HashSet, resulting in problems such as missing entries or increased lookup times. Active recyleAfter onDestroy() or recycling the bitmap, the active resource is put into memory cache. ActiveResources.java 1234567891011121314151617181920212223242526272829 void cleanupActiveReference(@NonNull ResourceWeakReference ref) &#123; synchronized (this) &#123; activeEngineResources.remove(ref.key); if (!ref.isCacheable || ref.resource == null) &#123; return; &#125; &#125; EngineResource&lt;?&gt; newResource = new EngineResource&lt;&gt;( ref.resource, /* isMemoryCacheable= */ true, /* isRecyclable= */ false, ref.key, listener); listener.onResourceReleased(ref.key, newResource); // 这里存储进内存缓存 &#125;Engine.java @Override public void onResourceReleased(Key cacheKey, EngineResource&lt;?&gt; resource) &#123; activeResources.deactivate(cacheKey); if (resource.isMemoryCacheable()) &#123; cache.put(cacheKey, resource); &#125; else &#123; resourceRecycler.recycle(resource, /* forceNextFrame= */ false); &#125; &#125; LruCacheLruCache stands for Least Recently Used Cache. It’s a cache mechanism that keeps track of the most recently used items and evicts the least recently used items when the cache reaches its maximum size. This helps in maintaining a balance between memory usage and access speed. How Glide Uses LruCacheGlide uses LruCache to store decoded images (Bitmap objects) in memory. When an image is requested: Check Cache: Glide first checks the memory cache for the image. Load from Cache: If the image is found in the cache, it is loaded from there, making the process very fast. Fetch and Decode: If the image is not in the cache, Glide fetches it from the source (e.g., network, disk), decodes it, and adds it to the cache. LinkedHashMap参数含义 initialCapacity : 最大容量 loadFactor : 负载因子 accessOrder : 排序方式, true 按照访问顺序排序， false 按照插入顺序排序 访问顺序排序 accessOrder : true 1234567891011121314LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(0, 0.75f, true);map.put(&quot;a&quot;, &quot;A&quot;);map.put(&quot;b&quot;, &quot;B&quot;);map.put(&quot;c&quot;, &quot;C&quot;);map.put(&quot;d&quot;, &quot;D&quot;);map.put(&quot;e&quot;, &quot;E&quot;);map.put(&quot;f&quot;, &quot;F&quot;);map.get(&quot;a&quot;);map.put(&quot;n&quot;,&quot;N&quot;);for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; Log.d(&quot;LruCacheTest&quot;, &quot;testLinkedHashMap : &quot;+ entry.getKey()+&quot; : &quot; + entry.getValue());&#125; 结果 D LruCacheTest: testLinkedHashMap : b : B D LruCacheTest: testLinkedHashMap : c : C D LruCacheTest: testLinkedHashMap : d : D D LruCacheTest: testLinkedHashMap : e : E D LruCacheTest: testLinkedHashMap : f : F D LruCacheTest: testLinkedHashMap : a : A D LruCacheTest: testLinkedHashMap : n : N 可以看到 先访问a ,在插入n,把最新最近使用和访问的 A N,放到链表后面 1LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(100, 0.75f, true); D LruCacheTest: testLinkedHashMap : a : AD LruCacheTest: testLinkedHashMap : b : BD LruCacheTest: testLinkedHashMap : c : CD LruCacheTest: testLinkedHashMap : d : DD LruCacheTest: testLinkedHashMap : e : ED LruCacheTest: testLinkedHashMap : f : FD LruCacheTest: testLinkedHashMap : n : N https://github.com/JakeWharton/DiskLruCache Bitmap Reusebotain bitmap sequenceDiagram LruBitmapPool ->> LruBitmapPool : get() LruBitmapPool ->> LruBitmapPool : getDirtyOrNull() LruBitmapPool ->> SizeStrategy : strategy.get() Note right of SizeStrategy : possibleSize > LruBitmapPool : put(bitmap) LruBitmapPool ->> SizeConfigStrategy : strategy.put(bitmap) SizeConfigStrategy ->> KeyPool : get(size, bitmap.getConfig()) Note over SizeConfigStrategy, KeyPool : groupedMap.put(key, bitmap); bitmap save condition is mutable less than maxSize allowedConfigs LruBitmapPool.java 123456789101112131415public synchronized void put(Bitmap bitmap) &#123; if (!bitmap.isMutable() || strategy.getSize(bitmap) &gt; maxSize || !allowedConfigs.contains(bitmap.getConfig())) &#123; bitmap.recycle(); return; &#125; final int size = strategy.getSize(bitmap); strategy.put(bitmap); tracker.add(bitmap); puts++; currentSize += size; &#125; SizeConfigStrategy.java 123456789101112131415161718static final class Key implements Poolable &#123; @Override public boolean equals(Object o) &#123; if (o instanceof Key) &#123; Key other = (Key) o; return size == other.size &amp;&amp; Util.bothNullOrEqual(config, other.config); &#125; return false; &#125; @Override public int hashCode() &#123; int result = size; result = 31 * result + (config != null ? config.hashCode() : 0); return result; &#125;&#125; The key is judged based on bitmap size and Config format. decoded VS without decodeIn the context of using the Glide library in Android for image loading, the terms “decoded cache” and “without decode” refer to different stages and aspects of the image loading process. Here’s a detailed explanation: Decoded CacheDecoded Cache refers to the cache that stores images that have already been decoded into Bitmap objects. This means the images are stored in a format that can be directly used by the UI without needing further decoding. The benefits of using the decoded cache include: Faster Loading: Since the images are already decoded, they can be quickly retrieved and displayed, reducing the load time and improving the user experience. Reduced CPU Usage: Decoding an image is a CPU-intensive process. By caching decoded images, you avoid repeatedly decoding the same image, which saves CPU resources. Efficient Memory Usage: Decoded images are stored in memory, which allows for quick access, but this also means that the memory usage can be higher, especially if you are caching many large images. Without Decode (Encoded Cache)Without Decode or Encoded Cache refers to the cache that stores the raw, compressed image files (such as JPEG, PNG, or WebP) without decoding them into Bitmap objects. This cache stores the images in their original, encoded format. The benefits of using the encoded cache include: BUILD PROJECT 监控大图https://juejin.im/post/6844904136266219534 https://bumptech.github.io/glide/ https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/Glide%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md https://mp.weixin.qq.com/s/pAazRD9NaLPvBseG51ZOLw","categories":[],"tags":[{"name":"Library","slug":"Library","permalink":"https://noteforme.github.io/tags/Library/"}]},{"title":"Bitmap","slug":"bitmap","date":"2024-06-28T09:37:49.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/06/28/bitmap/","link":"","permalink":"https://noteforme.github.io/2024/06/28/bitmap/","excerpt":"","text":"Studying bitmap involves understanding how bitmap images are represented, stored, and manipulated. Here’s a guide to help you get started: Understanding Bitmap Basics Definition: A bitmap (or raster graphic) is a type of digital image composed of a matrix of dots (pixels). Each pixel represents a single point in the image and has its own color value. Resolution: Bitmap images have a resolution defined by the number of pixels horizontally and vertically. Higher resolution means more detail. Color Depth: This indicates the number of bits used to represent the color of each pixel. Common color depths are 8-bit (256 colors), 16-bit, 24-bit (true color), and 32-bit (true color with alpha channel for transparency). Steps to Study Bitmap Learn the File Formats: • Study different bitmap file formats such as BMP, GIF, JPEG, PNG, and TIFF. • Understand how these formats store pixel data, color information, and metadata. Get Familiar with Bitmap Data Structure: • Learn how bitmap images are stored in memory or files. For example, a BMP file typically starts with a header that contains information about the image’s size, color depth, and compression method. Programming with Bitmaps: • Practice reading and writing bitmap files using a programming language like Python, C++, or Java. • Use libraries such as PIL&#x2F;Pillow in Python or OpenCV to manipulate bitmap images. Manipulating Bitmap Images: • Learn common image processing techniques such as resizing, cropping, rotating, and color adjustments. • Explore algorithms for more advanced processing like filtering, edge detection, and transformations. Study Compression Techniques: • Understand lossless (e.g., PNG) and lossy (e.g., JPEG) compression methods and how they affect image quality and file size. Use Image Editing Software: • Experiment with bitmap images using tools lik Bitmap file formats differBitmap file formats differ in how they store image data, their support for transparency, compression methods, and intended use cases. Here’s an overview of the most common bitmap file formats: BMP (Bitmap) 1234567• File Extension: .bmp• Compression: None or optional lossless compression (RLE)• Color Depth: 1-bit to 24-bit• Transparency: No native support• Usage: Basic and uncompressed image storage, often used in Windows environments• Pros: Simple, widely supported• Cons: Large file sizes due to lack of compression GIF (Graphics Interchange Format) 12345678• File Extension: .gif• Compression: Lossless (LZW compression)• Color Depth: 8-bit (256 colors)• Transparency: Supports transparency• Animation: Supports simple animations• Usage: Web graphics, simple animations• Pros: Small file sizes, supports animations and transparency• Cons: Limited to 256 colors, not suitable for high-quality photographs JPEG (Joint Photographic Experts Group) 1234567• File Extension: .jpg, .jpeg• Compression: Lossy• Color Depth: 24-bit (16.7 million colors)• Transparency: No native support• Usage: Photographs, web images• Pros: High compression ratio, small file sizes, good for photographs• Cons: Lossy compression can result in quality loss, no transparency support PNG (Portable Network Graphics) 1234567• File Extension: .png• Compression: Lossless• Color Depth: 24-bit (16.7 million colors) and 32-bit (with alpha channel for transparency)• Transparency: Supports transparency• Usage: Web graphics, images requiring transparency• Pros: Lossless compression, supports transparency, good for graphics and images with text• Cons: Larger file sizes compared to JPEG TIFF (Tagged Image File Format) 1234567• File Extension: .tif, .tiff• Compression: None, lossless (LZW), or lossy (JPEG)• Color Depth: 1-bit to 32-bit• Transparency: Supports transparency• Usage: Professional image editing, printing, archiving• Pros: Flexible, high-quality images, supports multiple pages and layers• Cons: Large file sizes, not as widely supported on the web","categories":[{"name":"Computer Composition principles","slug":"Computer-Composition-principles","permalink":"https://noteforme.github.io/categories/Computer-Composition-principles/"}],"tags":[],"author":"Jon"},{"title":"Bits and Bytes","slug":"bits-and-bytes","date":"2024-06-28T08:04:14.000Z","updated":"2024-09-15T09:28:40.055Z","comments":true,"path":"/2024/06/28/bits-and-bytes/","link":"","permalink":"https://noteforme.github.io/2024/06/28/bits-and-bytes/","excerpt":"","text":"https://web.stanford.edu/class/cs101/bits-bytes.html Bit a “bit” is atomic: the smallest unit of storage A bit stores just a 0 or 1 ByteGroup 8 bits together to make 1 byte e.g. 0 1 0 1 1 0 1 0 One byte can store one character, e.g. ‘A’ or ‘x’ or ‘$’ Bytes and Characters - ASCII Code ASCII is an encoding representing each typed character by a number Each number is stored in one byte (so the number is in 0..255) A is 65 B is 66 a is 96 space is 32 “Unicode” is an encoding for mandarin, greek, arabic, etc. languages, typically 2-bytes per “character” https://www.asciitable.com/ Typing, Bytes, and You Each letter is stored in a byte, as below 100 typed letters takes up 100 bytes When you send, say, a text message, the numbers are sent Text is quite compact, using few bytes, compared to images etc. Numeral systems conversion table Decimal Binary Octal Hexadecimal 0 0000 0 0 1 0001 1 1 2 0010 2 2 3 0011 3 3 4 0100 4 4 5 0101 5 5 6 0110 6 6 7 0111 7 7 8 1000 10 8 9 1001 11 9 10 1010 12 A 11 1011 13 B 12 1100 14 C 13 1101 15 D 14 1110 16 E 15 1111 17 F HEX，英文全称 Hexadecimal system，表示十六进制。 DEC，英文全称 Decimal system，表示十进制。 OCT，英文全称 Octal system，表示八进制。 BIN，英文全称 Binary system，表示二进制。","categories":[{"name":"Computer Composition principles","slug":"Computer-Composition-principles","permalink":"https://noteforme.github.io/categories/Computer-Composition-principles/"}],"tags":[]},{"title":"LifeCycle","slug":"lifecycle","date":"2024-06-26T06:45:50.000Z","updated":"2024-09-15T09:29:19.990Z","comments":true,"path":"/2024/06/26/lifecycle/","link":"","permalink":"https://noteforme.github.io/2024/06/26/lifecycle/","excerpt":"","text":"https://developer.android.google.cn/topic/libraries/architecture/lifecycle 解藕页面与组件 解藕Service与组件 ProcessLifecycleOwner监听应用程序生命周期 解藕页面与组件12chronometer = (MyChronometer)findViewById(R.id.chronometer);getLifecycle().addObserver(chronometer); 解藕Service与组件https://blog.csdn.net/vitaviva/article/details/121224946 SavedStateHandle直接给viewmodel传值 https://medium.com/mobile-app-development-publication/passing-intent-data-to-viewmodel-711d72db20ad CodeLabhttps://developer.android.com/codelabs/android-lifecycles#4 OnLifecycleEventdeprecated&#x2F;&#x2F;运行时implementation “android.arch.lifecycle:runtime:1.1.1” 使用反射 &#x2F;&#x2F; 编译期annotationProcessor “android.arch.lifecycle:compiler:1.1.1”解析注解，生成处理器类,避免反射耗费性能 https://juejin.cn/post/6844903800088559623","categories":[{"name":"JETPACK","slug":"JETPACK","permalink":"https://noteforme.github.io/categories/JETPACK/"}],"tags":[],"author":"Jon"},{"title":"Android Safe","slug":"android-safe","date":"2024-06-19T08:09:45.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/06/19/android-safe/","link":"","permalink":"https://noteforme.github.io/2024/06/19/android-safe/","excerpt":"","text":"Android隐私正则应用市场 https://juejin.cn/post/7113767096579784734 proguard https://juejin.cn/post/7104539442739838983","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[],"author":"Jon"},{"title":"Design Pattern Strategy","slug":"DesignPattern-strategy","date":"2024-06-18T03:24:51.000Z","updated":"2024-09-15T12:47:55.039Z","comments":true,"path":"/2024/06/18/design-pattern-strategy/","link":"","permalink":"https://noteforme.github.io/2024/06/18/design-pattern-strategy/","excerpt":"","text":"https://refactoring.guru/design-patterns/strategy https://design-patterns.readthedocs.io/zh-cn/latest/behavioral_patterns/strategy.html Class UML behavioral design patterns The Strategy design pattern is one of the behavioral design patterns used to define a family of algorithms, encapsulate each one, and make them interchangeable. The strategy pattern lets the algorithm vary independently from the clients that use it. This pattern is particularly useful for situations where a class needs to perform a specific behavior or service in different ways based on the context or data it is working with. Key Concepts Context: The class that uses a Strategy. It is configured with a Strategy object and maintains a reference to the current Strategy object. It may define an interface for setting the strategy. Strategy: The interface that is common to all concrete strategies. This interface is used by the context to call the strategy defined algorithms. Concrete Strategies: Implementations of the Strategy interface. Each concrete strategy implements the algorithm using a different approach. Example ScenarioImagine you have a Payment class that can process payments in different ways (e.g., credit card, PayPal, Bitcoin). Using the Strategy pattern, you can define a common interface for all payment methods and create separate classes for each payment method. 123456789101112131415161718192021222324252627282930313233343536373839404142// Strategy interfaceinterface PaymentStrategy &#123; fun pay(amount: Double)&#125;// Concrete Strategy for Credit Card paymentclass CreditCardPayment(private val cardNumber: String) : PaymentStrategy &#123; override fun pay(amount: Double) &#123; println(&quot;Paying $amount using credit card $cardNumber&quot;) &#125;&#125;// Concrete Strategy for PayPal paymentclass PayPalPayment(private val email: String) : PaymentStrategy &#123; override fun pay(amount: Double) &#123; println(&quot;Paying $amount using PayPal account $email&quot;) &#125;&#125;// Context classclass Payment(private var strategy: PaymentStrategy) &#123; // 对应Context fun setStrategy(strategy: PaymentStrategy) &#123; this.strategy = strategy &#125; fun processPayment(amount: Double) &#123; strategy.pay(amount) &#125;&#125;// Usagefun main() &#123; // Using Credit Card payment strategy val creditCardPayment = CreditCardPayment(&quot;1234-5678-9876-5432&quot;) val payment = Payment(creditCardPayment) payment.processPayment(100.0) // Changing strategy to PayPal val paypalPayment = PayPalPayment(&quot;user@example.com&quot;) payment.setStrategy(paypalPayment) payment.processPayment(200.0)&#125;","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[],"author":"Jon"},{"title":"DesignPatterns Adatper","slug":"designpatterns-adatper","date":"2024-06-13T01:36:16.000Z","updated":"2024-09-15T09:32:14.687Z","comments":true,"path":"/2024/06/13/designpatterns-adatper/","link":"","permalink":"https://noteforme.github.io/2024/06/13/designpatterns-adatper/","excerpt":"","text":"The Adapter Pattern can be implemented in two main ways: Class Adapter and Object Adapter. Both serve the purpose of adapting one interface to another, but they do so using different approaches. Object AdapterAn Object Adapter uses composition to adapt one interface to another. This approach involves holding an instance of the Adaptee within the Adapter and delegating calls to it. Example of Object Adapter in Kotlin: Target Interface: Defines the expected interface. Adaptee: The existing class with an incompatible interface. Object Adapter: Uses composition to delegate calls to the Adaptee. 12345678910111213141516171819202122232425262728293031323334// Target interfacepublic interface Target &#123; void request();&#125;// Adaptee classpublic class Adaptee &#123; public void specificRequest() &#123; System.out.println(&quot;Called specificRequest()&quot;); &#125;&#125;// Object Adapterpublic class ObjectAdapter implements Target &#123; private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void request() &#123; adaptee.specificRequest(); &#125;&#125;// Client codepublic class Main &#123; public static void main(String[] args) &#123; Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); // Output: Called specificRequest() &#125;&#125; Class AdapterA Class Adapter uses inheritance to adapt one interface to another. This approach requires multiple inheritance (which Kotlin supports through interfaces). Example of Class Adapter in Kotlin: Target Interface: Defines the expected interface. Adaptee: The existing class with an incompatible interface. Class Adapter: Inherits from both the Target Interface and the Adaptee. 123456789101112131415161718192021222324// Target Interfaceinterface NewPaymentSystem &#123; fun pay(amount: Double)&#125;// Adapteeclass OldPaymentSystem &#123; fun makePayment(amount: Double) &#123; println(&quot;Payment of \\$$amount made using Old Payment System&quot;) &#125;&#125;// Class Adapterclass PaymentClassAdapter : OldPaymentSystem(), NewPaymentSystem &#123; override fun pay(amount: Double) &#123; makePayment(amount) &#125;&#125;// Client Codefun main() &#123; val adapter = PaymentClassAdapter() adapter.pay(100.0) // Outputs: Payment of $100.0 made using Old Payment System&#125; Differences Between Class Adapter and Object Adapter:Inheritance vs. Composition: Class Adapter uses inheritance to adapt the Adaptee to the Target Interface.Object Adapter uses composition to hold an instance of the Adaptee and delegate calls to it.Flexibility: Class Adapter is less flexible because it requires multiple inheritance, which can lead to complications if the Adaptee class changes or if you need to adapt multiple classes.Object Adapter is more flexible as it uses composition, making it easier to adapt multiple classes and change the Adaptee without affecting the Adapter.Reuse: Class Adapter reuses the Adaptee class directly through inheritance.Object Adapter reuses the Adaptee class indirectly through composition, which can be more reusable in different contexts. 类适配器使用对象继承的方式，是静态的定义方式； 对象适配器使用对象组合的方式，是动态组合的方式。 对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。 对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 对于对象适配器，需要额外的引用来间接得到Adaptee。 建议尽量使用对象适配器的实现方式，多用合成&#x2F;聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。 参考 ：https://github.com/stven0king/designmode?tab=readme-ov-file https://github.com/helen-x/AndroidInterview/blob/master/android/Android%20%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%9C%A8%E8%BF%99%E9%87%8C).md","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[],"author":"Jon"},{"title":"DesignPatterns  Factory","slug":"designpatterns-factory","date":"2024-06-12T08:48:40.000Z","updated":"2024-09-15T09:33:05.581Z","comments":true,"path":"/2024/06/12/designpatterns-factory/","link":"","permalink":"https://noteforme.github.io/2024/06/12/designpatterns-factory/","excerpt":"","text":"https://www.youtube.com/watch?v=EdFq_JIThqM origin donnot have a common base class 12345678910111213public class Restuarant&#123; public ???? orderBuger(String request)&#123; if(&quot;BEEF&quot;.equals(request))&#123; BeefBurger burger = new BeefBurger(); burget.prepare(); return burger; &#125;else if(&quot;VEGGIE&quot;.equals(request))&#123; VeggieBurger burger = new VeggieBurger(); burget.prepare(); return burger; &#125; &#125;&#125; We can extract common foods then have a standard factory below.It extracts common methods from the BeefBurger and VeggieBurger classes, reducing duplicated methods. Static Factory Method (Simple Factory)is not a full-fledged offical pattern Implementation Uses a single class with a static method to create different types of objects based on input parameters. Use Case Use the Simple Factory pattern when you have a limited number of classes to instantiate and do not expect the set of classes to change frequently. UML classDiagram class Restaurant{ + Burger orderBurger() } class SimpleBurgetFactory{ + Burger createBurget() } class Burger { + int productId + String addOns + prepare() } class BeefBurger { + boolean angus + prepare() } class VeggieBurger { + boolean combo + prepare() } Burger","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[],"author":"Jon"},{"title":"UML Relation","slug":"uml-relation","date":"2024-06-12T07:58:02.000Z","updated":"2024-12-12T13:55:31.687Z","comments":true,"path":"/2024/06/12/uml-relation/","link":"","permalink":"https://noteforme.github.io/2024/06/12/uml-relation/","excerpt":"","text":"工具Android Studio插件 UML.xmind UML标准建模语言中5种主要的类型图https://design-patterns.readthedocs.io/zh-cn/latest/read_uml.html https://www.visual-paradigm.com/tw/guide/uml-unified-modeling-language/what-is-uml/ class relationship https://www.cnblogs.com/shindo/p/5579191.html https://juejin.im/post/5e96b1cae51d4546e41beeb3https://design-patterns.readthedocs.io/zh-cn/latest/read_uml.html 类图1234567891011121314151617181920public class Person &#123; private Integer age; private String name; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; dependency 依赖关系 类中用到了对方。 如果是类的成员属性。 如果是方法的返回类型。 是方法接收的参数类型。 方法中使用到。 12345678910111213141516171819202122public class PersonServiceBean &#123; private PersonDao personDao; public void save(Person person) &#123; &#125; public void modify() &#123; Department department = new Department(); &#125;&#125;class PersonDao &#123;&#125;class IdCard &#123;&#125;class Person &#123;&#125;class Department &#123;&#125; generalization 泛化关系泛化关系实际上就是继承关系，他是依赖关系的特例。 12345678910111213abstract class DataSupport &#123; public void save(Object entity) &#123; &#125; public void delete(Object id) &#123; &#125;&#125;public class PersonServiceBean extends DataSupport &#123;&#125; realization 实现关系A实现B类，就是依赖关系的特例。 1234567891011//A实现B类，就是依赖关系的特例。public class PersonServiceBean implements PersonService &#123; @Override public void delete(Integer id) &#123; System.out.println(&quot;delte..&quot;); &#125;&#125;interface PersonService&#123; public void delete(Integer id);&#125; Association 关联关系关联关系实际上是 类与类之间的联系，他是依赖关系的特例。 关联具有导航性（理解成属性）： 即双向关系或单向关系 关系具有多重性： “1” 有且仅有一个，“0”表示0个或者多个，”n…m”表示n到m个 单向一对一关系 12345Public class Person&#123; private IDCard card;&#125;public class IDCard&#123;&#125; 双向一对一关系 1234567Public class Person&#123; private IDCard card;&#125;public class IDCard&#123; private Person person;&#125; Aggregation 聚合关系 上图中的Car类与Engine类就是聚合关系（Car类中包含一个Engine类型的成员变量）。由上图我们可以看到，UML中聚合关系用带空心菱形和箭头的直线表示。聚合关系强调是“整体”包含“部分”，但是“部分”可以脱离“整体”而单独存在。比如上图中汽车包含了发动机，而发动机脱离了汽车也能单独存在。 表示整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所有他具有关联的导航性与多重性。 如:一台电脑由keyboard ,monitor mouse组成，组成电脑的各个配件是可以从电脑上分离处理的，使用带空心菱形的实线表示。 123456789101112public class Computer &#123; private Moniter moniter; //moniter可以和computer分离 private Mouse mouse;//mouse可以和computer分离&#125;class Mouse &#123;&#125;class Moniter &#123;&#125; 下面是组合关系 12345678910111213// computer对象创建moniter,mouse创建， computer销毁也跟着销毁。public class Computer &#123; private Moniter moniter = new Moniter(); //moniter可以和computer不能分离 private Mouse mouse = new Mouse();//mouse可以和computer不能分离&#125;class Mouse &#123;&#125;class Moniter &#123;&#125; 组合关系-Composition也是整体与部分的关系，整体与部分不可以分开。 Person与IDCard Head，Head与Person就是组合关系，IDCard与Person就是聚合关系。 但是如果在程序中Person实体中定义了对 IDCard进行 级联删除，即删除Person时连同IDCard一起删除，那么IDCard和Person就是组合了。 1234567public class Person &#123; private IDCard card; private Head head = new Head();&#125;class IDCard&#123;&#125;class Head&#123;&#125; https://www.bilibili.com/video/BV1W4411c77E?p=28&amp;spm_id_from=pageDriver drawio部署​ https://zhangzw.com/posts/20200107.html tomacat 下载,下载 Core下的文件,解压 Draw下载，解压放到&#x2F;apache-tomcat-8.5.65&#x2F;webapps 启动tomcat chomd +x ./startup.sh , sudo ./statup.sh PlantUmlhttps://plantuml.com/zh/ 时序图都是plantuml,点编辑才能看到code","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://noteforme.github.io/categories/Architecture/"},{"name":"test","slug":"Architecture/test","permalink":"https://noteforme.github.io/categories/Architecture/test/"}],"tags":[],"author":"Jon"},{"title":"viewmodel","slug":"viewmodel","date":"2024-06-11T08:50:10.000Z","updated":"2024-09-15T09:35:05.244Z","comments":true,"path":"/2024/06/11/viewmodel/","link":"","permalink":"https://noteforme.github.io/2024/06/11/viewmodel/","excerpt":"","text":"问题, 为什么，这种方式，可以获取application对象 private val myViewModel: MyViewModel by viewModels() class MyViewModel(application: Application) : AndroidViewModel(application) { https://developer.android.com/topic/libraries/architecture/viewmodel Share data between fragments livedata和viewmodel关系viewmodel中的数据发生变化时通知页面 ViewModel出现前 瞬间数据丢失 异步调用的内存泄漏 类膨胀提高维护难度和测试难度 Share data between fragments It’s very common that two or more fragments in an activity need to communicate with each other 12345678910111213141516171819202122232425262728293031323334353637class SharedViewModel : ViewModel() &#123; val selected = MutableLiveData&lt;Item&gt;() fun select(item: Item) &#123; selected.value = item &#125;&#125;class MasterFragment : Fragment() &#123; private lateinit var itemSelector: Selector // Use the &#x27;by activityViewModels()&#x27; Kotlin property delegate // from the fragment-ktx artifact private val model: SharedViewModel by activityViewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) itemSelector.setOnClickListener &#123; item -&gt; // Update the UI &#125; &#125;&#125;class DetailFragment : Fragment() &#123; // Use the &#x27;by activityViewModels()&#x27; Kotlin property delegate // from the fragment-ktx artifact private val model: SharedViewModel by activityViewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) model.selected.observe(viewLifecycleOwner, Observer&lt;Item&gt; &#123; item -&gt; // Update the UI &#125;) &#125;&#125; https://codelabs.developers.google.com/codelabs/android-lifecycles/#0 使用12345678910111213141516public class MyViewModel extends ViewModel &#123; public MyViewModel(Application application)&#123; super(); &#125; public int number;&#125;public class MyViewModel extends AndroidViewModel &#123; //需要用到application就用AndroidViewModel public MyViewModel(Application application) &#123; super(application); &#125; public int number;&#125; ViewModel保持数据原理 使用 1viewModel = new ViewModelProvider(this, new ViewModelProvider.AndroidViewModelFactory(getApplication())).get(MyViewModel.class); owner.getViewModelStore() 123public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) &#123; this(owner.getViewModelStore(), factory);&#125; ComponentActivity 12345678910111213141516171819@Overridepublic ViewModelStore getViewModelStore() &#123; if (getApplication() == null) &#123; throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;); &#125; if (mViewModelStore == null) &#123; NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); //拿到上次屏幕的状态 if (nc != null) &#123; // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; // 获取上次的mViewModelStore，里面保存有HashMap&lt;String, ViewModel&gt; mMap &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; &#125; return mViewModelStore;&#125; 所以ViewModel横竖屏切换保存数据的秘诀就是 &#x2F;&#x2F;拿到上次屏幕的状态,获取上次的mViewModelStore，里面保存有HashMap&lt;String, ViewModel&gt; mMap,接着通过.get(MyViewModel.class);获取ViewModel,如果获取不到就反射newInstance()一个。 https://www.bilibili.com/video/BV1Hh411a7LX?p=6&amp;spm_id_from=pageDriver Unit testhttps://simplifiedcoding.in/all-courses https://simplifiedcoding.in/course/android-testing-tutorial-from-junit-to-espresso/start/1 点 DOWNLOAD CODE OF SPENDS TRACKER 跳转后就有下载地址 spend-tracker https://www.youtube.com/watch?v=B-dJTFeOAqw https://www.youtube.com/watch?v=uH6-HNxK32E SavedStateHandlehttps://www.kodeco.com/5212210-jetpack-saved-state-for-viewmodel-getting-started https://juejin.cn/post/6907121847024746503 VisibleForTesting通过上面的代码看出， 被测试的testPrivate方法的可见性还是被改成Protected。也就是,VisibleForTesting只是一个注释，一个元数据metadata，它并没有进入程序逻辑，也没有被转化成字节码byte code 从而被JVM执行。 笔者猜测可能是Guava 的 程序员犯懒了, 即不愿意在unit test里直接利用Reflection来测试私有方法。也没有把私有方法写入另一个类中。所以设计了VisibleForTesting的注解来提醒其他程序员: 这里为了测试私有方法把私有方法改成了Protected(受保护的)并放宽了访问限制。 可是就JAVA本身而言，只有通过Reflection才能真正测试私有方法。 https://www.cnblogs.com/yanlongpankow/p/6240563.html https://jefflin1982.medium.com/android-visiblefortesting%E7%9A%84%E7%94%A8%E9%80%94-5a666a17ba95 viewmodel sharehttps://github.com/google-developer-training/android-basics-kotlin-cupcake-app/tree/starter","categories":[{"name":"JETPACK","slug":"JETPACK","permalink":"https://noteforme.github.io/categories/JETPACK/"}],"tags":[],"author":"Jon"},{"title":"CPLUS","slug":"C-Plus","date":"2024-06-08T12:35:00.000Z","updated":"2025-03-09T14:02:38.523Z","comments":true,"path":"/2024/06/08/cplus/","link":"","permalink":"https://noteforme.github.io/2024/06/08/cplus/","excerpt":"","text":"https://en.cppreference.com/w/ https://www.youtube.com/watch?v=H4s55GgAg0I&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=7 https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main C++ Linker WorksC++中 #include就代表把文件，copy到对应的文件中，如果不用下面的内联，就会爆出重复的Log方法。 inline,只copy方法的内容，不会copy方法体，像这样的 123456void initLog()&#123; Log(&quot;Init log&quot;); 内联后被 std::cout &lt;&lt; message &lt;&lt; std::endl; 替换 &#125; Log.h 1inline void Log(const char * message); Log.cpp 123456789#include &lt;iostream&gt;#include &quot;Log.h&quot;void initLog()&#123; Log(&quot;Init log&quot;);&#125;void Log(const char *message) &#123; // 或者在这个方法加上，inline处理也可以 std::cout &lt;&lt; message &lt;&lt; std::endl;&#125; Math.cpp 1234567891011#include &lt;iostream&gt;#include &quot;Log.h&quot;static int multiply(int a, int b)&#123; Log(&quot;multiply&quot;); return a * b;&#125;int main()&#123; std::cout &lt;&lt; multiply(5,8) &lt;&lt;std::endl;&#125; headercopy all contents and paste it into that c++ file. pragma oncehttps://www.youtube.com/watch?v=9RJTQmK0YPI&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=11 Log.h 12void Log(const char * message);void initLog(); // 头文件声明后，其他地方可以直接调用了 Math.cpp 123int main()&#123; initLog();&#125; Pointer1234567 int a = 5;// void* pStr = &amp;a; // 拿到变量的指针，指针不需要类型 int* pStr = &amp;a; *pStr = 10 ;//如果给指针指向对象赋值，就需要类型 LOG(a) output : 10 REFERENCES123456789void increment(int value)&#123; // 只是copy的值过来，原来的数值没有变化 value ++;&#125;int main()&#123; int a = 5; increment(a); LOG(a);&#125; output: 5可以看到，a数值没有增加 指针传值123456789void increment(int* value)&#123; (*value) ++;&#125;int main()&#123; int a = 5; increment(&amp;a); LOG(a)&#125; output : 6 referencedemo1 123456789void increment(int&amp; value)&#123; value ++;&#125;int main()&#123; int a = 5; increment(a); LOG(a)&#125; output : 6可以看到，传递引用，操作的是同一个内存地址 demo2 123456int a = 5;int b = 8;int &amp; ref = a; //定义ref aref = b; // 操作引用ref,类似于操作aLOG(a)LOG(b) output: 8 8 操作指针 1234567891011int main()&#123; int a = 5; int b = 8; int * ref = &amp;a; // 拿到a的指针，赋值给ref *ref = 2; // 操作ref指向的值 ref = &amp;b; *ref = 1; LOG(a) LOG(b)&#125; output , 2 , 1 CLASSESmove() outside class1234567891011121314151617181920class Player &#123;public: int x, y; int speed;&#125;;void move(Player&amp; player,int xa ,int ya)&#123; player.x += xa * player.speed; player.y += ya * player.speed;&#125;int main() &#123; Player player; player.x = 5; player.speed = 10; move(player,1,-1); LOG(player.x)&#125; move() inside class可以看到player不需要再传入了 123456789101112131415161718class Player &#123;public: int x, y; int speed; void move(int xa, int ya) &#123; x += xa * speed; y += ya * speed; &#125;&#125;;int main() &#123; Player player; player.x = 5; player.speed = 10; player.move(1, -1); LOG(player.x)&#125; CLASSES vs STRUCTS没什么区别， c++为了兼容cstruct is publicly defaultlyclass is private defaultly Write a C++ Class1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;class Log &#123;public: const int LogLevelError = 0; const int LogLevelWarning = 1; const int LogLevelInfo = 2;private: int m_LogLevel = LogLevelInfo;public: void setLevel(int level) &#123; m_LogLevel = level; &#125; void error(const char *message) &#123; if (m_LogLevel &gt;= LogLevelError) &#123; std::cout &lt;&lt; &quot;[error]:&quot; &lt;&lt; message &lt;&lt; std::endl; &#125; &#125; void warn(const char *message) &#123; if (m_LogLevel &gt;= LogLevelWarning)&#123; std::cout &lt;&lt; &quot;[WARNING]:&quot; &lt;&lt; message &lt;&lt; std::endl; &#125; &#125; void info(const char *message) &#123; if (m_LogLevel &gt;= LogLevelInfo)&#123; std::cout &lt;&lt; &quot;[info]:&quot; &lt;&lt; message &lt;&lt; std::endl; &#125; &#125;&#125;;int main()&#123; Log log; log.setLevel(log.LogLevelWarning); log.warn(&quot;Hello!&quot;); log.error(&quot;Hello!&quot;); log.info(&quot;Hello!&quot;);&#125; staticstatic variable is onnly going to visible to that c++file that you have declared in . 为了避免global variable 产生的问题。static.cpp 1static int s_Variable = 10; //去掉static就会报错,默认private main.cpp 1234int s_Variable = 5;int main()&#123; std::cout&lt;&lt;s_Variable &lt;&lt;std::endl;&#125; output 5 或者 extern static.cpp 1static int s_Variable = 10; main.cpp 1234extern int s_Variable;int main()&#123; std::cout&lt;&lt;s_Variable &lt;&lt;std::endl;&#125; output : 10 Static for Classes and Structsglobal instance for that classdont have class instance 1234567891011121314151617struct Entity &#123; int x, y; // public void print() &#123; std::cout &lt;&lt; x &lt;&lt; &quot; , &quot; &lt;&lt; y &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Entity e; e.x = 2; e.y = 3; Entity e1 = &#123;5, 8&#125;; e.print(); e1.print();&#125; output :2 , 35 , 8 1234567891011121314151617181920212223struct Entity &#123; static int x, y; // setting static void print() &#123; std::cout &lt;&lt; x &lt;&lt; &quot; , &quot; &lt;&lt; y &lt;&lt; std::endl; &#125;&#125;;int Entity::x;int Entity::y;int main() &#123; Entity e; e.x = 2; e.y = 3; Entity e1; e1.x = 5; e1.y = 8; e.print(); e1.print();&#125; output:5 , 85 , 8 当我们设置 static int x, y; &#x2F;&#x2F; setting staticonly one instance of those tow vairables acrossall instances of classed which meanswhen we changed second entity’s x ,y ;e and e1 pointing to the same memory so we can refer to them like below 1234567891011121314151617181920212223struct Entity &#123; static int x, y; // public void print() &#123; std::cout &lt;&lt; x &lt;&lt; &quot; , &quot; &lt;&lt; y &lt;&lt; std::endl; &#125;&#125;;int Entity::x;int Entity::y;int main() &#123; Entity e; Entity::x = 2; Entity::y = 3; Entity e1; Entity::x = 5; Entity::y = 8; e.print(); e1.print();&#125; output:5 , 85 , 8 class static method1234567891011121314151617181920212223struct Entity &#123; static int x, y; // public static void print() &#123; std::cout &lt;&lt; x &lt;&lt; &quot; , &quot; &lt;&lt; y &lt;&lt; std::endl; &#125;&#125;;int Entity::x;int Entity::y;int main() &#123; Entity e; Entity::x = 2; Entity::y = 3; Entity e1; Entity::x = 5; Entity::y = 8; Entity::print(); Entity::print();&#125; output:5 , 85 , 8 static method cannot access non static variables.casue static method doens have a class instance. and it works like this , it knows which entitiy is. 1234567891011121314151617struct Entity &#123; static int x, y;&#125;;static void print(Entity e) &#123; std::cout &lt;&lt; e.x &lt;&lt; &quot; , &quot; &lt;&lt; e.y &lt;&lt; std::endl;&#125;int Entity::x;int Entity::y;int main() &#123; Entity e; e.x = 2; e.y = 3; print(e);&#125; ENUMS123456789101112131415161718192021class Log &#123;public: enum Level &#123; ERROR = 0, WARNING, INFO &#125;; const int LogLevelError = 0; const int LogLevelWarning = 1; const int LogLevelInfo = 2;private: int m_LogLevel = LogLevelInfo;public: void setLevel(int level) &#123; m_LogLevel = level; &#125;&#125;int main() &#123; Log log; std::cout &lt;&lt; log.INFO &lt;&lt; std::endl;&#125; output: 2so we can see the value increasly itself. Constructors1234567891011class Entity &#123; int x, y; Entity(int _x, int _y) &#123; x = _x; y = _y; &#125;&#125;;int main() &#123; Entity e(10, 20);&#125; delete default construcator 12345678class Log &#123;public: Log() = delete;&#125;int main() &#123;// Log log; //Call to deleted constructor of &#x27;Log&#x27;&#125; Destructors12345678910111213141516171819class Entity &#123; int x, y; Entity(int _x, int _y) &#123; x = _x; y = _y; std::cout &lt;&lt; &quot;Created Entity!&quot;&lt;&lt; std::endl; &#125; ~Entity()&#123; std::cout &lt;&lt; &quot;Destroyed Entity!&quot;&lt;&lt; std::endl; &#125;&#125;;int main() &#123; Entity e(10, 20); e.~Entity();&#125; Inheritance123456789101112131415161718192021class Player : Entity&#123;&#125;# Virtual Functions```cppclass Player : public Entity &#123;private: std::string m_Name;public: Player(const std::string &amp;mName) : m_Name(mName) &#123;&#125; std::string getName() &#123; return m_Name; &#125;&#125;;int main() &#123; Entity *e = new Entity(); std::cout &lt;&lt; e-&gt;getName() &lt;&lt; std::endl; Player *p = new Player(&quot;john&quot;); std::cout &lt;&lt; p-&gt;getName() &lt;&lt; std::endl;&#125; output :Entityjohn符合预期 添加 Entity* entity &#x3D; p; 123456789int main() &#123; Entity *e = new Entity(); std::cout &lt;&lt; e-&gt;getName() &lt;&lt; std::endl; Player *p = new Player(&quot;john&quot;); std::cout &lt;&lt; p-&gt;getName() &lt;&lt; std::endl; Entity* entity = p; std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;&#125; output:EntityjohnEntity 和java 类似，预期输出 john,但是实际输出 Entity. 再看一个方法的输出 12345678910111213141516171819202122232425262728class Entity &#123;public: std::string getName() &#123; return &quot;Entity&quot;; &#125; Entity() &#123;&#125;&#125;;class Player : public Entity &#123;private: std::string m_Name;public: Player(const std::string &amp;mName) : m_Name(mName) &#123;&#125; std::string getName() &#123; return m_Name; &#125;&#125;;void printName(Entity* entity)&#123; std::cout &lt;&lt; entity-&gt;getName() &lt;&lt; std::endl;&#125;int main() &#123; Entity *e = new Entity(); printName(e); Player *p = new Player(&quot;john&quot;); printName(p);&#125; output:EntityEntity和预期也是不一致 virtual新增 12345678910111213141516class Entity &#123;public: virtual std::string getName() &#123; return &quot;Entity&quot;; &#125; //virtual Entity() &#123;&#125;&#125;;class Player : public Entity &#123;private: std::string m_Name;public: Player(const std::string &amp;mName) : m_Name(mName) &#123;&#125; std::string getName() override&#123; return m_Name; &#125; //override option add&#125;; 新增virtual后output:Entityjohn和预期一致，类似于java多态。 Interfacesclass 里只有virtual,说明这个class就是一个Interfaces 123456789101112131415161718192021222324252627282930class Printable &#123;public: virtual std::string getClassName() = 0;&#125;;class Entity : public Printable &#123;public: virtual std::string getName() &#123; return &quot;Entity&quot;; &#125; //virtual virtual std::string getClassName() override &#123; return &quot;Entity&quot;; &#125;&#125;;class Player : public Entity &#123;private: std::string m_Name;public: Player(const std::string &amp;mName) : m_Name(mName) &#123;&#125; std::string getClassName() override &#123; return &quot;Player&quot;; &#125;&#125;;void print(Printable *obj) &#123; std::cout &lt;&lt; obj-&gt;getClassName() &lt;&lt; std::endl;&#125;int main() &#123; Entity *e = new Entity(); Player *p = new Player(&quot;john&quot;); print(e); print(p);&#125; output :EntityPlayer Array12345678910111213int example[5];int* ptr = example;for (int i = 0; i &lt; 5; ++i) &#123; example[i] = 2;&#125;example[2] = 5;*(ptr + 2) = 6;int* another = new int[5];for (int i = 0; i &lt; 5; ++i) &#123; another[i] = 2;&#125; Stringsconst 12const char *name = &quot;Cherno&quot;; // will change the charactername[2] = &#x27;a&#x27;; //Read-only variable is not assignable 12345678910void printString(std::string string) &#123; string += &quot;h&quot;; std::cout &lt;&lt; string &lt;&lt; std::endl;&#125;int main() &#123; std::string name = std::string(&quot;john&quot;) + &quot; hello&quot;; printString(name); std::cout &lt;&lt; name &lt;&lt; std::endl;&#125; output:john hellohjohn hello &#x2F;&#x2F; name的h没有，数据没变化 reference12345678910void printString(std::string &amp;string) &#123; string += &quot;h&quot;; std::cout &lt;&lt; string &lt;&lt; std::endl;&#125;int main() &#123; std::string name = std::string(&quot;john&quot;) + &quot; hello&quot;; printString(name); std::cout &lt;&lt; name &lt;&lt; std::endl;&#125; output:john hellohjohn helloh值发生的变化 const不能修改指针指向内容的值 *a但是指针a可以修改 1234567891011121314151617181920int main() &#123; const int MAX_AGE = 90; const int *a = new int; // 不能修改指针指向内容的值,指针的值可以修改 int const* a = new int; // 和上面写法一样 const int* a = new int; //和上面写法一样 int* const a = new int; //相反: 可以修改指针指向内容的值 ,但是不能修改指针的值 const int *const a = new int; //不能修改指针指向内容的值,也不能修改指针的值 std::cout &lt;&lt; &quot;a point change before &quot; &lt;&lt; a &lt;&lt; std::endl; a = (int *) &amp;MAX_AGE; std::cout &lt;&lt; *a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a point change after &quot; &lt;&lt; a &lt;&lt; std::endl;&#125; const int *a &#x3D; new int; &#x2F;&#x2F; 不能修改指针指向内容的值,指针的值可以修改 output:a point change before 0x60000262003090a point change after 0x16b886f5c not pointer member1234567891011121314class Entity &#123;private: int m_X, m_Y;public: int getX() const &#123;// m_X = 2; // const : cannot modify class member variables return m_X; &#125; void setX(int x) &#123; m_X = x; &#125;&#125;; pointer member12345678910111213class Entity &#123;private: int *m_X, *m_Y;public: const int *const getX() const &#123; return m_X; // the pointer cannot be modified and the content m_X,m_Y &#125; void setX(int x) &#123; m_X = x; &#125;&#125;; 上面两种情况，类似于java. get. set Member Initializer Lists12345678910111213141516171819202122232425class Entity &#123;private: std::string m_Name;public: Entity() &#123; m_Name = &quot;UnKnown&quot;; &#125; Entity(const std::string &amp;name) &#123; m_Name = name; &#125; const std::string &amp;getName() const &#123; return m_Name; &#125;;&#125;;int main() &#123; Entity e0; std::cout&lt;&lt;e0.getName() &lt;&lt;std::endl; Entity e1(&quot;john&quot;); std::cout&lt;&lt;e1.getName() &lt;&lt;std::endl;&#125; output:UnKnownjohn 另一种写法 1234567891011121314151617181920212223class Entity &#123;private: std::string m_Name; int m_Score;public: Entity() : m_Name(&quot;UnKnown&quot;), m_Score(0) &#123;&#125; Entity(const std::string &amp;name) : m_Name(name) &#123;&#125; const std::string &amp;getName() const &#123; return m_Name; &#125;;&#125;;int main() &#123; Entity e0; std::cout &lt;&lt; e0.getName() &lt;&lt; std::endl; Entity e1(&quot;john&quot;); std::cout &lt;&lt; e1.getName() &lt;&lt; std::endl;&#125; 可以看出这种写法更简单.而且还有另一个好处，下面来介绍. 1234567891011121314151617181920212223242526272829class Example &#123;public: Example() &#123; std::cout &lt;&lt; &quot;Created Example Entity!&quot; &lt;&lt; std::endl; &#125; Example(int x) &#123; std::cout &lt;&lt; &quot;Created Example Entity!&quot; &lt;&lt; x &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; &#125;&#125;;class Entity &#123;private: std::string m_Name; Example m_Example; // 1. Created Example Entity! // execute firstlypublic: Entity() &#123; m_Name = std::string(&quot;UnKnown&quot;); m_Example = Example(8); //2. execute secondly &#125; const std::string &amp;getName() const &#123; return m_Name; &#125;;&#125;;int main() &#123; Entity e0;&#125; output:Created Example Entity!Created Example Entity!8! 可以看到，创建了 2个对象。 1234567891011121314151617class Entity &#123;private: std::string m_Name; Example m_Example;public: Entity() : m_Example(8) &#123; m_Name = std::string(&quot;UnKnown&quot;); &#125; const std::string &amp;getName() const &#123; return m_Name; &#125;;&#125;;int main() &#123; Entity e0;&#125; output:Created Example Entity!8!这样只创建了一个对象。 CREATE&#x2F;INSTANTIATE OBJECTSstack栈内存 会自动回收 123456789101112131415161718192021class Entity &#123;private: std::string m_Name;public: Entity() : m_Name(&quot;UnKnown&quot;) &#123;&#125; Entity(const std::string &amp;name) : m_Name(name) &#123;&#125; const std::string &amp;getName() const &#123; return m_Name; &#125;;&#125;;int main() &#123; Entity *e; &#123; Entity entity(&quot;john&quot;); e = &amp;entity; std::cout &lt;&lt; (*e).getName() &lt;&lt; std::endl; &#125;&#125; IDE不一样,视频中entity 为空的情况，不知道怎么模拟出来, Heapallocated on the heap requires you to manually called delete 123456Entity *e;&#123; Entity *entity = new Entity(&quot;john&quot;); e = entity; std::cout &lt;&lt; (*e).getName() &lt;&lt; std::endl;&#125; The NEW Keyword new Entity(“john”); The Arrow Operator1234567891011121314151617181920212223242526272829303132333435class Entity &#123;public: void print() const &#123; std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl; &#125;&#125;;class ScopedPtr &#123;private: Entity *m_Obj;public: ScopedPtr(Entity *entity) : m_Obj(entity) &#123; &#125; ~ScopedPtr() &#123; delete m_Obj; &#125;// Entity *getObject() &#123;// return m_Obj;// &#125; Entity* operator-&gt;() &#123; return m_Obj; &#125;&#125;;int main() &#123;// ScopedPtr entity = new Entity(); // chatgpt也说这个会编译错误,很奇怪？// entity.getObject()-&gt;print(); ScopedPtr entity = new Entity(); entity-&gt;print();&#125; chatgpt也说这个会编译错误这一集视频，没看明白，包括上面的问题。","categories":[{"name":"CPP","slug":"CPP","permalink":"https://noteforme.github.io/categories/CPP/"}],"tags":[],"author":"Jon"},{"title":"Netowork Lab0","slug":"netowork-lab0","date":"2024-06-08T01:36:41.000Z","updated":"2024-09-15T09:43:04.333Z","comments":true,"path":"/2024/06/08/netowork-lab0/","link":"","permalink":"https://noteforme.github.io/2024/06/08/netowork-lab0/","excerpt":"","text":"environmenthttps://web.stanford.edu/class/cs144/vm_howto/username , pwdcs144, cs144 virtualbox m1 downloadhttps://www.virtualbox.org/wiki/Download_Old_Builds_7_0 visual studioCheckpoint 0: networking warmup (intro video) connect to VMssh connect server 12ip -assh cs144@192.168.64.2 LAB0Fetch a Web pagehelloIn a Web browser,visit http://cs144.keithw.org/hello and observe the result. do the same thing the browser does, by hand. On your VM, run telnet cs144.keithw.org http . This tells the telnetprogram to open a reliable byte stream between your computer and anothercomputer (named cs144.keithw.org), and with a particular service running onthat computer: the “http” service, for the Hyper-Text Transfer Protocol, used bythe World Wide Web.1If your computer has been set up properly and is on the Internet, you will see:user@computer:~$ telnet cs144.keithw.org httpTrying 104.196.238.229…Connected to cs144.keithw.org.Escape character is ‘^]’.If you need to quit, hold down ctrl and press ] , and then type close . Type GET &#x2F;hello HTTP&#x2F;1.1 . This tells the server the path part of the URL.(The part starting with the third slash.) Type Host: cs144.keithw.org . This tells the server the host part of theURL. (The part between http:&#x2F;&#x2F; and the third slash.) Type Connection: close . This tells the server that you are finishedmaking requests, and it should close the connection as soon as it finishes replying. Hit the Enter key one more time: . This sends an empty line and tells theserver that you are done with your HTTP request. If all went well, you will see the same response that your browser saw, precededby HTTP headers that tell the browser how to interpret the response my lab1Notice, don’t wait for a timeout when you input ‘telnet cs144.keithw.org http’. 1234567891011121314151617181920cs144@vm:~$ telnet cs144.keithw.org http Trying 104.196.238.229...Connected to cs144.keithw.org.Escape character is &#x27;^]&#x27;.GET /hello HTTP/1.1Host: cs144.keithw.orgConnection: close //after inputing all the above commandsHTTP/1.1 200 OKDate: Mon, 10 Jun 2024 03:18:22 GMTServer: ApacheLast-Modified: Thu, 13 Dec 2018 15:45:29 GMTETag: &quot;e-57ce93446cb64&quot;Accept-Ranges: bytesContent-Length: 14Connection: closeContent-Type: text/plainHello, CS144!Connection closed by foreign host. Assignmenthttp://cs144.keithw.org/lab0/sunjohn 123456789101112131415cs144@vm:~$ telnet cs144.keithw.org httpGET /lab0/sunjohn HTTP/1.1Host: cs144.keithw.orgConnection: close //after inputing all the above commandsHTTP/1.1 200 OKDate: Mon, 10 Jun 2024 03:59:20 GMTServer: ApacheX-You-Said-Your-SunetID-Was: sunjohnX-Your-Code-Is: 174534Content-length: 111Vary: Accept-EncodingContent-Type: text/plainHello! You told us that your SUNet ID was &quot;sunjohn&quot;. Please see the HTTP headers (above) for your secret code. Send yourself an email这个应该需要stanford内网,应该不用做 目前课程学到lab03.2 Modern C++: mostly safe but still fast and low-level部分，还是很有意思,后面有时间继续后续的学习.","categories":[{"name":"NETWORK","slug":"NETWORK","permalink":"https://noteforme.github.io/categories/NETWORK/"}],"tags":[],"author":"Jon"},{"title":"GSON","slug":"gson","date":"2024-06-07T03:40:36.000Z","updated":"2024-09-15T09:43:57.848Z","comments":true,"path":"/2024/06/07/gson/","link":"","permalink":"https://noteforme.github.io/2024/06/07/gson/","excerpt":"","text":"Running Gson source Codew注释 给GitHub PR https://www.bilibili.com/video/BV1JJ41197UK?spm_id_from=333.337.search-card.all.click json格式 数组 [1,2,3] 对象格式 {“key”:”value”} $Gson$Types理解官方教程 https://github.com/google/gson/blob/master/UserGuide.md 源码分析http://www.jianshu.com/p/89c314ae8c0b Gson转mapGson可以直接把json转为map,但是在转成map时，默认將int long型的数字,转换成doublel类型 12String sms = &quot;&#123;\\&quot;Code\\&quot;:200,\\&quot;Data\\&quot;:&#123;\\&quot;Code\\&quot;:\\&quot;\\&quot;&#125;,\\&quot;Message\\&quot;:\\&quot;发送成功\\&quot;&#125;&quot;;Map&lt;String, Object&gt; map = new Gson().fromJson(sms, HashMap.class); 这里装成map后，Code值尾 200.0 ,解析方法 123456789101112131415Gson gson = new GsonBuilder() .registerTypeAdapter(new TypeToken&lt;TreeMap&lt;String, Object&gt;&gt;() &#123; &#125;.getType(), new JsonDeserializer&lt;TreeMap&lt;String, Object&gt;&gt;() &#123; @Override public TreeMap&lt;String, Object&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123; TreeMap&lt;String, Object&gt; treeMap = new TreeMap&lt;&gt;(); JsonObject jsonObject = json.getAsJsonObject(); Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; entrySet = jsonObject.entrySet(); for (Map.Entry&lt;String, JsonElement&gt; entry : entrySet) &#123; treeMap.put(entry.getKey(), entry.getValue()); &#125; return treeMap; &#125; &#125;).create(); 参考 map to json(生成json数据) HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;real_name&quot;); map.put(&quot;value&quot;, userName); list.add(map); map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;mobile_phone&quot;); map.put(&quot;value&quot;, userPhone); map.put(&quot;hidden&quot;, false); list.add(map); userInfo.data = new Gson().toJson(list); kotlin json to object 12val type = object : TypeToken&lt;BaseCount&lt;List&lt;Site&gt;&gt;&gt;() &#123;&#125;.typevar response = gson.fromJson&lt;BaseCount&lt;List&lt;Site&gt;&gt;&gt;(json, type) https://ask.helplib.com/java/post_498433 java parse1234567891011121314151617181920212223242526272829303132333435 public static List&lt;RecipeBean&gt; analysisChild(String receps) throws JSONException &#123; List&lt;RecipeBean&gt; list = new ArrayList&lt;&gt;();// JSONObject jsonObject = new JSONObject(); JSONArray jsonArray = new JSONArray(receps); for (int i = 0; i &lt; jsonArray.length(); i++) &#123; JSONObject object = jsonArray.getJSONObject(i); RecipeBean mPatient = new RecipeBean(TYPE_ITEM); if (object.has(&quot;drug_name&quot;))&#123; mPatient.setDrug_name(object.getString(&quot;drug_name&quot;)); &#125; if (object.has(&quot;drug_num&quot;))&#123; mPatient.setDrug_num(object.getString(&quot;drug_num&quot;)); &#125; if (object.has(&quot;frequency&quot;))&#123; mPatient.setFrequency(object.getString(&quot;frequency&quot;)); &#125; if (object.has(&quot;num&quot;))&#123; mPatient.setNum(object.getString(&quot;num&quot;)); &#125; if (object.has(&quot;drug_num&quot;))&#123; mPatient.setDrug_num(object.getString(&quot;drug_num&quot;)); &#125; if (object.has(&quot;pharmacy_type&quot;))&#123; mPatient.setPharmacy_type(object.getString(&quot;pharmacy_type&quot;)); &#125; if (object.has(&quot;medicine_num&quot;))&#123; mPatient.setMedicine_num(object.getString(&quot;medicine_num&quot;)); &#125; if (object.has(&quot;medicine_unit&quot;))&#123; mPatient.setMedicine_unit(object.getString(&quot;medicine_unit&quot;)); &#125; list.add(mPatient); &#125; return list; &#125;","categories":[{"name":"Library","slug":"Library","permalink":"https://noteforme.github.io/categories/Library/"}],"tags":[],"author":"Jon"},{"title":"Annotation","slug":"annotation","date":"2024-06-06T02:13:46.000Z","updated":"2024-09-15T09:44:45.329Z","comments":true,"path":"/2024/06/06/annotation/","link":"","permalink":"https://noteforme.github.io/2024/06/06/annotation/","excerpt":"","text":"Annotations are used to provide supplementary information about a program and can be used for a variety of purposes, such as: Information for the compiler: Annotations can be used by the compiler to detect errors or suppress warnings. Compile-time processing: Software tools can process annotation information to generate code, XML files, etc. Runtime processing: Some annotations are available to be examined at runtime via reflection.https://docs.oracle.com/javase%2Ftutorial%2F/java/annotations/index.html 注解注解的作用 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息. 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取. 元注解 ： 不可以再分的注解， 负责注解其他注解。java定义了4个标准的meta-annotation类型,它们被用来提供对其它annotation类型作说明。Target Retention Documented Inherited 如上图的 Overide被@Target和@Retention修饰，他们用来说明解释其他注解，位于 java.lang.annotation下 Annotations That Apply to Other AnnotationsAnnotations that apply to other annotations are called meta-annotations. There are several meta-annotation types defined in java.lang.annotation. @Retention @Retention annotation specifies how the marked annotation is stored: 需要什么级别保存该注释信息，用于保留注解的生命周期 RetentionPolicy.SOURCE The marked annotation is retained only in the source level and is ignored by the compiler. RetentionPolicy.CLASS – The marked annotation is retained by the compiler at compile time, but is ignored by the Java Virtual Machine (JVM). RetentionPolicy.RUNTIME – The marked annotation is retained by the JVM so it can be used by the runtime environment. RetentionPolicy.RUNTIME The marked annotation is retained by the JVM so it can be used by the runtime environment. 编译和运行时注解区别运行时注解运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。https://juejin.cn/post/6925283352698159117#heading-4 注解设置 SxtStudent信息，映射数据库 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface SxtTable &#123; String value();&#125; 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface SxtField &#123; String columnName(); String type(); int length();&#125; 1234567891011@SxtTable(&quot;tb_student&quot;)public class SxtStudent &#123; @SxtField(columnName = &quot;id&quot;,type = &quot;int&quot;,length = 10) private int id; @SxtField(columnName = &quot;sname&quot;,type = &quot;varchar&quot;,length = 10) private String studentName; @SxtField(columnName = &quot;age&quot;,type = &quot;int&quot;,length = 3) private int age;&#125; 通过第三方工具获取注解信息 12345678910111213141516171819202122try &#123; Class clazz = Class.forName(&quot;annotation.SxtStudent&quot;); //获得类的所有有效注解 Annotation[] annotations = clazz.getAnnotations(); for (Annotation a:annotations)&#123; System.out.println(a); &#125; //获得类的指定注解 SxtTable st = (SxtTable)clazz.getAnnotation(SxtTable.class); System.out.println(st.value()); //获得类的属性的注解 Field f = clazz.getDeclaredField(&quot;studentName&quot;); SxtField sxtField = f.getAnnotation(SxtField.class); System.out.println(sxtField.columnName()+&quot;--&quot; + sxtField.type()+&quot;---&quot; + sxtField.length());&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (NoSuchFieldException e) &#123; e.printStackTrace();&#125; 运行结果 @annotation.SxtTable(value&#x3D;tb_student)tb_studentsname–varchar—10 运行时注解很好理解，代码运行的时候通过反射技术就可以获取上面的注解信息。从上面可以看到,反射增加了点性能问题 反射实例1234567891011121314151617181920String path = &quot;reflection.User&quot;;try &#123; Class&lt;?&gt; clazz = Class.forName(path); //对象是表示或封装一些数据。一个类被加载后，JVM会创建一个对应该类的Class对象，类的整个结构信息会放到对应的CLass对象中。 //这个Class对象就像一面镜子一样，通过这面镜子我可已看到对应类的全部信息。 System.out.println(clazz.hashCode()); Class clazz2 = Class.forName(path); // 一个类对应的一个class对象 System.out.println(clazz2.hashCode()); Class intCLazz = int.class; int[] arr01 = new int[10]; int[][] arr02 = new int[30][3]; int[]arr03 = new int[30]; double[] arr04 = new double[10]; System.out.println(arr01.getClass().hashCode()); System.out.println(arr02.getClass().hashCode()); System.out.println(arr03.getClass().hashCode()); System.out.println(arr04.getClass().hashCode()); https://www.youtube.com/watch?v=vZe5zG0vh3U&amp;list=PLC664nq_h8b9Jzh-qYJ_AeOpmSoBLC_tg&amp;index=1 编译时注解APT(Annotation Processing Tool)即注解处理器（通常也叫做编译时注解、编译时代码自动生成），是一种处理注解的工具，确切的说它是javac的一个工具，它用来在编译时扫描和处理注解。注解处理器以Java代码(或者编译过的字节码)作为输入，生成.java文件作为输出。简单来说就是在编译期，通过注解生成.java文件。通过上面的讲解，我们知道了：通常编译时注解要结合注解处理器一起使用的，通过解析注解，获取注解上面的信息，然后生成代码，从而生成一下辅助我们自己手写的代码。说得有点抽象，下面通过一个简单示例来演示一下。 我们做微信相关api，会有下面操作 示例最终效果如下： 12345678910@SubTypeAutoGenerate(&quot;com.flyme.videoclips.wxapi.WXEntryActivity&quot;)public class BaseWXEntryActivity extends Activity implements IWXAPIEventHandler &#123;&#125;// 自动生成的代码,请不要改动package com.flyme.videoclips.wxapi;import com.flyme.videoclips.util.wxapi.BaseWXEntryActivity;public class WXEntryActivity extends BaseWXEntryActivity &#123;&#125; 我们通过一个@SubTypeAutoGenerate注解就可以很方便地生成WXEntryActivity啦，其中@SubTypeAutoGenerate注解的参数就是生成的全类名。reference: https://juejin.cn/post/6925283352698159117 根据前面注解分类，编译时注解是保留到编译阶段的，即.class文件，不会保留到dex里面，即运行时根本获取不到这个注解了，那么这种编译时注解又有什么用呢？ 注解处理器是javac处理注解的一种工具，它用来在编译时扫描和处理注解。简单来说就是在编译器，通过注解采集信息，生成.java文件。减少重复代码的编写。 APT原理 步骤 问题APT就这固定的几步，网上demo可以生成，我的就是没法生成，原来是因为,@DIActivity类的头部没有设置 123@DIActivitypublic class MainActivity extends AppCompatActivity &#123;&#125; 项目 MRouter Arouter原理获得当前程序在手机中对应的apk文件,使用classsloader:dexfile(PMS)，反射获取apk所有的类，筛选出注册activity的类。初始化 核心实现 https://www.bilibili.com/video/BV1Ly4y1W7f5?p=6&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1nU4y1a79o?from=search&amp;seid=3188418579827888379 https://juejin.cn/post/6925283352698159117#heading-14 https://juejin.cn/post/6947992544252788767 https://blog.csdn.net/xx326664162/article/details/68490059 https://hanshuliang.blog.csdn.net/article/details/117072224 https://github.com/han1202012/APT @Target@Target annotation marks another annotation to restrict what kind of Java elements the annotation can be applied to. A target annotation specifies one of the following element types as its value: ElementType.ANNOTATION_TYPE can be applied to an annotation type.ElementType.CONSTRUCTOR can be applied to a constructor.ElementType.FIELD can be applied to a field or property.ElementType.LOCAL_VARIABLE can be applied to a local variable.ElementType.METHOD can be applied to a method-level annotation.ElementType.PACKAGE can be applied to a package declaration.ElementType.PARAMETER can be applied to the parameters of a method.ElementType.TYPE can be applied to any element of a class. 用于描述注解的使用范围(注解可以用在什么地方)如 类 属性 方法等 @Inherited@Inherited annotation indicates that the annotation type can be inherited from the super class. (This is not true by default.) When the user queries the annotation type and the class has no annotation for this type, the class’ superclass is queried for the annotation type. This annotation applies only to class declarations. 标明所修饰的注解，在所作用的类上，是否可以被继承。 12345678910111213141516171819202122@InheritedAnnotation(value = &quot;Applied to SuperClass&quot;)class SuperClass &#123; // Superclass implementation&#125;class SubClass extends SuperClass &#123; // Subclass implementation&#125;public class InheritedTest &#123; public static void main(String[] args) &#123; Class&lt;SubClass&gt; subClass = SubClass.class; // Check if the subclass inherits the annotation if (subClass.isAnnotationPresent(InheritedAnnotation.class)) &#123; Annotation annotation = subClass.getAnnotation(InheritedAnnotation.class); InheritedAnnotation inheritedAnnotation = (InheritedAnnotation) annotation; System.out.println(&quot;SubClass inherits annotation: &quot; + inheritedAnnotation.value()); &#125; else &#123; System.out.println(&quot;SubClass does not inherit the annotation.&quot;); &#125; &#125;&#125; output:SubClass inherits annotation: Applied to SuperClas , 所以可以拿到父类的注解信息。 @Repeatable@Repeatable annotation, introduced in Java SE 8, indicates that the marked annotation can be applied more than once to the same declaration or type use. For more information, see Repeating Annotations. 12345678910111213141516171819202122@Repeatable(ReviewTags.class)@Retention(RetentionPolicy.RUNTIME)@interface ReviewTag &#123; String value();&#125;@Retention(RetentionPolicy.RUNTIME)@interface ReviewTags &#123; ReviewTag[] value();&#125; public static void main(String[] args) &#123; try &#123; // Accessing annotations ReviewTag[] tags = ReviewTagsTest.class.getMethod(&quot;review&quot;).getAnnotationsByType(ReviewTag.class); System.out.println(&quot;Review Tags:&quot;); for (ReviewTag tag : tags) &#123; System.out.println(tag.value()); &#125; &#125; catch (NoSuchMethodException e) &#123; &#125; &#125; output : 12PositiveDetailed @Documented@Documented annotation indicates that whenever the specified annotation is used those elements should be documented using the Javadoc tool. (By default, annotations are not included in Javadoc.) For more information, see the Javadoc tools page.javadoc的工具文档化 Declaring an Annotation Type ,Generate DocumentClassPreamble.java 12345678910111213141516171819package annotation.doc;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.annotation.ElementType;@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface ClassPreamble &#123; String author(); String date(); int currentRevision() default 1; String lastModified() default &quot;N/A&quot;; String lastModifiedBy() default &quot;N/A&quot;; String[] reviewers();&#125; MyClass.java 12345678910111213141516package annotation.doc;@ClassPreamble( author = &quot;John Doe&quot;, date = &quot;06/06/2024&quot;, currentRevision = 2, lastModified = &quot;06/06/2024&quot;, lastModifiedBy = &quot;Jane Doe&quot;, reviewers = &#123;&quot;Alice&quot;, &quot;Bob&quot;&#125;)public class MyClass &#123; // Class implementation void print()&#123; // the function will not generate doc System.out.println(&quot;print&quot;); &#125;&#125; command steps 1234$ pwd/Users/m/Documents/workpersonal/THINKKOTLIN/src/main/java$ javac annotation/doc/ClassPreamble.java annotation/doc/MyClass.java$ javadoc -d doc annotation/doc/MyClass.java 这种方式可以生成文档","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[],"author":"Jon"},{"title":"Music","slug":"music1","date":"2024-06-05T07:26:44.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/06/05/music/","link":"","permalink":"https://noteforme.github.io/2024/06/05/music/","excerpt":"","text":"Memories TOP 40 Songs of 2021 2022 (Best Hit Music Playlist) on Spotifyhttps://www.youtube.com/watch?v=99XF71Fpjl8 MARINA - To Be Human (Official Music Video)https://www.youtube.com/watch?v=DM8Tm9ycGz4 Nothing gonna change my love for you","categories":[{"name":"LIFE","slug":"LIFE","permalink":"https://noteforme.github.io/categories/LIFE/"}],"tags":[],"author":"Jon"},{"title":"reflection","slug":"reflection","date":"2024-05-31T07:56:18.000Z","updated":"2024-09-15T09:46:29.318Z","comments":true,"path":"/2024/05/31/reflection/","link":"","permalink":"https://noteforme.github.io/2024/05/31/reflection/","excerpt":"","text":"https://jonblog.site/2024/05/28/designpattern-proxy/https://jonblog.site/2024/06/06/annotation/ https://www.oracle.com/technical-resources/articles/java/javareflection.htmlhttps://www.bilibili.com/video/BV1tY411Z799 reflect demo常用反射用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279/** * @author xiaoyaomeng */class Person &#123; private int age; private String name; public Person() &#123; &#125; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;class SuperMan extends Person implements ActionInterface &#123; private boolean BlueBriefs; public void fly() &#123; System.out.println(&quot;超人会飞耶～～&quot;); &#125; public boolean isBlueBriefs() &#123; return BlueBriefs; &#125; public void setBlueBriefs(boolean blueBriefs) &#123; BlueBriefs = blueBriefs; &#125; @Override public void walk(int m) &#123; // TODO Auto-generated method stub System.out.println(&quot;超人会走耶～～走了&quot; + m + &quot;米就走不动了！&quot;); &#125;&#125;interface ActionInterface &#123; public void walk(int m);&#125;public class ReflectMethod &#123; /** * Demo1: 通过Java反射机制得到类的包名和类名 */ public static void Demo1() &#123; Person person = new Person(); System.out.println(&quot;Demo1: 包名: &quot; + person.getClass().getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + person.getClass().getName()); &#125; /** * Demo2: 验证所有的类都是Class类的实例对象 * * @throws ClassNotFoundException */ public static void Demo2() throws ClassNotFoundException &#123; //定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类 Class&lt;?&gt; class1 = null; Class&lt;?&gt; class2 = null; //写法1, 可能抛出 ClassNotFoundException [多用这个写法] class1 = Class.forName(&quot;reflection.Person&quot;); System.out.println(&quot;Demo2:(写法1) 包名: &quot; + class1.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class1.getName()); //写法2 class2 = Person.class; System.out.println(&quot;Demo2:(写法2) 包名: &quot; + class2.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class2.getName()); &#125; /** * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在] */ public static void Demo3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;reflection.Person&quot;); //由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～ Person person = (Person) class1.newInstance(); person.setAge(20); person.setName(&quot;LeeFeng&quot;); System.out.println(&quot;Demo3: &quot; + person.getName() + &quot; : &quot; + person.getAge()); &#125; /** * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象 */ public static void Demo4() throws ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; // Get the class object Class&lt;?&gt; clazz = Person.class; // Get the constructors of the class Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); // all constructor methods // Iterate over constructors and print parameter types for (Constructor&lt;?&gt; constructor : constructors) &#123; System.out.println(&quot;Constructor: &quot; + constructor); // Get parameter types Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes(); for (Class&lt;?&gt; paramType : parameterTypes) &#123; System.out.println(&quot;Parameter type: &quot; + paramType.getName()); &#125; // Alternatively, you can use Parameter class to get more details Parameter[] parameters = constructor.getParameters(); for (Parameter parameter : parameters) &#123; System.out.println(&quot;Parameter: &quot; + parameter.getName() + &quot;, Type: &quot; + parameter.getType()); &#125; System.out.println(); &#125; try &#123; /** * public Person(String name) 构造方法 Create 对象 */ final Class&lt;?&gt;[] stringParam = &#123;String.class&#125;; final Constructor&lt;?&gt; consString = Person.class.getConstructor(stringParam); Person personString = (Person) consString.newInstance(new Object[]&#123;99&#125;); System.out.println(&quot;stringParam &quot; + personString); /** * public Person(int age, String name) 构造方法 Create 对象 */ final Class&lt;?&gt;[] stringIntParam = &#123;int.class, String.class&#125;; final Constructor&lt;?&gt; consStringInt = Person.class.getConstructor(stringIntParam); Person person1 = (Person) consStringInt.newInstance(new Object[]&#123;99, &quot;john&quot;&#125;); System.out.println(&quot;stringIntParam &quot; + person1); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125; Class&lt;?&gt; class1 = null; Person person1 = null; Person person2 = null; class1 = Class.forName(&quot;reflection.Person&quot;); //得到一系列构造函数集合 Constructor&lt;?&gt;[] constructors1 = class1.getConstructors(); person1 = (Person) constructors1[0].newInstance(); person1.setAge(30); person1.setName(&quot;leeFeng&quot;); //constructor onject that have two params: age and name person2 = (Person) constructors1[1].newInstance(20, &quot;leeFeng&quot;); System.out.println(&quot;Demo4: &quot; + person1.getName() + &quot; : &quot; + person1.getAge() + &quot; , &quot; + person2.getName() + &quot; : &quot; + person2.getAge() ); /** * Demo5: 通过Java反射机制操作成员变量, set 和 get */ public static void Demo5() throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;reflection.Person&quot;); Object obj = class1.newInstance(); Field personNameField = class1.getDeclaredField(&quot;name&quot;); personNameField.setAccessible(true); personNameField.set(obj, &quot;胖虎先森&quot;); System.out.println(&quot;Demo5: 修改属性之后得到属性变量的值：&quot; + personNameField.get(obj)); &#125; /** * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等 * * @throws ClassNotFoundException */ public static void Demo6() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;reflection.SuperMan&quot;); //取得父类名称 Class&lt;?&gt; superClass = class1.getSuperclass(); System.out.println(&quot;Demo6: SuperMan类的父类名: &quot; + superClass.getName()); System.out.println(&quot;===============================================&quot;); Field[] fields = class1.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; System.out.println(&quot;类中的成员: &quot; + fields[i]); &#125; System.out.println(&quot;===============================================&quot;); //取得类方法 Method[] methods = class1.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(&quot;Demo6,取得SuperMan类的方法：&quot;); System.out.println(&quot;函数名：&quot; + methods[i].getName()); System.out.println(&quot;函数返回类型：&quot; + methods[i].getReturnType()); System.out.println(&quot;函数访问修饰符：&quot; + Modifier.toString(methods[i].getModifiers())); System.out.println(&quot;函数代码写法： &quot; + methods[i]); &#125; System.out.println(&quot;===============================================&quot;); //取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈 Class&lt;?&gt; interfaces[] = class1.getInterfaces(); for (int i = 0; i &lt; interfaces.length; i++) &#123; System.out.println(&quot;实现的接口类名: &quot; + interfaces[i].getName()); &#125; &#125; /** * Demo7: 通过Java反射机制调用类方法 */ public static void Demo7() throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;reflection.SuperMan&quot;); System.out.println(&quot;Demo7: \\n调用无参方法fly()：&quot;); Method method = class1.getMethod(&quot;fly&quot;); method.invoke(class1.newInstance()); System.out.println(&quot;调用有参方法walk(int m)：&quot;); method = class1.getMethod(&quot;walk&quot;, int.class); method.invoke(class1.newInstance(), 100); method.invoke(new SuperMan(), 666); // 这个方法和上面的一样 &#125; /** * Demo8: 通过Java反射机制得到类加载器信息 * &lt;p&gt; * 在java中有三种类类加载器。[这段资料网上截取] * &lt;p&gt; * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 * &lt;p&gt; * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类 * &lt;p&gt; * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。 * * @throws ClassNotFoundException */ public static void Demo8() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;reflection.SuperMan&quot;); String nameString = class1.getClassLoader().getClass().getName(); System.out.println(&quot;Demo8: 类加载器类名: &quot; + nameString); &#125;&#125; class类是程序的一部分，每个类都有一个Class对象，每当编写并编译了一个新类就会产生一个Class对象（保存在一个同名的.class文件中）。为了生成这个对象就要用到JVM分析主要的类和方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253interface HasBatteries &#123;&#125;interface Waterproof &#123;&#125;interface Shoots &#123;&#125;class Toy &#123; //Comment out the following default constructor //to see NoSuchMethodError from(*1*) Toy() &#123; &#125; Toy(int i) &#123; &#125;&#125;class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots &#123; FancyToy() &#123; super(1); &#125;&#125;public class ToyTest &#123; static void printInfo(Class cc) &#123; Print.print(&quot;Class name: &quot; + cc.getName() + &quot; is Interface ? [&quot; + cc.isInterface() + &quot;]&quot;); //是否是接口 Print.print(&quot;Simple name: &quot; + cc.getSimpleName()); //不好含包名的类名 Print.print(&quot;Canonical name : &quot; + cc.getCanonicalName()); //全限定的类名 &#125; public static void main(String[] args) &#123; Class c = null; try &#123; c = Class.forName(&quot;TypeInfomation.Demo.FancyToy&quot;); &#125; catch (ClassNotFoundException e) &#123; Print.print(&quot;Can&#x27;t find FancyToy&quot;); System.exit(1); &#125; Print.print(c); printInfo(c); Print.print(); for (Class face : c.getInterfaces()) &#123; printInfo(face); Print.print(); &#125; Class up = c.getSuperclass(); Object obj = null; try &#123; //Requires default constructor: obj = up.newInstance(); &#125; catch (InstantiationException e) &#123; Print.print(&quot;Cannot instantiate&quot;); System.exit(1); &#125; catch (IllegalAccessException e) &#123; Print.print(&quot;Cannot access&quot;); System.exit(1); &#125; printInfo(obj.getClass()); &#125;&#125; Class类所有的Class对象都属于这个 类的一个static成员，Class对象和其他对象一样，我们可以使用 Class.forName(&quot;Gum&quot;) 获取并操作它的引用（这就是类加载器的工作）， 从上面的代码可以看到，getSuperclass()方法查询其直接基类，这将返回用来进一步查询的Class对象。由此，可以在运行时发现一个对象完整的类继承结构 newInstance方法Class的newInstance()实现“虚拟构造器”的一种途径，虚拟构造器寻你生命”我不知道你的确切类型，但是无论如何要正确地创建自己”，代码中的 up 只是一个Class引用，在编译期不具备任何更进一步的类型信息，创建新实例时，会得到指向Toy对象的Object引用，可以转型操作它。 动态代理12345678910111213141516171819202122232425262728293031class DynamicProxyHandler implements InvocationHandler&#123; private Object proxied; public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; //proxy:对象的引用 ,method :被调用的方法 ，args:方法里面的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;**** proxy: &quot; + proxy.getClass() + &quot;. method: &quot; +method + &quot;, args &quot; + args); if (args !=null) for (Object arg : args) //方法里面的参数 System.out.println(&quot; &quot; + arg); return method.invoke(proxied,args); //通过方法调用 引用和参数,转发调用 &#125;&#125;public class SimpleDynamicProxy &#123; public static void consumer(Interface iface)&#123; iface.doSomething(); iface.somethingElse(&quot;bonobo&quot;); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject();// consumer(real); //常用调用 //Insert a proxy and cal again: Interface proxy = (Interface) Proxy.newProxyInstance(Interface.class.getClassLoader(), new Class[]&#123;Interface.class&#125;,new DynamicProxyHandler(real)); consumer(proxy); &#125;&#125; more demo about dynamic proxy in this article https://jonblog.site/2024/05/28/designpattern-proxy/ 2、javap 一个随JDK发布的反编译工具 命令行 到Cat.java所对应的Cat.class文件的位置 运行 javap -private Cat.class 可以反编译源程序 3、没有任何方式可以阻止反射到达并调用那些非公共访问权限的方法 12345678910111213141516171819202122232425262728293031323334353637public class ModifyingPrivateFields &#123; public static void main(String[] args) throws Exception &#123; WithPrivateFinalField pf = new WithPrivateFinalField(); System.out.println(pf); Field f = pf.getClass().getDeclaredField(&quot;i&quot;); f.setAccessible(true); System.out.println(&quot;f.getInt(pf): &quot; + f.getInt(pf)); f.setInt(pf,47); System.out.println(pf); Print.print(); f =pf.getClass().getDeclaredField(&quot;s&quot;); f.setAccessible(true); System.out.println(&quot;f.get(pf): &quot;+f.get(pf)); f.set(pf,&quot;you are totally safe&quot;); System.out.println(pf); Print.print(); f = pf.getClass().getDeclaredField(&quot;s2&quot;); f.setAccessible(true); System.out.println(&quot;f.get(pf): &quot;+f.get(pf)); f.set(pf,&quot;No,you&#x27;re not!&quot;); System.out.println(pf); &#125;&#125;class WithPrivateFinalField &#123; private int i = 1; private final String s = &quot; I&#x27;m totally safe&quot;; private String s2 = &quot;Am I safe?&quot;; public String toString() &#123; return &quot;i = &quot; + i + &quot;, &quot; + s + &quot;, &quot; + s2; &#125;&#125; https://github.com/hengzhou/Rejectionhttp://blog.csdn.net/ljphhj/article/details/12858767 this video write code simulate JDK dynamic proxy https://www.bilibili.com/video/BV1Ve411o7WM 反射机制Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java的反射机制。 基本使用123456package reflection;public class MethodReflect &#123; public int addResult(int addNum) &#123; return addNum; &#125;&#125; 1234567891011121314151617181920212223242526//使用反射第一步:获取操作类MethodDemoFieldDemo所对应的Class对象Class &lt; ?&gt;cls = Class.forName(&quot;reflection.MethodReflect&quot;);//使用MethodDemo类的class对象生成 实例Object obj = cls.newInstance();//获取public int addResult(int addNum)方法Method addMethod = cls.getMethod(&quot;addResult&quot;, new Class[] &#123; int.class&#125;);System.out.println(&quot;修饰符: &quot; + Modifier.toString(addMethod.getModifiers()));System.out.println(&quot;返回值: &quot; + addMethod.getReturnType());System.out.println(&quot;方法名称: &quot; + addMethod.getName());System.out.println(&quot;参数列表: &quot; + addMethod.getParameterTypes());int result = (int) addMethod.invoke(obj, 2);System.out.println(&quot;调用addResult后的运行结果:&quot; + result);System.out.println(&quot;--------------------------------&quot;);//获取public String toString() 方法Method toStringMethod = cls.getMethod(&quot;toString&quot;, new Class[] &#123;&#125;);System.out.println(&quot;修饰符: &quot; + Modifier.toString(toStringMethod.getModifiers()));System.out.println(&quot;返回值: &quot; + toStringMethod.getReturnType());System.out.println(&quot;方法名称: &quot; + toStringMethod.getName());System.out.println(&quot;参数列表: &quot; + toStringMethod.getParameterTypes());String msg = (String) toStringMethod.invoke(obj);System.out.println(&quot;调用toString后的运行结果:&quot; + msg); Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象,如果参数为基本类型数据,必须转换为相应的包装类型的对象。invoke()方法的返回值总是对象,如果实际被调用的方法的返回类型是基本类型数据,那么invoke()方法会把它转换为相应的包装类型的对象,再将其返回. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class InvokeTester &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public InvokeTester() &#123; &#125; public int add(int param1, int param2) &#123; return param1 + param2; &#125; public String echo(String mesg) &#123; return &quot;echo&quot; + mesg; &#125; public static void main(String[] args) throws Exception &#123; Class classType = InvokeTester.class; Object invokertester = classType.newInstance(); //1 Method addMethod = classType.getMethod(&quot;add&quot;, new Class[]&#123; //2 int.class, int.class &#125;); Object result = addMethod.invoke(invokertester, new Object[]&#123; //3 new Integer(100), new Integer(200) &#125;); System.out.println(result); Method echo = classType.getMethod(&quot;echo&quot;, new Class[]&#123; String.class &#125;); Object obj = echo.invoke(invokertester, new Object[]&#123; new String(&quot;Jon is very good!!!&quot;) &#125;); System.out.println(obj.toString()); InvokeTester test = new InvokeTester(); //1 test.setName(&quot;黄翊&quot;); //2 //Method[] methods; Method[] methods = test.getClass().getDeclaredMethods(); //3 //循环查找获取id方法，并执行查看是否有返回值 for (int i = 0; i &lt; methods.length; i++) &#123; //如果此方法有get和Id关键字则执行 if (methods[i].getName().indexOf(&quot;get&quot;) != -1 &amp;&amp; methods[i].getName().indexOf(&quot;Name&quot;) != -1) &#123; // 获取此get方法返回值,判断是否有值,如果没有值说明即将执行的操作新增 if (methods[i].invoke(test, null) == null) &#123; //4 System.out.println(&quot;此对象没有值！！！&quot;); &#125; else &#123; Object strName = methods[i].invoke(test, null); System.out.println(strName); &#125; &#125; &#125; &#125;&#125; invoke方法的使用实际上invoke方法的使用，和我们常见的有所区别。 我们经常创建一个对象A，A对象里面的方法getA()方法，然后A.getA() 我们采用新的方式调用（1）弄一个方法的“替身”（其实就是构建一个Method对象，让这个Method对象来代替你现在要用的方法）（2）然后给替身需要的对象和参数，让替身去替你调用（像替身替你去战斗） 12345678910111213141516171819202122232425262728package reflection;import org.junit.jupiter.api.Test;import java.lang.reflect.Method;public class InvokeTest &#123; public void test(String[] arg)&#123; for (String string : arg) &#123; System.out.println(&quot;zp is &quot; + string); &#125; &#125; @Test public void invokeDemo() throws Exception &#123; //获取字节码对象,这里要填好你对应对象的包的路径 Class&lt;InvokeTest&gt; clazz = (Class&lt;InvokeTest&gt;) Class.forName(&quot;reflection.InvokeTest&quot;); //形式一：获取一个对象// Constructor con = clazz.getConstructor();// InvokeTest m = (InvokeTest) con.newInstance(); //形式二：直接new对象，实际上不是框架的话，自己写代码直接指定某个对象创建并调用也可以 InvokeTest m = new InvokeTest(); String[] s = new String[]&#123;&quot;handsome&quot;,&quot;smart&quot;&#125;; //获取Method对象 Method method = clazz.getMethod(&quot;test&quot;, String[].class); //invoke方法要比别的方法多做一步 //调用invoke方法来调用 method.invoke(m, (Object) s); &#125;&#125; 输出结果 zp is handsomezp is smart 所以使用invoke方法要比别的方法多做一步，就是构建一个Method对象，这个对象替代的是现在程序要调用方法的替代品。 而且除了参数以外，invoke还会多要一个对象，因为方法调用需要对象，所以invoke要想调用的目标方法，就需要目标方法的需要的对象。 看起来invoke方法不仅比平常方法直接调用要麻烦很多，但是你有想过吗，我只需要输入参数，我可以调用替代各种方法，在未知的情况下，根据条件决定去调用什么对象，什么方法，一下子就让代码变得灵活，这不仅是invoke的妙处，也是整个反射的妙处，在程序运行时根据条件灵活使用。 https://zhuanlan.zhihu.com/p/350058223 Method信息我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 123456789101112131415161718192021222324class Student extends Person &#123; public int getScore(String type) &#123; return 99; &#125; private int getGrade(int year) &#123; return 1; &#125;// @Override// public void hello() &#123;// System.out.println(&quot;Student:hello&quot;);// &#125;&#125;class Person &#123; public String getName() &#123; return &quot;Person&quot;; &#125; public void hello() &#123; System.out.println(&quot;Person:hello&quot;); &#125;&#125; 12Class&lt;Student&gt; methodClass = Student.class;Arrays.stream(methodClass.getMethods()).forEach(method -&gt; System.out.println(&quot;method方法: &quot; + method)); 打印出 method方法: public int reflection.liao.Student.getScore(java.lang.String)method方法: public void reflection.liao.Person.hello()method方法: public java.lang.String reflection.liao.Person.getName() 12Class&lt;Person&gt; methodClass = Person.class;Arrays.stream(methodClass.getMethods()).forEach(method -&gt; System.out.println(&quot;method方法: &quot; + method)); 打印出 method方法: public void reflection.liao.Person.hello()method方法: public java.lang.String reflection.liao.Person.getName() …object方法 getMethods()可以 获取所有public的Method（包括父类）， 不能获取到子类的方法,除非是是多肽实现 getDeclaredMethod获取的Method能否调用子类?父类class通过getDeclaredMethod获取的Method能否调用子类的对象 验证是不可以 1234567891011Class&lt;?&gt; clz = Class.forName(&quot;reflection.liao.Person&quot;);Object o = clz.newInstance();Method methodGetName = clz.getMethod(&quot;getName&quot;);Object noParams = methodGetName.invoke(o);System.out.println(noParams);Method methodHello = clz.getMethod(&quot;hello&quot;);System.out.println(methodHello.invoke(o));Method methodGetGrade = clz.getMethod(&quot;getGrade&quot;);System.out.println(methodGetGrade.invoke(o)); A PersonPerson:hellonull &#x2F;&#x2F; 这个null是哪里来的 提示 java.lang.NoSuchMethodException: reflection.liao.Person.getGrade() 所以是调用不了的。 https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760 http://www.51gjie.com/java/796.html https://www.cnblogs.com/onlywujun/p/3519037.html&gt;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[],"author":"Jon"},{"title":"TOOL IDEA ERROR","slug":"TOOL-idea-error","date":"2024-05-30T07:50:12.000Z","updated":"2024-09-15T12:52:11.529Z","comments":true,"path":"/2024/05/30/idea-error/","link":"","permalink":"https://noteforme.github.io/2024/05/30/idea-error/","excerpt":"","text":"No tests found for given includes Errorwhen running Parameterized Unit test in Android Studio","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[],"author":"Jon"},{"title":"Ready Interview this time","slug":"interview-ready-this-time","date":"2024-05-30T02:03:52.000Z","updated":"2024-09-15T09:47:46.005Z","comments":true,"path":"/2024/05/30/ready-interview-this-time/","link":"","permalink":"https://noteforme.github.io/2024/05/30/ready-interview-this-time/","excerpt":"","text":"ArchtechtrueAndroid MVP MVVM,现在组件演进成MVVM，最主要的原因是什么。数据绑定（Data Binding）： MVVM 通过数据绑定库（如 Android 的 Data Binding Library 和 Jetpack Compose）实现了视图和数据之间的直接绑定，减少了样板代码，使得代码更加简洁和易于维护。解耦性： MVVM 模式通过 ViewModel 将视图逻辑与业务逻辑分离，使得视图和模型之间的耦合度更低。这使得代码更易于测试和复用。响应式编程： MVVM 借助 LiveData 或 RxJava 等响应式编程工具，使得视图能够自动观察数据变化并进行更新，从而简化了更新 UI 的过程。生命周期感知： MVVM 中的 ViewModel 是生命周期感知的，这意味着它们在配置更改（如设备旋转）时不会被销毁，避免了内存泄漏和不必要的资源重建问题。适应现代架构组件： MVVM 更加适合与现代 Android 架构组件（如 Room、ViewModel、LiveData 等）一起使用，这些组件设计之初就是为了与 MVVM 模式无缝集成，提供更好的开发体验。这些优势使得 MVVM 成为 Android 开发中越来越流行的架构选择，帮助开发者更高效地构建和维护应用。","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"Architecture","slug":"architecture","date":"2024-05-30T02:01:47.000Z","updated":"2024-10-02T01:35:02.773Z","comments":true,"path":"/2024/05/30/architecture/","link":"","permalink":"https://noteforme.github.io/2024/05/30/architecture/","excerpt":"","text":"Archtechtruehttps://juejin.im/post/5e801a49e51d45470e2bc8bf https://wanandroid.com/blog/show/2754 https://mp.weixin.qq.com/s/AJ4QUqdYMeQWgWEQAFPsww https://juejin.im/post/6876968255597051917 APP模式 MVC MVP. MVVM:面试题 mvp与mvvm的区别，mvvm怎么更新UI 讲讲mvc,mvp模式，presenter内存泄漏的问题 代理模式与装饰模式的区别，手写一个静态代理，一个动态代理 MVP怎么处理内存泄漏 Mvp与Mvvm有什么区别? mvvm双向数据绑定的原理是怎样的？ViewModel 你在项目中有用到什么设计模式吗？ 单例模式有什么缺点？ 动画里面用到了什么设计模式？ OkHttp里面用到了什么设计模式？ 谈谈设计模式，你了解多少，运用了多少？ MVP Presenter 的作用类似于MVC中的Controller,但是其会反作用与View层，Model层的数据更新会被首先反馈到 Presenter,由Presenter优先处理并决定是否刷新以及刷新哪个View,也就是说Presenter完全将View层与Model层 隔离开，充当一个名副其实的中间人角色. MVVM MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上 缺点 1、过于简单的图形界面不适用，或说牛刀杀鸡。2、对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。3、数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。 Jetpack It helps to be familiar with software architectural patterns that separate data from the user interface, such as MVP or MVC https://developer.android.com/jetpack/docs/getting-started modules should interact NetworkBoundResource It starts by observing the database for the resource. When the entry is loaded from the database for the first time, NetworkBoundResource checks whether the result is good enough to be dispatched or that it should be re-fetched from the network. Note that both of these situations can happen at the same time, given that you probably want to show cached data while updating it from the network. https://developer.android.com/topic/libraries/architecture 架构学习从codelab开始吧! https://www.jianshu.com/p/19f97654c451 https://github.com/qingmei2/MVVM-Architecture https://juejin.im/post/5dafc49b6fb9a04e17209922 https://juejin.im/post/5d2be05ff265da1bd605d49a LifecycleOwnerLifecycleOwner is an interface implemented by the AppCompatActivity and Fragment classes. You can subscribe other components to owner objects which implement this interface, to observe changes to the lifecycle of the owner. To read an introductory guide to this topic, see Handling Lifecycles. https://codelabs.developers.google.com/codelabs/android-lifecycles/#1 https://mp.weixin.qq.com/s/gQhBeKA2vGAkh3Tbqn0tEA ViewModelhttps://noteforme.github.io/2020/04/06/viewmodel/ https://www.jianshu.com/p/731ca42823ee viewmodelstoreowner navigationhttps://developer.android.com/guide/navigation/ https://developer.android.com/guide/navigation/navigation-getting-started https://codelabs.developers.google.com/codelabs/android-navigation/index.html?index=..%2F..%2Findex#0 Codelab 抽屉图标不显示 BottomNavigationView 导航栏优化 recarete fragment https://medium.com/@freedom.chuks7/how-to-use-jet-pack-components-bottomnavigationview-with-navigation-ui-19fb120e3fb9 NOTICE : NavigationView each item ID is matching with fragment ID in navigation https://jiangjiwei.site/post/navigation-zhi-fragment-qie-huan/ https://github.com/lwj1994/navigation-keep-state-fragment https://github.com/STAR-ZERO/navigation-keep-fragment-sample Bottom tab定位 https://stackoverflow.com/questions/50577356/android-jetpack-navigation-bottomnavigationview-with-youtube-or-instagram-like 全局共享 googlesamples previously architectureMVC MVP. MVVM三种架构介绍 http://www.jcodecraeer.com/a/anzhuokaifa/2017/1024/8636.html https://mp.weixin.qq.com/s/Kc1826MQ3ReMkoIWlsQGVw https://juejin.im/post/5dafc49b6fb9a04e17209922 https://juejin.im/post/5dafc49b6fb9a04e17209922#heading-13 MVP https://juejin.im/entry/5955e7166fb9a06bc23a8598 https://github.com/yaozs/YzsBaseActivity 多个activity对p的复用 https://juejin.im/post/599ce8016fb9a0247e4255f4 Component https://mp.weixin.qq.com/s/8_8gGpkpO2QFNkWgSRBwIg https://www.jianshu.com/p/6a50ef1ef45c https://developer.android.com/studio/build/dependencies#duplicate_classes https://developer.android.com/studio/build/manifest-merge?hl=zh-cn merge androidmanifest 合并 &lt;https://developer.android.com/studio/build/manifest-merge https://www.jianshu.com/p/14a822e42151 compose https://mp.weixin.qq.com/s/0mAbKEuBH5HHYa23EcWalg lifecycle https://juejin.im/post/6847902220755992589 组件化 服务 https://juejin.im/post/6884492604370026503","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://noteforme.github.io/categories/Architecture/"},{"name":"test","slug":"Architecture/test","permalink":"https://noteforme.github.io/categories/Architecture/test/"}],"tags":[],"author":"Jon"},{"title":"DesignPattern Proxy","slug":"designpattern-proxy","date":"2024-05-28T07:32:07.000Z","updated":"2024-09-15T09:49:47.777Z","comments":true,"path":"/2024/05/28/designpattern-proxy/","link":"","permalink":"https://noteforme.github.io/2024/05/28/designpattern-proxy/","excerpt":"","text":"也可以参考一起https://jonblog.site/2024/05/31/reflection/https://jonblog.site/2024/05/28/designpattern-proxy/https://jonblog.site/2024/06/06/annotation/ Static Proxy编译的时候就已经存在Static proxies are created at compile time. You need to write the proxy class manually, and it will contain references to the methods of the original class.Key Characteristics: Compile-Time Creation: Static proxies are created at compile time, meaning you need to write the proxy class manually. Tight Coupling: Since you need to write the proxy class, there’s a tighter coupling between the proxy and the original class. Use Cases: Often used for simple scenarios where you need to add a specific behavior to a method call. Separate Proxy Class: You have to create a separate class for the proxy which implements the same interface as the target class. Java implement12345678910public interface ZyxInterface &#123; void sayHello(String name);&#125;public class ZhangYuXin implements ZyxInterface &#123; @Override public void sayHello(String name) &#123; System.out.println(&quot;Hello from zyx &quot;+ name); &#125;&#125; 代理类 1234567891011121314public class ZhangYuXinProxy implements ZyxInterface &#123; private ZhangYuXin zhangYuXin; public ZhangYuXinProxy(ZhangYuXin zhangYuXin) &#123; this.zhangYuXin = zhangYuXin; &#125; @Override public void sayHello(String name) &#123; System.out.println(&quot;拍电影前的准备工作&quot;); zhangYuXin.sayHello(name); System.out.println(&quot;拍电影后的收尾工作&quot;); &#125;&#125; 123ZhangYuXin zyxHello = new ZhangYuXin();ZhangYuXinProxy zhangYuXin = new ZhangYuXinProxy(zyxHello);zhangYuXin.sayHello(&quot;hello&quot;); 运行结果 拍电影前的准备工作Hello from zyx拍电影后的收尾工作 UML 代理模式 代理类与委托类有同样的接口 代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。 一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 Dynamic Proxy通过反射机制生成的代理对象 Dynamic proxies in Java are created at runtime. They use reflection and the java.lang.reflect.Proxy class along with the InvocationHandler interface to handle method invocations. Key Characteristics: Runtime Creation: Dynamic proxies are created at runtime, which means you don’t need to write separate classes for proxies. Flexibility: Since they are created at runtime, they can be more flexible and can easily adapt to changes. Use Cases: Commonly used in frameworks like Spring AOP for cross-cutting concerns (e.g., logging, transaction management). No Implementation Class Needed: You don’t need to create a separate class for the proxy; you just need to provide an implementation for the InvocationHandler. Summary Dynamic Proxy: Created at runtime using java.lang.reflect.Proxy. More flexible and decoupled. No need for separate proxy classes. Static Proxy: Created at compile time by manually writing the proxy class. Tighter coupling with the target class. Requires a separate proxy class. Dynamic proxy implementation生成的动态代理Class文件 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DoSomeThingDynamic &#123; Object object; public DoSomeThingDynamic(Object object) &#123; this.object = object; &#125; /** * @param say 需要代理执行的接口类 * @param &lt;T&gt; * @return 动态代理 运行时生成的一个say对应类型的类，用于调用say接口的时候 运行 */ public &lt;T&gt; T create(final Class&lt;T&gt; say) &#123; return (T) Proxy.newProxyInstance(say.getClassLoader(), new Class&lt;?&gt;[]&#123;say&#125;, new InvocationHandler() &#123; /** * invoke方法: 代理类 BinInterface$0 调用super.h.invoke(this, m3, new Object[]&#123;var1&#125;);就会调用到 * Object o : 代表生成的new BinInterface$0()对象， * Method method : 代理类调用的方法，把方法传进来。 * Object[] args ： 方法的参数 */ @Override public Object invoke(Object o, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;拍电影前的准备工作&quot;); /** * method这个函数是 反射的函数 * * 等价于 zhangYuXin.sayHello(); * similar to * object.method(arg) * * object 是目标类，也就是 new zhangYuXin() * 下面object 不能用invoke(Object o)中的参数o替代。 */ Object result = method.invoke(object, args); System.out.println(&quot;拍电影后的收尾工作&quot;); return result; &#125; &#125; ); &#125;&#125; call from client12345678910111213141516171819202122232425DoSomeThingDynamic say1 = new DoSomeThingDynamic(zyxHello);ZyxInterface zyxProxy = say1.create(ZyxInterface.class);zyxProxy.sayHello(&quot;John&quot;);System.out.println(&quot;---------------------\\n&quot;);BinBin binBye = new BinBin();DoSomeThingDynamic say2 = new DoSomeThingDynamic(binBye);BinInterface bbProxy = say2.create(BinInterface.class);bbProxy.sayBye();/** * 生成代理类的，并且输出字节码 */byte[] classFile = ProxyGenerator.generateProxyClass(&quot;BinInterface$0&quot;, new Class[]&#123;ZyxInterface.class&#125;);try &#123; FileOutputStream out = new FileOutputStream( &quot;BinInterface$0.class&quot;); out.write(classFile); out.flush();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; BinInterface$0.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class BinInterface$1 extends Proxy implements ZyxInterface &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public BinInterface$1(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void sayHello(String var1) throws &#123; try &#123; super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m3 = Class.forName(&quot;pattern.proxy.xiangxue.ZyxInterface&quot;).getMethod(&quot;sayHello&quot;, Class.forName(&quot;java.lang.String&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 运行结果 拍电影前的准备工作Hello from zyx John拍电影后的收尾工作 拍电影前的准备工作Bye Bye from BinBin拍电影后的收尾工作 https://www.bilibili.com/video/BV1ib4y1f7S1?p=10&amp;spm_id_from=pageDriverhttps://www.bilibili.com/video/BV1uQ4y1Z7gA?p=23https://juejin.cn/post/6844903520919879694https://juejin.cn/post/6844903978342301709https://time.geekbang.org/column/article/201823 Dynamic proxy principle sequenceDiagram DynamicProxyTest->>BinInterface$0 : invoke sayHello(\"hello\") BinInterface$0 ->> InvocationHandler : h.invoke(this, m3, new Object[]{var1}) Note right of InvocationHandler : 传参调用到InvocationHandler的invoke InvocationHandler ->> ZhangYuXin: method.invoke(object, args) Note right of ZhangYuXin : 类似于 object.method(arg) or ZhangYuXin.sayHello(\"arg\") 我们下面 bbProxy.sayBye(); 调用开始分析整个流程 bbProxy 是生成的代理类对象,调用后进入到代理类方法 123456789public final void sayHello(String var1) throws &#123; try &#123; super.h.invoke(this, m3, new Object[]&#123;var1&#125;); //这个是方法的传参，不是反射 &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125;&#125; 调用 super.h.invoke(this, m3, new Object[]{var1}); super.h 是调用public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)传进来的new InvocationHandler() 最终调用到cons.newInstance(new Object[]{h}); InvocationHandler()传入构造方法,然后调用 protected Proxy(InvocationHandler h) cons.newInstance(new Object[]{h}12345678private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) &#123; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); return cons.newInstance(new Object[]&#123;h&#125;); &#125; cl.getConstructor(constructorParams) 指定的是 InvocationHandler类型的构造方法, 也就是 1234protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h;&#125; 正常流程 123456789101112131415161718@Overridepublic Object invoke(Object o, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;拍电影前的准备工作&quot;); /** * method这个函数是 反射的函数 * * 等价于 zhangYuXin.sayHello(); * similar to * object.method(arg) * * object 是目标类，也就是 new zhangYuXin() * 下面object 不能用invoke(Object o)中的参数o替代。 */ Object result = method.invoke(object, args); System.out.println(&quot;拍电影后的收尾工作&quot;); return result;&#125; Object result &#x3D; method.invoke(object, args); 开始调用代理类的方法。 123456@Overridepublic void sayHello(String name) &#123; System.out.println(&quot;拍电影前的准备工作&quot;); zhangYuXin.sayHello(name); System.out.println(&quot;拍电影后的收尾工作&quot;);&#125; Simulate Jdkthis video write code simulate JDK dynamic proxy https://www.bilibili.com/video/BV1Ve411o7WM simple123456789101112131415161718192021222324252627282930313233public class ProxyDog implements Target&#123; InvocationHandler h; public ProxyDog(InvocationHandler h) &#123; this.h = h; &#125; @Override public void eat() &#123; h.invoke(); &#125; @Override public void drink() &#123; h.invoke(); &#125;&#125; /** * stimulate Jdk dynamic proxy 方式1 */ ProxyDog proxyDog = new ProxyDog(new InvocationHandler() &#123; @Override public void invoke() &#123; //enhancement feature System.out.println(&quot;before&quot;); new TargetDog().eat(); &#125; &#125;); proxyDog.eat(); proxyDog.drink(); //从这里看， 调用 drink()后，还是调用了eat() 这种方式 调用 drink()后，没法区分，调用drink()， 还是调用了eat() simulate jdk模拟jdk动态代理，InvocationHandler方法是自己的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface InvocationHandler &#123; void invoke(Method method,Object[] args);&#125;public class ProxyDog implements Target &#123; InvocationHandler h; public ProxyDog(InvocationHandler h) &#123; this.h = h; &#125; static Method eat; static Method drink; static &#123; try &#123; eat = Target.class.getMethod(&quot;eat&quot;); drink = Target.class.getMethod(&quot;drink&quot;); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public void eat() &#123; h.invoke(eat, new Object[0]); &#125; @Override public void drink() &#123; h.invoke(drink, new Object[0]); &#125;&#125; ProxyDog proxyDog = new ProxyDog(new InvocationHandler() &#123; @Override public void invoke(Method method, Object[] args) &#123; //enhancement feature System.out.println(&quot;before&quot;);// new TargetDog().eat(); try &#123; method.invoke(new TargetDog(),args); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;); proxyDog.eat(); proxyDog.drink(); simulate with jdk InvocationHandler下面的做法使用Jdk自带的InvocationHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ProxyDog implements Target &#123; InvocationHandler h; public ProxyDog(InvocationHandler h) &#123; this.h = h; &#125; static Method eat; static Method drink; static &#123; try &#123; eat = Target.class.getMethod(&quot;eat&quot;); drink = Target.class.getMethod(&quot;drink&quot;); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public void eat() &#123; try &#123; h.invoke(this,eat, new Object[0]); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public void drink() &#123; try &#123; h.invoke(this,drink, new Object[0]); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; ProxyDog proxyDog = new ProxyDog(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; //enhancement feature System.out.println(&quot;before&quot;);// new TargetDog().eat(); try &#123; return method.invoke(new TargetDog(), args); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;); proxyDog.eat(); proxyDog.drink(); 从上面可以看到，Method eat &#x3D; Target.class.getMethod(“eat”); class中的Method,可以作为参数传递。 Dynamic Constructor analysisfinal Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams); kotlin 委托的作用1234567891011121314interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by b // kotlin这里自动生成了java代理类fun main() &#123; val b = BaseImpl(10) Derived(b).print()&#125; 反编译后的代码 1234567891011121314151617181920212223242526272829303132// BaseImpl.javapackage test;public final class BaseImpl implements Base &#123; private final int x; public void print() &#123; int var1 = this.x; System.out.print(var1); &#125; public final int getX() &#123; return this.x; &#125; public BaseImpl(int x) &#123; this.x = x; &#125;&#125;public final class Derived implements Base &#123; // 生成的代理类 private final Base $$delegate_0; public Derived(@NotNull Base b) &#123; Intrinsics.checkNotNullParameter(b, &quot;b&quot;); super(); this.$$delegate_0 = b; &#125; public void print() &#123; this.$$delegate_0.print(); &#125;&#125;","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[],"author":"Jon"},{"title":"INTERVIEW CONCURRENCY","slug":"interview-concurrency","date":"2024-05-27T06:37:22.000Z","updated":"2024-09-15T09:52:07.305Z","comments":true,"path":"/2024/05/27/interview-concurrency/","link":"","permalink":"https://noteforme.github.io/2024/05/27/interview-concurrency/","excerpt":"","text":"https://noteforme.github.io/tags/concurrency/ 线程基础Java线程模型 用户线程与内核级线程 并发与并行 多线程模型 https://crazyfzw.github.io/2018/06/19/thred-model/ 谈谈对多线程的理解 在Android中一个应用程序就是一个单独的进程，一般来说，当我们运行一个应用，系统就会自动创建一个进程，并且为这个进程创建一个主线程–UI线程，这样就可以运行MainActivity。 线程是操作系统能够进行运算调度的最小单位，线程是进程的子集，线程可以并行的执行不同任务，所有的线程共享同一片内存空间，这就为线程间通信提供了基础，线程有五种状态：创建，就绪，运行，阻塞，死亡。 多线程有什么要注意的问题？并发问题，安全问题，效率问题。 谈谈你对并发编程的理解并举例说明 谈谈你对多线程同步机制的理解？ ? 进程和线程的区别 协程呢 进程 ​ 是系统给程序分配资源的基本单位，每个进程都有唯一的地址空间，一个程序至少有一个进程，一个进程至少有一个线程. 线程 线程是执行操作的基本单位，JVM结构中共享 Method Area ,Heap Area ​ https://blog.csdn.net/mxsgoden/article/details/8821936 ​ https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 进程 : 有很大的独立性 线程 : 所有线程都有完全一样的地址空间,意味着它们也共享同样的全局变量。由于线程可以访问进程地址空间的每一个内存地址，所以一个线程可以读、写甚至清除另一个线程的堆栈。 每个进程中的内容 : 地址空间 全局变量 打开文件 子进程 即将发生的定时器 信号与信号处理程序 每个线程中的内容：程序计数器、寄存器、堆栈、状态. 协程? ​ 协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的 时候，恢复先前保存的寄存器上下文和栈，即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。 协程的好处: 无需线程上下文切换的开销 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型 ​ 为什么要有线程，而不是仅仅用进程？ 怎么创建一个线程 继承Thread类创建线程类. 通过Runnable接口创建线程类 通过Callable和FutureTask创建线程 1234567891011121314151617181920212223242526272829public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; 的循环变量i的值&quot; + i); if (i == 20) &#123; new Thread(ft, &quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值：&quot; + ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for (; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; return i; &#125;&#125; 线程如何关闭？​ 最正确的停止线程的方式是使用 interrupt,和条件满足. 123while (!Thread.currentThread().isInterrupted() &amp;&amp; cout&lt;1000) &#123; do more work&#125; 在Java中wait和sleep方法的不同1231. sleep作用Thread上，wait作用object上2. sleep不会释放锁3. sleep可以在任何代码块。wait必须在同步方法，持有锁中运行。 ​ 谈谈wait&#x2F;notify关键字的理解 调用之前持有对象锁 wait ,线程进入 waiting状态，释放对象锁 notify,唤醒处于waiting状态的线程。 https://howtodoinjava.com/java/multi-threading/wait-notify-and-notifyall-methods/ 如何控制某个方法允许并发访问线程的个数？​ 信号量 什么导致线程阻塞？ 阻塞指的是暂停一个线程的执行以等待某个条件发生。 Thread.sleep t.join 等待输入 线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。 如何保证线程安全？121. 使用线程安全的类。2. 使用synchronized同步代码块，或者用Lock锁。 如何实现线程同步？121. Synchronized修饰整个方法或代码块。2. Lock 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？​ 可以进行同时读写，但为了保证数据的正确，必须要针对进程访问的共享临界区进行处理；两个进程不能同时进入临界区，否则会导致数据错乱。常见的处理方式有：信号量、管程、会合、分布式系统 信号量 信号量是一个计数器，它只支持2种操作：P操作（进入临界区）和V操作（退出临界区）。假设有信号量SV，则对它的P、V操作含义如下： P(SV)，如果SV的值大于0，意味着可以进入临界区，就将它减1；如果SV的值为0，意味着别的进程正在访问临界区，则挂起当前进程的执行； V(SV)，当前进程退出临界区时，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1，之后再退出临界区。 管程 提出原因：信号量机制不足，程序编写困难、易出错 12 方案：在程序设计语言中引入一种高级维护机制 定义：是一个特殊的模块；有一个名字；由关于共享资源的数据结构及在其上操作上的一组过程组成。进程只能通过调用管程中的过程间接访问管程中的数据结构 1）互斥：管程是互斥进入的 为了保证数据结构的数据完整性管程的互斥由编译器负责保证的，是一种语言机制 2）同步：设置条件变量及等待唤醒操作以解决同步问题可以让一个进程或者线程在条件变量上等待（先释放管程的管理权），也可以通过发送信号将等待在条件变量上的进程线程唤醒 链接：https://www.jianshu.com/p/72f5017c6649 线程间操作List​ 怎么中止一个线程，Thread.Interupt一定有效吗？不一定 https://juejin.cn/post/6844903896339447815#heading-6 线程安全 锁讲一下java中的同步的方法 结果锁一起 synchronized wait和notify volatile a. volatile关键字为域变量的访问提供了一种免锁机制b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新c.因此每次使用该域就要重新计算，而不是使用寄存器中的值d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 synchronize的原理 原子性：确保线程互斥的访问同步代码； 可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的； 有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”； 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解 当synchronized作用于普通方法是，锁对象是this； 当synchronized作用于静态方法是，锁对象是当前类的Class对象； 当synchronized作用于代码块时，锁对象是synchronized(obj)中的这个obj。 static synchronized 方法的多线程访问和作用也就是两个的区别了,也就是synchronized相当于this.synchronized，而static synchronized相当于Something.synchronized，它可以对类的所有对象实例起作用 synchronized与Lock的区别Lock支持的功能: 公平锁：Synchronized是非公平锁，ReentrantLock支持公平锁，默认非公平锁 可中断锁：ReentrantLock提供了lockInterruptibly（）的功能，可以中断争夺锁的操作，抢锁的时候会check是否被中断，中断直接抛出异常，退出抢锁。而Synchronized只有抢锁的过程，不可干预，直到抢到锁以后，才可以编码控制锁的释放。 快速反馈锁：ReentrantLock提供了trylock（） 和 trylock（tryTimes）的功能，不等待或者限定时间等待获取锁，更灵活。可以避免死锁的发生。 读写锁：ReentrantReadWriteLock类实现了读写锁的功能，类似于Mysql，锁自身维护一个计数器，读锁可以并发的获取，写锁只能独占。而synchronized全是独占锁 Condition：ReentrantLock提供了比Sync更精准的线程调度工具，Condition，一个lock可以有多个Condition，比如在生产消费的业务下，一个锁通过控制生产Condition和消费Condition精准控制。 https://www.jianshu.com/p/09d5ba4bfb7a ReentrantLock的内部实现显式锁ReentrantLock和同步工具类的实现基础都是AQS (AbstractQueuedSynchronizer).AQS内部有一条双向的队列存放等待线程，节点是Node对象。每个Node维护了线程、前后Node的指针和等待状态等参数。 ReentrantLock是可重入锁，也就是同一个线程可以多次获取锁，每获取一次就会进行一次计数，解锁的时候就会递减这个计数，直到计数变为0。 它有两种实现，一种是公平锁，一种是非公平锁， lock原理整体来看Lock主要是通过两个东西来实现的分别是CAS和AQS(AbstractQueuedSynchronizer)。通过加锁和解锁的过程来分析锁的实现。 一、整体概述流程 读取表示锁状态的变量 如果表示状态的变量的值为0，那么当前线程尝试将变量值设置为1（通过CAS操作完成），当多个线程同时将表示状态的变量值由0设置成1时，仅一个线程能成功，其它线程都会失败。失败后进入队列自旋转并阻塞当前线程。 2.1 若成功，表示获取了锁， 2.1.1 如果该线程（或者说节点）已位于在队列中，则将其出列（并将下一个节点则变成了队列的头节点） 2.1.2 如果该线程未入列，则不用对队列进行维护 2.1.3 然后当前线程从lock方法中返回，对共享资源进行访问。 2.2 若失败，则当前线程将自身放入等待（锁的）队列中并阻塞自身，此时线程一直被阻塞在lock方法中，没有从该方法中返回（被唤醒后仍然在lock方法中，并从下一条语句继续执行，这里又会回到第1步重新开始）。 如果表示状态的变量的值为1，那么将当前线程放入等待队列中，然后将自身阻塞https://blog.csdn.net/liyantianmin/article/details/54673109 死锁的四个必要条件？ 互斥条件: 指线程对己经获取到的资源进行排它性使用 ，即该资源同时只由 一个线程占用。如果 此时 还有其 他 线程请求获取该资源 ，则 请求者只能等待，直至占有资源 的 线程释放该资源。 请求并持有条件 : 指一个线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其 他 线程占有，所 以 当前线程会被阻塞 ，但 阻塞 的同时 并不释放自 己己经获取的资源。 不可剥夺条件 : 指线程获取到的资源在自己使用完之前不能被其他线程抢占 ， 只有在自己使用完 毕后才 由 自 己释放该资源。 环路等待条件 : 指在发生死锁时 ，必然存在一个线程→资源的环形链 ，即线程集合 怎么避免死锁？请求并持有和环路等待条件是可 以被破坏. synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的 synchronized只能是非公平锁。 而ReentrantLock可以实现公平锁和非公平锁两种。 公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象 synchronized跟ReentranLock有什么区别？都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待 synchronized 自动释放锁,只有非公平锁。都是可重入的 ReentrantLock 手动释放锁 对象锁和类锁是否会互相影响？不会相互影响 类锁 在代码中的方法上加了static和synchronized的锁，或者synchronized(xxx.class）的代码段 对象锁 在代码中的方法上加了synchronized的锁，或者synchronized(this）的代码段 私有锁 在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock） 管理线程 提高效率volatile的原理有序性. 可见性 : （1）修改volatile变量时会强制将修改后的值刷新的主内存中。 （2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 https://www.cnblogs.com/paddix/p/5428507.html https://www.bilibili.com/video/BV1NT4y1G7WE?p=8 synchronized 和volatile 关键字的区别 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化. 多线程断点续传原理 其实原理很简单，只需要保证每个子任务的下载进度能够被即时地记录即可。这样继续下载时只需要读取这些下载记录，从上次下载结束的位置开始下载即可。 https://juejin.cn/post/6844904013440221198 线程池JavaAPI线程池有哪些参数 为什么要用线程池 降低资源消耗2. 提高响应速度3. 提高线程的可管理性 什么是线程池，如何使用?很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池 什么是核心线程​ 常驻线程池的线程数量 怎么销毁核心线程​ allowCoreThreadTimeOut ​ https://objcoding.com/2019/04/14/threadpool-some-settings/ 为什么DCL DOUBLE CHECK LOCK要那么写，直接在方法前加synchronized不行吗​ 不DCL 这样写，就会创建多个实例 ​ synchronized可以，这样粒度太大了. ​ https://blog.csdn.net/zhaoyajie1011/article/details/106812327 如何让两个线程循环交替打印LockSupport_1A2B.java 12345678910111213141516171819202122232425 char[] aI = &quot;1234567&quot;.toCharArray(); char[] aC = &quot;ABCDEFG&quot;.toCharArray(); t1 = new Thread(() -&gt; &#123; for (char c : aI) &#123; System.out.print(c); LockSupport.unpark(t2); LockSupport.park(); &#125; LockSupport.unpark(t2); &#125;); t2 = new Thread(() -&gt; &#123; for (char c : aC) &#123; System.out.print(c); LockSupport.unpark(t1); LockSupport.park(); &#125; LockSupport.unpark(t1); &#125;); t1.start(); t2.start();// System.out.println(&quot;t1 &quot; + t1.getState());// System.out.println(&quot;t2 &quot; + t2.getState()); t1.join(); t2.join(); Notify_1A2B.java 12345678910111213141516171819202122232425262728293031323334Notify_1A2B o = new Notify_1A2B();char[] aI = &quot;1234567&quot;.toCharArray();char[] aC = &quot;ABCDEFG&quot;.toCharArray();t1 = new Thread(() -&gt; &#123; synchronized (o) &#123; for (char c : aI) &#123; System.out.print(c); o.notify(); try &#123; o.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;);t2 = new Thread(() -&gt; &#123; try &#123; synchronized (o) &#123; for (char c : aC) &#123; System.out.print(c); o.notify(); o.wait(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;);t1.start();t2.start();t1.join();t2.join(); 协程可以在Java项目中使用吗？ 线程池了解多少？拒绝策略有几种,为什么有newSingleThread 跨进程通信了解多少？管道了解吗？123456789101112文件AIDL （基于 Binder） Android 进阶：进程通信之 AIDL 的使用 Android 进阶：进程通信之 AIDL 解析Binder Android 进阶：进程通信之 Binder 机制浅析Messenger （基于 Binder） Android 进阶：进程通信之 Messenger 使用与解析 ContentProvider （基于 Binder） Android 进阶：进程通信之 ContentProvider 内容提供者 Socket Android 进阶：进程通信之 Socket （顺便回顾 TCP UDP） 原文链接：https://blog.csdn.net/u011240877/article/details/72863432 底层原理 RXJava怎么切换线程 binder进程间通信可以调用原进程方法吗？ SharedPreference原理？读取xml是在哪个线程? AQS了解吗？ ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。 https://www.zhihu.com/question/63859501 AQShttp://gee.cs.oswego.edu/dl/papers/aqs.pdf https://www.bilibili.com/video/BV11Q4y1M7K2?from=search&amp;seid=12598203519866117819 https://javadoop.com/post/AbstractQueuedSynchronizer https://www.bilibili.com/video/BV1yJ411v7er?from=search&amp;seid=12598203519866117819 阻塞队列原理 阻塞功能:阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来 是否有界 LinkedBlockingQueue 的上限是 Integer.MAX_VALUE，约为 2 的 31 次方, ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"INTERVIEW NETWORK","slug":"interview-network","date":"2024-05-27T06:33:00.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/05/27/interview-network/","link":"","permalink":"https://noteforme.github.io/2024/05/27/interview-network/","excerpt":"","text":"1.ARP协议:在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。 2.HTTP HTTPS的区别: 1.HTTPS使用TLS(SSL)进行加密 2.HTTPS缺省工作在TCP协议443端口 3.它的工作流程一般如以下方式: 1.完成TCP三次同步握手 2.客户端验证服务器数字证书，通过，进入步骤3 3.DH算法协商对称加密算法的密钥、hash算法的密钥 4.SSL安全加密隧道协商完成 5.网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改 3.http请求包结构，http返回码的分类，400和500的区别 1.包结构： 1.请求：请求行、头部、数据 2.返回：状态行、头部、数据 2.http返回码分类：1到5分别是，消息、成功、重定向、客户端错误、服务端错误 4.Tcp 1.可靠连接，三次握手，四次挥手 1.三次握手：防止了服务器端的一直等待而浪费资源，例如只是两次握手，如果s确认之后c就掉线了，那么s就会浪费资源 1.syn-c &#x3D; x，表示这消息是x序号 2.ack-s &#x3D; x + 1，表示syn-c这个消息接收成功。syn-s &#x3D; y，表示这消息是y序号。 3.ack-c &#x3D; y + 1，表示syn-s这条消息接收成功 2.四次挥手：TCP是全双工模式 1.fin-c &#x3D; x , 表示现在需要关闭c到s了。ack-c &#x3D; y,表示上一条s的消息已经接收完毕 2.ack-s &#x3D; x + 1，表示需要关闭的fin-c消息已经接收到了，同意关闭 3.fin-s &#x3D; y + 1，表示s已经准备好关闭了，就等c的最后一条命令 4.ack-c &#x3D; y + 1，表示c已经关闭，让s也关闭 3.滑动窗口，停止等待、后退N、选择重传 4.拥塞控制，慢启动、拥塞避免、加速递减、快重传快恢复","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"},{"name":"NETWORK","slug":"INTERVIEW/NETWORK","permalink":"https://noteforme.github.io/categories/INTERVIEW/NETWORK/"}],"tags":[],"author":"Jon"},{"title":"INTERVIEW MINE experience","slug":"interview-mine","date":"2024-05-27T06:19:54.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/05/27/interview-mine/","link":"","permalink":"https://noteforme.github.io/2024/05/27/interview-mine/","excerpt":"","text":"My Interview question 米尘组件化用过没，组件化用什么通信，arouter底层源码 Arouter讲的不清楚 Android用了哪些第三方库 Retrofit底层实现，在okhttp的基础下做了哪些封装 Okhttp Resonse之后怎么交给Rxjava处理 自定义view绘制流程 构造方法 - onsizechange - onmeasre - ondraw 说下Onmeasrstate 三个常量 atmost作用 为什么onMeasrue onlayout 绘制的过程执行多遍，ondraw不会 自定义view宽高写死，不管什么地方宽高一样的，xml使用 Glide使用什么缓存机制 LRUcache底层实现 讲下事件分发机制 事件分发都没拦截，最终被谁消费hashmap hashtable区别Hashmap扩容机制 负载因子Activity启动过程Aws作用属性动画和其他动画的区别为什么不用系统进程通信用Binder内存泄漏方式 每日互动一面kotlin特点有什么不习惯的地方 ， 我说了并发 flutter包为什么那么大 fultter有什么特点 数字签名？ 谁通知zygote进程，fork新进程。 点击桌面图标，应用启动流程 屏幕上有个button,为什么button能消费事件 https流程， 签名是什么,怎么知道服务端是谁。 客户端输入一个地址到服务端，中间经历了哪些流程。 路由器是怎么找服务器的。 TCP对包处理做了什么。 二面客户投诉，反馈的问题是怎么解决，发版本。 Intent机制什么样的 发起一个Binder请求，中间有一个怎么样的流程。 多线程是怎么改造的。 线程池里面的内部调度机制是怎么样的，什么情况下让出，什么时候抓住锁。或者说线程之间的状态是怎么切换的。 加密平时有了解吗 快速排序。 澳润激MVC MVP MVVM区别 mvvm说得不清楚 MVP里面p持有activity引用，怎么持有比较好。 MVP Presenter复用，怎么处理比较好。 项目中用到测量模式，语音项目代码结构怎么样。 Okhttp retrofit Rxjava有没有看过源码。 OkHttp拦截器有没有用过，拦截器怎么实现整体的拦截的。 讲下Retrofit 动态代理类具体的方法实现。自己在项目里面有没有用过动态代理。 动态代理用到哪些场景。 Retrofit里面用Rxjava返回一个Observable，这个是怎么实现的。 Retrofit还有convert，这个convert和CallAdabter的区别。 有没有自定义convert没 onMeasure的时候，怎么确定view的大小。 Xml layout_width layout_height对应代码里面怎么对应。 Https怎么防止中间人攻击。Server的公钥一定要和本地一样的是吧。 性能优化你做过哪些方面的。 内存泄漏是怎么发生的。 内存抖动是用什么工具进行检测的。内存抖动很频繁的话，有没有针对性的做一些优化.(这个最好实践下) Android还有一个常见的性能问题，ANR你能说一下吗。 线上的ANR有没有排查的经验。怎么处理的。 kotlin在项目中有没有使用过。Kotlin相比java有哪些优势。 Kotlin ? !!都可以让编译通过，实际上有区别吗。it对象是怎么来的 Findviewbyid kotlin是怎么实现的。findviewbyid通过Map 缓存,在项目里面有使用过缓存吗。 Reprice三个单元测试步骤. 单元测试覆盖率有没有看。 组件化框架，共享数据怎么处理。放公共里面就太多了。用户model需要其他组件使用。这个怎么处理 。 自定义view触摸事件分发，能说一下吗。 ViewGroup拦截了view的事件，怎么让view不拦截，内部拦截法。 ScrollView 放了 竖的viewpager 怎么处理滑动冲突。 Gradle插件，自动化的任务。 杭州橙鹰MVP MVVM,现在组件演进成MVVM，最主要的原因是什么。 讲下viewmodel,livedata ViewModel为什么不会丢失 Livedata版本管理，这块有没有了解.(也就是粘性事件) kotlin协程有没有了解过。（协程是kotlin 语言对线程的封装） 讲下java匿名内部类, 我说 ，匿名内部类会创建类的对象，lambda不会创建对象，（面试官讲:lambda会怎么样） Kotlin 内部类的实现方式。 kotlin拓展函数是如何做到的。 为什么https要这么麻烦呢。 Https 服务端公钥客户端认可，如何做到的 中间人怎么攻击怎么做。 反射的原理，为什么能获取方法。 讲下阻塞队列，怎么实现。 对flutter怎么看. 阻塞队列原理 蚂蚁面试红包项目通用组件是 怎么跨模块调用的， applink是怎么消费的，Activity透明弹窗的逻辑。多语言和字体。什么是泛型有没有用过注解，注解是怎么消费的。字节码怎么加载到jvm中 其他总结项目中遇到什么困难，应用场景 Android MVC MVP,现在组件演进成MVVM，最主要的原因是什么。 讲下viewmodel,livedata ViewModel为什么不会丢失 Livedata版本管理，这块有没有了解.(也就是粘性事件) kotlin协程有没有了解过。（协程是kotlin 语言对线程的封装） 讲下java匿名内部类 Kotlin 内部类的实现方式。 kotlin拓展函数是如何做到的。 为什么https要这么麻烦呢。 Https 服务端公钥客户端认可，如何做到的 中间人怎么攻击怎么做。 反射的原理，为什么能获取方法。 讲下阻塞队列，怎么实现。 对flutter怎么看. 阻塞队列原理 组件化用过没，组件化用什么通信，arouter底层源码 Arouter讲的不清楚 Android用了哪些第三方库 Retrofit底层实现，在okhttp的基础下做了哪些封装 Okhttp Resonse之后怎么交给Rxjava处理 自定义view绘制流程 构造方法 - onsizechange - onmeasre - ondraw 说下Onmeasrstate 三个常量 atmost作用 为什么onMeasrue onlayout 绘制的过程执行多遍，ondraw不会 自定义view宽高写死，不管什么地方宽高一样的，xml使用 Glide使用什么缓存机制 LRUcache底层实现 讲下事件分发机制 事件分发都没拦截，最终被谁消费 hashmap hashtable区别 Hashmap扩容机制 负载因子 Activity启动过程 Aws作用 属性动画和其他动画的区别 为什么不用系统进程通信用Binder 内存泄漏方式 kotlin特点有什么不习惯的地方 ， 我说了并发 flutter包为什么那么大 fultter有什么特点 数字签名？ 谁通知zygote进程，fork新进程。 点击桌面图标，应用启动流程 屏幕上有个button,为什么button能消费事件 https流程， 签名是什么,怎么知道服务端是谁。 客户端输入一个地址到服务端，中间经历了哪些流程。 路由器是怎么找服务器的。 TCP对包处理做了什么。 客户投诉，反馈的问题是怎么解决，发版本。 Intent机制什么样的 发起一个Binder请求，中间有一个怎么样的流程。 多线程是怎么改造的。 线程池里面的内部调度机制是怎么样的，什么情况下让出，什么时候抓住锁。或者说线程之间的状态是怎么切换的。 加密平时有了解吗 快速排序。 MVC MVP MVVM区别 mvvm说得不清楚 MVP里面p持有activity引用，怎么持有比较好。 MVP Presenter复用，怎么处理比较好。 项目中用到测量模式，语音项目代码结构怎么样。 Okhttp retrofit Rxjava有没有看过源码。 OkHttp拦截器有没有用过，拦截器怎么实现整体的拦截的。 讲下Retrofit 动态代理类具体的方法实现。自己在项目里面有没有用过动态代理。 动态代理用到哪些场景。 Retrofit里面用Rxjava返回一个Observable，这个是怎么实现的。 Retrofit还有convert，这个convert和CallAdabter的区别。 有没有自定义convert没 onMeasure的时候，怎么确定view的大小。 Xml layout_width layout_height对应代码里面怎么对应。 Https怎么防止中间人攻击。Server的公钥一定要和本地一样的是吧。 性能优化你做过哪些方面的。 内存泄漏是怎么发生的。 内存抖动是用什么工具进行检测的。内存抖动很频繁的话，有没有针对性的做一些优化**.(这个最好实践下)** Android还有一个常见的性能问题，ANR你能说一下吗。 线上的ANR有没有排查的经验。怎么处理的。 kotlin在项目中有没有使用过。Kotlin相比java有哪些优势。 Kotlin ? !!都可以让编译通过，实际上有区别吗。it对象是怎么来的 Findviewbyid kotlin是怎么实现的。findviewbyid通过Map 缓存,在项目里面有使用过缓存吗。 Reprice三个单元测试步骤. 单元测试覆盖率有没有看。 组件化框架，共享数据怎么处理。放公共里面就太多了。用户model需要其他组件使用。这个怎么处理 。 自定义view触摸事件分发，能说一下吗。 ViewGroup拦截了view的事件，怎么让view不拦截，内部拦截法。 ScrollView 放了 竖的viewpager 怎么处理滑动冲突。 Gradle插件，自动化的任务。 HTTP介绍RPC，RPC和其他协议HTTP有什么区别，然后扣项目细节。。。（录像都不敢看，不想写了） 客户端网络安全实现 HTTP1.0、HTTP1.1、HTTP2.0知道吗？他们相比之前的版本有哪些优化？ 输入一个URL到网页显示的过程 3 (输入完了直接弹出一个广告可能是哪个环节出了问题，怎么解决我猜是DNS解析出了问题，不知道怎么解决 面完之后想到清浏览器缓存、加强前端校验之类的) localhost 与127.0.0.1的区别 HTTP1，HTTP2，HTTP3的协议 get与post区别 HTTPS的加密过程，为什么第一次发送公钥不需要加密HTTP状态码分别代表什么意思 HTTPS是怎么实现的？ HTTPS是怎么保证安全的 https请求流程 3 HTTP3 http的流程以及和https的区别 HTTP支持长链接吗？什么时候开始支持的？ HTTPS的组成是什么？ http状态码 https请求到响应的过程（加密过程） 怎么加速http连接 http基于tcp还是udp http协议有哪些跟缓存相关的属性？ http可以用UDP吗 OSI七层模型介绍一下？应用层有什么协议？ OSI七层网络模型 网络传输层的协议 传输层的主要协议有哪些 微信视频是用了tcp还是udp UDP和TCP的区别，UDP的使用例子，TCP怎么保证连接可靠 TCP三次握手四次挥手，如果中间信息丢失了怎么办，设置超时时间那这个时间具体应该设置多少 OSI七层有哪些 TCP UDP在哪些层 交换器路由器在哪些层 TCP拥塞控制 四次挥手详解 TCP怎么保证可靠传输 DNS解析过程 TCP报文里的字段 TCP报头 UDP STL 和TCP区别 2 TCP与UDP区别，优缺点 TCP传输中header里的字段 TCP三次握手，如何保证安全传输的 TCP三次握手，TCP三次握手的步骤？两次握手为什么不行？ 3 tcp滑动窗口，TCP三次握手 2 TCP拥塞控制 DNS协议 2 5层结构以及相应的作用 长连接什么时候会释放？ 服务端通过timeout还是探测决定是否关闭长连接？ TCP有没有这种关闭连接的方式？ 对称加密和非对称加密有哪些算法 什么区别 ANDROIDhandler的作用 深入问handler（比如messagequeue为空时候，looper在做什么） handle和Activity在链表中的顺序是怎么样的？ Handler为什么会发生内存泄漏 looper阻塞为什么不会造成ANR looper死循环会不会卡死？为什么？ handler详解，是否会内存泄漏，泄露的原理 handler处理流程，looper和handler是一对一还是一对多，为什么主线程loop不会ANR？ 广播的两种启动方式 安卓中的消息机制是什么样的 消息机制中，如何更新UI 安卓有哪几种页面通讯的方式 自定义view的基本流程 3 提到了滑动冲突怎么解决的 Android事件传递流程和OnTouchListener的关系 touch事件的传递机制 安卓的view事件分发机制 3 介绍一下view渲染流程 Android View绘制流程，当一个TextView的实例调用setText()方法后执行了什么 view绘制流程 2 view怎么确认位置与大小，测量模式 常用的viewgroup，与view区别，在事件处理过程中有什么区别 安卓点击事件的处理 lifecycle介绍 jetpack全家桶用过哪些 livedata有什么能力 双指缩放拖动大图 Android屏幕渲染机制 RecyclerView绘制步骤和复用机制 Recyclerview的复用机制 recyclerview的缓存机制（知道但不懂，我说做项目用list view出现了重复刷显示的问题，所以换了recyclerview解决 retrofit的具体实现，其中接口的作用，注解的作用 怎么在子线程中更新UI？ 安卓存储方式 contentprovider介绍，能实现耗时操作吗 service介绍，生命周期与 contentprovider区别 介绍对安卓中intent的理解 service与activity通信 Kotlin有没有static 关键字？那创建静态函数怎么办 协程Flow有哪些应用场景？ 内存泄漏的情况有哪些，讲一种检测方法 gradle打包流程 Android签名流程 对AMS的了解 content provider的作用。 sqlite的底层原理(不了解) 索引的原理及实现。 如何定位ANR和崩溃问题的原因。 compose和view写法的优缺点 使用recycleview碰到的问题 compose实现音乐播放栏固定 activity a -&gt; b 的生命周期 （哪个阶段界面不可见） fragment的构造函数初始化，navigate的跳转。两种方式理解 可以异步加载fragment吗，答案：可以。 serialVersionUID是否了解 handlerMessage什么时候会发生内存泄漏（要怎么预防） 图片有哪些格式，他们的区别 Fragment的replace,hide,add,show的区别 Retrofit中的Call对象如何转换成okhttp的call对象(这个题目是埋坑的) Retrofit设计模式 加载so有几种方法 Handler工作机制Looper如何识别Handler LIBRARYOkHttp的原理 okhttp的请求机制 okhttp如何处理网络缓存的 okhttp拦截器 okhttp责任链设计模式 okhttp发送请求的拦截方式okhttp的拦截器设计模式 retrofit怎么实现多线程 2 Retrofit的调用过程（我给你点提示，你自己思考一下） viewmodel的实现原理 2 viewmodel怎么更新数据的 viewmodel实现原理 LeakCanary的使用和实现原理 安卓图片缓存，加载 协程实现原理 Glide的缓存机制 2 安卓glide中与生命周期的关系 glide的缓存加载机制 glide和OkHttp的任务调度是怎么实现的（比如同时发起很多请求） okhttp、picasso等底层原理如缓存机制等（一个也没答上来，literally ACTIVITYActivity遵循什么设计模式 Activity启动模式，allowReparent的特点和栈亲和性 从点击应用图标到进入应用，Android系统都做了哪些工作，期间涉及到的进程切换有哪些？ 写个单例模式 -Activity启动模式 Activity的启动流程,从Launcher到AMS——从AMS到ApplicationThread——从ApplicationThread到Activity activity生命周期 onStart与onResume解释 activity四大启动模式 说下 Activity 的四种启动模式、应用场景 ？ ——standard标准模式；singleTop 栈顶复用模式；singleTask 栈内复用模式；singleInstance 单实例模式 横竖屏切换的 Activity 生命周期变化？ fragment的生命周期 viewmodel设计模式，mvc,mvp,mvvm介绍 广播里怎么执行耗时操作 阻塞多久会出现ANR Android intent如何传递数据Android广播谈谈Android性能优化 Activity的生命周期，从Activity A启动Activity B生命周期的变化 Activity生命周期，横竖屏切换的 Activity 生命周期变化？ SharedPreference 跨进程使用会怎么样？如何保证跨进程 使用安全？ activity，fragment 传值问题 activity 与 fragment 区别 Fragment 中 add 与 replace 的区别？ FragmentManager的Add和Replace区别 Activity因为内存不足销毁了如何恢复数据 点击锁屏后Activity会执行onPause和onStop吗 Activity的onDestory回调时机 Activity调用finish后是否立即onDestory Activity调用finish后是否立即onDestoryActivity A 启动 Activity B,Activity A 的onDestory和Activity B 的onCreate执行顺序Activity A 启动 Activity B,然后调用finish,Activity A 的onDestory和Activity B 的onCreate执行顺序Activity的singleTop和singleTask的区别 binder原理 KOTLINkotlin的let，apply，also有什么区别。kotlin的inline，nonline关键字有什么作用。 异步调用有几种方式，从简单到复杂。 逆变与协变。 作用域函数（应用场景） 高阶函数（概念） kotlin和java一块编译碰到啥问题 ::funName 双冒号的写法的理解 泛型 out in 与Java泛型中的联系和区别 知道哪些高阶函数 协程的理解协程相对于线程的区别 Kotlin 闭包Kotlin 静态方法 链表逆序Handler的postDelay原理P2P网络 THREAD进程、线程、协程的联系与区别 2 Java创建线程的方式 线程并发会遇到哪些问题，怎么解决 线程的 wait 和 block 有什么区别？和 sleep 有什么区别？ sychronized和lock的区别 volatile详解、synchronized详解，两者区别 Java线程间通信， volatile详解、synchronized详解 线程的状态 线程池详解 线程池怎么做到线程复用 安卓中挂起函数怎么实现的 安卓中实现多线程的方法 线程池设计模式，怎么自己设计一个线程池 安卓里解决多线程冲突的方法 Android线程池设计原理 进程线程区别 进程通信方式有哪些线程通信方式有哪些 安卓的线程通信 JAVAGC如何判断是否回收以及僵尸线程 双线程通过线程同步的方式打印12121212……. 为什么安卓用BINDER 有啥优点 安卓中进程间通信方式 线程安全的单例模式（双重检测），为什么要两次判断，volatile作用 多线程如何解决线程冲突？ Java加锁方式 死锁的必要条件 2 死锁怎么造成的 多线程会遇到什么问题 死锁的条件，手写一个死锁代码并运行出来 怎么避免死锁问题 可重入锁 对象、锁、对象监视器相互之间的关系？ 乐观锁如何实现？缺点有哪些？ volatile 和 synchronized 有什么区别？ synchronized 和 lock 有什么区别？ synchronized 底层是如何实现加锁操作的？ ThreadLocal 是如何存储的？ ThreadLocal了解么，他有什么问题 ThreadLocalMap中遇到冲突是如何处理的？ threadlocal，动态代理，这俩我说没用过不了解 synchronized 底层是如何实现的？ ReentrantLock 如何实现公平锁与非公平锁？ 公平锁与非公平锁的释放有什么区别？ 消费者与生产者模型 实现多线程的几种方式 乐观锁和悲观锁 wait 和 sleep 的区别 Android 线程间通信有哪几种方式 ——1. 共享内存（变量）；2.文件，数据库；3.Handler；4.Java 里的 wait()，notify()，notifyAll() synchronized 原理 锁的升级 JVM内存模型 生产者消费者模型，应用（线程池） 用过线程池吗，线程池如何实现 如何全局管理异步任务(不知道) 多线程下如何保证类的线程安全？ CopyOnWriteArrayList底层实现？如何实现线程安全？ 线程池核心线程数数量的设计考虑因素 MAPHashMapHashMap的实现机制，怎么样HashMap线程安全 1.HashMap原理创建HashMap要放入1000个不同hashCode的键值对,初始最大值多少HashMap如果Hash冲突了怎么解决？ 2 HashMap的扩容机制是什么样的？ concurrenthashmap详解 hashtable,hashmap与 concurrenthashmap详解 ConcurrentHashMap 是如何实现线程安全的？如果让你设计锁的数量你会怎么设计来提高效率？ HashMap的扩容机制，它线程安全吗？ 哈希冲突解决方法， hashmap插入数据的流程？ 如何计算hashmap数据插入的位置？ 如何解决哈希冲突？ 有一千个键值对的数据，如何设计HashMap的初始容量大小？HashMap的实现原理 2 和HashTable区别，线程不安全的原因 哈希表解决冲突的方法 ArrayList线程安全的队列有哪些 ArrayList的扩容机制？ 底层实现？深拷贝还是浅拷贝？ ArrayList的remove方法原理 ArrayList和LinkedList区别 2 面试官给了一段代码，问运行结果：代码是new了个空arraylist（string，integer）问这时候int i&#x3D;arraylist.get（“key”）然后print会输出啥 如果是Integer i呢，会是啥（好家伙两个全答错） DESIGN MODELmvp是什么？2 MVVM与mvc、mvp架构的区别与联系 MVVM、MVC、MVP的区别与联系，各自优缺点 mvvm用到的设计模式 介绍一下中介者模式吧 问设计模式，要求挑一个深入分析，问你对这些模式的理解 除了中介者模式你还了解哪些设计模式 面向对象的原则有哪些 AOP了解吗 说说你对设计模式的理解，开发过程中主要用到了哪些设计模式？ 介绍一下你在开发过程中使用到的设计模式 你都用过哪些设计模式？ Android中的ClassLoader 面向切面编程你知道么，和面向对象的区别和细节 设计模式作用 动态代理与静态代理","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"INTERVIEW JAVA","slug":"interview-java","date":"2024-05-27T06:17:54.000Z","updated":"2024-09-15T09:53:31.965Z","comments":true,"path":"/2024/05/27/interview-java/","link":"","permalink":"https://noteforme.github.io/2024/05/27/interview-java/","excerpt":"","text":"JAVA 多实现接口，如果接口里面有入参出参一样的同名方法，会实现几个 说一下final，static . final的arraylist，往里面add东西会咋样 static方法能调用非静态吗，非静态能调用static吗 面向对象三大特性，多态怎么实现 静态方法与变量是否可以继承，原因 Java内存模块分区和GC机制， GC算法有哪些 Finalize机制 强引用 弱引用 软引用 虚引用的区别和使用场景 ClassLoader的双亲委托机制 2 .Java代理是否用过，怎么实现 类加载的过程 类加载器，双亲委派模型 对象生命周期 判断对象是否可以回收的方法 有哪些GC roots Java引用类型 抽象类与接口区别，各自优缺点 Java泛型，泛型擦除机制 匿名内部类，原理是什么 Java引用类型，弱引用的作用，引用队列。 Java内存回收 GC roots 垃圾标记方法(拓展了很多) Java入口函数 Java异常介绍，是否所有异常都需要捕获 类编译过程 JVM 中创建一个对象的过程是什么样的？ JVM 如何判断一个对象需要被回收? 如果电脑内存是4G，已经使用了3G，现在启动一个程序需要超过1G的内存，会发生什么？(内存回收) 类加载过程是什么样的？ 双亲委派模型有什么作用？ &#x3D;&#x3D;和equals的区别 重载和重写的区别 值传递和引用传递 static、final作用 所有类的父类 this()和super() int和Integer的区别 线程池和线程 锁了解哪些（说了分布式锁，又问我分布式锁是什么） Java反射原理Java面向对象的理解，封装，继承，多态 Java四次引用 垃圾回收机制 线程安全的集合有哪些（问得比较细） 进程间通信的方式 HashMap的底层实现 View的绘制过程 String、StringBuffer、StringBuidler的区别 注解的类型有哪些？ JVM的内存模型 什么是多态，怎么去实现呢 接口和抽象类的区别，它们各自的使用场景呢 java四种引用JVM内存区域 OOM能捕获吗 运行时异常与编译时异常 了解网络字节序吗 双亲委派(写一个路径名字一样的String，new String（）会创建自己写的还是系统的) 受检异常和非受检异常 抽象类和接口的区别 java里弱引用和强引用分别用在什么场景 深拷贝、浅拷贝 OS进程线程在操作系统中的实现 内核态与用户态 linux内存管理机制 虚拟内存与物理内存 进程间能共享内存吗 虚拟内存 跨进程通信的几种方式 线程与进程的使用场景 线程安全与不安全的例子 B站的虚拟人物么，你觉得当前的技术方面是怎么来进行实现的 https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Java/HashMap%E5%8E%9F%E7%90%86-%E7%BE%8E%E5%9B%A2.html 面试题含答案 java基础面试知识点java中&#x3D;&#x3D;和equals和hashCode的区别类型 基本类型：比较的是值是否相同； 引用类型：如果是 类、接口、数组的话,当他们用双等号（&#x3D;&#x3D;）进行比较的时候，比较的是他们的引用，如果要比较堆中对象是否相同，那么就要重写equals方法了； 默认情况下（没有覆写equals方法）的equals方法都是调用Object类的equals方法，而Object的equals方法主要是用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。 int、char、long各占多少字节数byte 1字节 short 2字节 int 4字节 long 8字节 char 2字节 float 4字节 double 8字节 boolean false&#x2F;true(理论上占用1bit,1&#x2F;8字节，实际处理按1byte处理) int与integer的区别​ Integer 是int的包装类；int是基本数据类型; ​ Integer实际是对象的引用，int是直接存储数据值 谈谈对java多态(polymorphism)的理解,Java中实现多态的机制是什么实现的机制是，父类或者接口定义的引用变量指向子类或者子类的实现， 执行期间判断所引用对象的实际类型，根据其实际的类型调用相应的方法。 编译时多态(静态多态)&#x3D;&#x3D;重载 运行时多态（动态多态） 无论哪种方法，核心之处在对父类方法的改写或对接口方法的实现，以取得运行时不同的执行效果. https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html https://cloud.tencent.com/developer/article/1447574 String、StringBuffer、StringBuilder区别 都是fianl类，不能被继承,底层都是 char[] value实现 String类长度是不可变的，substring()、 concat(),最终实现都是通过 new String(buf, true)实现的,StringBuffer,StringBuilder是通过操作本类的value实现的 StringBuffer类是线程安全的，StringBuilder不是线程安全的 String：字符串常量。 ​ 什么是内部类？内部类的作用​ 内部类: 一个类定义在另一个类的内部，就叫内部类 ​ 作用: 内部类 拥有外部类的所有访问权限，包括被private修饰的私有数据 内部类可以很好的隐藏实现 内部类可以实现多重继承 12345678910111213141516171819202122232425262728293031323334353637383940//类一public class ClassA &#123; public String name()&#123; return &quot;liutao&quot;; &#125; public String doSomeThing()&#123; // doSomeThing &#125;&#125;//类二public class ClassB &#123; public int age()&#123; return 25; &#125;&#125;//类三public class MainExample&#123; private class Test1 extends ClassA&#123; public String name()&#123; return super.name(); &#125; &#125; private class Test2 extends ClassB&#123; public int age()&#123; return super.age(); &#125; &#125; public String name()&#123; return new Test1().name(); &#125; public int age()&#123; return new Test2().age(); &#125; public static void main(String args[])&#123; MainExample mi=new MainExample(); System.out.println(&quot;姓名:&quot;+mi.name()); System.out.println(&quot;年龄:&quot;+mi.age()); &#125;&#125; MainExample 类通过内部类拥有了 ClassA 和 ClassB 的两个类的继承关系。 而无需关注 ClassA 中的 doSomeThing 方法的实现。这就是比接口实现更有戏的地方 https://juejin.cn/post/6844903566293860366 抽象类和接口区别 Abstract class Interface 1) Abstract class can have abstract and non-abstract methods. Interface can have only abstract methods. Since Java 8, it can have default and static methods also. 2) Abstract class doesn’t support multiple inheritance. Interface supports multiple inheritance. 3) Abstract class can have final, non-final, static and non-static variables. Interface has only static and final variables. 4) Abstract class can provide the implementation of interface. Interface can’t provide the implementation of abstract class. 5) The abstract keyword is used to declare abstract class. The interface keyword is used to declare interface. 6) An abstract class can extend another Java class and implement multiple Java interfaces. An interface can extend another Java interface only. 7) An abstract class can be extended using keyword “extends”. An interface can be implemented using keyword “implements”. 8) A Java abstract class can have class members like private, protected, etc. Members of a Java interface are public by default. 9)Example: public abstract class Shape{ public abstract void draw(); } Example: public interface Drawable{ void draw(); } https://www.javatpoint.com/difference-between-abstract-class-and-interface ? 泛型中extends和super的区别 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景 https://noteforme.github.io/2018/04/16/Generics/ string 转换成 integer的方式及原理 判断是否null或”” 判断第一位正负数，逐位获取值 ? https://blog.csdn.net/nobody_1/article/details/91488686 静态内部类的设计意图​ 非静态内部类编译后会隐含的保存着一个引用，改引用指向创建它的外围类，静态内部类没有， ​ 它不能使用任何外围类的非static成员变量和方法. final，finally，finalize的区别Final : 用于申明属性，方法，类，表示属性不可变，方法不可以覆盖，类不能继承 final数组 Java 中数组也是对象 12345final int arr[] = &#123;1, 2, 3, 4, 5&#125;; // 注意，数组 arr 是 final 的 for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i]*10; System.out.println(arr[i]); &#125; 数组是对象的一种，现在数组是被 final 修饰的，所以它的意思是一旦被赋值之后，变量的引用不能修改。但是我们现在想证明的是，数组对象里面的内容可以修改 非数组对象 12345678class Test &#123; int p = 20; public static void main(String args[])&#123; final Test t = new Test(); t.p = 30; System.out.println(t.p); &#125;&#125; 把它用 final 修饰，然后去尝试改它里面成员变量 p 的值，并打印出结果，程序会打印出“30”。一开始 p 的值是 20，但是最后修改完毕变成了 30，说明这次修改是成功的。 以上我们就得出了一个结论，final 修饰一个指向对象的变量的时候，对象本身的内容依然是可以变化的。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=311 Finally: 异常语句处理机构中，与try{}进行配合使用，不论try中的代码是否执行完，表示总是执行的部分 Finalize: Object类的一个方法，用于对象”消失”时，由JVM进行调用用于对对象进行垃圾回收，释放对象占用的资源. Serializable 和Parcelable 的区别，如何将一个Java对象序列化到文件里？ 两者最大的区别在于 存储媒介的不同，Serializable 使用 I&#x2F;O 读写存储在硬盘上，而 Parcelable 是直接 在内存中读写。很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 Parcelable。 Serializable 会使用反射，序列化和反序列化过程需要大量 I&#x2F;O 操作，也会创建很多临时对象， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。 https://juejin.cn/post/6844903518826921991 父类的静态方法能否被子类重写 不能，静态方法只和类有关,JVM加载后先初始化static相关属性方法,重写依赖于类的实例. 成员内部类、局部内部类以及项目中的应用成员内部类 : 普通的内部类，不存在任何static的变量和方法； 局部内部类： 嵌套于方法和作用域内 12345678910111213141516171819public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(&quot;chenssy&quot;); &#125;&#125; 闭包和局部内部类的区别 Java中对象的生命周期​ 1、创建阶段(Created) 检测类是否被加载没有加载的先加载→为新生对象分配内存→将分配到的内存空间都初始化为零值→对对象进行必要的设置→执行&lt;init&gt;方法把对象进行初始化 对象的加载大小是类加载中就已经确定好了的，类加载过程就相当复杂了，如下图： 类加载过程.png 2、应用阶段(In Use) 至少有一个强引用使用着 3、不可见阶段(Invisible) 程序的执行已经超出了该对象的作用域了 4、不可达阶段(Unreachable) 程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root” 5、收集阶段(Collected) 垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。 6、终结阶段(Finalized) 当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。 7、对象空间重分配阶段(De-allocated) 垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。 链接：https://www.jianshu.com/p/72f5017c6649 JVMString特性Java虚拟机在内存中开辟出一块单独的区域 https://zhuanlan.zhihu.com/p/60643031 https://www.bilibili.com/video/BV1PJ411n7xZ?p=118 几个视频讲到用法，最好能用图画出来 https://www.iteye.com/blog/rednaxelafx-774673 哪些情况下的对象会被垃圾回收机制处理掉？ 可达性分析,GC Root向下搜索，产生一个reference chain 。当一个对象不能和任何GC Root产生关系时就被回收. 强引用 ：那垃圾回收器绝不会回收 软引用: 内存溢出时候对象回收 弱引用:下一次GC时候对象回收 虚引用：随时可能被回收 当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法并没有什么新的思想，只是根据对象的存活周期将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，那就选用复制算法，只要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外的空间对它进行分配担保，那就使用标记清理或者标记整理算法来进行回收。 https://noteforme.github.io/2021/01/05/JVM-GC/ https://noteforme.github.io/2020/04/18/JVM/ String为什么要设计成不可变的？ 便于实现字符串池 由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。 如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！ https://www.cnblogs.com/wkfvawl/p/11693260.html java深入源码级的面试题讲一下常见编码方式？ ASCII码: 用一个字节的低7位表示，总共128个,031 是控制字符如换行回车删除等；32126 是打印字符，可以通过键盘输入并且能够显示出来 UTF-16: 固定两个字节表示一个字符：说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 UTF-8: 优化UTF-16,UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。UTF-8 有以下编码规则：如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 GBK 、ISO-8859-1、GB2312 https://www.cnblogs.com/mlan/p/7823375.html https://www.cnblogs.com/mlan/p/7823375.html utf-8编码中的中文占几个字节；int型几个字节？​ 少数是汉字每个占用3个字节，多数占用4个字节。 ​ https://blog.csdn.net/hellokatewj/article/details/24325653 ​ int类型 4个字节 静态代理和动态代理的区别，什么场景使用？​ 静态代理 : 编译的时候就已经存在， ​ 动态代理 ： 通过反射机制生成的代理对象 ​ https://noteforme.github.io/2021/01/14/DesignPattern-Proxy/ ​ https://www.jianshu.com/p/2f518a4a4c2b Java的异常体系非运行时异常 :编译期间可以检查到的异常, 像IoException,DataFormatException,CertificateException 运行时异常 : NullPointerException, ClassCastException,IndexOutOfBoundsException ? 谈谈你对解析与分派的认识。说说你对Java反射的理解​ 对于任何一个类都可以通过反射知道的它的属性和方法。 说说你对Java注解的理解​ 注解，对代码进行注明。使得程序在编译或者运行时，读取到注解并加以处理，以间接的改变程序的运行。 为什么Java里的匿名内部类只能访问final修饰的外部变量？​ 因为匿名内部类最终会被编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类。如果变量不定义为final的，参数在匿名内部类中可以被修改，进而造成和外部的变量不一致的问题，为了避免这种不一致的情况，规定匿名内部类只能访问final修饰的外部变量。 说说你对依赖注入的理解?​ 给予调用方它所需要的对象 泛型说一下泛型原理，并举例说明​ 泛型实现了参数化类型的概念，使代码可以应用于多种类型。 ​ 在泛型代码内部，无法获得任何有关泛型参数类型的信息。 容器常用数据结构简介数组 栈 队列 链表 图 树 哈希表 并发集合了解哪些？ConcurrentHashMap CopyOnWriteArrayList CopyOnWriteArraySet ArrayBlockingQueue LinkedBlockingQueue https://blog.csdn.net/u010942020/article/details/73610121 列举java的集合以及集合之间的继承关系 List,Set,Map的区别容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类） List是一个有序的队列，每一个元素都有它的索引。Set是一个不允许有重复元素的集合。 Map是一个映射接口，即key-value键值对。 List和Map的实现方式以及存储方式 list ArrayList 查询快 . LinkedList 插入删除快 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？ 集合Set实现Hash怎么防止碰撞1，如果hash码值不相同，说明是一个新元素，存储； 如果没有元素和传入对象（也就是add的元素）的hash值相等，那么就认为这个元素在table中不存在，将其添加进table； 2.1，如果hash码值相同，且equles判断相等，说明元素已经存在，不存； 2.2，如果hash码值相同，且equles判断不相等，说明元素不存在，存； 原文链接：https://blog.csdn.net/github_37130188/article/details/96508272 ​ https://noteforme.github.io/2018/05/31/HashMap/ HashMap 对key的Dashcode()做hash运算，计算index. 如果没碰撞直接放到bucket⾥ 如果碰撞了，以链表的形式存在buckets后 如果节点已经存在就替换old value(保证key的唯⼀性) 如果bucket满了(超过load factor*current capacity)，就要resize get数据 对key的hashCode()做hash运算，计算index; 如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;分为下面两种方式. 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 ArrayMapArrayMap相比传统的HashMap速度更慢，因为其查找方法是二分法，并且当删除或添加数据时，会对空间重新调整，可以说ArrayMap是牺牲了时间来换空间，ArrayMap与HashMap的区别主要在： 存储方式不同：HashMap内部有一个HashMapEntry&lt;K,V&gt;[ ]对象，而ArrayMap是一个&lt;key,value&gt;映射的数据结构，内部使用两个数组进行数据存储，一个数组记录key的hash值，另一个数组记录value值。 添加数据时扩容的处理不一样：HashMap进行了new操作，重新创建对象，开销很大，而ArrayMap用的是copy数据，效率相对高很多。 ArrayMap提供了数组收缩的功能，在clear或remove之后，会重新收缩数组，释放空间。 ArrayMap采用的是二分法查找。 hashmap hashtable区别堆的结构 ​ 堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式。 在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。https://www.jianshu.com/p/6b526aa481b1 堆和树的区别​ 左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？ 什么是深拷贝和浅拷贝 浅拷贝 是一个传址,也就是把a的值赋给b的时候同时也把a的地址赋给了b，当b（a）的值改变的时候，a（b）的值同时也会改变 深拷贝 ​ 深拷贝是指，拷贝对象的具体内容，二内存地址是自主分配的，拷贝结束之后俩个对象虽然存的值是一样的，但是内存地址不一样，俩个对象页互相不影响，互不干涉 手写链表逆序代码 讲一下对树，B+树的理解 讲一下对图的理解 判断单链表成环与否？ 链表翻转（即：翻转一个单项链表） 合并多个单有序链表（假设都是递增的）","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"INTERVIEW  experience ONLINE","slug":"interview-experience","date":"2024-05-27T06:06:56.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/05/27/interview-experience/","link":"","permalink":"https://noteforme.github.io/2024/05/27/interview-experience/","excerpt":"","text":"https://github.com/Moosphan/Android-Daily-Interview/ https://lrh1993.gitbooks.io/android_interview_guide&#x2F;content&#x2F; https://www.nowcoder.com/discuss/396383934924292096 https://www.nowcoder.com/discuss/456922214454091776 https://www.nowcoder.com/discuss/462666906584043520 我是21年入坑，一年晋升一次，第一次靠业务配合技术，第二次靠数据监控搭建配合数据挖掘找业务优化点，下一步打算挖掘端智能配合动态化加上数据挖掘来继续晋升，另外我是iOS和Android都做，希望对你有帮助 … 展开 作者：吐泡泡的咸鱼链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 怎么在短时间打牢基础？你就搜搜大多数的面试题经常问那些问题，提起多看几遍，不至于问到的时候，根本不知道说什么，至少你能说出个大概也比什么都说不出来好。当然，这不是教你诈，是你找到工作后，要赶紧把自己薄弱的地方补上来。 我11月顺利拿到了OPPO公司Android工程师offer，我有三年多的工作经验，这次面试历经两轮，终于是拿到了offer，一面是以项目来展开的，简历上的东西一定要熟悉，面试官就是通过简历去问，然后会针对项目中遇到的问题，让你现场给你解决方案。 二面是由部门的主管负责面试，主要也是询问工作上的一些事，大头当然还是项目上的经历，遇到的难点和解决办法，还针对团队合作问题上提了一些问题，类似于结构化面试中的人际关系题，考察的应该是沟通协调能力了吧。 作者：juncos链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 OSI七层网络模型UDP和TCP的区别，UDP的使用例子，TCP怎么保证连接可靠HTTP1，HTTP2，HTTP3的协议TCP三次握手四次挥手，如果中间信息丢失了怎么办，设置超时时间那这个时间具体应该设置多少HTTPS的加密过程，为什么第一次发送公钥不需要加密HTTP状态码分别代表什么意思数据库TABLE和VIEW的区别（我回答不太懂数据库后面就没问了）死锁产生条件FragmentManager的Add和Replace区别Activity因为内存不足销毁了如何恢复数据点击锁屏后Activity会执行onPause和onStop吗Recyclerview的复用机制 作者：牛客784018930号 \\3. 介绍一下七层模型，每一层的作用 \\4. 生产者消费者模型，应用（线程池） \\5. 用过线程池吗，线程池如何实现 \\6. 进程间通信方式 \\7. http请求的过程 \\8. 什么是多态，应用场景 \\9. 了解过设计模式吗？单例模式，应用场景 \\10. epoll的优势 \\11. 手撕简单题 \\12. 项目中遇到什么困难，应用场景 作者：已run的小学生很爱看电影链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 \\1. kotlin的let，apply，also有什么区别。\\2. kotlin的inline，nonline关键字有什么作用。\\3. 异步调用有几种方式，从简单到复杂。\\4. 如何全局管理异步任务(不知道)\\5. mvvm与mvp的区别。\\6. 逆变与协变。\\7. content provider的作用。\\8. sqlite的底层原理(不了解)\\9. 索引的原理及实现。\\10. 跨端框架的核心实现要点(开放题)\\11. 如何定位ANR和崩溃问题的原因。 作者：摸不着头发 ·对面向对象的理解·ArrayList扩容等·垃圾回收·网络七层协议·TCP三次握手 四次挥手·https加密的算法 快手客户端一面（40min）自我介绍 1.ArrayList的扩容机制？ 2.底层实现？深拷贝还是浅拷贝？ 3.单例模式 4.懒汉线程安全？ 5.多线程下如何保证类的线程安全？ 6.CopyOnWriteArrayList底层实现？如何实现线程安全？ 7.HTTP支持长链接吗？什么时候开始支持的？ 8.长连接什么时候会释放？ 9.服务端通过timeout还是探测决定是否关闭长连接？ 10.TCP有没有这种关闭连接的方式？ 11.算法题：给你一个数组，和一个数字m，问这个数组中存不存在一个子序列（不一定连续），使得它的和为m，输出true或false 12.反问 作者：Namcoo 影石：客户端iOS开发，一面面经\\4. 八股：计网和数据结构与算法4.1 你知道哪些常见的数据结构？4.2 链表有哪些类型？4.3 什么是哈希冲突？4.4 说一下排序算法中冒泡排序如何实现？4.5 快速排序如何实现？4.6 堆排序知道吗？如何实现？（麻了已经）4.7 TCP协议与UDP协议的区别4.8 TCP三次握手和四次挥手的过程4.9 TCP滑动窗口、拥塞控制如何实现？4.10 HTTP1.0、HTTP1.1、HTTP2.0知道吗？他们相比之前的版本有哪些优化？ 作者：勤奋的鼠鼠 2023.5.9 美团 移动端 一面（1小时）了解网络字节序吗 你对移动端客户端开发感兴趣吗 介绍一下中介者模式吧 除了中介者模式你还了解哪些设计模式 面向对象的原则有哪些 C语言源文件编译过程 知道编译器前端和后端吗 死锁是什么，怎么避免死锁 关于前端你学过什么，了解前端的框架吗 你平时都通过什么方式学习 两个算法（判断链表是否有环、链表重排&#x2F;链表折叠） 反问 作者：genius1008 快手客户端2面项目 compose和view写法的优缺点 使用recycleview碰到的问题 glide的缓存加载机制 compose实现音乐播放栏固定 安卓glide中与生命周期的关系 java 双亲委派(写一个路径名字一样的String，new String（）会创建自己写的还是系统的) 受检异常和非受检异常 抽象类和接口的区别 koltin 作用域函数（应用场景） 高阶函数（概念） kotlin和java一块编译碰到啥问题 ::funName 双冒号的写法的理解 泛型 out in 与Java泛型中的联系和区别 安卓 activity a -&gt; b 的生命周期 （哪个阶段界面不可见） fragment的构造函数初始化，navigate的跳转。两种方式理解 可以异步加载fragment吗，答案：可以。 serialVersionUID是否了解 算法 反转字符串 上楼梯动态规划，如果第M阶梯是不能踩的 作者：偷偷look痛苦面具 安卓开发货拉拉日常实习(寄)\\1. 先问项目(提到了滑动冲突怎么解决的)\\2. 安卓有哪几种页面通讯的方式\\3. 用过什么开源框架（消息总线[#%￥#]()？）\\4. jetpack全家桶用过哪些\\5. livedata有什么能力\\6. java里弱引用和强引用分别用在什么场景\\7. 用到什么布局（为什么不用constraintLayout)\\8. glide和OkHttp的任务调度是怎么实现的（比如同时发起很多请求）\\9. handlerMessage什么时候会发生内存泄漏（要怎么预防）\\10. handler和Activity两者是怎么相互引用的？（这里没听懂，面试官语速太快太模糊了）\\11. handle和Activity在链表中的顺序是怎么样的？\\12. http协议有哪些跟缓存相关的属性？\\13. kotlin比java新的地方在哪\\14. 知道哪些高阶函数 作者：JojoYo链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 东方财富校招安卓二面50min（已过）2.为什么选择东财3.介绍项目，具体的一些功能会问怎么实现的4.问第三方库如okhttp、picasso等底层原理如缓存机制等（一个也没答上来，literally5.穿插问面向对象、安卓、java、计网的常规知识，网上面经可以概括者不加赘述6.深入问handler（比如messagequeue为空时候，looper在做什么）7.问设计模式，要求挑一个深入分析，问你对这些模式的理解8.安卓怎么判断activity发生内存泄漏（其实我没答上来，面试官问有简易方法么？我说as内置的资源监视工具里面看是否在使用的时候内存占用不停增加，面试官说嗯应该可以。。9.threadlocal，动态代理，这俩我说没用过不了解10.recyclerview的缓存机制（知道但不懂，我说做项目用list view出现了重复刷显示的问题，所以换了recyclerview解决11.图片有哪些格式，他们的区别？（报菜名，并且一问三不知 过于基础的不贴了，这位面试官感觉技术特扎实，但是他对技术的考量应该有一定阈值，大部分是在给你施加压力考察在压力中应变的能力。比如问了很多源码我一概不知，他这时候说那你对什么比较了解？我把handler整套流程憋出来了，并且说我是在xx项目遇到xx问题所以深入了解了handler 作者：歇息必取 东方财富校招Android一面（春招）\\2. 多实现接口，如果接口里面有入参出参一样的同名方法，会实现几个\\3. 说一下final，static\\4. static方法能调用非静态吗，非静态能调用static吗\\5. final的arraylist，往里面add东西会咋样（摸黑了，完全不确定，当时瞎蒙了个答案\\6. 面试官给了一段代码，问运行结果：代码是new了个空arraylist（string，integer）问这时候int i&#x3D;arraylist.get（“key”）然后print会输出啥\\7. 如果是Integer i呢，会是啥（好家伙两个全答错）\\8. 安卓问得不多且比较基础，忘了\\9. 倒水问题，3l和5l桶子要4l水怎么搞\\10. 算法思路，链表右移动k位和数组右移动k位怎么搞\\11. 左右括号匹配，最少情况要加多少次括号，写在纸上拍照三、大概说说项目，反问 作者：歇息必取 百度安卓春招二面凉经java内存分配 方法区：方法没有运行的时候，实在这里存储的栈区：方法如果进行运行，在没有进行新生成数据的时候，代码就是在栈中存储。堆区：new出来的东西会在这块内存中开辟空间并产生地址 GC算法：app启动流程recyclerViewkotlin基础安卓内存泄露Retrofit 图片缓存树、图的存储结构http可以用UDP吗线程进程区别 作者：想去广西嗦粉的小黄鸭在学习 B站安卓客户端实习面经## 一面1.自我介绍2.项目3.介绍一下多线程 问题很宽泛讲了一大堆4.输入bilibili.com之后发生了什么5.扩展：输入完了直接弹出一个广告可能是哪个环节出了问题，怎么解决我猜是DNS解析出了问题，不知道怎么解决 面完之后想到清浏览器缓存、加强前端校验之类的6.http协议1.0 2.0xx 版本之间的区别 有了解吗 （没了解）7.TCP和UDP的区别8.TCP为什么是可靠的9.死锁了解吗 （没复习 但扯一点）10.深拷贝、浅拷贝11.你学习过安卓的哪些东西12.介绍一下view渲染流程13.写题 括号匹配面完10分钟 hr约第二天下午二面 作者：FANIII__链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 火币Global部门一面1.HashMap原理2.创建HashMap要放入1000个不同hashCode的键值对,初始最大值多少3.ArrayList的remove方法原理4.对线程池的理解5.使用线程池的考虑因素6.线程池核心线程数数量的设计考虑因素7.CPU密集型和IO密集型8.DCL单例模式原理9.Fragment的replace,hide,add,show的区别10.多渠道打包11.APK瘦身12.Kotlin相比较java的好处13.Retrofit中的Call对象如何转换成okhttp的call对象(这个题目是埋坑的)14.Retrofit设计模式15.项目中的组件化架构方案16.对Arouter的理解17.在Google Play上架过吗18.对国外机型的适配方案19.对低端机型和弱网的适配方案20.线上问题排查方案21.Room有什么问题22.EditText的监控方法 二面1.Android art 和 dalvik的区别2.协程的理解3.协程相对于线程的区别4.内存优化5.内存检测工具6.优化方面可以做的内容7.启动优化8.单例能否继承(对象初始化过程)9.APK体积优化10.加载so有几种方法11.okhttp责任链设计模式12.Activity的onDestory回调时机13.Activity调用finish后是否立即onDestory14.Activity A 启动 Activity B,Activity A 的onDestory和Activity B 的onCreate执行顺序15.Activity A 启动 Activity B,然后调用finish,Activity A 的onDestory和Activity B 的onCreate执行顺序16.Activity的singleTop和singleTask的区别17.Handler工作机制18.Looper如何识别Handler19.K线图的绘制和优化(非金融相关不用考虑这个问题) 钱包部门1.Kotlin 闭包2.Kotlin 静态方法3.链表逆序4.Handler的postDelay原理5.P2P网络6.okhttp发送请求的拦截方式7.okhttp的拦截器设计模式8.线上ANR监控策略9.线上卡顿监控策略10.区块链钱包的签名和交易原理 作者：天大地大我最大链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 View绘制前的流程算法题给出二叉树的前序中序，输出后序 先来了一道算法题:找出最左边的次数最多的字母。 算法题：删除排序链表中的重复元素（力扣82） 快排和反转链表 判断一个树是不是平衡二叉树， 算法：旋转链表 LC61题意是这样子的：给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。输入：head&#x3D;[1,2,3] k &#x3D; 1输出：[3,1,2] 22.算法题：二分法查找目标数 爱奇艺 Android消息机制 Android View绘制流程，当一个TextView的实例调用setText()方法后执行了什么 Android dalvik虚拟机和Art虚拟机的优化升级点 Android屏幕渲染机制 热修复的原理，你都了解过哪几种热修复框架 OkHttp的原理 Android 线程池的实现原理 JavaGC机制 HashMap的实现机制，怎么样HashMap线程安全 可重入锁的实现，公平锁非公平锁都是什么定义？ 都用过那些常用的数据结构，说说对树的了解？ Activity启动模式，allowReparent的特点和栈亲和性 WebView优化 有没有Jni使用经验 有使用过RxJava吗？ 说说你对设计模式的理解，开发过程中主要用到了哪些设计模式？ 快排写一下，动态规划了解吗？ 小米 冒泡排序的链表实现 写个快排 写个单例模式 -Activity启动模式 异常生命周期 从点击应用图标到进入应用，Android系统都做了哪些工作，期间涉及到的进程切换有哪些？ 说说你了解的IPC方法 说说Binder的大体实现 怎么控制另外一个进程的View显示 广播中怎么进行网络请求 说说Android中线程池的实现 HashMap如果Hash冲突了怎么解决？ 双线程通过线程同步的方式打印12121212……. 腾讯 HTTPS是怎么实现的？ Android事件传递流程和OnTouchListener的关系 Activity启动模式 Android线程池实现原理 双指缩放拖动大图 客户端网络安全实现 Webview优化 Android应用保活 RemoteViews实现和使用场景 RecyclerView绘制步骤和复用机制 Binder的大体设计模式 Activity遵循什么设计模式 EventBus源码解析，遵循什么设计模式 Handler为什么会发生内存泄漏 Java内存模块分区和GC机制，GC算法有哪些 Finalize机制 强引用 弱引用 软引用 虚引用的区别和使用场景 LeakCanary的使用和实现原理 介绍一下你在开发过程中使用到的设计模式 快排 对服务器众多错误码的处理（错误码有好几万个） 阿里 Android消息机制 Android事件传递流程 Android View绘制流程 Activity启动模式 Android IPC机制 Android线程池设计原理 EventBus源码和设计模式 Android应用保活 Android UI优化 Android启动优化 快排 堆排 单例 进程线程在操作系统中的实现 HTTPS的组成是什么？ ClassLoader的双亲委托 Android中的ClassLoader 有过Jni使用经验吗？ 有过跨平台开发经验吗？ 今日头条 视频加密 Android Native Crash 视频组成 播放器原理 作者：Android小崽链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 哈啰安卓一面面经问了一个半小时 很多问题没记住 挑几个说一下1、进程通信方式有哪些2、线程通信方式有哪些3、进程线程区别4、JAVAGC如何判断是否回收以及僵尸线程5、AOP了解吗6、为什么安卓用BINDER 有啥优点7、GC回收算法有哪些8、http的流程以及和https的区别9、OSI七层有哪些 TCP UDP在哪些层 交换器路由器在哪些层10、UDP STL 和TCP区别11、对称加密和非对称加密有哪些算法 什么区别12、有哪些数据结构 增删改查的复杂度多少13、算法的五大基本要素有哪些？为什么算法效率不是基本要素？14、算法题 判断二叉树深度 1、Glide2、http和https3、view绘制流程4、TCP&#x2F;UDP5、Handler和AsyncTask6、TCP\\UDP7、MVP8、Retrofit9、AsyncTask Handler 作者：想去广西嗦粉的小黄鸭在学习腾讯一面 50分钟 1.MVVM与mvc、mvp架构的区别与联系 2.mvvm用到的设计模式 3.viewmodel的实现原理 4.viewmodel怎么更新数据的 5.安卓的线程通信 6.looper阻塞为什么不会造成ANR 7.广播里怎么执行耗时操作 8.阻塞多久会出现ANR 9.开发遇到的一些异常，怎么处理 10.线程安全的队列有哪些 11.concurrenthashmap详解 12.fragment的生命周期 13.安卓里解决多线程冲突的方法 14.volatile详解、synchronized详解，两者区别 15.activity生命周期 16.onStart与onResume解释 17.安卓中进程间通信方式 18.内核态与用户态 21.TCP传输中header里的字段 22.http状态码 23.Java GC机制 24.进程、线程、协程的联系与区别 25.死锁的必要条件 26.银行家算法 27.TCP拥塞控制 28.四次挥手详解 29.TCP与UDP区别 30.TCP怎么保证可靠传输 31.DNS解析过程 32.TCP报文里的字段 33.算法题：计算二叉树的高度（递归与非递归两种方式） 腾讯二面，35分钟1.mvvm，mvp,mvc 2.详细介绍项目 3.网络传输层的协议 4.TCP报头 5.TCP三次握手，为什么三次 6.linux内存管理机制 7.虚拟内存与物理内存 8.常用数据结构 9.堆排序原理 vivo一面 45分钟1.面向对象三大特性，多态怎么实现 2.静态方法与变量是否可以继承，原因 3.Java代理是否用过，怎么实现 4.Java异常详解 5.项目中遇到的异常 线程安全的队列 7.类加载的过程 8.类加载器，双亲委派模型 9.对象生命周期 10.判断对象是否可以回收的方法 11.有哪些GC roots 12.Java引用类型 13.抽象类与接口区别，各自优缺点 14.Java线程间通信， volatile详解、synchronized详解 15.线程的状态 16.进程、线程、协程 17.死锁怎么造成的 18.线程池详解 19.线程池怎么做到线程复用 20.thread local详解 21.Java泛型，泛型擦除机制 22.TCP与UDP区别，优缺点 23.TCP可靠传输机制 24.介绍http协议 25.https请求流程 26.b树、b+树、红黑树 27.红黑树怎么增加、删除节点 28.输入一个URL到网页显示的过程 29.localhost 与127.0.0.1的区别 30.MVVM、MVC、MVP的区别与联系，各自优缺点 31.activity的生命周期 32.安卓中的数据存储，sharedpreference详解 字节一面 1小时1.进程、线程、协程 2.进程间能共享内存吗 3.安卓中挂起函数怎么实现的 4.安卓中实现多线程的方法 5.线程池详解 6.线程池设计模式，怎么自己设计一个线程池 7.handler详解，是否会内存泄漏，泄露的原理 8.匿名内部类，原理是什么 9.Java GC算法 10.Java引用类型，弱引用的作用，引用队列。 11.安卓图片缓存，加载 12.安卓中的布局，布局优化方法，常用标签 13.安卓四大组件 14.activity四大启动模式 15.onnewintent方法 16.本地广播 17.jetpack组件 18.viewmodel设计模式，mvc,mvp,mvvm介绍 19.retrofit的具体实现，其中接口的作用，注解的作用 20.hashtable,hashmap与 concurrenthashmap详解 21.哈希冲突解决方法， 22.算法题：随机生成不重复的100个数0-99 字节二面，50分钟1.https详细介绍 2.get与post区别 3.请求状态码 4.cookie与session 5.Java内部类 6.泛型擦除机制 7.Java内存回收 8.GC roots 9.Java加锁方式 10.线程安全的单例模式（双重检测），为什么要两次判断，volatile作用 11.安卓的事件分发机制 12.算法题：获得二叉树的最大宽度，写出最优解 字节三面，50分钟5道代码题 1.写一个泛型方法，实现删除数组中的元素功能 2.写一个单例模式 3.返回二叉树的第k大数 另外两个记不得了，代码写的很差，所以三面卒。。。 顺丰一面，30分钟1.面向对象三大特性与面向过程区别 2.怎么判断对象相等，equals详解 3.抽象类与接口区别 4.Java跨平台的原因 5.JVM，GC算法 6.安卓view绘制流程 7.view怎么确认位置与大小，测量模式 8.常用的viewgroup，与view区别，在事件处理过程中有什么区别 9.安卓事件传递机制 10.listview详解，缓存机制与recyclerview区别 顺丰二面，15分钟1.项目详细介绍 2.安卓中的listview与recyclerview 3.安卓中的网络请求方式 4.项目中的设计模式 美团一面，1小时1.安卓项目介绍 2.mvc,mvp,mvvm架构 3.jetpack组件 4.lifecycle介绍 5.viewmodel实现原理 6.retrofit介绍 7.retrofit怎么实现多线程 8.线程池详解 9.多线程会遇到什么问题 10.死锁的条件，手写一个死锁代码并运行出来 11.怎么避免死锁问题 12.可重入锁 13.安卓怎么进行ui操作 14.安卓点击事件的处理 15.下拉刷新原理 16.安卓存储方式 17.contentprovider介绍，能实现耗时操作吗 18.service介绍，生命周期与 contentprovider区别 19.https请求过程 20.算法题：返回第k大的数，先说下你能想到的方法，再选一个最优方法。 美团二面，50分钟1.Java入口函数 2.方法签名 3.方法修饰符 4.static关键字详解，说下自己知道的关键字 5.Java基本类型 6.字符串详解 7.字符串的常用操作 8.Java io 9.Java异常介绍，是否所有异常都需要捕获 10.对Java抽象的理解 11.接口与抽象类区别 12.类编译过程 13.介绍对安卓中intent的理解 14.自定义view过程 15.介绍service 16.service与activity通信 17.输入URL到返回页面的完整过程 18.怎么加速http连接 19.虚拟内存 20.线程并发会遇到哪些问题，怎么解决 21.详细介绍自己的项目，项目可以有哪些改进的地方 22.算法题：二分法查找目标数 作者：Android大牛 小米安卓开发一二面面经一面9.291、手撕：使用一个固定长度数组实现队列，包括添加和取数据的功能 2、时间复杂度、空间复杂度，如何优化 3、链表如何优化，可以降低查询的时间复杂度？ 4、hashmap插入数据的流程？ 5、如何计算hashmap数据插入的位置？ 6、如何解决哈希冲突？ 7、多线程如何解决线程冲突？ 8、手撕：手写一个单例模式 9、volatile 和 synchronized 有什么区别？ 10、synchronized 和 lock 有什么区别？ 11、synchronized 底层是如何实现加锁操作的？ 12、对象、锁、对象监视器相互之间的关系？ 13、乐观锁如何实现？缺点有哪些？ 14、ThreadLocal 是如何存储的？ 15、ThreadLocalMap中遇到冲突是如何处理的？ 16、框架部分是如何学习的？遇到问题如何解决？ 17、如果转安卓开发，将怎样制定学习路线？ 18、对小米的了解？（我说我老米粉了，给面试官整笑了） 反问 （面试之前沟通时我说不会安卓，他也就没问我安卓的东西，面试官人还挺好的） 二面9.301、为什么会转码？（…每次面试必问） 2、有一千个键值对的数据，如何设计HashMap的初始容量大小？ 3、HashMap的扩容机制是什么样的？ 4、ConcurrentHashMap 是如何实现线程安全的？如果让你设计锁的数量你会怎么设计来提高效率？ 5、synchronized 底层是如何实现的？ 6、ReentrantLock 如何实现公平锁与非公平锁？ 7、公平锁与非公平锁的释放有什么区别？ 8、线程的 wait 和 block 有什么区别？和 sleep 有什么区别？ 9、JVM 中创建一个对象的过程是什么样的？ 10、JVM 如何判断一个对象需要被回收? 11、如果电脑内存是4G，已经使用了3G，现在启动一个程序需要超过1G的内存，会发生什么？(内存回收) 12、SpringBoot相比于Spring有什么优势？ 13、Spring中控制反转和依赖注入有什么区别和联系？为什么要进行控制反转？有什么好处？ 14、单例模式的好处有哪些？应用场景有哪些？ 15、三种工厂模式有什么区别？ 16、类加载过程是什么样的？ 17、双亲委派模型有什么作用？ 18、项目中如何设计单点登录？如何实现你这边登陆，另一边强制下线的功能？ 19、OSI七层模型介绍一下？应用层有什么协议？ 20、三次握手变成两次可不可以？为什么？ 21、手撕：二叉搜索树第 k 小的节点 小米面试官感觉都挺好的，不会的问题会进行引导，二面多问些场景题。 作者：CodeWH 2.&#x3D;&#x3D;和equals的区别 3.重载和重写的区别 4.值传递和引用传递 5.static、final作用 6.所有类的父类 7.this()和super() 8.int和Integer的区别 9.线程池和线程 10.锁了解哪些（说了分布式锁，又问我分布式锁是什么） 11.项目的难点，解决 Java反射原理Java面向对象的理解，封装，继承，多态HashMap底层原理接口和抽象类的区别你是怎么学习的，你的学习能力怎么样Activity的启动模式有哪些多进程通信的方式Android intent如何传递数据Android广播谈谈Android性能优化 https和http的区别三次握手你都用过哪些设计模式？ 作者：被光选中的人 字节跳动安卓工程师一、二面社招一面|1h聊了好久，一面也太正式了，问得较为基础，但是问得真的挺多的，心累。项目介绍 Java四次引用 垃圾回收机制 线程安全的集合有哪些（问得比较细） 进程间通信的方式 HashMap的底层实现 eventbus原理 View的绘制过程 Surfaceview可以在非主线程绘制吗 Glide的缓存机制 内存优化（追着问） TCP三次握手 算法：合并区间 算法：排序数组 二面|45min二面在源码这块真的问得很深，Android部分问得比较多，不能小看啊 Java虚拟机 okhttp的请求机制 RxJava实现原理 handler处理流程，looper和handler是一对一还是一对多，为什么主线程loop不会ANR？ AsyncTask的底层是怎么实现的 消费者与生产者模型 Activity的生命周期，从Activity A启动Activity B生命周期的变化 touch事件的传递机制 TCP与UDP的区别 常用的数据结构 算法：序列化和反序列化二叉搜索树 作者：田鸡不是鸡 对Java面向对象的理解（重点讲三大特性，哪些可以继承下来）你知道Java哪些数据类型呢？接口和抽象类的区别进程间通信的方式线程池参数HashMap的扩容机制，它线程安全吗？ArrayList和LinkedList区别String、StringBuffer、StringBuidler的区别讲讲activity的生命周期Android框架有了解过吗？binder原理安卓是如何进行数据存储的？TCP三次握手，为什么三次？用过哪些设计模式吗？单例模式有哪些实现方法 客户端技术成长路线分享 计算机网络、操作系统、计算机组成原理、数据结构与算法、数据库原理等计算机基础课：学习这些一方面是为了应付面试，就Android的面试，很多公司爱问http&#x2F;https，tcp&#x2F;udp，hashmap，linkedhashmap，用户态&#x2F;核心态等八股；更重要的是，对Android开发及体系的全面理解，Android应用层建立在linux操作系统上，所以才有Java和C++分别去写应用层代码和系统层代码，而系统层代码会做一些系统调用，这就需要了解一些操作系统。 Java：由于笔者之前学习的是Java后端开发，所以Java基础还比较扎实，语言的学习一定是需要不断地实践思考的。在学习Java的同时也需要去搞懂Java中的多线程（包括各种锁和线程管理）、JVM、集合类实现原理，这部分一定需要去慢慢啃原理甚至源码。 kotlin：kt目前作为Google主推的Android开发语言，以其空安全、简便性和各种语法糖会更进一步受到Android开发工程师的喜爱，同时支持Java和kt相互调用。同样地，kt的学习也需要不断地去实践，写一些小demo，更重要的是去识别kt与Java之间的区别，以及kt所拥有的新特性（协程、扩展函数、更优秀的函数式编程、一些常用的关键字如by lazy、lateinit、apply、run、with、object等等）。总之，kt学习过程中一定是需要和Java去对比着来的。 Android基础 推荐Android第一行代码（尽量看最新的版本，用kt写的） ​ Android四大组件（Activity、Service、ContentProvider、BroadcastReceiver）的使用； ​ Activity的生命周期，Activity显式跳转和隐式跳转，各种操作的生命周期变化（包括横竖屏切换、Activity间跳转、Activity非正常销毁生命周期变化），Activity的LaunchMode； Android动画； ​ Service两种启动方式及生命周期； ​ 网络编程、SqlLite、SharedPreferences； ​ Fragment管理，与Activity之间的通信； ​ Intent、Bundle、Parcelable使用； ​ 常见的控件和布局使用，ContraintLayout； ​ 常见的UI框架如ViewPager、ViewPager2、ListView、GridView、RecyclerView的使用，ListView和RecyclerView的缓存机制，RecyclerView的LayoutManager自定义布局，ViewPager2原理。 Android进阶 推荐Android系统源代码情景分析 ​ 笔者认为学习Android Framework非常有必要，一方面对于整个Android体系的把握，另一方面做Android Framework可以往智能车载系统开发等方向走。笔者花了1-2个月的时间看了Android系统源代码情景分析，看完以后对我触动很大，也理解了Android体系工作过程，所以笔者还是非常推荐读者有时间的话都学习一下Framework的知识，只要你肯专研，其实也并没有想象中那么难。 c++学习，学c++一方面是为了看懂系统源码，特别是binder基本上是用c++写的；另一方面NDK相关开发用的就是c++； ​ Android Framework，包括handler（Android线程间通信、Android应用层心脏）、Binder（Android 进程间通信、Android系统层心脏）、AMS、PMS、WMS工作原理； ​ Android 启动流程（包括系统开机流程、应用启动），Launcher工作原理，zygote工作原理； ​ 自定义View，View绘制（ViewRootImpl中三大绘制整个过程），滑动冲突； ​ Hook，动态代理； ​ AIDL使用和原理（其实本质上还是用的Binder），Messager使用和原理； ​ Android启动优化，Android应用整个启动流程和可以优化的点（1、业务，2、线程处理耗时任务，3、线程池管理，4、界面渲染，5、避免启动卡顿，6、闪屏），还有一些启动优化常用的工具如systrace； ​ Android卡顿优化，卡顿产生的原因，卡顿的检测； ​ Android内存优化，内存泄漏产生的原因和检测，内存溢出产生的原因和检测，LeakCanary原理； ​ 构建原理（gradle、groovy），Dalvik虚拟机和dex文件； ​ ANR原理和解决手段； ​ 开源库使用和源码，okhttp、retrofit、livedata、databinding、rxjava、glide等，glide缓存机制和内存优化； ​ MVC、MVP、MVVM使用； ​ Android开发架构，组件化、模块化； ​ 黑科技：插件化、热部署（笔者也还在学）； 作者：_Hawper 欧科云链安卓工程师一面项目提问（这里就不说了，大家看自己项目就好，项目尽量不要写得模棱两可） Java基本的数据类型有哪些？ 注解的类型有哪些？ sychronized和lock的区别 Java创建线程的方式 JVM的内存模型 自定义view的流程 HashMap的实现原理，和HashTable区别，线程不安全的原因 Activity生命周期，横竖屏切换的 Activity 生命周期变化？ view事件分发机制 https请求到响应的过程（加密过程） TCP拥塞控制 单例模式的实现方法，如何破坏一个单例模式？ 二面项目介绍 有用过kotlin，那问这块没问题吧？ Kotlin有没有static 关键字？那创建静态函数怎么办 构造方法有哪些 协程Flow有哪些应用场景？ （问了四五道就没问了，内心OS：要不还是问Java吧） Handler原理 looper死循环会不会卡死？为什么？ 内存泄漏的情况有哪些，讲一种检测方法 okhttp拦截器 Retrofit的调用过程（我给你点提示，你自己思考一下） mvp是什么？ TCP三次握手，如何保证安全传输的 现在Android岗位真的不多了，各位面试Android的朋友可以抱个团，共享下最新情况，我可以给大家分享一份自己整理的Android面试手册，需要的话可以给到大家，也可以看我专栏哦，都是新鲜面经。 作者：汉尼拔哈哈 海信项目介绍（听你讲完项目觉得你Android这块是没啥问题的，还是问了下Android架构和性能优化这块，让我具体谈谈）对Java面向对象思想的理解讲一下Java的基本数据类型（没答全，开头棒喝）深拷贝和浅拷贝分别是什么？Java 容器都有哪些？List、Set和Map的区别知道吗？String 类可以继承吗？为什么？它和StringBuilder、StringBuffer有什么区别？线程的 sleep() 方法和 yield() 方法有什么区别呢？线程不安全的情形有哪些？为什么要使用线程池？GC Root有哪些呢?那你就讲Java垃圾收集机制就行MVC架构是怎样的？https和http的区别，它是如何来保证安全性的？TCP三次握手的步骤？两次握手为什么不行？ 作者：汉尼拔哈哈 荣耀Android技术面面经荣耀是一个很值得去的地方，我9月初投的简历，国庆上来陆续进行了面试，荣耀是有一轮技术面、一轮综合面以及一轮HR面，我也都感受了一遍，这里重点给大家讲一下技术面的内容，希望能够帮到大家。 技术面丨50min自我介绍 项目中遇到的难题 使用了什么技术来解决 Java垃圾回收 HashMap底层原理 哈希表解决冲突的方法 什么是多态，怎么去实现呢 接口和抽象类的区别，它们各自的使用场景呢 安卓的四大组件 Activity回调的方法 你都用过哪些设计模式？ 实现多线程的几种方式 用过哪些数据结构 Java面向对象 synchronized equals和hashCode方法 广播的两种启动方式 三次握手 kotlin有了解过吗（聊了一会） 作者：牛牛！向前冲！链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 小米安卓面经(已offer)9.5 一面 25min ​ 自我介绍 ​ 写代码带来的快乐 ​ 设计模式 ​ 单例模式的好处 ​ 线程安全 ​ 形成死锁的条件,破解死锁的方法 ​ gc是什么 ​ 垃圾标记方法(拓展了很多) ​ 强引用,弱引用 ​ 对操作系统的了解 9.9 二面 40min ​ 自我介绍 ​ 多线程 ​ 线程池 ​ 并行与并发 ​ 死锁 ​ arraylist与linkedlist ​ hashmap ​ hashtable与concurrenthashmap ​ 手撕快速排序 ​ 手撕单例模式 ​ 内存泄露 ​ 项目中碰到的异常 作者：rsthh链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 蚂蚁金服Android客户端一面面经一面|40minjava四种引用JVM内存区域乐观锁和悲观锁gradle打包流程线程和进程的区别线程池的参数多线程同步问题，怎么保证线程安全？Android签名流程Android的四大组件有哪些？活动的生命周期http的缓存机制tcp滑动窗口，三次握手hashmap的底层结构常用的设计模式，重点问了单例模式的实现对AMS的了解讲一个红黑树和一个排序算法的时间复杂度问题的分析思路 二面|35min实习项目和小应用开发过程（扒裤子）HTTPS是怎么保证安全的DNS协议tap和udp的区别对称加密Android签名机制okhttp如何处理网络缓存的 作者：汉尼拔哈哈 OPPO安卓岗一、二面的面经一面|35min数组和链表的区别 hashmap原理 java中的异常处理与分类 线程池的参数 java垃圾回收机制 GC ROOT包括什么 dns协议 thread fragment的生命周期 handler的作用 hashmap相关 TCP传输层 https怎么保证他的安全性 http与https的区别 单例模式 二面|45minview绘制流程 双亲委派机制 内存泄漏的原因及方案 try catch finally 中遇到的return问题 讲一下排序算法的思路 作者：统一鲜橙多 商米-安卓开发-一面面经技术问题包括数据结构、算法、计算机网络和安卓的知识 数据结构： 数据结构的分类 数组和链表最大的区别 5个元素没有排序，数组和链表查找哪个更快一些？ 如果排序了，哪个会快一些？为什么？ hashmap具体是怎么实现的？ hash冲突如何解决？ 栈和队列的区别 二叉查找树的概念 树退化成链表如何解决？ B树以及B树可以解决什么问题？ 图的遍历以及具体代码如何实现？（迭代） 算法： 时间复杂度和空间复杂度的概念 常见的排序算法以及时间复杂度 链表的反转怎么实现？ 安卓： 安卓的四大组件 activity的声明周期 activity的启动模式 事件的触发流程 计算机网络： 5层结构以及相应的作用 传输层的主要协议有哪些 作者：鲸鱼sama链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 商米安卓校招面经分享先说结果：技术面挂了，但是感觉收获还是蛮大的。 简历过了，先是笔试关，一共8道题，全是lc上刷到过的原题，毫不犹豫的过了。 面试一开始，面试官根据简历上的项目经历问问题。 然后问Java语言基础，问到了泛型，有没有自己定义过泛型？（没有） Java中父类对象能否强制转换为子类对象？（印象中这题并没有刷到过，就回答的没有，面试官再追问 那有没有一种可能，在某种特殊情况下父类对象能强制转换为子类对象？）此时我心里已经发凉了，他这么追问的意思是，肯定能强制转换，只是我不知道，这也不是题库里能见到的题。这题过了。 然后是问c语言基础，宏定义 再就是数据结构和算法，堆排序的实现过程，快速排序的实现过程（快速排序的实现过程用语言给他描述了，然后他再追问细节，第二轮排序的时候，数组是不是要移动？）人麻了，稀里糊涂不知道讲的什么，这题过。 再然后是操作系统和计算机网络。Java多线程。计算机网络的7层模型。线程和进程的区别。线程和函数的关系。创建线程需要什么参数？哪些参数是必要的？如何用函数创建一个线程？ 然后，大学成绩怎么样？（绩点3.3）问高数，x立方的导数是多少？（3x方，很简单）如何用微积分计算圆锥体的体积？（具体过程不记得了，毕竟三年没学高数了，答的用极限的思想，把圆锥体抽象成无限个圆柱体，底面积乘高，两层类似f的符号相乘得出圆锥体的体积。） 然后再是概率论，如何计算数学期望？（答，数学期望类似平均值，比如在有10个点的散点图中，数学期望即这10个点的y值相加除以10） 最后是华为经典题，一个桶5L，另一个桶7L，如何得到6L？（答出来了）面试官立马追问，有没有一种数学理论可以给这个问题提供支持来证明，1L，2L，3L，4L，6L是不是都可以得到还是只能得到其中的某几种？（到这里，我是真的麻了，考这种题真的无从准备，面试官是啥问题都能深挖深挖再深挖）（最后一题有知道的同学可以评论区留言） 作者：AlaJackie 2022百度Android面试题汇总+解析思路1、 Activity的启动流程 ——从Launcher到AMS——从AMS到ApplicationThread——从ApplicationThread到Activity 2、 handler机制的原理 3、 跨进程通信的几种方式 4、 wait 和 sleep 的区别 5、 String,StringBuffer,StringBuilder 的区别 6、 View 和 SurfaceView 的区别 7、 View 的绘制原理 8、 简述 JNI 9、 简述 TCP，UDP，Socket 10、 进程和线程的区别 11、 内存泄露如何查看和解决 12、 View 的分发机制 13、 RecyclerView 和 ListView 的区别 14、 谈 MVC ，MVP，MVVM 15、 Android 性能优化 16、 SharedPreference 跨进程使用会怎么样？如何保证跨进程 使用安全？ 17、 activity，fragment 传值问题 18、 activity 与 fragment 区别 19、 Fragment 中 add 与 replace 的区别？ 20、 说下 Activity 的四种启动模式、应用场景 ？ ——standard标准模式；singleTop 栈顶复用模式；singleTask 栈内复用模式；singleInstance 单实例模式 21、 横竖屏切换的 Activity 生命周期变化？ 22、 Android 线程间通信有哪几种方式 ——1. 共享内存（变量）；2.文件，数据库；3.Handler；4.Java 里的 wait()，notify()，notifyAll() 23、自定义view的基本流程 24、 tcp和udp区别 25、 微信视频是用了tcp还是udp 26、 udp的优点 27、 http基于tcp还是udp 28、 为什么很多用https而不用http 29、 加密算法有了解吗 30、 什么是对称加密和非对称加密 31、 https的加密是对称的还是非对称的 32、 service在项目中怎么使用？ 33、 怎么在子线程中更新UI？ 同花顺 安卓 09.23 二面 50min 自我介绍 面向对象和面向过程的区别 面向切面编程你知道么，和面向对象的区别和细节 有无面向切面编程的案例 开闭原则的细节 设计模式的其他设计原则 synchronized了解么 ThreadLocal了解么，他有什么问题 快排的思想 快排解决topk问题（我哭死啊，我没有想到当前的会使用快排来进行解决topk，我之前都是使用堆排序） 快排和堆排来进行解决topk问题 自己手上的意向offer有那些 地点会考虑哪一些么 不知道你最近看过一些B站的虚拟人物么，你觉得当前的技术方面是怎么来进行实现的 看过那些书籍 假如说你来同花顺，你对团队怎么来看 你有那些优势和缺点 假如说同花顺给你一笔资金，你会怎么考虑来进行创业 反问：1：部门的一些情况；2：使用到的技术栈（安卓） 作者：叶子与花(o-ωｑ)).oO困 传音 Android开发 一面+二面09&#x2F;13 一面 volatile 在Java和C++中的区别 synchronized 原理 锁的升级 JVM内存模型 NoSQL与关系型数据库区别 垃圾回收算法 内存泄露检测方法 JVM调优 09&#x2F;19 二面 设计模式作用 动态代理与静态代理 线程与进程的使用场景 线程安全与不安全的例子 TCP三次握手 HTTP3 Java内存泄露场景 OOM能捕获吗 运行时异常与编译时异常 安卓相关知识 作者：牛客100861101链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 滴滴安卓客户端一二面面经一面（40min） 算法: 反转链表 合并两个排序的链表 自我介绍 安卓学习路线 http和https的区别 TCP与UDP区别 TCP流量控制 Cookie与Session的作用与原理 进程和线程的区别 进程间通信方式 多线程里的关键字 synchronized应用场景 wait() 和 sleep() 的区别 Java内存回收机制 垃圾收集器有哪些 二面（30min） 算法: 合并两个有序数组 合并区间 自我介绍 选择这个岗位的原因 项目盘点 当系统内存不足时，会存在单个 Activity 直接被系统回收的情况吗？ 安卓中的消息机制是什么样的 分发给Handler的消息是怎么处理的 消息机制中，如何更新UI 用过哪些安卓相关的开源框架 作者：统一鲜橙多链接：https://www.nowcoder.com/?type=11023_0来源：牛客网 1.介绍RPC，RPC和其他协议HTTP有什么区别，然后扣项目细节。。。（录像都不敢看，不想写了）","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"health","slug":"health","date":"2024-05-25T11:19:39.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/05/25/health/","link":"","permalink":"https://noteforme.github.io/2024/05/25/health/","excerpt":"","text":"Takeaway阿呆炒饭* 炒江西米粉 , 炒面难吃,太咸了疆岚大盘鸡 不好吃巧哥湘粉馆： 煮粉，太辣，难吃悦娟私厨。 味道还行，太咸了温岭嵌糕 ： 不卫生. Kneerecovery videohttps://www.youtube.com/watch?v=V-zQ2ePEj1Y https://mp.weixin.qq.com/s/KRcLEmkJI_ELGtdI2kufig 您好，您31岁，右膝关节疼痛一月余，参加过马拉松。看您的磁共振来说，有积液，髌骨软骨有损伤，半月板是个2级信号。半月板2级信号不需要处理，这是个退变信号，和活动多有关系，积液说明膝关节内有无菌性炎症。 从目前来看，引起目前您疼痛的原因主要是运动损伤。也许您没有严重的外伤，但是您平时打羽毛球，球类运动对膝关节要求极高，包括急停、急跑、旋转、蹲位到站立（或者反过来）。这些动作会造成膝关节的慢性损伤，尤其是膝关节内髌骨软骨，会早期发生软骨损伤，髌骨软骨不光滑，髌骨和股骨的摩擦界面摩擦力增大，髌股关节逐渐出现问题，而且是不可逆的，年纪大了就是关节炎。 好在您年轻，目前损伤不严重，不需要手术等处理，做好以下几点即可[1,2]：1.运动前做好热身。热身能唤醒肌肉，保持肌肉的原记忆和兴奋性，这样能减少受伤的几率。2.膝关节功能锻炼。细节很多，不过做好了这些锻炼，利于膝关节保护，减缓关节退变，增加运动寿命。①加强股四头肌的锻炼：直腿抬高坚持5秒钟，放下几秒钟，再抬高，再放下，反复做，50-100次为一组，每天上午一组下午一组。 ②靠墙静蹲：推荐症状不明显的中青年做，上身后背靠墙，重心后移，膝关节的屈曲不要超过90度，坚持到大腿发酸停止运动，注意不要膝盖内扣，脚后跟不要太靠近墙面。 ③每日膝关节按摩法：左右推髌骨，增加髌骨活动度，按摩侧副韧带2分钟。 ④甩腿运动：2000次。手扶住支撑物，一只脚垫高，另一只脚前后甩动，每侧甩1000次，两脚交替进行甩动，可分多次完成，一般2小时之内完成。 ⑤勾脚运动：坐在椅子上，伸直腿，勾脚尖绷脚尖交替完成，每条腿30-50次1组，每天3组。 患者可根据自身习惯，耐力选择适合自己的运动与理疗方式。 OAT容易胀气，少量多次5 勺 燕麦片 + 无糖豆浆 https://www.youtube.com/watch?v=Tx_R1ewl7DA&amp;pp&#x3D;ygUM54eV6bqm6YCJ5oup https://www.youtube.com/watch?v=xnbfDZOyFDA 而男人們則不應超過2,000kcal。https://www.esquirehk.com/health/calories-how-to-allocation 千焦和千卡的换算关系是：1000千焦&#x3D;238.9大卡，1 大卡（千卡）&#x3D;4.18千焦（KJ） MILKhttps://mp.weixin.qq.com/s/3G6ojq9zIvoZW-0B6hXXbAhttps://mp.weixin.qq.com/s/6biNR2ecGKYGU4qGtYUTbwhttps://mp.weixin.qq.com/s/zrrig_-da9KdOUhyuMWHTQ 酸奶https://mp.weixin.qq.com/s/BPU9f9YbIgtLUaV827QnTw 维生素 Dhttps://mp.weixin.qq.com/s/tuFUAUAHkjhJOP0yxH39vA EAThttps://mp.weixin.qq.com/s/hn_fErI9jWFz5orcVYPNOQ salary薪资 关于武汉佰钧成技术有限责任公司的外包，针对杭州阿里外包，本人现在刚脱坑，在杭州阿里外包的职位级别是W3-W5，以上都是针对阿里的外包开发和测试岗位。W3 对应的甲方给出的薪资是25K W4对应的甲方给出的薪资是30K W5不知道一般甲方只会给你一半的薪资，并且会很坑，还有一点就是各种压榨你们外包人力资源，对于想进来的人，我表示看你个人意愿。然后薪资尽量朝着20+往上来要，给不到就不需要来，跟外包人员得硬气一点，里面公积金和社保都是最低的来，没有什么团建活动，几乎为零，也没有归宿感，给人感觉就是一头牛。如果在里面混日子的话，基本上就废了。还有一点还会卡你离职，总的来说，垃圾公司，垃圾公司，垃圾公司。重要的事情说三遍哟，如果说要的薪资够高的话，我觉得也不亏，不要给公司面子。没有人会理解你的。 作者：axolotl链接：https://www.zhihu.com/question/67747911/answer/1488575977来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 https://maimai.cn/web/feed_detail?fid&#x3D;1798366727&amp;efid&#x3D;iJ0LEumBeKjT6BqWVHmggQ 20年12月份进入蚂蚁金服外包当是级别是w3薪资12k不到，然后21年8月底离职去了家自研公司薪资15k 13薪 主要是负责移动端的测试，做了2月公司决定项目解散不做了，11月中旬又被之前阿里主管招回去了，升了一级加薪到了15k。https://www.zhihu.com/question/502753583","categories":[{"name":"LIFE","slug":"LIFE","permalink":"https://noteforme.github.io/categories/LIFE/"}],"tags":[],"author":"Jon"},{"title":"Computer Network","slug":"computer-network","date":"2024-05-24T07:56:10.000Z","updated":"2024-09-15T10:00:05.063Z","comments":true,"path":"/2024/05/24/computer-network/","link":"","permalink":"https://noteforme.github.io/2024/05/24/computer-network/","excerpt":"","text":"Summary of 4 Layer Model The 7-layer OSI Model traceroute -w 1 www.jonblog.site https://www.bilibili.com/video/BV1F54y1t7Dx?from=search&amp;seid=12798261982184143495 Open System InterconnectionOSI 7层模型 TCP&#x2F;IP 5层模型 应用层protocolURI ftp://ftp.is.co.za/rfc/rfc1808.txt http://www.ietf.org/rfc/rfc2396.txt ldap:&#x2F;&#x2F;[2001:db8::7]&#x2F;c&#x3D;GB?objectClass?one mailto:&#x4a;&#111;&#104;&#110;&#x2e;&#68;&#111;&#x65;&#64;&#x65;&#120;&#97;&#109;&#x70;&#108;&#x65;&#46;&#99;&#111;&#109; news:comp.infosystems.www.servers.unix tel:+1-816-555-1212 telnet:&#x2F;&#x2F;192.0.2.16:80&#x2F; urn:oasis:names:specification:docbook:dtd:xml:4.1.2 Http1.1https://tools.ietf.org/html/rfc7230#section-6 HyperText Transfer Protocol 可靠的数据传输协议，基于TCP 报文格式 Http2.0https://tools.ietf.org/html/rfc7540 可以看到http2.0改造了协议， head 改成了 HEADERS frame ,Body 改成了 DATA frame。 Length : 整个frame 开始到结束 Type : frame的类型 Stream ID用作流控制 Payload 请求正文 https://www.bilibili.com/video/BV1SJ411q7ei?from=search&amp;seid=10178848750670062838 https://www.bilibili.com/video/BV1Sw411d7oE?from=search&amp;seid=10178848750670062838 端口作用进程id是会变化的，进程通过绑定固定不变的端口，来实现通信。 http版本区别 https://juejin.cn/post/6844903489596833800 Socket对TCP&#x2F;IP的封装， 提供可供程序员做网络开发的接口-Socket编程接口。 SocketHttpTest.java http get请求 按照get请求拼接字符串 1234567891011121314151617StringBuffer protocol = new StringBuffer(); //请求行 protocol.append(&quot;GET &quot;); protocol.append(url.getPath()); protocol.append(&quot;?&quot;); protocol.append(url.getQuery()); protocol.append(&quot; &quot;); protocol.append(&quot;HTTP/1.1&quot;); protocol.append(&quot;\\r\\n&quot;); // http请求头 protocol.append(&quot;Host:&quot;); protocol.append(url.getHost()); protocol.append(&quot;\\r\\n&quot;); //空行 protocol.append(&quot;\\r\\n&quot;); 1234567891011121314//post请求体 get没有System.out.println(&quot;发送的http报文: \\n&quot; + protocol.toString()); Socket socket = new Socket();socket.connect(new InetSocketAddress(url.getHost(), 80)); //获得输入输出流BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); bufferedWriter.write(protocol.toString());bufferedWriter.flush(); StringBuilder stringBuilder = new StringBuilder(); 1234567String line = &quot;&quot;;while ((line = bufferedReader.readLine()) != null) &#123; stringBuilder.append(line) .append(&quot;\\r\\n&quot;);&#125;System.out.println(stringBuilder.toString()); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* Http Post请求参数放入请求体中```java URL url = new URL(cUrl); StringBuffer protocol = new StringBuffer(); //请求行 protocol.append(&quot;POST &quot;); protocol.append(url.getPath()); protocol.append(&quot; &quot;); protocol.append(&quot;HTTP/1.1&quot;); protocol.append(&quot;\\r\\n&quot;); // http请求头 protocol.append(&quot;Host:&quot;); protocol.append(url.getHost()); protocol.append(&quot;\\r\\n&quot;); protocol.append(&quot;Content-Length: 60\\r\\n&quot;); protocol.append(&quot;Content-Type: application/x-www-form-urlencoded\\r\\n&quot;); //空行 protocol.append(&quot;\\r\\n&quot;); // 必须用空行分隔请求体 //post请求体 get没有// protocol.append(&quot;city=&quot;+ URLEncoder.encode(&quot;长沙&quot;,&quot;UTF-8&quot;) +&quot;&amp;key=13cb58f5884f9749287abbead9c658f2&quot;); protocol.append(url.getQuery()); System.out.println(&quot;发送的http报文: \\n&quot; + protocol.toString()); Socket socket = new Socket(); socket.connect(new InetSocketAddress(url.getHost(), 80)); //获得输入输出流 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); bufferedWriter.write(protocol.toString()); bufferedWriter.flush(); StringBuilder stringBuilder = new StringBuilder(); String line = &quot;&quot;; while ((line = bufferedReader.readLine()) != null) &#123; stringBuilder.append(line) .append(&quot;\\r\\n&quot;); &#125; System.out.println(stringBuilder.toString()); 分块编码数据量很大！分块编码 上面的5就是 下面的字符长度 HTTPShttps://www.bilibili.com/video/BV1F54y1t7Dx?p=5 https://www.bilibili.com/video/BV1j7411H7vV?from=search&amp;seid=12798261982184143495 传输层 (TCP UDP)代码运行在用户机器上，为了对 网络层进行更好的控制 UDP(User Datagram Protocol) 面向报文传输 没有拥塞控制,无法保证数据在网络中是否丢失 UDP首部开销小 ​ ![传输层] TCP (Transmission Control Protocol) 面向连接的协议 提供可靠传输 全双工通信 面向字节流协议: 可能对用户数据合并或分拆进行传输 TCP首部 序号 tcp标记 如何保证TCP可靠传输? 停止等待协议 连续ARQ协议(Automatic Repeat request) : ​ 滑动窗口: 以字节为单位，实现流量控制 累计确认 ​ 选择重传: 重传边界和范围 定时器 超时定时器 坚持定时器: 解决死锁局面,当收到窗口为0的消息，则启动坚持定时器,每隔一段时间发送一个窗口探测报文 TCP协议的拥塞控制 报文超时即认为拥塞 慢启动算法 由小到大逐渐增加发送数据量,直到到达 “慢启动阈值”&#x3D;&gt;开始 拥塞避免算法 拥塞避免算法 只要网络不拥塞，就试探拥塞窗口调大 TCP三次握手TCP标记 三次握手 ![shake] 为何3次握手1客户端角度 : 1 ，2，说明客户端的发送和接收没问题 服务端角度： 1，2，说明服务端的接收没问题，但是不确定自己的发送收否有问题，所以需要3确认 为何3次握手2第一次握手客户端发出: Server觉得 : 客户端的发送能力没问题 第二次握手服务端发出: Client觉得 : 服务端的接收能力没问题， 以及服务端的发送能力没问题。 第三次握手客户端发出: Server觉得: 客户端的接收能力没问题。 为什么要第三次握手? 只有两次握手的话，一旦第二次握手接收超时，重新发送后就会重新发送，会导致建立2个连接 TCP连接的4次挥手 由客户端向服务端发起 : 服务端收到信息后,就能确定客户端已经停止发送数据。 由服务端向客户端发起 : 客户端收到消息后,就能确定服务端已经知道客户端不会再发送数据。这一次是为了TCP可靠传输，确认收到了数据包。 由服务端向客户端发起 : 客户端收到消息后,就能确定服务端已经停止发送数据。此时 服务端数据发送完了。 由客户端向服务端发起 : 服务端收到信息后,就能确定客户端已经知道服务端不会再发送数据。 Client: 分手 Server : what Server : 好吧 分吧 Client : 我已经删微信了； 等待计时器 : 2MSL(Max Segment liftime), **为什么需要等待计时器?**： 如果第4个挥手报文接收方没收到，那么接收方会重新发送第3次的挥手报文 为什么第3次挥手是接收方发出的? : 我的理解是，第2次挥手是确认收到的回复，第三次是挥手是确认数据发送完毕，告诉发送方可以断开了,然而我又有了疑问? 为什么需要第4次挥手? 小扎和小美通信 https://www.zhihu.com/question/63264012 网络层通过ISP、路由 找到 ,运行在路由器上 rip协议:不太理解 网络配置 主机计算IPADDR : 192.168.139.10 NETMASK子网掩码 : 255.255.255.0 网络号: 就是上面的IPADDR ,NETMASK进行 与运算, 192.168.139.0,10就是网络中的第10号主机。 ##路由表 第一条意思 我这台计算机通过 eth0,不需要任何中间的网关Geteway,久可以访问这个网络(192.168.150.)中的任何计算机， 怎么找到目标主机面试题:路由器是怎么找目标服务器 https://www.bilibili.com/video/BV1PU4y1s7Bs?p=18&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1PU4y1s7Bs?p=24&amp;spm_id_from=pageDriver www.baidu.com通过 DNS解析得到目标ip地址 61.135.169.121 61.135.169.121和第一条255.255.255.0进行 按位与运算的到的61.135.169.0和192.168.150.0结果不一样，所以该条目被淘汰。 第二条目不用管（好像这个条目有问题），来到第三条，按照步骤2按位与运算，得到结果0.0.0.0，和Destination结果一样。则此时的Gateway起作用。 数据给到下一跳网关，也就是192.168.150.2，如果获得的下一跳网关Gateway是 0.0.0.0的话，那么说明在同一个局域网直接发数据就好了，不用跳了。 #数据链路层 封装成帧透明传输差错检测ARP协议 网卡的IP 192.168.150.1 和at后面对应的 网卡mac地址。 网卡pc1到pc5的过程网络数据里层存放目标IP地址，外层有下一跳的mac地址。 但是mac地址是怎么来的呢? 就是通过 arp协议, pc1发到pc2路由器,带的数据是1，mac先定义成FFFFFF pc2接受到后，回传给pc1自己的mac地址，接着上面的传输层步骤4就有了下一跳的mac地址了。 物理层: 铜线介质类 数据链路层 ： 相邻两台机器间的连接，把数据报以帧的形式发送, 以太网协议 https://www.bilibili.com/video/BV1pA411M7Ai?p=137&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1PU4y1s7Bs?from=search&amp;seid=16016904944562540448 https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html https://hpbn.co/brief-history-of-http/ https://www.w3.org/Protocols/History.html https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP TCP 三次握手，确保两端收发能力的正常。 Client -&gt; Server : Client发送Ok Client send Client recieve Server send Server Recieve Client-&gt;Server ok Server -&gt;Client ok Client-&gt;Server ok ok","categories":[{"name":"NETWORK","slug":"NETWORK","permalink":"https://noteforme.github.io/categories/NETWORK/"}],"tags":[],"author":"Jon"},{"title":"Solar System","slug":"solar-system","date":"2024-05-22T13:44:38.000Z","updated":"2024-10-01T14:27:08.955Z","comments":true,"path":"/2024/05/22/solar-system/","link":"","permalink":"https://noteforme.github.io/2024/05/22/solar-system/","excerpt":"","text":"https://www.iau.org/public/themes/pluto/","categories":[],"tags":[{"name":"LIFE","slug":"LIFE","permalink":"https://noteforme.github.io/tags/LIFE/"}],"author":"Jon"},{"title":"INTERVIEW-ANDROID-BASIC","slug":"interview-android-basic","date":"2024-05-22T06:48:34.000Z","updated":"2024-09-15T10:06:24.109Z","comments":true,"path":"/2024/05/22/interview-android-basic/","link":"","permalink":"https://noteforme.github.io/2024/05/22/interview-android-basic/","excerpt":"","text":"architecturehttps://jonblog.site/2024/05/30/architecture/ Android基础知识点四大组件是什么Activity ,Service ,BroadCastReceiver,ContentProvider ActivityActivity各种情况下的生命周期? 先启动A 再跳转B A_onCreate()-&gt; A_onStart()-&gt;A_onResume-&gt; A_onPause()-&gt; B_onCreate() -&gt; B_onStart() -&gt; B_resume -&gt; A_onSaveInstanceState()-&gt;A_onStop() 弹出Dialog 不调用任何生命周期,所以Activity上有Dialog的时候按Home键时的生命周期,有没有Dialog都一样的。 横竖屏切换的时候，Activity 各种情况下的生命周期 Activity状态保存于恢复 (什么都不设置) 设置android:screenOrientation=&quot;portrait&quot; 不会旋转 Android 8.0 设置android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 会发生旋转，生命周期不发生变化，只是会调用 onConfigurationChanged() https://blog.csdn.net/qq_36713816/article/details/80538467 前台切换到后台，然后再回到前台，Activity生命周期回调方法。 前台切换到后台: A_onCreate()-&gt; A_onStart()-&gt;A_onResume-&gt; A_onPause()-&gt;A_onSaveInstanceState()-&gt; A_onStop() 再回到前台: A_onRestart() -&gt;A_onStart()-&gt; A_onResume() Activity之间的通信方式 Intent startActivity()或startActivityForResult(),通过Intent传递信息,需要注意，Intent对携带信息大小有限制。 BroadcastReceiver 数据存取传递，sharePreference&#x2F;sql&#x2F;File Application 静态变量 Activity的四种启动模式对比 Standard 默认启动模式，每次都重新创建一个新的Activity 。 SingleStop 当前Activity如果在栈顶，那么就不会创建新的Activity，会原先调用Activity的onNewIntent() SingleTask 当前任务栈已经有Activity实例，就不会再创建了，会调用 onNewIntent(). SingleInstance 单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。 可以得出以下结论： \\1. 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例。 \\2. 以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 \\3. 以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中。 \\4. 被singleInstance模式的Activity开启的其他activity，能够在新的任务中启动，但不一定开启新的任务，也可能在已有的一个任务中开启。 https://blog.csdn.net/zivensonice/article/details/51569502 https://ayusch.com/android-launch-modes-explained/ https://noteforme.github.io/2021/01/16/Activity/ 为什么 application.startActivity 要设置NEW_TASK 如果Activity是由一个已经启动的Activity发起的，那么把它放在这个已经启动的任务栈是合理的，Application本来没有任务栈，那么就新创建一个放起来. https://www.wanandroid.com/wenda/show/8697 任务栈的底层原理 Android APK编译打包流程 AAPT（Android Asset Packaging Tools）工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译成二进制形式，当然assets文件夹中的文件不会被编译，图片以及raw文件夹中的资源也会保持原有的形态，需要注意的是raw文件夹中的资源也会生成资源ID。AAPT编译完成后会生成R.java文件。 AIDL工会将所有的aidl接口转换为java接口。 所有的Java源代码、R文件、接口都会编译器编译成.class文件。 Dex工具会将上述产生的.class文件以及第三方库和其他class文件转化为dex（Dalvik虚拟机可执行文件）文件，dex文件最终会被打包进APK文件。 apkbuilder会把编译后的资源和其他资源文件同dex文件一起打入APK中。 生成APK文件之后，，需要对其签名才能安装到设备上，平时测试都会使用debug keystore，当发布应用时必须使用release版的keystore对应用进行签名。 如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时能提高速度，但是会相应的增加内存开销。 总结：编译 –&gt; DEX –&gt; 打包 –&gt; 签名和对齐 ART虚拟机与Dalvik虚拟机的区别 什么是ART？ ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time（JIT）编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time（AOT）编译。在移除解释代码这一过程后，应用程序执行将更加效率。启动更快。 ART优点： 系统性能的显著提升。 应用启动更快、运行更快、体验更流畅、触摸反馈更及时。 更长的电池续航能力 支持更低的硬件。 ART缺点 更大的存储空间占用，可能会增加10%-20% 更长的应用安装时间 LaunchMode应用场景FragmmentFragment生命周期管理过程遇到的坑和解决办法fragment各种情况下的生命周期 Activity与Fragment之间生命周期比较​ onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; ​ onDestroyView() -&gt; onDestroy() -&gt; onDetach() Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？ Fragment发起 Fragment onActivityResult能接收。Activity onActivityResult能接收,但是requestCode不正确。 Activity发起 Fragment不能接收。 Activity onActivityResult能接收。 fragment之间传递数据的方式？ Fragment.setArguments()方法传递bundle findFragmentById()找到tag,然后直接操作Framgent 123456789101112131415161718public void onArticleSelected(int position) &#123; ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment); if (articleFrag != null) &#123; articleFrag.updateArticleView(position); &#125; else &#123; ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); transaction.commit(); &#125; &#125; 接口回调 Service请描述一下Service 的生命周期 startService() ​ 启动: onCreate() - onCommandStart() - onDestory() ​ 继续startService : 只会执行 onCommandStart() bindService() ​ onCreate() - onBind() - onUnbind()-onDestory() service和activity怎么进行数据交互？ bindService() Service中定义接口，ServiceConnection中获取Service实例，调用响应接口 注册广播传递数据说说ContentProvider、ContentResolver、ContentObserver 之间的关系 把自己的程序数据提供给其他应用程序调用，提供相关的uri接口,没用过ntentObserver 之间的关系 把自己的程序数据提供给其他应用程序调用，提供香港的uri接口,没用过 http://wangbufan.cn/2019/09/17/Service%E5%8F%8AService%E4%B8%8EActivity%E9%80%9A%E4%BF%A1/ 请描述一下广播BroadcastReceiver的理解 广播是可以作为应用全局监听器，可以实现应用中不同组件少量数据的通信！！！，更深研究后可以多说点. 基于消息的发布&#x2F;订阅事件模型. 广播的分类 无序广播 有序广播 接收者按照优先级顺序接收,每个接收者都有权终止广播,下一个就得不到. 广播使用的方式和场景 app全局监听 binder机制 https://www.jianshu.com/p/5a983578418e BroadcastReceiver，LocalBroadcastReceiver(本地广播) 区别BroadcastReceiver：针对应用间，系统和应用间通信。 LocalBroadcastReceiver： 只有自己应用内部才能收到,效率更高. DialogAlertDialog,popupWindow,Toast区别 ？Android是不允许Activity或Dialog凭空出现的,而Dialog则必须在一个Activity上面弹出 AlertDialog 拦截了屏幕上所有的TouchK&#x2F;key PopupWindow 仅仅拦截自身区域touch&#x2F;key 需要Activity类型的Context启动 Toast 可以研究下 两者最根本的区别在于有没有新建一个 window，PopupWindow 没有新建，而是通过 WMS 将 View 加到 DecorView；Dialog 是新建了一个 window (PhoneWindow)，相当于走了一遍 Activity 中创建 window 的流程 https://www.jianshu.com/p/aed496937bd2 Application 和 Activity 的 Context 对象的区别ApplicatioContext ： ​ 应用生命周期一样长,长生命周期对象就用ApplicationContext Activity的Context： ​ 当前Activity的生命周期,和UI相关的都用Activity为Context来处理 https://www.jianshu.com/p/e215c90a460e Context的理解？​ Context是维持Android程序中各组件能够正常工作的一个核心功能类 AnimAndroid属性动画特性Android动画框架实现原理 可以改变对象的属性。还需要说说什么吗? 如何导入外部数据库?把数据库文件防盗asserts目录下，然后写入databases目录下面, 然后通过数据库容器装载里面数据库里面的数据。 https://blog.csdn.net/chaoyu168/article/details/50467913 插值器 估值器区别​ 插值器: （Interpolator）决定 值 的变化模式（匀速、加速） ​ 估值器 : (TypeEvaluator)决定 值 的具体变化数值 谈谈对接口与回调的理解 理解: A发送消息给B,B处理完后高速A处理结果. 实现: 一般而言，处理消息的类是唯一的，发送消息的类却是各种各样的，将回调方法做成一个接口，不同的发送者实现该接口，并且把自己的接口实现类的对象在发送消息时，传递给消息处理者。 注册之后不马上执行，而是某个时机再触发执行。 回调的原理 写一个回调demo12345678910111213141516171819202122232425262728public class MyTest &#123; public static void main(String[] args) &#123; ProcessClick process = new ProcessClick(new OnClickListener() &#123; @Override public void onClick() &#123; System.out.println(&quot;已经点击&quot;); &#125; &#125;); process.click(); &#125;&#125;interface OnClickListener&#123; void onClick();&#125;class ProcessClick &#123; OnClickListener listener; public ProcessClick(OnClickListener listener) &#123; this.listener = listener; &#125; void click()&#123; listener.onClick(); &#125;&#125; https://developer.aliyun.com/article/614769 VIEW相关如何优化自定义Viewandroid view绘制机制和加载过程，请详细说下整个流程每个Activity包含一个Window对象，Android中window对象由PhoneWindow实现，PhoneWindow将一个DecorView设置为整个应用窗口的根View,DecorView作为窗口界面的顶层视图，封装了窗口操作的通用方法，DecorView将要显示的具体内容显示在PhoneWindow上，这里所有的View监听事件通过WindowMangerService来接收,通过Activity对象来回调相应的onCLicklistener.显示是将屏幕分成两部分，一个TitleView，另一个是ContentView. Measure 如果是原始的 View,通过measure方法就完成了测量过程,如果是ViewGroup,除了完成自己的测量外，还需要遍历所有的子View,各个子元素再去递归执行这个流程. Layout Draw MeasureSpeck的意义，怎么计算MeasureSpecwrap content 和MATCH_PARENT的测量方式WRAP_CONTENT : 最大模式，大小不定，但是不能超过窗口的大小. specMode是AT_MOST模式,这种模式下，它的宽，高等于specSize, 这种情况下specSize是parentSize,而parentSize是父容器目前可以使用的大小,也就是父容器剩余的空间大小. MATCH_PARENT: 精确模式，大小就是窗口大小. https://noteforme.github.io/2017/11/12/View_OVER/ LayoutParams是是什么介绍下SurfaceView SurfaceView使用双缓冲技术缓解，页面绘制频繁引起的卡顿。 SurfaceView可以在子线程更新 UI,不会阻塞主线程，提高响应速度。 https://noteforme.github.io/2019/11/05/SurfaceView/ SurfaceView在更新视图时用到了两张 Canvas，可以先创建一个临时的Canvas对象，将图像都绘制到这个临时的Canvas对象中，绘制完成之后再将这个临时Canvas对象中的内容(也就是一个Bitmap)，通过drawBitmap()方法绘制到onDraw()方法中的canvas对象中。 RecycleView的使用​ https://noteforme.github.io/2017/07/17/RecyclerView/ webview安全问题WebView漏洞的根源在于强制其访问攻击者控制的网页。网页中含有攻击者可以控制的JS,因此可能钓鱼，窃取私有文件，甚至是 RCE,带来比较大的危害。 下面主要是4.4系统以上的机型 Webview密码明文存储漏洞WebView默认开启密码保存功能mWebView.setSavePassword(true),如果未关闭，用户输入密码时，会弹出提示框，询问用户是否保存密码，如果选是，密码会明文保存到 &#x2F;data&#x2F;data&#x2F;com.package.name&#x2F;databases&#x2F;webview.db WebView域控制不严格漏洞setAllowFileAccess(true) : 窃取APP任意目录下的私有文件 ​ setAllowUniversalAccessFromFileURLs : 允许通过file域url中的 javascript访问其他的源。 https://noteforme.github.io/2017/09/01/WebView/ webview内存泄漏 Leakcanary 验证?​ android 5.0以下有内存泄漏问题 https://juejin.cn/post/6901487965562732551 viewstub延迟加载原理 123456789101112131415161718 // 设置 ViewStub 不进行绘制 setWillNotDraw(true);private void replaceSelfWithView(View view, ViewGroup parent) &#123; final int index = parent.indexOfChild(this); // 把 ViewStub 从控件层级中移除。 parent.removeViewInLayout(this); // 把新创建的 View 对象加入控件层级结构中，并且位于 ViewStub 的位置， // 并且在这个过程中，会使用 ViewStub 的布局参数，例如宽高等。 final ViewGroup.LayoutParams layoutParams = getLayoutParams(); if (layoutParams != null) &#123; parent.addView(view, index, layoutParams); &#125; else &#123; parent.addView(view, index); &#125;&#125; ​ https://juejin.cn/post/6844903799337779214 overdraw过度绘制优化方法​ 移除默认和不必要背景 ​ https://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html ​ https://www.jianshu.com/p/9e095bacf44a View刷新机制 View绘制流程 自定义控件原理 如何取消AsyncTask？ 为什么不能在子线程更新UI？ Requestlayout，onlayout，onDraw，DrawChild区别与联系 invalidate和postInvalidate的区别及使用 Activity-Window-View三者的差别 自定义View如何考虑机型适配 自定义View的事件 封装View的时候怎么知道view的大小 事件分发机制是否解决过事件冲突问题，怎么解决的。 问题: https://juejin.cn/post/6922300686638153736 https://noteforme.github.io/categories/VIEW/ https://www.bilibili.com/video/BV1754y1H7jT 请描述一下View事件传递分发机制 Touch事件传递流程 事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？ View和ViewGroup分别有哪些事件分发相关的回调方法 我的面试问题activity被销毁后重建，怎么获取fragment​ findFragmentByTag ​ https://www.wanandroid.com/wenda/show/11077 activity和service通信 通过bindService 通过广播 https://www.jianshu.com/p/6040dfa83594 activity销毁线程会不会消失不会, 可以这样处理 12345678910111213141516171819/** * 静态内部类将不会再隐式的持有外部类的引用，所以在配置改变时，你的Activity的实例在也不会 * 出现内存泄露 */ private static class MyThread extends Thread &#123; private boolean mRunning = false; @Override public void run() &#123; mRunning = true; while (mRunning) &#123; SystemClock.sleep(1000); &#125; &#125; public void close() &#123; mRunning = false; &#125; &#125; activity每个方法处理的区别 onCreate(): Activity创建的时候调用，绑定数据。 onStart() : 当Activity对用户变得可见的时候调用. onResume() : activity开始和用户交互的时候调用，这时候activity处于栈顶，伴随着用户的输入. onPause() : 当activity失去前台状态，开始进入stopped&#x2F;hidden or destroyed状态，不能再获取焦点，此时activity对用户可见，但是更新的UI的操作要快。 onStop() : 当activity不再可见，可能是新的activity来到栈顶，或者当前activity正在被destroy. onDestory(): 当前activity正在离开。 activity fragment传递数据方式 ViewModel onTach() 回调 单例模式怎么理解的 创建唯一的对象 res&#x2F;raw和assets 三者目录下的文件在打包后原封不动的保存在apk包中，不会被编译成二进制。 Res&#x2F;raw文件会被映射到R.java文件中，访问的时候直接使用资源 R.id.filename; res&#x2F;raw不可以有目录结构，而asserts则可以有目录结构，也就是asserts目录下可以建立文件夹. https://www.jianshu.com/p/4c8bcb8c3717 截获通知新建一个服务MessageNotificationService实现 NotificationListenerService final特性 final类不能被继承，没有子类 方法不能被子类的方法重写，但可以被继承 表示常量，只能被赋值一次，赋值后不再改变。 android多线程怎么处理的 ，两个子线程间怎么通讯​ Android主线程和子线程之间的通信是通过消息循环机制，主线程中的handler把子线程的 message发送给主线程的Looper，那么子线程是如何通信的， 可以把looper绑定到子线程中，调用Looper.prepare()为改子线程生成Looper,然后调用Looper.loop()启动消息队列，并且在该子线程中创建一个Handler,在另一个子线程调用handler发送消息。这样实现通信. 1234567891011121314151617181920212223242526272829303132333435363738val threadA = ThreadA()val threadB = ThreadB()Thread(threadA).start()if (threadA.getHandler() == null) &#123; Thread.sleep(1000) handler = threadA.getHandler()&#125;Thread(threadB).start()class ThreadA : Runnable &#123; var mHandler: Handler? = null fun getHandler(): Handler? &#123; return mHandler &#125; override fun run() &#123; Looper.prepare() mHandler = object : Handler(Looper.myLooper()!!) &#123; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) Timber.d(&quot;线程A: 线程B发过来消息了-- $&#123;msg.obj&#125; &quot;) &#125; &#125; Looper.loop() &#125; &#125; inner class ThreadB : Runnable &#123; override fun run() &#123; val message = Message.obtain() message.what = 1 message.obj = &quot;线程B 发送消息&quot; + System.currentTimeMillis() handler?.sendMessage(message) &#125; &#125; https://blog.csdn.net/pbm863521/article/details/103493708 防止应用被被杀死,怎么保证service不被杀死http://www.52im.net/thread-2881-1-1.html http://www.52im.net/thread-2893-1-1.html 怎么让线程有序两个线程，想让来的一个插队怎么弄​ Join 批量网络请求 子线程创建Handler context对象互相引用，对象回收 Android界面怎么回收的 生命周期 内存溢出和内存泄露的区别，oom是怎么处理的 ， ANR怎么避免 java内存回收机制 android管理机制 怎么处理内存泄露 怎么做性能优化 反射机制 broadcastReciever和 handler区别 后台图片更改，前台怎么处理 图片加载库,图片加载方法 图片加载框架怎么处理oom问题 java Android加载机制 Android加载动态库 AndroidManifest权限是怎么获取的，封装权限管理，为什么需要权限分组. listview图片 缓存，listview怎么优化 viewpager listview处理滑动冲突 list遍历删除 fragment tag sercice ALDL (后面再弄) Hashmap实现原理 实现有序 android事件分发机制，请详细说下整个流程 android四大组件的加载过程 提高sqlite的查询效率 冒泡排序，插入排序 Android源码相关分析Handler机制和底层实现​ https://noteforme.github.io/2017/08/21/Handler/ RecycleView​ https://noteforme.github.io/2017/07/17/RecyclerView/ Binder通信原理与机制https://blog.csdn.net/Android_SE/article/details/103898581 https://www.bilibili.com/video/BV1Ko4y117Ca?p=74 JetPackhttps://noteforme.github.io/categories/Jetpack/ Android各个版本API的区别 描述一次网络请求的流程 Bitmap对象的理解 ActivityThread，AMS，WMS的工作原理 SpareArray原理 AndroidService与Activity之间通信的几种方式 IntentService原理及作用是什么？ 说说Activity、Intent、Service 是什么关系 ApplicationContext和ActivityContext的区别 SP是进程同步的吗?有什么方法做到同步？ 谈谈多线程在Android中的使用 进程和 Application 的生命周期 AsyncTask机制 AsyncTask原理及不足 AndroidManifest的作用与理解 性能优化https://noteforme.github.io/2017/08/16/PerformancePatterns/ https://noteforme.github.io/2018/02/09/LeakMemory/ ANR产生的原因是什么？ ANR定位和修正 oom是什么？ 什么情况导致oom？ 有什么解决方法可以避免OOM？ Oom 是否可以try catch？为什么？ 内存泄漏是什么？ 什么情况导致内存泄漏？ 如何防止线程的内存泄漏？ 内存泄露场的解决方法 内存泄漏和内存溢出区别？ LruCache默认缓存大小 如何通过广播拦截和abort一条短信？ 广播引起anr的时间限制是多少？ 计算一个view的嵌套层级 Activity栈 Android线程有没有上限？ 线程池有没有上限？ Android为什么引入Parcelable？ 有没有尝试简化Parcelable的使用？ （四）开发中常见的一些问题 屏幕适配的处理技巧都有哪些? 服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？ 动态布局的理解 怎么去除重复代码？ 画出 Android 的大体架构图 Recycleview和ListView的区别 ListView图片加载错乱的原理和解决方案 动态权限适配方案，权限组的概念 Android系统为什么会设计ContentProvider？ 下拉状态栏是不是影响activity的生命周期 如果在onStop的时候做了网络请求，onResume的时候怎么恢复？ Bitmap 使用时候注意什么？ Bitmap的recycler() ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？ 点击事件被拦截，但是想传到下面的View，如何操作？ 微信上消息小红点的原理 CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: CAS简介） https://github.com/android-exchange/Android-Interview Kotin面试题 http://www.youkmi.cn/2019/10/27/kotlin-ti-mu-zheng-li/ https://www.jianshu.com/p/45866c8415c8 怎么看源码 https://www.bilibili.com/video/BV1d54y1h768 面经 https://blog.csdn.net/sjy0118/article/details/112759112 https://www.kaelli.com/43.html https://www.jianshu.com/p/058c54948ca5 https://juejin.cn/post/6888222422760488974#heading-51 https://github.com/Omooo/Android_QA","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"INTEVIEW-ALGORITHEM","slug":"inteview-algorithem","date":"2024-05-22T06:46:53.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/05/22/inteview-algorithem/","link":"","permalink":"https://noteforme.github.io/2024/05/22/inteview-algorithem/","excerpt":"","text":"算法排序算法有哪些？冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序 https://zhuanlan.zhihu.com/p/42586566 最快的排序算法是哪个？快速排序 最好情况O(nlogn) 最坏情况 O(n^2) 为什么不是堆排序 ? 在堆排序（小根堆）的时候，每次总是将最小的元素移除，然后将最后的元素放到堆顶，再让其自我调整。这样一来，有很多比较将是被浪费的，因为被拿到堆顶的那个元素几乎肯定是很大的，而靠近堆顶的元素又几乎肯定是很小的，最后一个元素能留在堆顶的可能性微乎其微，最后一个元素很有可能最终再被移动到底部。在堆排序里面有大量这种近乎无效的比较。随着数据规模的增长，比较的开销最差情况应该在（线性*对数）级别，如果数据量是原来的10倍，那么用于比较的时间开销可能是原来的10log10倍原文链接：https://blog.csdn.net/qq_36770641&#x2F;article&#x2F;details&#x2F;82669788 手写一个冒泡排序 手写快速排序代码 快速排序的过程、时间复杂度、空间复杂度 手写堆排序 堆排序过程、时间复杂度及空间复杂度 写出你所知道的排序算法及时空复杂度，稳定性 https://noteforme.github.io/2021/03/21/Data-Sort/ 二叉树给出根节点和目标节点，找出从根节点到目标节点的路径 给阿里2万多名员工按年龄排序应该选择哪个算法？ GC算法(各种算法的优缺点以及应用场景) 蚁群算法与蒙特卡洛算法 子串包含问题(KMP 算法)写代码实现 一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法 万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射-&gt;hash分组-&gt;多文件读写效率-&gt;磁盘寻址以及应用层面对寻址的优化) 百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。 两个不重复的数组集合中，求共同的元素。 两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？ 一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法 一张Bitmap所占内存以及内存占用的计算 2000万个整数，找出第五十大的数字？ 烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？ 求1000以内的水仙花数以及40亿以内的水仙花数 5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同 时针走一圈，时针分针重合几次 N*N的方格纸,里面有多少个正方形 x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？用过哪些数据结构 常用数据结构 有哪些数据结构 增删改查的复杂度多少 计算二叉树的高度（递归与非递归两种方式） 快排写一下，动态规划了解吗？ 冒泡排序的链表实现 写个快排 都用过那些常用的数据结构，说说对树的了解？ 堆排 算法题 判断二叉树深度. 2 算法的五大基本要素有哪些？为什么算法效率不是基本要素 银行家算法 堆排序原理 b树、b+树、红黑树 红黑树怎么增加、删除节点 算法题：随机生成不重复的100个数0-99 写一个泛型方法，实现删除数组中的元素功能 返回二叉树的第k大数 返回第k大的数，先说下你能想到的方法，再选一个最优方法。 二分法查找目标数 使用一个固定长度数组实现队列，包括添加和取数据的功能 时间复杂度、空间复杂度，如何优化 链表如何优化，可以降低查询的时间复杂度？ 手撕：手写一个单例模式 手撕：二叉搜索树第 k 小的节点 算法：合并区间 算法：排序数组 算法：序列化和反序列化二叉搜索树 equals和hashCode方法 手撕快速排序 讲一个红黑树和一个排序算法的时间复杂度问题的分析思路 二叉查找树的概念 树退化成链表如何解决？ B树以及B树可以解决什么问题？ 图的遍历以及具体代码如何实现？（迭代） 时间复杂度和空间复杂度的概念 常见的排序算法以及时间复杂度 链表的反转怎么实现？ 讲一下排序算法的思路 最后是华为经典题，一个桶5L，另一个桶7L，如何得到6L？（答出来了）面试官立马追问，有没有一种数学理论可以给这个问题提供支持来证明，1L，2L，3L，4L，6L是不是都可以得到还是只能得到其中的某几种？（到这里，我是真的麻了，考这种题真的无从准备，面试官是啥问题都能深挖深挖再深挖）（最后一题有知道的同学可以评论区留言 快排的思想 快排解决topk问题（我哭死啊，我没有想到当前的会使用快排来进行解决topk，我之前都是使用堆排序） 快排和堆排来进行解决topk问题 反转链表 合并两个排序的链表 算法题：给你一个数组，和一个数字m，问这个数组中存不存在一个子序列（不一定连续），使得它的和为m，输出true或false 两个算法（判断链表是否有环、链表重排&#x2F;链表折叠） 反转字符串 上楼梯动态规划，如果第M阶梯是不能踩的 倒水问题，3l和5l桶子要4l水怎么搞算法思路，链表右移动k位和数组右移动k位怎么搞左右括号匹配，最少情况要加多少次括号，写在纸上拍照 树、图的存储结构 给出二叉树的前序中序，输出后序 先来了一道算法题:找出最左边的次数最多的字母。 算法题：删除排序链表中的重复元素（力扣82） 快排和反转链表 判断一个树是不是平衡二叉树， 旋转链表 LC61:题意是这样子的：给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。输入：head&#x3D;[1,2,3] k &#x3D; 1输出：[3,1,2] 22.算法题：二分法查找目标数","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"INTERVIEW-LIABARY","slug":"interview-library","date":"2024-05-22T06:39:05.000Z","updated":"2024-09-15T10:06:57.580Z","comments":true,"path":"/2024/05/22/interview/","link":"","permalink":"https://noteforme.github.io/2024/05/22/interview/","excerpt":"","text":"https://github.com/pengMaster/BestNote/blob/master/docs/android/Android-Interview/Android/Android%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%9510%E5%A4%A7%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md https://www.youtube.com/watch?v=pUV3qZh481k okhttphttps://jonblog.site/2024/05/11/okhttp/ https://www.51cto.com/article/689330.html OKHttp 请求的整体流程是怎样的? OKHttp 分发器是怎样工作的? OKHttp 拦截器是如何工作的? 应用拦截器和网络拦截器有什么区别? OKHttp 如何复用 TCP 连接? OKHttp 空闲连接如何清除? OKHttp 有哪些优点? OKHttp 框架中用到了哪些设计模式? okhttp怎么支持http2.0 配置合适的适配器，解析json数据。 Android 如何编写基于编译时注解的项目 编译时注解与运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？ 在项目中有直接使用tcp,socket来发送消息吗 https://www.bilibili.com/video/BV1ib4y1f7S1 okhttp怎么支持http2.0 Handshake则会把服务端支持的Tls版本，加密方式等都带回来，然后会把这个没有验证过的HandShake用X509Certificate去验证证书的有效性。然后会通过Platform去从SSLSocket去获取ALPN的协议支持信息，当后端支持的协议内包含Http2.0时，则就会把请求升级到Http2.0阶段。 配置合适的适配器，解析json数据。 Android 如何编写基于编译时注解的项目 编译时注解与运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？ https://www.bilibili.com/video/BV1ib4y1f7S1 Okhttp缓存机制 网络请求缓存处理，okhttp如何处理网络缓存的 自己去设计网络请求框架，怎么做？ HTTP Network 从网络加载一个10M的图片，说下注意事项 TCP的3次握手和四次挥手 TCP与UDP的区别 TCP与UDP的应用 HTTP协议 HTTP1.0与2.0的区别 HTTP报文结构 HTTP与HTTPS的区别以及如何实现安全性 如何验证证书的合法性? https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解? client如何确定自己发送的消息被server收到? 谈谈你对安卓签名的理解。 请解释安卓为啥要加签名机制? 视频加密传输 App 是如何沙箱化，为什么要这么做？ 权限管理系统（底层的权限是如何进行 grant 的）？ 从网络加载一个10M的图片，说下注意事项 TCP的3次握手和四次挥手 TCP与UDP的区别 TCP与UDP的应用 HTTP协议 HTTP1.0与2.0的区别 HTTP报文结构 HTTP与HTTPS的区别以及如何实现安全性 如何验证证书的合法性? https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解? client如何确定自己发送的消息被server收到? 谈谈你对安卓签名的理解。 请解释安卓为啥要加签名机制? 视频加密传输 App 是如何沙箱化，为什么要这么做？ 权限管理系统（底层的权限是如何进行 grant 的）？ okio1.简介； 1.sink：自己–》别人 2.source：别人–》自己 3.BufferSink：有缓存区域的sink 4.BufferSource：有缓存区域的source 5.Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行 2.比java io的好处： 1.减少内存申请和数据拷贝 2.类少，功能齐全，开发效率高 3.内部实现： 1.Buffer的Segment双向链表，减少数据拷贝 2.Segment的内部byte数组的共享，减少数据拷贝 3.SegmentPool的共享和回收Segment 4.sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source 5.最终okio只是对java io的封装，所有操作都是基于java io 的 写在最后:能看到这里的人,我挺佩服你的.这篇文章是我在头条面试之前整理的,最后**80%**的题目都命中了,所以祝你好运. 不贩卖焦虑，也不标题党。分享一些这个世界上有意思的事情。题材包括且不限于：科幻、科学、科技、互联网、程序员、计算机编程。下面是我的微信公众号：世界上有意思的事，干货多多等你来看。 作者：何时夕 链接：https://www.jianshu.com/p/cf5092fa2694来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Retrofit在retrofit中的泛型是怎么解析的 https://noteforme.github.io/2017/09/23/Retrofit/ coroutine 面试kotlin协程有没有了解过。（协程是kotlin 语言对线程的封装）协程实现原理协程的理解协程相对于线程的区别协程Flow有哪些应用场景？进程、线程、协程的联系与区别你了解协程吗？协程有什么作用？可以完全取代rxjava吗？ 高端技术面试题 这里讲的是大公司需要用到的一些高端Android技术，这里专门整理了一个文档，希望大家都可以看看。这些题目有点技术含量，需要好点时间去研究一下的。 Glidehttps://jonblog.site/2024/06/18/glide/ RxJavahttps://noteforme.github.io/2020/08/04/RxJava/ 在 RxJava 中， 会遇到被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息，这就是典型的背压（ Back Pressure ）场景。 RxJava 是基于 Push 模型 。对于 Pull 模型而言，当消费者请求数据的时候，如果生产者比较慢 ，则消费者会阻塞等待。如果生产者比较快，生产者会等待消费者处理完后再生产新的数据，所以不会出现背压的情况。然而在 RxJava 中，只要生产者数据准备好了就会发射出去。如果生产者比较慢，则消费者会等待新的数据到来。如果生产者比较快，则会有很多数据发射给消费者，而不管消费者当前有没有能力处理数据，这样就会导致背压。 在 RxJava 2.x 中， Observable 不再支持背压，而是改用 Flowable 来专门支持背压。默认队列大小为 128 ，并且要求所有的操作符强制支持背压。 RxJava原理及如何封装使用​ 使用观察者模式，和装饰器模式。 ​ 先用Observablex向右构建流，然后向左创建订阅流，最后时间通过观察者回调流发送。 ​ ​ 你了解协程吗？协程有什么作用？可以完全取代rxjava吗？ rxjava里面用了大量的&lt;? super T&gt;这些，是什么意思。 如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends) 如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super),只能用Object接收。 如果既要存又要取，那么就不要使用任何通配符。 https://www.jianshu.com/p/86cf908afcb6 RxJava怎么通过被订阅者传给订阅者的过程是什么样的?Observer处理完onComplete后会还能onNext吗?​ onComplete是用来控制不能发送数据的，也就是不能onNext了，包括onError也是不能再发送onNext数据了，该方法中也是调用了 dispose方法。 RxJava中map、flatMap的区别，你还用过其他哪些操作符?​ map是通过原始数据类型返回另外一种数据类型，而flatMap是通过原始数据类型返回另外一种被观察者。 Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？​ 如果只想发一条数据，或者不发数据就用Maybe，如果想发多条数据或者不发数据就用Observable，如果只发一条数据或者失败就用Single，如果想用背压策略使用Flowable，如果不发数据就用Completable 也就是说Maybe可能不发送数据，如果发送数据只会发送单条数据。 single也是发送单条数据，但是它要么成功要么失败。 RxJava切换线程是怎么回事?subscribeOn实际是创建了ObservableSubscribeOn的Observable，它的订阅方法里面创建了SubscribeOnObserver，通过线程池执行Runnable，使上游Observable的订阅在子线程中执行，这就是为什么subscribeOn能控制observable在哪个线程中执行的原因 RxJava的subscribeOn只有第一次生效?subscribeOn对subscribe订阅进行处理，针对是订阅流，从后向前流动，所以最前面的一次生效。 subscribeOn是规定上游的observable在哪个线程中执行，如果我们执行多次的subscribeOn的话，从下游的observer到上游的observable的订阅过程，最开始调用的subscribeOn返回的observable会把后面执行的subscribeOn返回的observable给覆盖了，因此我们感官的是只有第一次的subscribeOn能生效。 RxJava的observeOn多次调用哪个有效?observeOn在事件发送的 onNext(T t)进行处理，针对的是观察者流，从前向后流动，所以最后一次生效。 observeOn是指定下游的observer在哪个线程中执行，所以这个更好理解，看observeOn下一个observer是哪一个，所以多次调用observeOn肯定是最后一个observeOn控制有效。 https://juejin.cn/post/6900870262062120967 https://zhuanlan.zhihu.com/p/339620311 RxJava中背压是怎么回事？ https://www.jianshu.com/p/c3965e82b164 https://zhuanlan.zhihu.com/p/322405376 https://www.bilibili.com/video/BV1Af4y187b8 数据库 sqlite升级，增加字段的语句 数据库框架对比和源码分析 数据库的优化 数据库数据迁移问题 插件化、模块化、组件化、热修复、增量更新、Gradle 对热修复和插件化的理解 插件化原理分析 模块化实现（好处，原因） 热修复,插件化 项目组件化的理解 描述清点击 Android Studio 的 build 按钮后发生了什么 架构设计和设计模式​ https://noteforme.github.io/categories/DesignPatterns/ 设计原则​ 单一职责 ​ 一个类应该只负责一项职责。 接口隔离 ​ 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 依赖倒置 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 依赖倒置的中心思想是面向接口编程。 里氏替换 所有使用基类的地方必须能透明的使用其子类。 使用继承时，遵循里氏替换原则，子类尽量不要重写父类的方法。继承实际上让两个类耦合性增强了，适当情况下可以通过 聚合 组合 依赖来解决问题。 ​ 通用做法是： 原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。 开闭原则 ocp 迪米特法则 ​ 一个对象应该对其他对象保持最少的了解 设计模式 谈谈你对Android设计模式的理解 MVC MVP MVVM原理和区别 你所知道的设计模式有哪些？ 项目中常用的设计模式 手写生产者&#x2F;消费者模式 写出观察者模式的代码 适配器模式，装饰者模式，外观模式的异同？ 用到的一些开源框架，介绍一个看过源码的，内部实现过程。 谈谈对RxJava的理解 RxJava的功能与原理实现 RxJava的作用，与平时使用的异步操作来比的优缺点 说说EventBus作用，实现方式，代替EventBus的方式 从0设计一款App整体架构，如何去做？ 说一款你认为当前比较火的应用并设计(比如：直播APP，P2P金融，小视频等) 谈谈对java状态机理解 Fragment如果在Adapter中使用应该如何解耦？ Binder机制及底层实现 对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？ 实现一个Json解析器(可以通过正则提高速度) 统计启动时长,标准 性能优化 如何对Android 应用进行性能分析以及优化? ddms 和 traceView 性能优化如何分析systrace？ 用IDE如何分析内存泄漏？ Java多线程引发的性能问题，怎么解决？ 启动页白屏及黑屏解决？ 启动太慢怎么解决？ 怎么保证应用启动不卡顿？ App启动崩溃异常捕捉 自定义View注意事项 现在下载速度很慢,试从网络协议的角度分析原因,并优化(提示：网络的5层都可以涉及)。 Https请求慢的解决办法（提示：DNS，携带数据，直接访问IP） 如何保持应用的稳定性 RecyclerView和ListView的性能对比 ListView的优化 RecycleView优化 View渲染 Bitmap如何处理大图，如一张30M的大图，如何预防OOM java中的四种引用的区别以及使用场景 强引用置为null，会不会被回收？ NDK、jni、Binder、AIDL、进程通信有关 请介绍一下NDK 什么是NDK库? jni用过吗？ 如何在jni中注册native函数，有几种注册方式? Java如何调用c、c++语言？ jni如何调用java层代码？ 进程间通信的方式？ Binder机制 简述IPC？ 什么是AIDL？ AIDL解决了什么问题？ AIDL如何使用？ Android 上的 Inter-Process-Communication 跨进程通信时如何工作的？ 多进程场景遇见过么？ Android进程分类？ 进程和 Application 的生命周期？ 进程调度 谈谈对进程共享和线程安全的认识 谈谈对多进程开发的理解以及多进程应用场景 什么是协程？ framework层、ROM定制、Ubuntu、Linux之类的问题 java虚拟机的特性 谈谈对jvm的理解 JVM内存区域，开线程影响哪块内存 对Dalvik、ART虚拟机有什么了解？ Art和Dalvik对比 虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派) 谈谈你对双亲委派模型理解 JVM内存模型，内存区域 类加载机制 谈谈对ClassLoader(类加载器)的理解 谈谈对动态加载（OSGI）的理解 内存对象的循环引用及避免 内存回收机制、GC回收策略、GC原理时机以及GC对象 垃圾回收机制与调用System.gc()区别 系统启动流程是什么？（提示：Zygote进程 –&gt; SystemServer进程 –&gt; 各种系统服务 –&gt; 应用进程） 大体说清一个应用程序安装到手机上时发生了什么 简述Activity启动全部过程 App启动流程，从点击桌面开始 Android中进程内存的分配，能不能自己分配定额内存？ 如何保证一个后台服务不被杀死？（相同问题：如何保证service在后台不被kill？）比较省电的方式是什么？ App中唤醒其他进程的实现方式 ​ https://www.jianshu.com/p/c3965e82b164 ​ https://www.cnblogs.com/deman/p/5860976.html#_label29 AMS是如何启动的？ AMS在Android起到什么作用？ AMS有哪些应用场景？我们是如何应用AMS核心原理的？ WMS的工作原理说说？ JVM的核心原理你懂多少？ 我们的代码是如何在栈区中运行的？ **如何使用字节码研究系统级原理？ 大佬面试经验 https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Android/","categories":[{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"}],"tags":[],"author":"Jon"},{"title":"GIT","slug":"git","date":"2024-05-21T09:30:32.000Z","updated":"2025-02-22T04:38:48.976Z","comments":true,"path":"/2024/05/21/git/","link":"","permalink":"https://noteforme.github.io/2024/05/21/git/","excerpt":"","text":"官方文档https://git-scm.com/book/en/v2http://iissnan.com/progit/ Git基本操作github上传项目 分支创建 123git branch Dev1.10 git push origin Dev1.10 // 提交该分支到远程仓库git pull origin dev //从远程获取分支 下面是对已有项目的提交 12git remote add origin git@gitee.com:huaiyi/EffectiveJava.gitgit push -u origin master 分支提交到远程仓库$ git push origin v1.0.0 commit Git撤销git commit 但是未git push的修改 找到上次git commit的 id git log 找到你想撤销的commit_id git reset –hard commit_id 完成撤销,同时将代码恢复到前一commit_id 对应的版本。 git reset commit_id 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改。 git分支简介http://blog.csdn.net/hyr83960944/article/details/36185231 合并分支合并hotfix到dev 12$ git checkout // 先切换到dev $ git merge hotfix 合并分支 远程分支获取本地没有的远程分支1git branch -r #查看远程分支 或 git branch -a #查看所有分支 会显示 123origin/HEAD -&gt; origin/masterorigin/daily/1.2.2origin/master 然后直接 123git checkout -b &lt;local-branch-name&gt; origin/&lt;remote-branch-name&gt; 显示远程仓库 $ git remote show origin 1. 本地分支重命名(还没有推送到远程) 1git branch -m oldName newName 2. 远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同) a. 重命名远程分支对应的本地分支 1git branch -m oldName newName c. 删除本地分支 ` git branch -d v1.0.0 ` 删除远程分支1git push --delete origin oldName 远程仓库更新到本地12$ git fetch origin$ git merge origin/hexo 或者合并 1$ git pull origin hexo http://www.ruanyifeng.com/blog/2014/06/git_remote.html 修改远程仓库地址 github创建 New项目，项目地址是 &#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#111;&#109;:BlogForMe&#x2F;News.git 修改远程服务器地址 ：git remote set-url origin git@github.com:BlogForMe/News.git 推送到远程服务器 : git push origin http://jcpplus.github.io/2015/07/23/modify-remote-url/ fork后的项目处理get fork后分支的tag123456789git remote add upstream git@github.com:square/okhttp.gitgit fetch upstream --tags//Verify that the tags are fetched:git tag//will show [new tag] parent-4.9.0 -&gt; parent-4.9.0git push origin --tagsgit checkout tags/parent-4.12.0 https://gaohaoyang.github.io/2015/04/12/Syncing-a-fork/ https://blog.csdn.net/sdujava2011/article/details/138312278 merge the src directoryAssume you want to merge the android-test-app directory from master into parent-4.12.0-study. 12345678okhttp_dump % git branch main master* parent-4.12.0-studyokhttp_dump % git checkout parent-4.12.0-studyokhttp_dump % git checkout master android-test-appokhttp_dump % git add android-test-appokhttp_dump % git commit -m &quot;Merged src directory from feature-branch&quot; 忽略文件已提交的文件 对于单个文件处理 假如要忽略 .idea&#x2F;misc.xml文件，.gitignore可以添加 /.idea/* 把.idea文件过滤 主要是 git rm --cached .idea/misc.xml 然后提交修改,每次手输入才有用? 对文件夹的处理,比如common-bankcard 12git rm -r --cached common-bankcardgit rm --cached *idea/* 修复已发布版本bug修复bug主要以下几步: 使用git reset –hard 命令退回到发布标签对应的版本 使用git checkout -b BugFix新建一个BugFix的分支，原分支前进到最新提交版本 使用git checkout BugFix切换到BugFix分支，修改bug，重新发布并使用git tag打标签 git reaset –hard 切换主干最新的分支 使用git merge合并BugFix分支到主分支 参考:https://blog.masterliu.net/git-retag/ 标签是一个文件快照，并不是真拉出一份代码放在了那里 12D:\\Project\\ASProjects\\cqianjia&gt;git tagv1.0.2 参考: http://gepeiyu.com/2017/06/28/git-tag-oldversion-debug/ 还有一种情况是在最新提交版本修复bug git stash https://www.jianshu.com/p/54b8ea4317cc https://qiita.com/hudichao/items/d665cd769ed1d2ce832a Git仓库迁移 迁移git仓库 原来托管于github,clone一份裸版本库 git clone --bare git@gitee.com:huaiyi/CQJ.git 在新的版本库(gitlab)里面创建一个新的项目，例如 cqianjia 推送刚才clone的镜像到gitlab服务器 12cd CQJ.git/git push --mirror git@45.77.22.97:root/cqianjia.git mirror 克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步 删除本地代码 12cd ..rm -rf project.git 到新的服务器clone到本地就Ok了 git clone git@45.77.22.97:root/cqianjia.git 参考: https://my.oschina.net/kind790/blog/510601 git clone 所有分支 这种方式有一个弊端，切换分支后 工程名没了， 还是慢慢摸索吧 ! 123git branch -r | grep -v &#x27;\\-&gt;&#x27; | while read remote; do git branch --track &quot;$&#123;remote#origin/&#125;&quot; &quot;$remote&quot;; donegit fetch --allgit pull --all 参考: http://blog.csdn.net/allangold/article/details/78028709 GIT标签 查看所有的版本​ git tag 查看远程分支 git ls-remote --tags 创建标签 git tag -a v1.0.2 -m &quot;my version 1.0.2&quot; -m 选项指定了一条将会存储在标签中的信息 创建Tag 123git tag -a v1.0.0 -m &quot;my version 1.0.0&quot;git push origin v1.0.0 //推送到远程分支git push origin --tags //推送所有的标签 删除tag 123456 git tag -d &lt;tagname&gt; git push origin :refs/tags/&lt;tagname&gt;例如 git push origin :refs/tags/v1.0.2 git tag -d v1.0.2 检出标签 检出标签 Checkout Git Tagshttps://devconnected.com/how-to-checkout-git-tags/ 1234git fetch --all --tagsgit checkout tags/v1.0 -b v1.0-branch //git checkout tags/v2.1.1 -b v2.1.1-branch v1.0代表tag名称git log --oneline --graph //You can inspect the state of your branch by using the “git log” command. Make sure that the HEAD pointer (the latest commit) is pointing to your annotated tag. checkout remote tag12345678git fetch --all --tagsgit ls-remote --tags refs/tags/v2.5.9 refs/tags/v2.5.9^&#123;&#125;git checkout refs/tags/v2.5.9 -b v2.5.9-branch //-b 后面是自定义的分支名称 这个自定义 在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支： $ git checkout -b version2 v2.0.0 Switched to a new branch ‘version2’ 当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。 修复已发布版本\bBughttp://gepeiyu.com/2017/06/28/git-tag-oldversion-debug/ git stash经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。 git stash save &#39;暂存备注信息&#39; &#x2F;&#x2F;进入暂存状态,此时执行 git status 已经没有要提交的了 git checkout 切换到要修改的分支上 ,修改完 完成后回到原来的开发分支上，git stash apply 获取最近暂存内容 git stash drop stash@&#123;1&#125; apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 git stash drop，加上你希望移除的储藏的名字： git stash 可以进行多次暂存,多次存后 git stash list长下面这样,可以用 · git stash apply stash@{1}· 获取某次暂存的内容 stash@{0}: WIP on dev: 3d01a6c Patient Entity数据库删除stash@{1}: WIP on dev: b6a688e 跑起来提交 取消储藏 git stash show -p stash@&#123;0&#125; | git apply -R 如果没指定具体的标签 取消最近的 这个和git stash drop的区别是 取消的是文件内容，stash标签还在 https://git-scm.com/docs/git-stash 注意是 stash@{0} 不是 3d01a6c git branch 分支名 hash(历史版本) update forked project https://blog.csdn.net/qq1332479771/article/details/56087333 获取暂存 git stash apply stash@{0} &#x2F;&#x2F; don‘t remove stash git stash pop stash@{0} SVN SVN不能添加文件:https://blog.csdn.net/yujiayinshi/article/details/51381942 github提速www.github.com 替换为 www.github.com.cnpmjs.org https://github.com/flutter/flutter.git git clone https://github.com.cnpmjs.org/love-flutter/flutter-column.git git pull git fetch区别git fetch更新本地仓库的两种用法： 1234# 方法一$ git fetch origin master #从远程的origin仓库的master分支下载代码到本地的origin maste$ git log -p master.. origin/master #比较本地的仓库和远程参考的区别$ git merge origin/master #把远程下载下来的代码合并到本地仓库，远程的和本地的合并 12345# 方法二$ git fetch origin master:temp #从远程的origin仓库的master分支下载到本地并新建一个分支temp$ git diff temp #比较master分支和temp分支的不同$ git merge temp #合并temp分支到master分支$ git branch -d temp #删除temp 这样理解 pull &#x3D; fetch + merge https://segmentfault.com/a/1190000017030384 https://www.jianshu.com/p/d265f7763a3a https://blog.csdn.net/riddle1981/article/details/74938111 https://www.cpweb.top/455 master revert 今天将一段代码合入了master，上线的时候有问题，而不能很快解决掉，为了不影响其他同事合入master或将有问题的commit带上线，因此我将我的commit revert掉了。 同时，当天晚上的时候有同事刚好问我git revert后自己代码消失的问题，当时思考不清晰，也比较少用revert，因此现在来复盘下。 commit提交流程示意图如下： 其中A是有问题的commit，R是revert的commit，M是master，序号N代表master的流向, 从master checkout分支 F-A ,提交了TestA文件 从master checkout分支 UP-R,提交了TESTB, TestR 分别吧F-A , UP-R分支合并到master. 此时觉得F-A代码有问题，需要修改，master对F-A进行revert ,此时 master的F-A 分支TesA被删除了,并且有一条提交记录 从master checkout得到分支verify-b,然后将之前需要会退的提交 , 再进行 git revert commit,然后push (这个方式没想明白) 把master合并到verify-b就能解决这个问题. https://blog.csdn.net/oYiMiYangGuang123/article/details/99437382 上面的步骤还是没想明白. 主要 git reset不能解决，有问题.除非强制push。 删除一条历史记录git revert 纪录 Git force push git rebase -i 7158b278b8f47f9b46f9af2207996bce783c0b57 这篇blog介绍的，但是没起作用。 https://linuxhint.com/remove-commit-from-history-git/ 查看日志 git log –author zh –since&#x3D;2022-12-10 git ssh原理http://skypegnu1.blog.51cto.com/8991766/1641064 多平台配置SSH正常情况会哟几个平台的配置情况,ssh操作方式 用户信息设置在config后加上 –global 即可全局设置用户名和邮箱，否则就是局部的。有时候用手输入才有用 $ git config –global user.name “John Doe” $ git config –global user.email &#x6a;&#111;&#x68;&#x6e;&#x64;&#x6f;&#101;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d; 检查配置信息 git config --list 生成sshkey如果视其他平台生成时就要修改名称了 ssh-keygen -t rsa -b 4096 -C “&#x79;&#111;&#117;&#114;&#x5f;&#101;&#109;&#97;&#105;&#108;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109;“Enter file in which to save the key (&#x2F;home&#x2F;jon&#x2F;.ssh&#x2F;id_rsa): &#x2F;home&#x2F;jon&#x2F;.ssh&#x2F;id_rsa.Oschinacat ~&#x2F;.ssh&#x2F;id_rsa.li | clip Adding your SSH key to the ssh-agent start the ssh-agent in the background $ eval $(ssh-agent -s) Agent pid 59566 $ ssh-add ~/.ssh/id_rsa.li gitbash下把生成的id_rsa.pub 添加到sshkey oschina 测试连接：$ ssh -T git@git.oschina.net github 测试连接: $ ssh -T git@github.com如果出现: Hi username! You’ve successfully authenticated, but GitHub does not provide shell access. 配置成功 不同平台 不同的rsa.key 我前面的key重新命名，clone项目还是有问题 解决方法: 在 .ssh目录下 新建config文件 添加 Host github HostName github.com User Jon IdentityFile ~&#x2F;.ssh&#x2F;id_rsa.li 不同的平台，相同的rsa.key (推荐)复制id_rsa.pub填入 clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub 参考：github生成方式https://help.github.com/articles/about-ssh/ gitlab生成方式https://gitlab.com/help/ssh/README oschina方式:http://git.mydoc.io/?t=154712 gogs:参考github,配置sskey后还需要用账号登陆 问题 类似下面错误使用 git push -u origin master git push -f origin master ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to ‘https://github.com/aniruddhabarapatre/learn-rails.git‘hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushing 参考：https://stackoverflow.com/questions/20939648/issue-pushing-new-code-in-github 生成key时，我改成了 id_rsaOschinaandroid studio 最后push 时authentication id_rsaOschina using key failed报错方法: AndroidStudio -&gt; File -&gt; Settings -&gt;Git -&gt; SSH executable : built-in 改成Native 参考:https://stackoverflow.com/questions/24688700/android-studio-push-failed-fatal-could-not-read-from-remote-repository GitHub CLI 配置 在windows平台 git auth login 授权 要用windows命令行工具。 Mac使用ssh密钥登录Linux - 简书","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[],"author":"Jon"},{"title":"LIFE-Equipment ear","slug":"LIFE-equipment","date":"2024-05-20T01:57:34.000Z","updated":"2024-09-15T12:50:56.408Z","comments":true,"path":"/2024/05/20/equipment/","link":"","permalink":"https://noteforme.github.io/2024/05/20/equipment/","excerpt":"","text":"domain","categories":[{"name":"LIFE","slug":"LIFE","permalink":"https://noteforme.github.io/categories/LIFE/"}],"tags":[],"author":"Jon"},{"title":"http_ca","slug":"https_ca","date":"2024-05-15T07:08:40.000Z","updated":"2025-03-25T14:12:07.548Z","comments":true,"path":"2024/05/15/https_ca/","link":"","permalink":"https://noteforme.github.io/2024/05/15/https_ca/","excerpt":"","text":"Posthttps://jsonplaceholder.typicode.com/posts request 12345:method: POST:path: /posts:authority: jsonplaceholder.typicode.com:scheme: httpscontent-type: application/x-www-form-urlencodedcontent-length: 42accept-encoding: gzipuser-agent: okhttp/5.0.0-SNAPSHOT response 1234567891011121314151617:status: 201date: Wed, 17 Apr 2024 06:45:30 GMTcontent-type: application/json; charset=utf-8content-length: 82location: https://jsonplaceholder.typicode.com/posts/101report-to: &#123;&quot;group&quot;:&quot;heroku-nel&quot;,&quot;max_age&quot;:3600,&quot;endpoints&quot;:[&#123;&quot;url&quot;:&quot;https://nel.heroku.com/reports?ts=1713336330&amp;sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&amp;s=Hua%2F7slOIpUhGTDPNaKu4xbP%2Bjuwplp9ehOh7C014ok%3D&quot;&#125;]&#125;reporting-endpoints: heroku-nel=https://nel.heroku.com/reports?ts=1713336330&amp;sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&amp;s=Hua%2F7slOIpUhGTDPNaKu4xbP%2Bjuwplp9ehOh7C014ok%3Dnel: &#123;&quot;report_to&quot;:&quot;heroku-nel&quot;,&quot;max_age&quot;:3600,&quot;success_fraction&quot;:0.005,&quot;failure_fraction&quot;:0.05,&quot;response_headers&quot;:[&quot;Via&quot;]&#125;x-powered-by: Expressx-ratelimit-limit: 1000x-ratelimit-remaining: 999x-ratelimit-reset: 1713336348vary: Origin, X-HTTP-Method-Override, Accept-Encodingaccess-control-allow-credentials: truecache-control: no-cachepragma: no-cacheexpires: -1access-control-expose-headers: Locationx-content-type-options: nosniffetag: W/&quot;52-HKy3Gu5DcI5r2jj3f8TQwnYvlDs&quot;via: 1.1 vegurcf-cache-status: DYNAMICserver: cloudflarecf-ray: 875a73ddee780484-HKGalt-svc: h3=&quot;:443&quot;; ma=86400 GEThttps://api.github.com/repos/square/okhttp/contributors Request 1234:method: GET:path: /repos/square/okhttp/contributors:authority: api.github.com:scheme: httpsaccept-encoding: gzipuser-agent: okhttp/5.0.0-SNAPSHOT Response 12345678910111213141516:status: 200server: GitHub.comdate: Wed, 17 Apr 2024 06:58:41 GMTcontent-type: application/json; charset=utf-8cache-control: public, max-age=60, s-maxage=60vary: Accept, Accept-Encoding, Accept, X-Requested-Withetag: W/&quot;699b092aa0b0980f1b2f2bde5e810a75c5c1921ee2f53c4d9f28fc8ea5fca327&quot;last-modified: Wed, 17 Apr 2024 02:18:24 GMTx-github-media-type: github.v3; format=jsonlink: &lt;https://api.github.com/repositories/5152285/contributors?page=2&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/repositories/5152285/contributors?page=9&gt;; rel=&quot;last&quot;x-github-api-version-selected: 2022-11-28access-control-expose-headers: ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunsetaccess-control-allow-origin: *strict-transport-security: max-age=31536000; includeSubdomains; preloadx-frame-options: denyx-content-type-options: nosniffx-xss-protection: 0referrer-policy: origin-when-cross-origin, strict-origin-when-cross-origincontent-security-policy: default-src &#x27;none&#x27;content-encoding: gzipx-ratelimit-limit: 60x-ratelimit-remaining: 55x-ratelimit-reset: 1713337679x-ratelimit-resource: corex-ratelimit-used: 5accept-ranges: bytesx-github-request-id: 200C:21C6BE:267A047:2720F58:661F7320 Key Points Deprecation of TLS 1.0 and 1.1:Android 10 disables TLS 1.0 and TLS 1.1 by default due to known vulnerabilities in these older protocols. Enhanced Security:By requiring TLS 1.2 or newer, Android 10 and later versions improve the security of network communications. Developer Implications:Apps that rely on legacy servers supporting only TLS 1.0 or TLS 1.1 may encounter connection issues on devices running Android 10 or higher. Developers are encouraged to update their server configurations and client code to support TLS 1.2 or TLS 1.3. Industry Alignment:This move is in line with broader industry trends, where many platforms and browsers have also phased out support for TLS 1.0 and 1.1. If you’re maintaining an app or server infrastructure, it’s important to verify that your connections support TLS 1.2 or higher to ensure compatibility with Android 10+ devices. Part 1: Generate a Self‑Signed CA and Server Certificate1.1 Create the Self‑Signed CAGenerate the CA private key: 1openssl genrsa -out ca.key 4096 Create the CA certificate (valid for 10 years in this example): 12openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt \\ -subj &quot;/C=US/ST=State/L=City/O=Organization/OU=OrgUnit/CN=MySelfSignedCA&quot; 1.2 Create the Server Certificate with IP Address in SANCreate an OpenSSL configuration file (e.g., server.cnf) with the following contents (replace 192.168.1.100 with your server’s IP): 1234567891011121314151617[ req ]default_bits = 2048prompt = nodefault_md = sha256distinguished_name = dnreq_extensions = req_ext[ dn ]C = USST = StateL = CityO = OrganizationOU = OrgUnitCN = 192.168.1.100 # Server IP[ req_ext ]subjectAltName = IP:192.168.1.100 # Must match the server IP Generate the server private key: 1openssl genrsa -out server.key 2048 Generate a Certificate Signing Request (CSR) using the configuration file: 1openssl req -new -key server.key -out server.csr -config server.cnf Sign the CSR with your CA to produce the server certificate (valid for 1 year in this example): 12openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ -out server.crt -days 365 -sha256 -extfile server.cnf -extensions req_ext 1.3 Create a PKCS12 Keystore for Spring BootCombine the server key and certificate into a PKCS12 keystore: 12openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12 \\ -name springboot -CAfile ca.crt -caname root Part 2: Configure Spring Boot for TLSv1.3Place the generated server.p12 into your Spring Boot application’s resources (e.g., src/main/resources) and add the following configuration to your application.properties (or equivalent YAML file): properties Copy server.port=8443 server.ssl.key-store=classpath:server.p12 server.ssl.key-store-password=yourpassword # Use the password set above server.ssl.keyStoreType=PKCS12 server.ssl.keyAlias=springboot server.ssl.enabled-protocols=TLSv1.3 Note: Ensure your Java version is 11 or later for TLSv1.3 support. Part 3: Android OkHttp Demo with a Self‑Signed CertificateWhen using a self‑signed certificate on Android, the client must trust your CA. One common approach is to bundle the CA certificate (e.g., ca.crt) in the app’s assets and use it to configure OkHttp with a custom SSL context. 3.1 Place the CA Certificate in Assets Copy your ca.crt file into the assets folder of your Android project. 3.2 OkHttp Demo CodeBelow is an example Java class demonstrating how to load the CA from assets, configure the SSL context for TLSv1.3, and make an asynchronous HTTPS request using OkHttp. Make sure to execute network calls off the main thread (this example uses a separate thread): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import android.content.Context;import android.util.Log;import java.io.InputStream;import java.security.KeyStore;import java.security.cert.Certificate;import java.security.cert.CertificateFactory;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManager;import javax.net.ssl.TrustManagerFactory;import javax.net.ssl.X509TrustManager;import okhttp3.Call;import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.SSLSession;import java.io.IOException;public class OkHttpSelfSignedDemo &#123; public static void makeRequest(final Context context) &#123; new Thread(() -&gt; &#123; try &#123; // Load the CA certificate from the assets folder CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); InputStream caInput = context.getAssets().open(&quot;ca.crt&quot;); Certificate ca = cf.generateCertificate(caInput); caInput.close(); // Create a KeyStore containing the trusted CA KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, ca); // Create a TrustManager that trusts the CA in our KeyStore TrustManagerFactory tmf = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); tmf.init(keyStore); TrustManager[] trustManagers = tmf.getTrustManagers(); X509TrustManager trustManager = null; for (TrustManager tm : trustManagers) &#123; if (tm instanceof X509TrustManager) &#123; trustManager = (X509TrustManager) tm; break; &#125; &#125; if (trustManager == null) &#123; throw new IllegalStateException(&quot;No X509TrustManager found&quot;); &#125; // Create an SSLContext for TLSv1.3 SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.3&quot;); sslContext.init(null, new TrustManager[]&#123;trustManager&#125;, null); // Build the OkHttpClient with the custom SSL settings OkHttpClient client = new OkHttpClient.Builder() .sslSocketFactory(sslContext.getSocketFactory(), trustManager) .hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; // Accept the specific IP address (replace with your actual server IP) return hostname.equals(&quot;192.168.1.100&quot;); &#125; &#125;) .build(); // Build and execute the HTTPS request (adjust URL, port, and path as needed) Request request = new Request.Builder() .url(&quot;https://192.168.1.100:8443/&quot;) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.e(&quot;OkHttpDemo&quot;, &quot;Request failed&quot;, e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125; String responseBody = response.body().string(); Log.d(&quot;OkHttpDemo&quot;, &quot;Response: &quot; + responseBody); &#125; &#125;); &#125; catch (Exception e) &#123; Log.e(&quot;OkHttpDemo&quot;, &quot;Error setting up HTTPS connection&quot;, e); &#125; &#125;).start(); &#125;&#125; HTTPS Springboot配置openssl生成的证书 - lovelylily - 博客园 Springboot 证书配置实战Springboot证书配置实战 创建证书 生成CA证书 生成CA证书 将CA证书加到 - 掘金","categories":[{"name":"NETWORK","slug":"NETWORK","permalink":"https://noteforme.github.io/categories/NETWORK/"}],"tags":[],"author":"Jon"},{"title":"Cache File","slug":"cache-file","date":"2024-05-15T06:28:23.000Z","updated":"2025-02-04T14:00:04.931Z","comments":true,"path":"/2024/05/15/cache-file/","link":"","permalink":"https://noteforme.github.io/2024/05/15/cache-file/","excerpt":"","text":"In Android, creating cache files and managing permissions related to file storage are common tasks, especially when you need to store temporary data. Here’s how you can handle creating cache files and manage the necessary permissions: Creating a Cache File Android provides two main cache storage options: Internal cache directory: Private to your app and doesn’t require any permissions to read or write. External cache directory: Accessible by other apps and the user. Depending on your target API level and Android version, you may need to request permissions. Creating a File in Internal Cache: Here’s how you can create a file in the internal cache directory. This method does not require any special permissions: kotlin Copy code fun createCacheFile(context: Context, fileName: String): File { &#x2F;&#x2F; Creating a file in the internal cache directory val file &#x3D; File(context.cacheDir, fileName) if (!file.exists()) { file.createNewFile() } return file } Creating a File in External Cache: For external cache files, you might need to check and request permissions, especially on Android versions prior to Android 10 (API level 29). From Android 10 and beyond, scoped storage simplifies permission management. 123456789Copy codefun createExternalCacheFile(context: Context, fileName: String): File &#123; // Check for the external storage state val externalCacheDir = context.externalCacheDir ?: throw IllegalStateException(&quot;External cache is not available&quot;) val file = File(externalCacheDir, fileName) if (!file.exists()) &#123; file.createNewFile() &#125; return file&#125; Managing Permissions For versions before Android 10, if you’re using external storage for anything other than the cache directories, you’ll need to request the following permissions in your AndroidManifest.xml: xml Copy code 12&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; Requesting Permissions at Runtime (Android 6.0 and up): You should request permissions at runtime for accessing external storage with API level 23 and above. Here’s a simplified way to request permissions: 1234Copy codeif (ContextCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), REQUEST_CODE)&#125; In the above code, replace REQUEST_CODE with any integer value that you use to identify the permission request. This code should be called before you perform any operations that require the permission. Note on Scoped Storage (Android 10+) From Android 10 (API level 29), scoped storage is enforced, which restricts access to broad file paths and requires you to use either the app-specific directories or scoped storage APIs to access files. For temporary files, using the cache directories as shown above usually does not require additional permissions with scoped storage. This should help you manage cache files and permissions effectively in your Android applications.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[],"author":"Jon"},{"title":"Retrofit","slug":"retrofit","date":"2024-05-14T02:01:38.000Z","updated":"2024-09-15T10:15:08.635Z","comments":true,"path":"/2024/05/14/retrofit/","link":"","permalink":"https://noteforme.github.io/2024/05/14/retrofit/","excerpt":"","text":"Retofit调用关系 illustrating interceptor request flow调用整体流程 sequenceDiagram autonumber participant SimpleService as Retrofit participant ProxyClass as BinInterface$0 participant InvocationHandler participant ExecutorCallbackCall as RetrofitCall SimpleService ->> ProxyClass : retrofit.create(IGitHub.class) ProxyClass ->> InvocationHandler : github.contributors InvocationHandler ->> ExecutorCallbackCall : h.invoke(this, m3, new Object[]{var1}) Note over InvocationHandler, ExecutorCallbackCall: it invoke in proxyclass loadServiceMethod(service, method).invoke(proxy, args) ExecutorCallbackCall ->> OkHttpCall : retrofit2::call.execute() OkHttpCall ->> OkHttpCall : createRaw Okhttp Call OkHttpCall ->> RealCall : Okhttp Call.execute() RealCall ->> RealCall: getResponseWithInterceptorChain Note over RealCall : RetryAndFollowUpInterceptor BridgeInterceptor CacheInterceptor CallServerInterceptor RealCall -->> OkHttpCall : parseResponse OkHttpCall -->> SimpleService : Response Entity 动态代理创建一个接口的代理类,为代理类注入一个回调。 The step cannot check out the source code because it is generated by ProxyGenerator. Invoke the contributors method of the proxy class. The InvocationHandler parameter, h, is passed in step 1. The object is constructed with var1.newInstance(var2). In step 3, create an ExecutorCallbackCall object last so that it can invoke retrofit2::execute(). 通过反射解析每个接口的注解、入参构造http请求获取到返回的http请求，使用Adapter解析成需要的返回值。 Retrofit 交付请求给OkHttp主要是，OkHttpCall中处理, 组装数据后，请求方式就是OkHttp官方提供的方式了。请求的body是在这里处理的 123456okhttp3.Request create(@Nullable Object instance, Object[] args) &#123; handlers[p].apply(requestBuilder, args[p]); return requestBuilder .get() // 组装body和请求 .build();&#125; Retrofit VS OkhttpEase of Use: Retrofit:Provides a high-level API that simplifies the creation and execution of network requests. You define API endpoints using Java interfaces, and Retrofit generates the necessary code to handle these requests. OkHttp:While powerful, requires more boilerplate code to set up and execute requests. You need to manually construct HTTP requests, handle responses, and parse the results. Automatic JSON Parsing: Retrofit: Integrates seamlessly with JSON libraries like Gson or Moshi to automatically convert JSON responses into Java objects. This reduces the need for manual parsing and makes the code cleaner and easier to maintain. OkHttp: Does not include built-in support for JSON parsing, so you need to manually parse JSON responses using a separate library. Annotations: Retrofit: Uses annotations to define request parameters, headers, and endpoints. This makes the code more readable and easier to understand. OkHttp: Requires manual handling of these aspects, leading to more verbose and error-prone code. Interceptors and Customization: Retrofit: Allows for easy integration of OkHttp interceptors to handle logging, authentication, and other concerns. Retrofit itself focuses on simplifying API interactions while allowing OkHttp to handle lower-level HTTP operations. OkHttp: You can also use interceptors and customize requests, but it requires more effort compared to Retrofit. Error Handling: Retrofit: Provides built-in support for error handling, including deserialization of error responses and easier differentiation between HTTP error codes. OkHttp: Requires manual implementation of error handling, which can be more complex and less consistent. Scalability: Retrofit: Ideal for larger projects with multiple API endpoints. The use of interfaces and annotations makes it easier to manage and scale the codebase. OkHttp: Better suited for simpler or lower-level network tasks where fine-grained control over the HTTP layer is required. 用户网络请求的借口配置 繁琐， 尤其是需要配置复杂的请求body,请求头，参数的时候。 数据解析过程需要用户手动拿到respponsbody进行解析，不能复用。 无法适配自动进行线程的切换。 Retrofit底层实现，在okhttp的基础下做了哪些封装Retrofit在OkHttp的基础上进行了多个层次的封装，主要集中在简化网络请求的创建、执行和响应处理。以下是Retrofit在OkHttp基础上所做的主要封装： 接口定义和注解： Retrofit允许开发者使用Java接口来定义网络请求。每个接口方法对应一个API端点，并通过注解（如@GET、@POST、@Path、@Query等）来描述请求的类型、路径和参数。这些注解让代码更简洁、易读，避免了手动构建请求所需的冗长代码。 动态代理： Retrofit使用Java的动态代理机制（Proxy类）在运行时生成接口实现。这些实现会将方法调用转换为HTTP请求。通过动态代理，Retrofit能够在开发者调用接口方法时，自动创建并执行相应的OkHttp请求。 请求和响应转换：Retrofit提供了Converter接口，用于将请求体转换为HTTP请求的有效负载（如JSON）以及将HTTP响应转换为Java对象。常见的Converter包括GsonConverter、MoshiConverter和JacksonConverter，方便开发者使用各种JSON库来解析响应。 异步和同步请求：Retrofit支持同步和异步请求。开发者可以选择返回Call对象，并使用enqueue方法进行异步请 求，或者使用execute方法进行同步请求。这种灵活性使得网络请求的处理方式更加丰富和适应不同的需求场景. 错误处理:Retrofit内置了对HTTP错误的处理机制，能够方便地捕获和处理HTTP错误状态码和网络异常。开发者可以通过自定义Callback或者配合使用Call对象的Response类，方便地进行错误处理和重试逻辑。 拦截器： 虽然OkHttp本身也支持拦截器，Retrofit对其进行了更友好的集成。开发者可以轻松地将OkHttp的拦截器（如日志记录、认证拦截器）添加到Retrofit的配置中。这使得调试和网络请求的管理更加方便。 URL管理： Retrofit支持在接口方法上通过注解来灵活配置URL参数，路径变量和查询参数。这使得构建复杂的URL变得更加简单和直观。通过注解和参数替换，Retrofit能够动态地生成完整的请求URL。内置协程支持（在Kotlin中）： 对于使用Kotlin的项目，Retrofit提供了对协程的支持，使得网络请求可以以挂起函数的形式实现，简化了异步代码的编写。通过这些封装，Retrofit将OkHttp强大的低级网络功能与高层的API定义和处理结合起来，使得开发者能够更加专注于业务逻辑，而不需要过多关心底层的网络请求细节。 Retrofit中的Call对象如何转换成okhttp的call对象Retrofit中有一个OkHttpCall类，它实现了Call接口，并封装了OkHttp的Call对象。创建OkHttp Request对象： 在OkHttpCall类中，createRawCall方法会调用OkHttp的Call.Factory来创建一个新的OkHttp Call对象。 12345@Overridepublic okhttp3.Call createRawCall() &#123; Request request = serviceMethod.toRequest(args); return serviceMethod.callFactory.newCall(request);&#125; 在retrofit中的泛型是怎么解析的?为什么retrofit要使用运行时注解？什么时候用运行时注解？Retrofit使用运行时注解的原因在于其灵活性和动态特性，这使得Retrofit能够在运行时解析接口方法的注解和参数，并根据这些信息动态地构建HTTP请求。下面是Retrofit使用运行时注解的具体原因以及适用场景： 灵活的请求配置 运行时注解允许开发者在接口方法上灵活地配置HTTP请求。例如，可以通过注解指定HTTP方法、URL路径、查询参数、请求头等。这种方式 比硬编码请求配置更加灵活和可维护。 1234public interface ApiService &#123;@GET(&quot;users/&#123;user&#125;/repos&quot;)Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);&#125; 动态解析和生成请求 使用运行时注解，Retrofit可以在运行时解析接口方法的注解，生成相应的请求对象。这个过程包括解析HTTP方法、URL、请求参数等信息， 并动态构建请求。这种动态生成请求的方式相比于编译时生成请求代码，更加灵活且易于修改。 适应多变的API 许多网络API会频繁变化，使用运行时注解可以更容易地适应这些变化。因为注解的解析和请求的生成是在运行时进行的，所以在代码中修改 注解即可应对API的变化，而不需要重新编译代码。 DESIGN PATTERNstatic method factory1234567private static Platform findPlatform() &#123; if (isAndroid()) &#123; return findAndroidPlatform(); &#125; else &#123; return findJvmPlatform(); &#125;&#125; Abstract Factory methodRetrofit deserializes data using the abstract factory method classDiagram class Factory { +requestBodyConverter(): RequestBody +responseBodyConverter(): ResponseBody } class GsonConverterFactory { +requestBodyConverter(): GsonRequestBodyConverter +responseBodyConverter(): GsonResponseBodyConverter } class Converter { +convert(): T } class MoshiConverterFactory { +requestBodyConverter(): MoshiRequestBodyConverter +responseBodyConverter(): MoshiResponseBodyConverter } class RequestBody { +operationA(): void } class ResponseBody { +operationA(): void } class AbstractProductB { +operationB(): void } class ConcreteProductB1 { +operationB(): void } class ConcreteProductB2 { +operationB(): void } Factory AndroidMainExecutor : callbackExecutor.execute AndroidMainExecutor -->> DefaultCallAdapterFactory : handler.post(r); DefaultCallAdapterFactory -->> RetrofitCall : callback.onResponse implementation在添加默认适配器工厂defaultCallAdapterFactories时，将callbackExecutor作为了一个参数，那么它的具体实现也就是在这个默认适配器工厂中。 我们来看下callbackExecutor在里面做了些啥。 1234567891011121314151617181920static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; delegate.enqueue( new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute( // 这里切换到主线程 () -&gt; &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t)); // 这里切换到主线程 &#125; &#125;); &#125; 在上述代码里了解到，callbackExecutor即Executor，一个线程调度器。在Call的enqueue实现里执行了一个异步网络请求delegate.enqueue，在请求的响应onResponse、onFailure中 Executor也同样执行了一个线程，这里就有个疑问，为什么要在一个异步请求里又调用一个线程？我们知道callbackExecutor是一个线程调度器，那他内部到底实现的是什么？ 默认callbackExecutor的创建在Retrofit的初始化中，callbackExecutor &#x3D; platform.defaultCallbackExecutor(); 1234567891011121314151617static final class Android extends Platform &#123;@Overridepublic Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor();&#125;static final class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125;&#125;&#125;&#125; platform是一个Android平台，defaultCallbackExecutor 内部其实调用的是 new MainThreadExecutor() ，很清楚的看到， handler.post(r) 内部使用Handler将响应抛到了主线程。 这就是Retrofit将子线程切换到主线程的核心所在。 问3：Retrofit为什么要用动态代理？ 原文链接：https://blog.csdn.net/qq_37492806/article/details/133995368 Retrofit结合RxJava 感觉RxJava可以了解下，Retrofit结合courutine 感觉courutine代码不懂，courutine的可以了解下，感觉courutine有先级别更高一点，回来再来画Retrofit其他的类图 Retrofit 注解是怎么消费的123456789101112 private void parseMethodAnnotation(Annotation annotation) &#123; if (annotation instanceof DELETE) &#123; parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false); &#125; else if (annotation instanceof GET) &#123; parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false); &#125; else if (annotation instanceof HEAD) &#123; parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false); &#125; else if (annotation instanceof PATCH) &#123; parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true); &#125; else if (annotation instanceof POST) &#123; parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);&#125; https://github.com/pengMaster/BestNote/blob/master/docs/android/Android-Interview/Android/Android%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%9510%E5%A4%A7%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md https://github.com/stven0king/designmode?tab=readme-ov-file Build Project","categories":[{"name":"Library","slug":"Library","permalink":"https://noteforme.github.io/categories/Library/"}],"tags":[],"author":"Jon"},{"title":"DesignPattern","slug":"designpattern","date":"2024-05-14T01:54:42.000Z","updated":"2024-09-15T12:50:22.130Z","comments":true,"path":"/2024/05/14/designpattern/","link":"","permalink":"https://noteforme.github.io/2024/05/14/designpattern/","excerpt":"","text":"ResourceOverviewhttps://refactoring.guru/design-patterns/abstract-factoryhttps://design-patterns.readthedocs.io/zh-cn/latest/behavioral_patterns/behavioral.html https://blog.csdn.net/unique_perfect/article/details/109621369 meituanhttps://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html 列举了视频示例https://blog.csdn.net/mrhanzhou5273/article/details/119248595 尚硅谷-Java设计模式https://www.bilibili.com/video/BV1W4411c77Ehttps://github.com/vectorxxxx/NOTE_DesignPatterns 23种 https://www.cnblogs.com/furenjun/archive/2008/12/28/DesignPatterns1.htmlhttps://masiyi.blog.csdn.net/article/details/128345543https://www.yuque.com/u22582281/qyidho/bd7d1k#e3c84592 画em的图 https://github.com/noteforme/noteforme.github.io/blob/main/source/_posts&#x2F;DesignPatterns_Factory.md 设计原则设计模式六大原则1-单一职责原则一个类应该只负责一项职责。 设计模式六大原则2-里氏替换原则 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法，里氏替换原则规定，子类不能覆写父类已实现的方法。父类中已实现的方法其实是一种已定好的规范和契约，如果我们随意的修改了它，那么可能会带来意想不到的错误。 子类完美继承父类的设计初衷，并做了增强 https://www.jianshu.com/p/cf9f3c7c0df5 里氏替换 所有使用基类的地方必须能透明的使用其子类。 使用继承时，遵循里氏替换原则，子类尽量不要重写父类的方法。继承实际上让两个类耦合性增强了，适当情况下可以通过 聚合 组合 依赖来解决问题。 通用做法是： 原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。 之前的方案 123456789101112131415161718192021222324252627282930public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(&quot;11-3=&quot; + a.func1(11, 3)); System.out.println(&quot;1-8=&quot; + a.func1(1, 8)); System.out.println(&quot;---------------&quot;); B b = new B(); System.out.println(&quot;11-3=&quot; + b.func1(11, 3)); System.out.println(&quot;1-8=&quot; + b.func1(1, 8)); System.out.println(&quot;11+3+9=&quot; + b.func2(11, 3)); &#125;&#125;class A &#123; public int func1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;class B extends A &#123; //没意识到 重写了该方法 public int func1(int num1, int num2) &#123; return num1 + num2; &#125; public int func2(int a, int b) &#123; return func1(a, b) - 9; &#125;&#125; 改进后的方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(&quot;11-3=&quot; + a.func1(11, 3)); System.out.println(&quot;1-8=&quot; + a.func1(1, 8)); System.out.println(&quot;---------------&quot;); B b = new B(); //因为B类不再继承A类，因此调用者，不会再func1求减法 System.out.println(&quot;11+3=&quot; + b.func1(11, 3)); System.out.println(&quot;1+8=&quot; + b.func1(1, 8)); System.out.println(&quot;11+3+9=&quot; + b.func2(11, 3)); //使用组合仍然可以使用A类相关方法 System.out.println(&quot;11-3=&quot; + b.func3(11, 3)); &#125;&#125; class Base&#123; //把更基础的方法和成员写到Base类中&#125;class A extends Base &#123; public int func1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;class B extends Base &#123; //如果B需要使用A类的方法，使用组合关系 private A a = new A(); //没意识到 重写了该方法 public int func1(int num1, int num2) &#123; return num1 + num2; &#125; public int func2(int a, int b) &#123; return func1(a, b) +9; &#125; public int func3(int a,int b)&#123; return this.a.func1(a,b); &#125;&#125; 开闭原则 ocp open closed principle 不适用该原则的方案 1234567891011121314151617public class GraphicEditor &#123; public static void main(String[] args) &#123; GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); &#125; //添加一个图形需要修改 public void drawShape(Shape s) &#123; if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); else if (s.m_type == 3) drawTriangle(s); &#125; private void drawCircle(Shape s) &#123; System.out.println(&quot;绘制圆形&quot;); &#125; private void drawRectangle(Shape s) &#123; System.out.println(&quot;绘制矩形&quot;); &#125; //添加一个图形需要修改 private void drawTriangle(Shape s) &#123; System.out.println(&quot;绘制三角形&quot;); &#125; } class Shape { public int m_type; } class Rectangle extends Shape { public Rectangle() &#123; super.m_type = 1; &#125; } class Circle extends Shape { public Circle() &#123; super.m_type = 2; &#125; } &#x2F;&#x2F;新增图形class Triangle extends Shape { public Triangle() &#123; super.m_type = 3; &#125; } 可以看到改动很多 使用ocp原则改进后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class GraphicEditor &#123; public static void main(String[] args) &#123; GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); &#125; public void drawShape(Shape s) &#123; s.drawShape(); &#125;&#125;abstract class Shape &#123; public int m_type; abstract void drawShape();&#125;class Rectangle extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;绘制矩形&quot;); &#125;&#125;class Circle extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;绘制圆形&quot;); &#125;&#125;class Triangle extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;绘制三角形&quot;); &#125;&#125;//新增一个图形class OtherGraphic extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;新增一个图形&quot;); &#125;&#125; 实现代码没有任何改动 设计模式六大原则3-依赖倒置原则 高层模块不应该依赖于底层模块，两者都应该依赖于抽象， 抽象不应该依赖于细节，细节应该依赖于抽象 依赖倒置的中心思想是面向接口编程。 设计模式六大原则4-接口隔离原则 接口隔离原则:Clients should not be forced to depend upon interfaces that they do not use.与外部关系上只依赖需要的抽象 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 接口隔离原则的关键是接口以及这个接口要小，如何小呢，也就是我们要为专门的类创建专门的接口，这个接口只对它有效，不要试图让一个接口包罗万象，要建立最小的依赖关系 https://blog.csdn.net/dingshuo168/article/details/103531805 设计模式六大原则5-迪米特法则 减少依赖 Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers 一个类应该应该对其他类尽可能了解得最少；类只与直接的朋友通信等等。但是其最终目的只有一个，就是让类间解耦。 https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/ 迪米特法则 一个对象应该对其他对象保持最少的了解 Demeter Principle又叫最少知道原则， 即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外出了提供的public方法，不泄漏任何信息 只与直接的朋友通信。 直接的朋友: 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多， 依赖 关联，组合，聚合等。 其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。 ​ 改进前 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Demeter1 &#123; public static void main(String[] args) &#123; SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmployee(new CollegeManger()); &#125;&#125;//学校总部员工的类class SchollEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//学院的员工class CollegeEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//管理学院员工的管理类class CollegeManger &#123; public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; ArrayList&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(&quot;学院员工id= &quot; + i); list.add(collegeEmployee); &#125; return list; &#125;&#125;// SchollEmployee , CollegeManger 是直接朋友// CollegeEmployee 不是直接朋友，而是一个陌生类，这样违反了 迪米特法则。class SchoolManager &#123; public List&lt;SchollEmployee&gt; getAllEmployee() &#123;//方法返回值:直接朋友 ArrayList&lt;SchollEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; SchollEmployee schollEmployee = new SchollEmployee(); // CollegeEmployee 不是直接朋友，以局部变量出现在SchoolManager schollEmployee.setId(&quot;学校总部员工id= &quot; + i); list.add(schollEmployee); &#125; return list; &#125; //该方法完成输出学校总部和学院员工ID void printAllEmployee(CollegeManger sub) &#123;//方法参数:直接朋友 List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); System.out.println(&quot;-----------学院员工--------&quot;); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125; List&lt;SchollEmployee&gt; list2 = this.getAllEmployee(); System.out.println(&quot;-----------学校总部员工--------&quot;); for (SchollEmployee e : list2) &#123; System.out.println(e.getId()); &#125; &#125;&#125; 改进后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class Demeter2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;使用迪米特法则的改进&quot;); SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmployee(new CollegeManger()); &#125;&#125;//学校总部员工的类class SchollEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//学院的员工class CollegeEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//管理学院员工的管理类class CollegeManger &#123; public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; ArrayList&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(&quot;学院员工id= &quot; + i); list.add(collegeEmployee); &#125; return list; &#125; // 输出学院员工的信息 void printCollegeEmployee() &#123; //改进方法： 将输出学院员工的方法，封装到CollegeManager中。 List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); System.out.println(&quot;-----------学院员工--------&quot;); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125; &#125;&#125;// SchollEmployee , CollegeManger 是直接朋友// CollegeEmployee 不是直接朋友，而是一个陌生类，这样违反了 迪米特法则。class SchoolManager &#123; public List&lt;SchollEmployee&gt; getAllEmployee() &#123;//方法返回值:直接朋友 ArrayList&lt;SchollEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; SchollEmployee schollEmployee = new SchollEmployee(); // CollegeEmployee 不是直接朋友，以局部变量出现在SchoolManager schollEmployee.setId(&quot;学校总部员工id= &quot; + i); list.add(schollEmployee); &#125; return list; &#125; //该方法完成输出学校总部和学院员工ID void printAllEmployee(CollegeManger sub) &#123;//方法参数:直接朋友 /* List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); System.out.println(&quot;-----------学院员工--------&quot;); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125;*/ //改进方法： 将输出学院员工的方法，封装到CollegeManager中。 sub.printCollegeEmployee(); List&lt;SchollEmployee&gt; list2 = this.getAllEmployee(); System.out.println(&quot;-----------学校总部员工--------&quot;); for (SchollEmployee e : list2) &#123; System.out.println(e.getId()); &#125; &#125;&#125; 设计模式六大原则6-开闭原则控制反转 在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。 谈一谈自己对依赖、关联、聚合和组合之间区别的理解 http://blog.itpub.net/69952849/viewspace-2672009/ Creational Design PatternsSingletonFactoryPrototype 原型Behavioral PatternsChain of Responsibility 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。 https://refactoring.guru/design-patterns/chain-of-responsibilityhttps://www.bilibili.com/video/BV1W4411c77E?p=147 https://github.com/vectorxxxx/NOTE_DesignPatterns&#x2F;blob&#x2F;main&#x2F;%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&#x2F;22-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F&#x2F;README.md classDiagram class Handler{ + successor :Handler + setSuccessor(Handler): void + handleRequest(): void } class ConcreteHandlerA { + handleRequest() } class ConcreteHandlerB { + handleRequest() } ConcreteHandlerA --|> Handler ConcreteHandlerB --|> Handler Handler o-- Handler class Client Client --> Handler 为请求创建了一个接收者对象的链. 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止 Handler抽象处理者： 定义了一个处理请求的方法，同时含有另外一个Handler ConcreteHandler具体处理者： 处理自己负责的请求，同时可以访问它的后继者（即下一个处理者） ；如果可以处理请求，则进行处理，否则交给后继者去处理，从而形成一个职责链 Request含有很多属性，表示一个请求 Command 命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能 在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换 Iterator一般会涉及容器 List 和容器迭代器 iterator 两部分内容. Mediator 中介者 将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系). Memento 备忘录 这个模式理解、掌握起来不难，代码实现比较灵活，应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等. ObserverStateStrategy 包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。 类似于面向接口编程,策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿 Template Method 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。 回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。 Visitor 在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态. Structural : 类或对象的组合或组装Adapter 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。 类适配器: 通过继承关系 对象适配器：通过组合关系 Proxy代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。 Bridge有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发 Decorator 装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。 代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。 对于为什么必须继承装饰器父类 FilterInputStream的思考：装饰器如BufferedInputStream等，本身并不真正处理read()等方法，而是由构造函数传入的被装饰对象：InputStream（实际上是FileInputStream或者ByteArrayInputStream等对象）来完成的。如果不重写默认的read()等方法，则无法完成如FileInputStream或者ByteArrayInputStream等对象所真正实现的read功能。所以必须重写对应的方法，代理给这些被装饰对象进行处理（这也是类似于代理模式的地方）。如果像DataInputStream和BufferedInputStream等每个装饰器都重写的这些方法话，会存在大量重复的代码。所以让它们都继承FilterInputStream提供的默认实现，可以减少代码重复，让装饰器只聚焦在它自己的装饰功能上即可。 https://noteforme.github.io/2017/09/12/JavaIo/ Facade 门面模式 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。这个定义很简洁，我再进一步解释一下。假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用 Composite 组合模式 将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。 组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。 Flayweight 享元模式 如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的. 实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。 思考: 提取相同对象，最终还是要创建相同的数量的对象，只是字段省略了 https://github.com/mxg133/learnforJava_DesignPattern 设计模式 原则 设计模式六大原则1-单一职责原则 设计模式六大原则2-里氏替换原则 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法，里氏替换原则规定，子类不能覆写父类已实现的方法。父类中已实现的方法其实是一种已定好的规范和契约，如果我们随意的修改了它，那么可能会带来意想不到的错误。 子类完美继承父类的设计初衷，并做了增强 六大设计原则之里氏替换原则（LSP） - 简书 设计模式六大原则3-依赖倒置原则 高层模块不应该依赖于底层模块，两者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象 设计模式六大原则4-接口隔离原则 接口隔离原则:Clients should not be forced to depend upon interfaces that they do not use.与外部关系上只依赖需要的抽象 接口隔离原则的关键是接口以及这个接口要小，如何小呢，也就是我们要为专门的类创建专门的接口，这个接口只对它有效，不要试图让一个接口包罗万象，要建立最小的依赖关系 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？_接口隔离原则有哪三种应用?原则中的接口该如何理解?-CSDN博客 设计模式六大原则5-迪米特法则 减少依赖 Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers 一个类应该应该对其他类尽可能了解得最少；类只与直接的朋友通信等等。但是其最终目的只有一个，就是让类间解耦。 https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/ 设计模式六大原则6-开闭原则 控制反转 在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。 谈一谈自己对依赖、关联、聚合和组合之间区别的理解 http://blog.itpub.net/69952849/viewspace-2672009/ 设计模式之美迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 关于Android设计模式，设计模式面试必会 - 简书 https://juejin.im/post/6844903591686176776 GitHub - Meng997998&#x2F;AndroidJX: Flutter+Kotlin+小程序+面试大全+面经。加BAT技术交流q群；708683109 vx[xx13414521]免费领取资料, 深入了解volatile关键字关键字volatile可以保证变量对所有线程的可见性，也就是当一个线程修改了这个变量的值， - 掘金 GitHub - JsonChao&#x2F;Awesome-Android-Interview: :fire: A awesome android expert interview questions and answers（continuous updating …） 一年经验 Android 开发面经总结19 年双非本科毕业，洋洋洒洒的写了一年多业务，九月份开始面试，将一些面试题分享给 - 掘金 并发单例为什么使用volatile修饰 https://juejin.im/post/6844903605292498958 http://static.kancloud.cn/alex_wsc/mianshi/1811436 https://mp.weixin.qq.com/s/eCotdGOWvSMki062eLjS8g https://mp.weixin.qq.com/s/7DvReHYugl1KClKFGBwSfg 平常有用到什么锁，synchronized底层原理是什么 锁之间的区别 线程间同步的方法 阿里编程规范不建议使用线程池，为什么？ RXJava怎么切换线程 平常有用到什么锁，synchronized底层原理是什么 简单描述下Handler,Handler是怎么切换线程的,Handler同步屏障 synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的 线程间同步的方法 锁之间的区别 OkHttp怎么实现连接池 如果让你来实现一个网络框架，你会考虑什么 说说你对volatile字段有什么用途？ 四种线程池原理？ 怎么中止一个线程，Thread.Interupt一定有效吗？ 如何让两个线程循环交替打印 线程池了解多少？拒绝策略有几种,为什么有newSingleThread okhttp线程使用方式 RXJava RXJava怎么切换线程 Rxjava自定义操作符 JVMAndroid 面试必备之 JVM 相关口水话Java 中的运行时数据可以划分为两部分，一部分是线程私有的，包括虚拟机栈 - 掘金 设计模式之美 25 26 39. 40代码没什么了解 Hashmap 注解作用路线图 注解","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[],"author":"Jon"},{"title":"Spring Boot","slug":"spring-boot","date":"2024-05-13T14:11:04.000Z","updated":"2024-09-13T21:02:22.000Z","comments":true,"path":"/2024/05/13/spring-boot/","link":"","permalink":"https://noteforme.github.io/2024/05/13/spring-boot/","excerpt":"","text":"Add Headerhttps://blog.csdn.net/qq_26878363&#x2F;article&#x2F;details&#x2F;102487207","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[],"author":"Jon"},{"title":"WordPress","slug":"wordpress","date":"2024-05-12T10:01:56.000Z","updated":"2025-01-06T13:18:35.395Z","comments":true,"path":"/2024/05/12/wordpress/","link":"","permalink":"https://noteforme.github.io/2024/05/12/wordpress/","excerpt":"","text":"Install guidehttps://www.linuxtuto.com/how-to-install-wordpress-on-debian-12/ Try not to create a &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;wordpress.conf file; instead, make the necessary configurations directly in /etc/nginx/sites-enabled/default . 装完这个后， 之前按照这个安装, https://shape.host/resources/certbot-installation-guide-on-debian-12 12345678sudo apt updatesudo apt upgradesudo apt install certbot python3-certbot-nginxsudo certbot --apache -d jonblog.site -d www.jonblog.sitecertbot certificatessystemctl status certbot.timercertbot renew --dry-run 如果还是不行，把/etc/nginx/sites-available/default也配置上。 &#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress&#x2F;wp-config.php 目前这个没有配置 12345678/**define(&#x27;FORCE_SSL_ADMIN&#x27;, true);if (strpos($_SERVER[&#x27;HTTP_X_FORWARDED_PROTO&#x27;], &#x27;https&#x27;) !== false) &#123; $_SERVER[&#x27;HTTPS&#x27;] = &#x27;on&#x27;;&#125;*/ set https://jonblog.site forWordPress Address (URL)Site Address (URL) wordpress backuphttps://www.youtube.com/watch?v=2qoX-siH0cY IPV6bridge mode settiing https://www.bilibili.com/video/BV1wa411H7NJ/ https://www.youtube.com/watch?v=t3H8kVQmTu0","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[],"author":"Jon"},{"title":"Intellij idea Clion","slug":"intellij-idea","date":"2024-05-11T01:38:10.000Z","updated":"2024-10-02T02:23:43.667Z","comments":true,"path":"/2024/05/11/intellij-idea/","link":"","permalink":"https://noteforme.github.io/2024/05/11/intellij-idea/","excerpt":"","text":"Ideahttps://blog.lupf.cn/articles/2023/11/12/1699792053397.html 【请解压】IDEA 2023.x激活至2099年插件 clion 全家桶https://www.jetbrains.com/zh-cn/clion/download/other.html https://blog.lupf.cn/articles/2023/07/10/1689000614618.html 【请解压】Jetbrains全家桶最新永久激活插件 IDEA 2023.2永久激活破解至2099年（亲测有效，持续更新） - 码霸霸","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[],"author":"Jon"},{"title":"kotlin coroutine","slug":"kotlin-coroutine","date":"2024-05-10T06:25:21.000Z","updated":"2025-02-04T13:56:25.376Z","comments":true,"path":"/2024/05/10/kotlin-coroutine/","link":"","permalink":"https://noteforme.github.io/2024/05/10/kotlin-coroutine/","excerpt":"","text":"大致上是将本来函数该返回的值通过参数中的回调函数进行返回。 https://flaneur2020.github.io/2020/07/04/kotlin-coroutine-cps/ https://time.geekbang.org/column/article/497868","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[],"author":"Jon"},{"title":"permission_storage","slug":"permission-storage","date":"2023-11-15T14:52:48.000Z","updated":"2025-01-20T14:13:44.633Z","comments":true,"path":"2023/11/15/permission-storage/","link":"","permalink":"https://noteforme.github.io/2023/11/15/permission-storage/","excerpt":"","text":"App data and filesAndroid uses a file system that’s similar to disk-based file systems on other platforms. The system provides several options for you to save your app data: App-specific storage: Store files that are meant for your app’s use only, either in dedicated directories within an internal storage volume or different dedicated directories within external storage. Use the directories within internal storage to save sensitive information that other apps shouldn’t access. Shared storage: Store files that your app intends to share with other apps, including media, documents, and other files. Preferences: Store private, primitive data in key-value pairs. Databases: Store structured data in a private database using the Room persistence library. https://developer.android.com/guide/topics/data Type of content Access method Permissions needed Can other apps access? Files removed on app uninstall? App-specific files Files meant for your app’s use only From internal storage, getFilesDir() or getCacheDir() From external storage, getExternalFilesDir() or getExternalCacheDir() Never needed for internal storage Not needed for external storage when your app is used on devices that run Android 4.4 (API level 19) or higher No Yes Media Shareable media files (images, audio files, videos) MediaStore API READ_EXTERNAL_STORAGE when accessing other apps’ files on Android 11 (API level 30) or higher READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE when accessing other apps’ files on Android 10 (API level 29) Permissions are required for all files on Android 9 (API level 28) or lower Yes, though the other app needs the READ_EXTERNAL_STORAGE permission No Documents and other files Other types of shareable content, including downloaded files Storage Access Framework None Yes, through the system file picker No App preferences Key-value pairs Jetpack Preferences library None No Yes Database Structured data Room persistence library None No Yes https://developer.android.com/training/data-storage On Android 4.4 (API level 19) or higher, your app doesn’t need to request any storage-related permissions to access app-specific directories within external storage. The files stored in these directories are removed when your app is uninstalled. https://developer.android.com/training/data-storage/app-specific#external Internal It’s always available. Files saved here are accessible by only your app. When the user uninstalls your app, the system removes all your app’s files from internal storage. 内部存储不需要申请任何权限 12345678String fileInnerName = &quot;/inner/img&quot;; //目录名 //内置存储缓存目录File fileCache = new File(getActivity().getCacheDir(), fileInnerName); // /data/data/com.android.imageloaderstorage/cache/inner/img if (!fileCache.exists()) &#123; boolean isInner = fileCache.mkdirs(); &#125; Log.i(&quot; FileFragment &quot;, &quot; &quot; + fileCache.getAbsolutePath()); 由此可以看到 绝对路径： Context.getCacheDir()：&#x2F;data&#x2F;data&#x2F;应用包名&#x2F;cache&#x2F; fileInnerName External Storage 外部存储也分两种 Private files (外部私有存储) 、Public files (外部公有存储) https://developer.android.com/guide/topics/manifest/uses-permission-element.html (context.getExternalCacheDir()) 1234567891011121314/* Checks if external storage is available for read and write */ String fileOutName = &quot;/AutDir/fileOut&quot;; if (!isExternalStorageWritable()) &#123; return; &#125; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT) &#123; File fileOut = new File(getActivity().getExternalFilesDir(Environment.DIRECTORY_PICTURES) + fileOutName); // /storage/emulated/0/Android/data/com.android.imageloaderstorage/files/Pictures/AutDir/fileOut boolean flag = fileOut.mkdirs(); Log.i(&quot;FileFragment&quot;, fileOut.getAbsolutePath()); &#125; //缓存目录 File fileOutCache = new File(getActivity().getExternalCacheDir() + fileOutName); // /storage/emulated/0/Android/data/com.android.imageloaderstorage/cache/AutDir/fileOut Boolean isInner = fileOutCache.mkdirs(); Log.i(&quot;FileFragment&quot;, &quot; 路径 &quot; + fileOutCache.getAbsolutePath()); 特别注意 mkdir(),mkdirs(),createNewFile()的区别 createNewFile:新建文件（非目录） mkdir：新建目录 mkdirs：新建目录，与mkdir的区别是：比如 mkdirs（“D:&#x2F;test&#x2F;test2”) 如果test , 不存在会创建，然后创建test2，如果是 mkdir（“D:&#x2F;test&#x2F;test2”) ，如果 test不存在，会失败。 android io输入文件 12345new File(param1,param2); param1 File,param2 String类型String dir = StorageUtils.getCacheDirectory(this);String apkDIR = &quot;apkdir.apk&quot;;File apkFile = new File(dir, apkDIR); 参考： https://developer.android.com/training/permissions/requesting.htmlhttps://developer.android.com/guide/topics/permissions/requesting.htmlhttps://developer.android.com/training/basics/data-storage/files.html?hl=zh-cn Android 13媒体文件访问权限适配_read_media_images-CSDN博客 Android 13 媒体权限适配指南 - 掘金 Permissions and access to external storageAndroid defines the following storage-related permissions: READ_EXTERNAL_STORAGE, WRITE_EXTERNAL_STORAGE, and MANAGE_EXTERNAL_STORAGE. MANAGE_EXTERNAL_STORAGEAndroid 11 introduces the MANAGE_EXTERNAL_STORAGE permission, which provides write access to files outside the app-specific directory and MediaStore. To learn more about this permission, and why most apps don’t need to declare it to fulfill their use cases, see the guide on how to manage all files on a storage device. The answer is NO it is not required if you are simply capturing image from camera or by gallery by calling an intent (calling other app to perform some task for you ) in our case this other app would be the camera application in your mobile https://medium.com/@bilalhameed0800/is-permission-required-for-android-capture-image-from-camera-and-gallery-intent-4812964e8c9a https://developer.android.com/training/data-storage Preparing for scoped storage (Android Dev Summit &#39;19) - YouTube android SD卡主要有两种存储方式 Internal 、 External Storage external storage permission 自己创建的文件，不需要权限 ，不是自己的 需要 READ_EXTERNAL_STORAGE photo pickerhttps://developer.android.com/about/versions/14/changes/partial-photo-video-access if your app is running on a device with Android 14 (API level 34) or higher, limit access to selected photos and videos, request “Manifest.permission.READ_MEDIA_IMAGES” will show READ_MEDIA_VISUAL_USER_SELECTED这个限制和 iOS 相似，Android 14 提供了对照片和视频的部分访问权限。当您访问媒体数据时，用户将看到一个对话框，提示用户授予对所有媒体的访问、或者授予单个照片&#x2F;视频的访问权限，该新功能将适用于 Android 14 上所有应用程序，无论其 targetSdkVersion 是多少 谷歌在 API 33（Android 13）上面引入了 READ_MEDIA_IMAGES 和 READ_MEDIA_VIDEO 这两个权限，目前针对这两个权限在 Android 14 上面有新的变动，具体的变动点就是新增了 READ_MEDIA_VISUAL_USER_SELECTED权限，那么这个权限的作用是什么呢？ 我们都知道 READ_MEDIA_IMAGES 和 READ_MEDIA_VIDEO 是申请图片和视频权限的，但是这样会有一个问题，当第三方应用申请到权限后，就拥有了手机相册中所有照片和视频的访问权限，这是十分危险的，也是非常不可控的，因为用户也无法知道第三方应用会干什么，所以谷歌在 API 34（Android 14）引入了这个权限，这样用户拥有了更多的选择，可以将相册中所有的图片和视频授予给第三方应用，也可以将部分的图片和视频给第三方应用。 讲完了这个特性的来龙去脉，那么接下来讲讲这个权限如何适配，如果你的应用申请了 READ_MEDIA_IMAGES 或者 READ_MEDIA_VIDEO 权限，并且 targetSdkVersion 大于等于 33（Android 13），那么需要在申请权限时携带上 READ_MEDIA_VISUAL_USER_SELECTED 权限方能正常申请，如果不携带上 READ_MEDIA_VISUAL_USER_SELECTED 权限就申请 READ_MEDIA_IMAGES 或者 READ_MEDIA_VIDEO 权限，会弹出权限询问对话框，但是如果用户是选择全部授予，那么 READ_MEDIA_IMAGES 或者 READ_MEDIA_VIDEO 权限状态是已授予的状态，如果用户是选择部分授予，那么 READ_MEDIA_IMAGES 或者 READ_MEDIA_VIDEO 权限状态是已拒绝的状态，假设此时有携带了 READ_MEDIA_VISUAL_USER_SELECTED 权限的情况下，那么 READ_MEDIA_VISUAL_USER_SELECTED 权限是已授予的状态。 看到这里，脑洞大的同学可能有想法了，那我不申请 READ_MEDIA_IMAGES 或者 READ_MEDIA_VIDEO 权限，我就只申请 READ_MEDIA_VISUAL_USER_SELECTED 权限行不行啊？答案也是不行的，我替大家试验过了，这个权限申请会在不会询问用户的情况下，被系统直接拒绝掉。 另外需要的一点是 READ_MEDIA_VISUAL_USER_SELECTED 属于危险权限，除了在运行时动态申请外，还需要在清单文件中进行注册。 [Bug]：安卓14，申请READ_MEDIA_IMAGES时，当用户选择部分允许后，READ_MEDIA_IMAGES的isGranted&#x3D;true · Issue #244 · getActivity&#x2F;XXPermissions · GitHub https://developer.android.com/training/data-storage/shared/photopicker#kotlin 12345678910111213141516var filter by remember &#123; mutableStateOf&lt;VisualMediaType&gt;(ImageAndVideo) &#125;/** * [PickMultipleVisualMedia] is an ActivityResultContract that will launch the photo picker * intent while providing an enhanced API over the available customisations options (media type, * max number of items). * * If you&#x27;re looking for single selection only, use PickVisualMedia ActivityResultContract * instead. */ val pickMultipleMedia = rememberLauncherForActivityResult(PickMultipleVisualMedia(maxItems)) &#123; uris -&gt; selectedMedia = uris &#125; pickMultipleMedia.launch(PickVisualMediaRequest(filter))","categories":[],"tags":[{"name":"permission","slug":"permission","permalink":"https://noteforme.github.io/tags/permission/"}]},{"title":"notification","slug":"notification","date":"2023-11-15T00:30:59.000Z","updated":"2023-12-06T00:30:28.431Z","comments":true,"path":"2023/11/15/notification/","link":"","permalink":"https://noteforme.github.io/2023/11/15/notification/","excerpt":"","text":"Notification switch1NotificationManagerCompat.from(this).areNotificationsEnabled() channel switch1NotificationManager.IMPORTANCE_NONE == NotificationManagerCompat.from(this).getNotificationChannel(CHANNEL_ID)?.importance ======= https://stackoverflow.com/questions/71159130/custom-android-notification-sound Android 13 and abovegranted permission and channel is nullgranted permission and channel open Android 8 and above - below Android 13notfication switch openchannel switch open Blow Android 8notification switch open Channel SoundSince Android Oreo / 8 the Notificationsound is coming from the Channel and can only be set the first time you add the channel via your channel.setSound(). If you want to change it later on you need to delete the channel and then re-add it to the system. The user will be warned about that behaviour though (App deleted channels X amount of times). Custom Android notification sound - Stack Overflow","categories":[],"tags":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/tags/ANDROID/"}]},{"title":"compose_layout","slug":"compose-layout","date":"2023-08-20T13:41:06.000Z","updated":"2024-04-11T23:35:14.893Z","comments":true,"path":"2023/08/20/compose-layout/","link":"","permalink":"https://noteforme.github.io/2023/08/20/compose-layout/","excerpt":"","text":"Compose study pathJetpack Compose for Android Developers Compose Guide document Images and graphics in Compose &nbsp;|&nbsp; Jetpack Compose &nbsp;|&nbsp; Android Developers ScaffoldJetpack Compose basics &nbsp;|&nbsp; Android Developers GitHub - android/codelab-android-compose GitHub - android/codelab-android-compose Jetpack Compose basics &nbsp;|&nbsp; Android Developers Jetpack Compose for Android Developers Compose test Testing your Compose layout &nbsp;|&nbsp; Jetpack Compose &nbsp;|&nbsp; Android Developers 5 ways Compose improves UI testing - YouTube Llaazy layouts in Compose - YouTube","categories":[],"tags":[{"name":"compose","slug":"compose","permalink":"https://noteforme.github.io/tags/compose/"}]},{"title":"LC_DP_BAG","slug":"LC-DP-BAG","date":"2023-08-09T14:42:49.000Z","updated":"2023-10-18T13:59:55.119Z","comments":true,"path":"2023/08/09/LC-DP-BAG/","link":"","permalink":"https://noteforme.github.io/2023/08/09/LC-DP-BAG/","excerpt":"","text":"对于01背包，物品i，我觉得也是从0开始更好。 纯01背包:装满这个背包的最大价值。 分割等和子集：能否装满。 本题: 给一个背包容量，有多少种方式装满。 解法一随想录 背包问题理论基础 这个视频讲的很好 https://www.bilibili.com/video/BV1jT4y1o71J/ 0/1 Knapsack problem | Dynamic Programming - YouTube https://www.bilibili.com/video/BV1cg411g7Y6/ The 0/1 Knapsack Problem (Demystifying Dynamic Programming) - YouTube 有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是 value[i] 。 1234567dp[i][j] [0,i]物品任取放容量为j的背包不放物品i : dp[i-1][j]放物品i : dp[i-1][j-weight[i]] + value[i]， 那么就是前i-1种物品的选择，减去当前i物品的重量 + 当前i物品的价值，其实就转化为 i-1种物品 j-weight[i]的容量下的最大值。dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) 从上面的递推公式可以看出，当前值都是由 左上角的值，其实我觉得是正上角， 来递推出来的。dp[i-1][j] 随想录的解法，物品0是第一个物品，所以X方向初始化是有值的 下面两个视频，x,y都初始化0，感觉更好。 01背包问题，这个视频讲的很好 https://www.bilibili.com/video/BV1pY4y1J7na https://www.bilibili.com/video/BV1K4411X766 对第0行，第0行没有任何物品，在任何背包容量下，前0个物品，能装进背包的最大价值为0. 对第0列，第0列没有任何容量，在任何物品都无法放进背包，因此价值也都为0. 最后一个单元格的数字，就是我们要得到的最终答案。 j sts/LC-DP/2023-09-09-21.54.02.png) [2,1] 放葡萄情况下： 葡萄占用2，并且葡萄无法再次被选择 ， 此时问题从背包容量为2的情况下，对前一种物品取舍选择后获得的容量，变成了背包容量最大为0的情况下，对前0种物品进行取舍选择后获得的最大价值。 第2行3列的单元格，背包容量最大为3的情况下，对前面2种物品进行选择。 对于i行j列的单元格，背包容量最大为j的情况下，对前面i种物品进行选择，能使得背包价值最大，也就是说每个单元格都是当前条件下的最优解。 下面这个代码，把x,y 0的点都初始化为0. 放入的物品 https://www.bilibili.com/video/BV1jT4y1o71J/ caculate what goods were added in bag. 33:00 先从dp[5][10] ,17开始，15 !=17 所以 物品5放入了背包, 这个是 dp[4][10-3]=11+6 得出来的，我们可以用10-3 走到了dp[4][7], dp[4][7] 11 == dp[3][7] 所以物品4没有放入背包。然后走到了dp[3][7], dp[3][7] 11 != dp[2][7] 9 , 所以物品3放入背包, dp[2][7-4] + 3 = 9 . 然后走到了 dp[2[3] dp[2][3] == dp[1][3] ==6,所以物品2没有放入背包, 然后走到了 dp[1][3] dp[1][3] != dp[0][3] 说明 物品1放入背包，dp[0][3-2] + 6 , 然后就走到了dp[0][1]. and then will impement above code 1234567891011121314151617181920212223242526272829303132333435363738394041424344fun knap01(): Int &#123; val weightArr = arrayOf(1, 3, 4) val valueArr = arrayOf(15, 20, 30) val n = 5 // the number of goods val w = 8// the max of bag weight val dp = Array(n + 1) &#123; IntArray(w + 1) &#125; // 0 is nothing , so need one more //即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 //初始化 //j==0 , 背包容量为0，放物品 for (i in 1 until n) &#123; //number dp[i][0] = 0 &#125; // i==0 nothing to put in bag for (j in 1 until w) &#123; //weights dp[0][j] = 0 &#125; for (i in 0 until n) &#123; //number // i==0 , nothing to put in bag for (j in 0 until w) &#123; //weights if (weightArr[i] &gt; j) &#123; // 物品重量大于 背包容量 dp[i][j] = dp[i - 1][j] // if object weight &lt; j , then use top item &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weightArr[i]] + valueArr[i]) &#125; &#125; &#125; //这个需要后续的真题验证 val addedList = ArrayList&lt;Int&gt;() var j = w for (i in n downTo 0) &#123; if (dp[i - 1][j] &gt;= dp[i][j]) &#123; j-=weightArr[j] &#125; &#125; return dp[n][w]&#125; 滑动数组 https://www.bilibili.com/video/BV1jT4y1o71J/ 40:00 the video clearly talking about 01 knapstack problem which two ways. 正推的时候，是拿着新值， 去更新,新的值。所以第4个数会放入多次。 完全背包 1 - i 种物品可以取 n 次。 完全背包就是01背包 这个代码需要验证 1234567891011fun knapStackarray(N: Int, W: Int) &#123; val weightArr = arrayOf(1, 3, 4) val valueArr = arrayOf(15, 20, 30) val dp = Array(4) &#123; 0 &#125; for (i in 1..N) &#123; for (j in W downTo weightArr[i]) &#123; // 只有j容量大于当前物品的容量，才会考虑添加到数组中，更新当前cell的值，否则就直接用上一层的值 dp[j] = Math.max(dp[j],dp[j-weightArr[i]+valueArr[i]]) &#125; &#125;&#125; 416. 分割等和子集转化成背包问题的，1,5,11,5，背包容量11，前面题解是装到最大值但是不一定能装满，但是在这里不是拿到最大值，是装到最大值的情况,而且==11两个条件.刚好装满。 一开始打印的时候，发现超出了target,正常情况下是不可能的，加入放入新的物品后，留下的容量去之前的最大值去找，所以不可能超过. 12345678910111213141516171819202122232425262728fun canPartition(nums: IntArray): Boolean &#123; var sum = 0 nums.forEach &#123; sum += it &#125; if (sum % 2 != 0) &#123; return false // will not fill target exactly &#125; val target = sum / 2 val dp = IntArray(target + 1) println(&quot;target $target&quot;) for (i in 0 until nums.size) &#123; println() println(&quot; i $i &quot;) println() for (j in target downTo nums[i]) &#123; println(&quot; j = $j j - nums[i] = $&#123;j - nums[i]&#125; dp[j - nums[i]] $&#123;dp[j - nums[i]]&#125; &quot;) dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]) // 一开始 dp[j] 写成了dp[target]排查了很久 print(&quot; dp[j] $&#123;dp[j]&#125; &quot;) &#125; dp.printIntArray() println() &#125; if (dp[target] == target) &#123; return true &#125; return false&#125; 1049. 最后一块石头的重量 II 两堆石头如果刚好一样大小，结果就是0，所以找出最接近中间重量的石头。 也就是转化成01背包问题了。 12345678910111213141516171819 fun lastStoneWeightII(stones: IntArray): Int &#123; var sum = 0 stones.forEach &#123; sum += it // total sum &#125; val target = sum / 2 val dp = IntArray(target + 1) for (i in 0 until stones.size) &#123; for (j in target downTo stones[i]) &#123;// println(&quot; j = $j j - nums[i] = $&#123;j - stones[i]&#125; dp[j - nums[i]] $&#123;dp[j - stones[i]]&#125; &quot;) dp[j] = Math.max(dp[j - stones[i]] + stones[i], dp[j])// print(&quot; dp[j] $&#123;dp[j]&#125; &quot;) &#125;// dp.printIntArray()// println() &#125; return sum - dp[target]*2 // 这是target,而不是物品的size &#125; 494.目标和https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=d4c5260002405798a57476b318eccac9 花花酱 LeetCode 494. Target Sum 上 - 刷题找工作 EP156 - YouTube 12:00 positve 是正数的总和 negative 负数的总和 分析positive - negative = target positive + negative = sum 上面公式相加 positive = (target + sum)/2 然后就转化成 01背包问题 , 装满容量为positive的背包，有dp[positive]种方法。 确定递推公式有哪些来源可以推出dp[j]呢？ 只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。dp[j - nums[i]]， 说明装进nums[i]后,剩下dp[j - nums[i]]的方法数, 一直往前找，初始dp[j]数组的值是0, 例如：dp[j]，j 为5， 已经有一个物品1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包 那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。 所以求组合类问题的公式，都是类似这种： 1dp[j] += dp[j - nums[i]] 这个公式在后面在讲解背包解决排列组合问题的时候还会用到！ //dp[j] += dp[j - nums[i]]对这句组合数的理解： 1、如果不选第i个数（nums[i]）的话，则方法数为dp[j]； 2、如果选第i个数（nums[i]）的话，则方法数为dp[j - nums[i]]；// 所以方法总数为：dp[j] = dp[j] + dp[j - nums[i]]；（感觉这样拆开写比较容易理解） 可以对比其他01背包问题：dp[j] = max(dp[j], dp[j - nums[i]])，这种问题即是从选i与不选i里，选取最大值。 1234567891011121314151617181920212223242526272829303132333435363738fun findTargetSumWays(nums: IntArray, target: Int): Int &#123; /** * positive - negative = target * positive + negative = sum * * positive = (target + sum)/2 * */ //dp[j] += dp[j - nums[i]]对这句组合数的理解： 1、如果不选第i个数（nums[i]）的话，则方法数为dp[j]； 2、如果选第i个数（nums[i]）的话，则方法数为dp[j - nums[i]]； // 所以方法总数为：dp[j] = dp[j] + dp[j - nums[i]]；（感觉这样拆开写比较容易理解） 可以对比其他01背包问题：dp[j] = max(dp[j], dp[j - nums[i]])，这种问题即是从选i与不选i里，选取最大值。 var sum = 0 nums.forEach &#123; sum += it &#125; if (Math.abs(target)&gt;sum) return 0 // 如果target 大于 sum是不可能有值的 if ((target + sum) % 2 != 0) return 0 // positive 一定是正整数 ,这种情况下没有 val positive = (target + sum) / 2 val dp = IntArray(positive + 1) dp[0] = 1 for (i in nums.indices) &#123; for (j in positive downTo nums[i]) &#123; // j表示背包容量 println(&quot; i = $i j = $j j - nums[i] = $&#123;j - nums[i]&#125; dp[j - nums[i]] $&#123;dp[j - nums[i]]&#125; &quot;) dp[j] += dp[j - nums[i]] println(&quot; dp[j] $&#123;dp[j]&#125; &quot;) &#125; println() dp.printIntArray() println() println() &#125; return dp[positive] &#125; 这个看了很多视频，还不是特别理解， 474.一和零装满m个0,n个1 容器的背包，有哪些物品 ，其实就是01背包，只是装的物品是两个纬度。 1234567891011121314151617181920212223 fun findMaxForm(strs: Array&lt;String&gt;, m: Int, n: Int): Int &#123; val dp = Array(m + 1) &#123; IntArray(n + 1) &#125; strs.forEachIndexed &#123; index, str -&gt; var oneNum = 0 // 一开始放，外面，要在里面 var zeroNum = 0 str.forEach &#123; if (&#x27;1&#x27; == it) &#123; oneNum++ &#125; else &#123; zeroNum++ &#125; &#125; for (i in m downTo zeroNum) &#123; // for (j in n downTo oneNum) &#123;// dp[i][j] = Math.max(dp[i][j], dp[m - i][n - j] + 1) // 错的写法 dp[i][j] = Math.max(dp[i][j], dp[i-zeroNum][j - oneNum] + 1) &#125; &#125; &#125; return dp[m][n] &#125;","categories":[],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"LC-DP","slug":"LC-DP","date":"2023-04-02T09:32:31.000Z","updated":"2023-08-09T14:42:00.048Z","comments":true,"path":"2023/04/02/LC-DP/","link":"","permalink":"https://noteforme.github.io/2023/04/02/LC-DP/","excerpt":"","text":"Labuladong https://www.bilibili.com/video/BV1XV411Y7oE 重叠子问题 状态转移方程 (最关键) 最优子结构 明确状态 明确 选择 明确dp函数/数组的定义 明确base case 随想录 https://www.bilibili.com/video/BV13Q4y197Wg 动规5部曲对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！ 123451. 确定dp数组（dp table）以及下标的含义2. 确定递推公式3. dp数组如何初始化4. 确定遍历顺序5. 举例推导dp数组 动态规划解法代码框架 509. 斐波那契数随想录 迭代递推自底向上 通过for循环递推出 dp[n]的值，一开始解的时候写成了 dp[n] = dp[n - 1] + dp[n- 2] 12345678910111213141516 /** * 随想录视频思路解法1 */ fun fib1(n: Int): Int &#123;// println(n) if (n == 0) return 0 else if (n == 1) return 1 val dp = IntArray(n+1) dp[0] = 0 dp[1] = 1 for (i in 2..n) &#123; dp[i] = dp[i - 1] + dp[i - 2]// println(&quot; dp[n - 1]= $&#123; dp[n - 1]&#125; dp[n - 2]= $&#123;dp[n - 2]&#125;&quot;) &#125; return dp[n] &#125; 随想录 视频思路解法2这种解法，dp数组空间复杂度减少了。 123456789101112131415161718/** * 随想录视频思路解法2 */fun fib(n: Int): Int &#123; if (n == 0) return 0 else if (n == 1) return 1 val dp = IntArray(2) dp[0] = 0 dp[1] = 1 var sum = 0 for (i in 2..n) &#123; sum = dp[0] + dp[1] println(&quot;sum $sum dp[0]= $&#123;dp[0]&#125; , dp[1]= $&#123;dp[1]&#125;&quot;) dp[0] = dp[1] dp[1] = sum &#125; return sum&#125; labuladong把所有计算的值先保存起来，后面需要的话先直接返回，避免重复计算. 为什么申请 n+1 数组大小 因为索引从0开始 ，后面要取memory[n]，所有就申请 n+1 大小. 自顶向下 1234567891011121314151617fun fib(n: Int): Int &#123; val memory = IntArray(n + 1) if (memory[n] != 0) &#123; return memory[n] &#125; else if (n == 0) return 0 else if (n == 1) return 1 memory[n] = fib(n - 1) + fib(n - 2) return memory[n]&#125;fun fib(n: Int): Int &#123; if (n == 0) return 0 if (n == 1) return 1 return fib(n - 1) + fib(n - 2)&#125; 还有一种lablado解法一开始没想出来,双指针应该怎么操作 这个思路和随想录的思路2是一样的 1234567891011121314fun fib(n: Int): Int &#123; var pre1 = 0 var pre2 = 1 var sum = 0 if (n == 0) return 0 else if (n == 1) return 1 for (i in 2..n) &#123; sum = pre1 + pre2 // 得到当前n的num pre1 = pre2 //移动指针 pre2 = sum &#125; return sum&#125; 70 爬楼梯根据阶梯 0阶 1 // 需要返回1，2 = 1 +1,否则2就不正确了,正常理解应该返回0,不过递归解法，需要返回1 1阶 1 2阶 1+1 , 2 2 3阶 1+1+1, 1+2, 2+1 3 四阶 5 根据上面的推导，这个问题也类似于 斐波那契数 ， 看了随想录的视频，这个推导过程还是没看明白 看了这个视频推导明白了 https://www.bilibili.com/video/BV1G54y1X72H/ 进度条5分钟. 到达 k 只有 两种方式 , k-2过去和k-1过去，所以到k的所有情况就是 (k-2) + (k-1) ,我们这里讨论的是多少种不同的方法，而不用管k-2,k-1多少步到达k. k k-1 k-2 递归解法超时 1234567891011/** * 递归解法 ， 会超时 */fun climbStairs(n: Int): Int &#123; if (n == 0) return 1 // 需要返回1，2 = 1 +1,否则2就不正确了 if (n == 1) return 1 val dp = IntArray(n + 1) dp[0] = 1 dp[1] = 1 return climbStairs(n - 1) + climbStairs(n - 2)&#125; 迭代解法1234567891011fun climbStairs1(n: Int): Int &#123; if (n == 0) return 1 if (n == 1) return 1 val dp = IntArray(n + 1) dp[0] = 1 dp[1] = 1 for (i in 2..n) &#123; dp[i] = dp[i - 1] + dp[i - 2] &#125; return dp[n]&#125; 746 使用最小花费爬楼梯如果要走到dp[i] 的位置， 有两种选择，dp[i-1] + cost[i-1] ，dp[i-2] + cost[i-2]， cost就是从当前位置跳出消耗的能量值，dp[i-1] 已经包含dp[0]开始的所有 消费值。 1dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) 可以用这个推导 官方题解 这种方式比较好理解 123456789fun minCostClimbingStairs(cost: IntArray): Int &#123; val dp = IntArray(cost.size + 1) //要走完数组最后一步的下一步 dp[0] = 0 dp[1] = 0 for (i in 2..cost.size) &#123; dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) &#125; return dp[cost.size]&#125; 其他的后面在看吧 62. 不同路径这题二叉树解法没看懂，给忘了。 递归公式的推导， 1那么很自然，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。 dp数组的初始化 1如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，因为只能向右向下走，那么dp[0][j]也同理。 所以初始化代码为： 12for (int i = 0; i &lt; m; i++) dp[i][0] = 1;for (int j = 0; j &lt; n; j++) dp[0][j] = 1; 可以根据上图来推导出 dp[i][j] i =1 时 , j 代入进去进行推导。 j = 1 : dp[i][j] = dp[i-1][j] + dp[i][j-1] j = 2 : dp[i][j] = dp[i-1][j] + dp[i][j-1] j = 3 : dp[i][j] = dp[i-1][j] + dp[i][j-1] 然后逐步就能推导出所有的值,注意dp[m][n] 要-1,否则会越界。 1234567891011fun uniquePaths(m: Int, n: Int): Int &#123; val dp = Array(m) &#123; IntArray(n) &#125; for (i in 0 until m) dp[i][0] = 1 for (j in 0 until n) dp[0][j] = 1 for (i in 1 until m) &#123; for (j in 1 until n) &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] &#125; &#125; return dp[m-1][n-1]&#125; 63. 不同路径 II原理还是一样，从左到右,array[i][0] : array[0][0],array[1][0],array[2][0] ，从上到下 进行推导。 这一题是上一题的拓展版本 通过62题可以看到 m 是竖线，n是横线。 [0][0] [m-1][n-1] 那么不可能有有路径往后走了。 有一点不同的是，如果是有障碍，后面就不用初始化了。 还有一点不同的是，如果要找的位置没有障碍物，才有求出递推值的意义。 递推公式和前面差不多 ，在处理递推公式的时候，看上图，前一步有障碍物的时候，影响的是 dp[i-1] dp[j-1] 前一步的一个值。 后续递推的时候，碰到obstacles后，obstacles的点就是0，所以下一个点就是障碍物 0 和另一个点相加。 123456789101112131415161718192021222324fun uniquePathsWithObstacles(obstacleGrid: Array&lt;IntArray&gt;): Int &#123; val m = obstacleGrid.size // 表示有多少个数组 val n = obstacleGrid[0].size // 其中一个数组的长度 if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0 // if there are obstacle in these two points, will no path. val dp = Array(m) &#123; IntArray(n) &#125; for (i in 0 until m) &#123; // 里面再加个条件不好加 if (obstacleGrid[i][0] == 1) break // when init dats, hit path , following init will 0 dp[i][0] = 1 // 前面[i][0] i表述多少个数组 &#125; for (j in 0 until n) &#123; if (obstacleGrid[0][j] == 1) break dp[0][j] = 1 // [0][j] 后面表述一个数组的长度 &#125; for (i in 1 until m) &#123; for (j in 1 until n) &#123; if (obstacleGrid[i][j] != 1) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1] &#125; &#125; &#125; return dp[m - 1][n - 1]&#125; 343. 整数拆分我们按照动规 5 部曲来分析先 确定dp数组（dp table）以及下标的含义 拆分i，最大乘积是dp[i] 确定递推公式 这一步是比较难的， 对 i 进行拆分，看了随想录的视频，有3种可能 第一种: 拆成2个数的情况 i * j 也就是 dp[i] = i * (i-j) 第二种：拆成2个数以上的情况 : dp[i] = i * dp[i-j] 这种可以用6来测试拆分 1 * 5 2 * 4 3 * 3 4 * 2 5 * 1 上面我们可以只拆分j, 我们有必要拆分i吗，其实是没必要的， 我的理解是2 * 4 中， 2已经被 1 * 5 中的5包含了， 那么5 拆成 2 *1 * 1 * 1 就包括了 2的情况，不知道我的理解对不对。 第三种 : 就是 i本身。 123456789101112131415161718192021222324252627282930313233343536 fun integerBreak(n: Int): Int &#123; if (n == 2) return 1 // 1+1 val dp = IntArray(n + 1) dp[0] = 0 dp[1] = 0 dp[2] = 1 for (i in 3..n) &#123; for (j in 1 until i) &#123;// println(&quot;i $i j $j &quot;) val a = j * (i - j) val b = j * dp[i - j]// maxNum = max(a, b, i) println(&quot;j * (i - j) $j * ($i - $j) a =$a dp[i - j] $&#123;dp[i - j]&#125; b= $b &quot;)// maxNum = max(a, b,dp[i])// maxNum= max(a,b)// val abMax = max(a, b)// println(&quot;abMax $abMax dp[$i] $&#123;dp[i]&#125; &quot;) dp[i] = max(a, b, dp[i]) // dp[i] 初始值是0，所以得出的值还是从a,b中拿到最大值 &#125;// println(&quot;dp[$i] $&#123;dp[i]&#125;&quot;) &#125; return dp[n] &#125;fun max(a: Int, b: Int, c: Int): Int &#123; var max = a if (b &gt; max) &#123; max = b &#125; if (c &gt; max) &#123; max = c &#125; return max&#125; 96. 不同的二叉搜索树​ 上面是i==3的情况， root node =1的时候， left tree 0 , right tree 2种情况 , 右子树和 root node =2的树的结构是一样的。 root node =2的时候， left tree 1 , right tree 1种情况, 左，右子树和 root node =1的树的结构是一样的。 root node =3的时候， left tree 2 , right tree 0种情况. 左子树和 root node =2的树的结构是一样的。 所以 dp[3] = (root node ==1 +dp[2]) + (root node ==2 +dp[1]) + (root node ==3 +dp[2]) dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量 有2个元素的搜索树数量就是dp[2]。 有1个元素的搜索树数量就是dp[1]。 有0个元素的搜索树数量就是dp[0]。 所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2] 这个图更直观 确定dp数组（dp table）以及下标的含义目前可以根据下面推导来，确认dp数组的含义。dp[1] =1dp[2]= 2dp[3] =5 确定递推公式这个没推导出来，i j没搞清楚。把随想录的拿过来12345在上面的分析中，其实已经看出其递推关系， dp[i] +&#x3D; dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]j相当于是头结点的元素，从1遍历到i为止。所以递推公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量 dp数组如何初始化 确定遍历顺序 举例推导dp数组 12345678910111213141516 fun numTrees(n: Int): Int &#123; // 1. 确定dp数组（dp table）以及下标的含义 val dp = IntArray(n + 1) dp[0] = 1 dp[1] = 1 //3. dp数组如何初始化 //4.确定遍历顺序 for (i in 2 ..n) &#123; for (j in 1 ..i) &#123; // 注意这里边界，一开始都 没加==// println(&quot; dp[$i] $&#123;dp[i]&#125; += (dp[j - 1] $&#123;dp[j - 1]&#125; * dp[i - j]) $&#123;dp[i - j]&#125; j = $j&quot;) dp[i] += (dp[j - 1] * dp[i - j]) //2.确定递推公式 &#125; &#125; return dp[n] &#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"RecyclerView-padding","slug":"RecyclerView-padding","date":"2023-01-10T07:16:04.000Z","updated":"2023-02-23T14:17:11.783Z","comments":true,"path":"2023/01/10/RecyclerView-padding/","link":"","permalink":"https://noteforme.github.io/2023/01/10/RecyclerView-padding/","excerpt":"","text":"修改Display scaling属性后，即使设置字体是dp也会导致，也会出现Text内容的有变化。 计算转账页面的padding,5个TextView平分屏幕宽度，之前nexus5没问题，因为是刚好2倍，我的手机就是有问题，原来是dp转px有损耗。 1234567@get:JvmName(&quot;dp2px&quot;)val Float.dp: Float get() = convert(this, TypedValue.COMPLEX_UNIT_DIP)@get:JvmName(&quot;dp2px&quot;)val Int.dp: Int get() = convert(this.toFloat(), TypedValue.COMPLEX_UNIT_DIP).toInt() 然后用 2f.dp这样就能避免dp转px的损耗。 其实选择上面这个方法就能解决这个问题。 字体测量方法 1234567fun getTextLength(typeface: Typeface, txt: String): Int &#123; val paint = Paint() paint.typeface = typeface paint.textSize = 12f.dp.toFloat() val textWidth = paint.measureText(txt) return textWidth.toInt()&#125; 文字宽度 https://www.cnblogs.com/dasusu/p/6602710.html https://www.jianshu.com/p/9fc07c3311c1 https://www.laoyuyu.me/2020/08/03/android/text_measure_wh/","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://noteforme.github.io/tags/RecyclerView/"}]},{"title":"LC-GREEDY","slug":"LC-GREEDY","date":"2023-01-02T14:42:03.000Z","updated":"2023-04-02T11:24:38.736Z","comments":true,"path":"2023/01/02/LC-GREEDY/","link":"","permalink":"https://noteforme.github.io/2023/01/02/LC-GREEDY/","excerpt":"","text":"https://www.bilibili.com/video/BV1sA4y1S7Sp 这个视频讲到暴力 对数器可以验证答案，有意思。 有同学问了如何验证可不可以用贪心算法呢？ 刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。 贪心算法一般分为如下四步： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。 做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。 https://www.bilibili.com/video/BV1XY411A766 https://www.bilibili.com/video/BV1Hz4y117CP/ 455.分发饼干分解题目 每个孩子最多只能给一块饼干。 每个孩子 i，都有一个胃口值 g[i]，每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i。 Idea1g &#x3D; [1,3], s &#x3D; [1,2,4] 对孩子的胃口值和， 饼干的大小进行排序，得到两行数组。 如上面示例，s中的s[0]=1饼干大小，满足g[0]=1 孩子的胃口值,那么同时向右移动.s[1]=2 不满足g[1],s指针向右移动，s[2]满足g[1]. 这样所有孩子都满足了。 上面思路和随想录的不一样，随想录的是大饼干喂 胃口值大的孩子，不过觉得我这个更好理解。 Code123456789101112131415161718fun findContentChildren(g: IntArray, s: IntArray): Int &#123; if (s.isEmpty()) return 0 Arrays.sort(g) // 写了s.isEmpty()， 一开始忘了加这个排序 Arrays.sort(s) var pg = 0 var ps = 0 var count = 0 while (pg &lt; g.size &amp;&amp; ps &lt; s.size) &#123; // 控制边界 if (s[ps] &gt;= g[pg]) &#123; //饼干满足孩子的胃口大小. count++ pg++ ps++ &#125; else &#123; ps++ //饼干不满足孩子的胃口大小，饼干数组指针往右走. &#125; &#125; return count&#125; 376摆动序列Idea摆动序列，其实求波峰 波谷的个数，所以有一个方向改变就算一个波动。 根据图1可以看到 preDiff = 17-1 &gt;0 , curveDiff = 5 -10&lt;0 ，这个就是一个摆动序列。还有 preDiff = 5-10 &lt;0 , curveDiff = 16 -5&gt;0 的情况，这又是另一种情况的摆动序列。 根据图2可以看到 preDiff ==0 , curveDiff = 5 -2 &gt; 0, preDiff ==0 , curveDiff = 5 -8 &gt; 0, 题目说 两个不等元素的序列也视作摆动序列。所以这种情况也是摆动序列。 但是我感觉这个和前面的 “如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列”,是有矛盾的。 根据 1.2,所以条件可以合并, preDiff &gt;=0 , curveDiff &lt;=0 ,preDiff &lt;=0 , curveDiff &gt;=0 图3，只有2个摆动，但是根据根据1，2的总结代码在2,3节点处，红色pre的地方也有1个摆动，这种情况要去掉，因为他是同方向的摆动。所以pre应该停在绿色的地方，只有摆动发生她才需要改变，平波不用管。 12345678910111213141516fun wiggleMaxLength(nums: IntArray): Int &#123; if (nums.size &lt;= 1) &#123; return nums.size &#125; var preDiff = 0 //前一对差值 var curveDiff = 0 var result = 1 for (i in 1 until nums.size) &#123; // 第一个数已经计入摆动序列了，所以从1开始 curveDiff = nums[i] - nums[i - 1] // 因为要给值给preDiff，所以从i开始，随想录c++解法是从0开始的。 if ((preDiff &gt;= 0 &amp;&amp; curveDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curveDiff &gt; 0)) &#123; result++ preDiff = curveDiff &#125; &#125; return result&#125; 53 最大子序和 -2, 1, -3, 4, -1, 2, 1, -5, 4 *Q *P IDEA 题意是找到最大和的连续子数组， 所以是不能对数组排序。 这题可以考虑用双指针解法，移动*p，从0开始 加上指针对应的计数。如果计数增加则是正数计入，如果减小则重置，移动 *q指针。 上面这个思路是不行的，4, -1, 2, 1这种就有问题。 间隔后新的黄色部分是重置数据。 根据随想录的思路 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。 这句话看起来有问题，但是也拿不出反例. 123456789101112fun maxSubArray(nums: IntArray): Int &#123; var result = 0 var maxResult = Int.MIN_VALUE for (pIndex in nums.indices) &#123; result += nums[pIndex] maxResult = maxResult.coerceAtLeast(result) if (result &lt; 0) &#123; result = 0 &#125; &#125; return maxResult&#125; 122 买卖股票的最佳时机 II127, 1, 5, 3, 6, 4 -6 4 -2 3 -2 假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。 此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！ 那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。 1234567891011121314fun maxProfit(prices: IntArray): Int &#123; val diffArray = IntArray(prices.size - 1) for (i in 1 until prices.size) &#123; println(i) diffArray[i - 1] = prices[i] - prices[i - 1] &#125; var sum = 0 for (i in diffArray.indices) &#123; if (diffArray[i] &gt; 0) &#123; sum += diffArray[i] &#125; &#125; return sum&#125; 55 跳跃游戏[2,3,1,1,4] 题意给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度，比如在2的位置，可以跳一格到3的位置，也可以两格到1的位置。 上面第二幅图，第一条线应该有问题，应该覆盖到2 3 1 遍历每个位置，确定每个位置能覆盖的最大范围。 12345678910fun canJump(nums: IntArray): Boolean &#123; var coverArea = 0 for (i in 0..coverArea) &#123; // 注意:这里是coverArea,需要确定能走多少步 coverArea = (i + nums[i]).coerceAtLeast(coverArea) //新的范围和 之前的范围做比较 if (coverArea &gt;= nums.size - 1) &#123; return true &#125; &#125; return false&#125; 45 跳跃游戏 IIIdea题目意思 总是可以到达数组的最后一个位置 1234567891011121314151617fun jump(nums: IntArray): Int &#123; var maxCover = 0 var count = 0 for (i in 0..maxCover) &#123; if (i + nums[i] &gt; maxCover) &#123; maxCover = i + nums[i] &#125; else &#123; count++ &#125; if (maxCover &gt;= nums.size) &#123; println(&quot;count $count&quot;) return count &#125; &#125; return count&#125; 找到能覆盖的最远距离，如果移动到了这个地方，那么就计算一次，直到 nums.size - 1- 1个节点，然后再count++就可以了。 12345678910111213fun jump(nums: IntArray): Int &#123; var nextCover = 0 var count = 0 var currentCover = 0 for (i in 0 until nums.size - 1) &#123; nextCover = Math.max(i + nums[i], nextCover) if (i == currentCover) &#123; currentCover = nextCover count++ &#125; &#125; return count&#125; 1005. K 次取反后最大化的数组和 先对数组进行排序，把 &lt; 0的数按位取反 ,直到数组的数据都&gt;0,此时翻转了n次 对翻转后的数组重新进行排序，对最小的数 翻转 k-n 次 My Idea 1234567891011121314151617181920fun largestSumAfterKNegations(nums: IntArray, k: Int): Int &#123; Arrays.sort(nums) var balanceK = 0 for (i in 0 until k) &#123; // kotlin用while 应该更好 if (i &gt;= nums.size || nums[i] &gt; 0) &#123; balanceK = k - i break &#125; nums[i] = Math.abs(nums[i]) &#125; Arrays.sort(nums) if (balanceK &gt; 0 &amp;&amp; (balanceK % 2) &gt; 0) &#123; nums[0] = -nums[0] &#125; var sum = 0 for (value in nums) &#123; sum += value &#125; return sum&#125; 这个也可以 https://www.bilibili.com/video/BV1iY411s7qB 1234567891011121314151617181920fun largestSumAfterKNegations(nums: IntArray, k: Int): Int &#123; val typedArray = nums.toTypedArray() // 转成数组 Arrays.sort(typedArray, Comparator.comparingInt(Math::abs)) // 按照绝对值排序 var k = k for (i in typedArray.indices) &#123; if (k &gt; 0 &amp;&amp; typedArray[i] &lt; 0) &#123; // 碰到数组中&gt;0的数 typedArray[i] *= -1 k-- &#125; &#125; Arrays.sort(typedArray) if (k % 2 &gt; 0) &#123; typedArray[0] *= -1 &#125; var sum = 0 for (value in nums) &#123; sum += value &#125; return sum&#125; 参考随想录，但是编译不通过 https://www.bilibili.com/video/BV138411G7LY 134 加油站暴力解法1234567891011121314fun canCompleteCircuit(gas: IntArray, cost: IntArray): Int &#123; for (i in gas.indices) &#123; var balance = gas[i] - cost[i] var index = (i + 1) % gas.size while (balance &gt; 0 &amp;&amp; i != index) &#123; // 还有油的话，没走完一圈，继续走 balance += (gas[index] - cost[index]) index = (index + 1) % gas.size &#125; if (balance &gt;= 0 &amp;&amp; (index == i)) &#123;//走完一圈，返回下标 return i &#125; &#125; return -1&#125; 贪心解法这里k不用看 https://www.bilibili.com/video/BV1DF411L7cz j 到 j+1跑不到 , 从i 到 j +1 油量&lt;0 因为 i 能开到j,从 i 出发到 i+1 油量 &gt;=0 , 那么 i+1 到 j+1 油量一定 &lt;0. 如果起点在 i+1, 因为 i 到j+1&lt;0 ,因此 i 到 i+1&gt;=0 , i+1 到j+1一定&lt;0. 总结来看, i 到 j+1&lt;0 ,中间不用看，直接从 j+1开始即可。 LC134我的解法有问题，看到随想录的解法后感觉很妙 1234567891011121314151617fun canCompleteCircuit(gas: IntArray, cost: IntArray): Int &#123; var totalSum = 0 // 所有路程需要的油量 var currentSum = 0 // 当前位置开始所需要的油量 var start = 0 for (i in gas.indices) &#123; totalSum += gas[i] - cost[i] currentSum += gas[i] - cost[i] if (currentSum &lt; 0) &#123; // 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新 start = i + 1 currentSum = 0 &#125; &#125; if (totalSum &lt; 0) &#123; return -1 &#125; return start&#125; 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新. j ,j+1是负数节点,如果存在这样一个节点,满足条件，那么j+1开始后面一圈的一定都是&gt;0 135 分发糖果12[1,2,2] 1 2 1 &#x2F;&#x2F;为什么array[2] 糖果是1，因为题目意思只有评分高才有更多的糖果，相等的情况按照最少的1个糖果了。 0 1 2 3 4 5 6 1 2 2 5 4 3 2 1 2 1 2 1 1 1 左&lt;右 1 1 1 2 2 2 1 1 2 1 4 3 2 1 左&gt;右 Idea需要一边一边考虑，否则顾此失彼 先考虑 左边孩子粉丝的情况 &lt; 右边孩子分数 ，此时需要从左往右, 得到第三行的分数. 再考虑 左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左，因为这种情况需要依赖，右边的孩子。如果从左到右，得到第4行结果，此时 2 3 4 5都是错的。 然后从右往左的过程，还需要考虑之前 左边孩子&lt; 右边的情况，所以取最大值。 code1234567891011121314151617181920212223242526272829 fun candy(ratings: IntArray): Int &#123; val answer = IntArray(ratings.size) answer[0] = 1// 左边孩子粉丝的情况 &lt; 右边孩子分数 ，此时需要从左往右 for (i in 1 until ratings.size) &#123; if (ratings[i] &gt; ratings[i - 1]) &#123; answer[i] = answer[i - 1] + 1 &#125; else &#123; answer[i] = 1 &#125; &#125; println() answer.printIntArray() //左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左 for (i in ratings.size - 1 downTo 1) &#123; if (ratings[i - 1] &gt; ratings[i]) &#123; answer[i - 1] = answer[i - 1].coerceAtLeast(answer[i] + 1) &#125; &#125; answer.printIntArray() var sum = 0 for (i in answer) &#123; sum += i &#125; return sum &#125; 860 柠檬水找零Idea 一开始想到的是暴力解法， 用map 存 5 , 10两种金额的个数，20不用考虑 来了5存起来 map5 +1，来了10存起来 map10+1 , map5 -1 , 来了20， map10-1, map5-1 code 暴力解法12345678910111213141516171819202122232425fun lemonadeChange(bills: IntArray): Boolean &#123; val map &#x3D; HashMap&lt;Int, Int&gt;() for ((index, money) in bills.withIndex()) &#123; if (money &#x3D;&#x3D; 5) &#123; map[5] &#x3D; map.getOrDefault(5, 0).plus(1) &#125; else if (money &#x3D;&#x3D; 10) &#123; map[5] &#x3D; map.getOrDefault(5, 0) - 1 map[10] &#x3D; map.getOrDefault(10, 0).plus(1) &#125; else &#123; &#x2F;&#x2F;for 20 rmb if (map.getOrDefault(10, 0) &gt; 0 &amp;&amp; map.getOrDefault(5, 0) &gt; 0) &#123; &#x2F;&#x2F;at lease 10rmb 1 , 5rmb 1 map[10] &#x3D; map.getOrDefault(10, 0) - 1 map[5] &#x3D; map.getOrDefault(5, 0) - 1 &#125; else if (map.getOrDefault(5, 0) &gt; 2) &#123; &#x2F;&#x2F; at least 3 * 5 rmb map[5] &#x3D; map.getOrDefault(5, 0) - 3 &#125; else &#123; return false &#125; &#125; println(&quot; index $index map5 $&#123;map[5]&#125; map10 $&#123;map[10]&#125; &quot;) if (map.getOrDefault(5, 0) &lt; 0 || map.getOrDefault(10, 0) &lt; 0) &#123; return false &#125; &#125; return true&#125; 看了随想录的解法，和我的解法类似，知识map中的值可以用变量来做. 12int five = 0, ten = 0, twenty = 0;这样++,--更方便. https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF 406 根据身高重建队列Idea 随想录对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？ 如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。 那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。 此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！ 123456789101112131415161718fun reconstructQueue(people: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123; Arrays.sort(people, object : Comparator&lt;IntArray&gt; &#123; override fun compare(o1: IntArray, o2: IntArray): Int &#123; if (o2[0] &#x3D;&#x3D; o1[0]) &#123; &#x2F;&#x2F; 如果身高相同，k小的排在前面 return o1[1] - o2[1] &#125; return o2[0] - o1[0] &#x2F;&#x2F; 对数组先按照身高来排序 &#125; &#125;) val linkedList &#x3D; LinkedList&lt;IntArray&gt;() for (value in people)&#123; val index &#x3D; value[1] linkedList.add(index,value) &#x2F;&#x2F; 按照k插入对应的位置, 这里插入时很容易越界。 &#125; return linkedList.toTypedArray()&#125; 452. 用最少数量的箭引爆气球IDEA 先对数组按照左边界大小进行排序。 如果当前i数组右边的值 &gt; 或者前面数组重叠区域的最小右边界， 此时没有重叠（和之前的共有区域），数量+1 否则有重叠，取最小右边界值。 一开始看题解，没理解特别是 points[i][1] 1points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界 123456789101112131415161718 fun findMinArrowShots1(points: Array&lt;IntArray&gt;): Int &#123;// Arrays.sort(points)&#123;o1,o2 -&gt; o1[0] - o2[0]&#125; 这个回报越界错 [[-2147483646,-2147483645],[2147483646,2147483647]] points.sortBy&#123;it[0]&#125; var count = 1 for (i in 1 until points.size) &#123; if (points[i][0] &gt; points[i - 1][1]) &#123; // 如果当前气球的左边界 &gt; 公共右边界 count++ &#125; else &#123; // 没有大于公共右边界 //points[i][1] = points[i][1].minus(points[i - 1][1]) // 用minus是有问题的 points[i][1] = points[i][1].coerceAtMost(points[i - 1][1]) // 更新重叠气球最小右边界 &#125; &#125;// points.printDimensionalArray() return count &#125; 1 6 ​ 2 8 ​ 7 12 ​ 10 16 使用chatGPT的算法，更好确定右边界, 如果新的左边界&gt;之前的右边界+1 , 使用新的数据，并且确定右边界。 The solution sorts the balloons by their end positions in ascending order, and then uses a greedy algorithm to shoot the balloons. We start with the first balloon and set end to its end position. Then, we iterate through the rest of the balloons and compare their start positions to end. If the start position of a balloon is greater than end, we shoot another arrow and update end to the end position of the current balloon. At the end, the function returns the number of arrows shot. 123456789101112131415fun findMinArrowShots(points: Array&lt;IntArray&gt;): Int &#123; if (points.isEmpty()) return 0 points.sortBy &#123; it[1] &#125; var arrows = 1 var end = points[0][1] for (i in 1 until points.size) &#123; if (points[i][0]&gt;end) &#123; arrows++ end = points[i][1] &#125; &#125; return arrows&#125; 435. 无重叠区间[1,2] [3,6] [7,12] [4,8] [10,16] 1 2 ​ 3 6 ​ 4 8 ​ 7 12 ​ 10 16 https://www.bilibili.com/video/BV1A14y1c7E1 左边数组进行排序。1231. if [i][0] &lt; [i-1][1] 说明会有重合，那么求出 [i][1] [i-1][1]中的最小值，作为右边界，更新数量否则就没重合更新右边界限。2. 否则，没有重合直接更新 end。 12345678910111213141516 fun eraseOverlapIntervals(intervals: Array&lt;IntArray&gt;): Int &#123; if(intervals.isEmpty()) return 0 var count = 0 Arrays.sort(intervals) &#123; a, b -&gt; a[0] - b[0] &#125; // 按照左边数组进行排序 var end = intervals[0][1] for (i in 1 until intervals.size) &#123; if (intervals[i][0] &lt; end) &#123; //重合的情况 count++ end = end.coerceAtMost(intervals[i][1]) // 确定最小重合的 右边界, 这里一开始弄错了 &#125; else &#123; end = intervals[i][1] &#125; &#125;// intervals.printDimensionalArray() return count &#125; 右边数组排序这种解法不理解. 根据随想录的思路，总的个数 - 非交叉个数 = 交叉个数。 这里的难点是要知道交叉后的右边界的 如果3在 1,2 右边最小值的左边，所以3条线还会有交叉，如果在1，2最小值的右边那么 2去掉就可以了，还是去掉1。 1234567891011121314151617 fun eraseOverlapIntervals(intervals: Array&lt;IntArray&gt;): Int &#123; if (intervals.isEmpty()) return 0 var count = 1 //非交叉区间个数 Arrays.sort(intervals) &#123; a, b -&gt; a[1] - b[1] &#125; // 按照左边数组进行排序 var end = intervals[0][1] for (i in 1 until intervals.size) &#123; if (intervals[i][0] &gt;= end) &#123; count ++ end = intervals[i][1] &#125;// else&#123;// end = intervals[i][1].coerceAtMost(end) // 这个不需要// &#125; &#125;// intervals.printDimensionalArray() return intervals.size - count &#125; 12 763 划分字母区间idea 遍历出每个字母的最远距离，出现的座标。 根据字母的hash值得到当前的座标，后面如果有重复的hash,会覆盖前面的。 遍历后序列找 当前字母hash值 == i , right = i 拿到当前 right + 1 - left, 就是片段的长度。 然后更新left值. ​ 12345678910111213141516171819 fun partitionLabels(s: String): List&lt;Int&gt; &#123; val result = arrayListOf&lt;Int&gt;() val hash = IntArray(26) for (i in s.indices) &#123; hash[s[i] - &#x27;a&#x27;] = i &#125; var left = 0 var right = 0 for (i in s.indices) &#123; right = hash[s[i] - &#x27;a&#x27;].coerceAtLeast(right) // 要找到当前hash值的最大值 if (right == i) &#123; //如果 hash值的最大值 和座标相等，就用到了分割点 result.add(right + 1 - left) left = i + 1 &#125; &#125;// hash.printIntArray() return result &#125; 56 合并区间Idea My初始化 left. right 按照左边数组 排序。 如果没重合直接[left,right]把前面数组加入区间 。 如果重合，那么确定 right右边界，判断 [i][0]和right,确定右边界，把right放入右边界。 1234567891011121314151617fun merge(intervals: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123; Arrays.sort(intervals) &#123; a, b -&gt; a[0] - b[0] &#125; var left = intervals[0][0] var right = intervals[0][1] val arrayOf = arrayListOf&lt;IntArray&gt;() for (i in 1 until intervals.size) &#123; if (intervals[i][0] &lt;= right) &#123; right = right.coerceAtLeast(intervals[i][1]) &#125; else &#123; arrayOf.add(intArrayOf(left, right)) left = intervals[i][0] right = intervals[i][1] &#125; &#125; arrayOf.add(intArrayOf(left, right)) return arrayOf.toTypedArray()&#125; Idea 2看了随想录的题解，觉得比我上面的更好，只需要更新右边界。 1 3 ​ 2 6 8 10 15 18 ​ 还是按照数组左边界排好序。 把第一组数组放入结果数组中，然后取出来，用它的右边界和第二组数组的左边界比较大小. 如果新的数组的左边界 &lt; 结果数组的右边界，说明有重合，更新结果数组的右边界。 如果新的数组的左边界 &gt; 结果数组的右边界,没有重合，新数组直接添加到结果数组集中。 738 单调递增的数字Idea看了随想录的题解 那么拿一个两位的数字来举例。 例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。 此时是从前向后遍历还是从后向前遍历呢？ 这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。 那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299 确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。 Code初始的想法 12345678910fun monotoneIncreasingDigits(n: Int): Int &#123; val arrStr = n.toString().toCharArray() for (i in arrStr.size - 1 downTo 1) &#123; if (arrStr[i - 1] &gt; arrStr[i]) &#123; arrStr[i] = &#x27;9&#x27; arrStr[i - 1] = arrStr[i - 1].toInt().minus(1).toChar() &#125; &#125; return String(arrStr).toInt()&#125; 100 跑完后变成90,其实后面所有位都要变成 ‘9’,只有当前位减1 找到 minus 1 的位置，后面的位都变成9 1234567891011121314fun monotoneIncreasingDigits(n: Int): Int &#123; val arrStr = n.toString().toCharArray() var position = arrStr.size //初始位置不能是 arrStr.size - 1 ，否则最后一位都会变成 &#x27;9&#x27; for (i in arrStr.size - 1 downTo 1) &#123; if (arrStr[i - 1] &gt; arrStr[i]) &#123; arrStr[i - 1] = arrStr[i - 1].toInt().minus(1).toChar() // digitToInt leetcode跑不了 position = i // 找到-1 的位置，后面的位都变成9 &#125; &#125; for (i in position until arrStr.size) &#123; arrStr[i] = &#x27;9&#x27; &#125; return String(arrStr).toInt()&#125; 968 监控二叉树这题比较难，暂时没必要写。","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"","slug":"Activity_Stack","date":"2023-01-02T03:31:38.914Z","updated":"2024-06-13T11:19:05.839Z","comments":true,"path":"2023/01/02/Activity_Stack/","link":"","permalink":"https://noteforme.github.io/2023/01/02/Activity_Stack/","excerpt":"","text":"ActivityAn activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).Acitivty和用户交互，所以也是用的最多的 lifecycle onCreate(): Activity创建的时候调用，绑定数据。 onStart() : 当Activity对用户变得可见的时候调用. onResume() : activity开始和用户交互的时候调用，这时候activity处于栈顶，伴随着用户的输入. onPause() : 当activity失去前台状态，开始进入stopped&#x2F;hidden or destroyed状态，不能再获取焦点，此时activity对用户可见，但是更新的UI的操作要快。 onStop() : 当activity不再可见，可能是新的activity来到栈顶，或者当前activity正在被destroy. onDestory(): 当前activity正在离开。 想到一个问题:界面Ａ到界面Ｂ，是Ａ的onStop()先执行 还是Ｂ的onResume()先走先用事实说话吧 I/BaseActivity: MainActivity -- onCreate() -- I/BaseActivity: MainActivity -- onStart() -- I/BaseActivity: MainActivity -- onResume() -- I/BaseActivity: MainActivity -- onPause() -- I/BaseActivity: StopResumeActivity -- onCreate() -- I/BaseActivity: StopResumeActivity -- onStart() -- I/BaseActivity: StopResumeActivity -- onResume() -- I/BaseActivity: MainActivity -- onStop() -- 从打印结果可以看到StopResumeActivity.onResume()先执行,然后是MainActivity的onStop onStop() :大概知道原因，但是还是不够说服力，因为onStart()方法已经对用户可见了，为什么MainActivity – onStop()不在 StopResumeActivity – onStart()后面呢？ 可能是onResume()调用后，新activity位于栈顶，之前的再onStop() https://blog.csdn.net/c6E5UlI1N/article/details/119549972 OnNewIntent()onNewIntent added in API level 1 1void onNewIntent (Intent intent) if the Activity was already created and a new Intent is being delivered to onNewIntent(android.content.Intent) This is called for activities that set launchMode to “singleTop” in their package, or if a client used the FLAG_ACTIVITY_SINGLE_TOP flag when calling startActivity(Intent). In either case, when the activity is re-launched while at the top of the activity stack instead of a new instance of the activity being started, onNewIntent() will be called on the existing instance with the Intent that was used to re-launch it. An activity will always be paused before receiving a new intent, so you can count on onResume() being called after this method. Note that getIntent() still returns the original Intent. You can use setIntent(Intent) to update it to this new Intent. Parameters intent Intent: The new intent that was started for the activity. 这个方法用于singleTop singleTask两种启动模式 先看看 singleTask方式：FirstActivity 12&lt;activity android:name=&quot;.launchmode.FirstActivity&quot; android:launchMode=&quot;singleTask&quot;/&gt; ​ 从 FirstActivity –&gt; LaunchActivity –&gt; FirstActivity 生命周期方法 04-24 11:49:14.602 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onCreate() 04-24 11:49:14.672 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onStart() 04-24 11:49:14.679 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onResume() 04-24 11:49:32.085 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onPause() 04-24 11:49:32.099 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onCreate() 04-24 11:49:32.127 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onStart() 04-24 11:49:32.132 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onResume() 04-24 11:49:32.462 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onStop() 04-24 11:49:53.681 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onPause() 04-24 11:49:53.701 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onNewIntent(Intent intent) 04-24 11:49:53.702 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onStart() 04-24 11:49:53.703 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onResume() 04-24 11:49:54.049 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onStop() 04-24 11:49:54.049 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onDestroy() 然后可以通过 onNewIntent(Intent intent);获取传回来的数据 12345String data1 = intent.getStringExtra(newIntent);String data2 = getIntent().getStringExtra(newIntent); //这种方式获取不到setIntent(intent); //通过这种设置获取String data3 = getIntent().getStringExtra(newIntent);Timber.d(&quot;onNewIntent &quot; + data3); 为什么要设置 setIntent(intent) 我们在多次启动同一个栈唯一模式下的activity时，在onNewIntent()里面的getIntent()得到的intent感觉都是第一次的那个数据。对，这里就是这个陷阱。因为它就是会返回第一个intent的数据 ActivityStackTaskRecord不同的应用就不同的 任务栈 安卓系统管理着不同模式下的多个ActivityStack（比如在home launcher界面需要有一个ActivityStack，画中画模式，分屏模式等），一个ActivityStack可以包含很多个TaskRecord，一个TaskRecord又可以包含很多个ActivityRecord。 每一个ActivityRecord都会有一个Activity与之对应，一个Activity可能会有多个ActivityRecord，因为Activity可以被多次实例化，取决于其launchmode。一系列相关的ActivityRecord组成了一个TaskRecord，TaskRecord是存在于ActivityStack中，ActivityStackSupervisor是用来管理这些ActivityStack的。 taskAffinity清单文件中Application和Activity标签都可以使用android:taskAffinity，值为String类型。 它代表这个Activity所希望归属的Task，在默认情况下，同一个app中的所有Activity拥有共同的Affinity，即manifest中定义的package。 另外task的affinity取决于它的根部Activity。 如果使用SingleInstance模式启动的Activity，如果没有指定affinity的话，创建的新task的affinity还是app的包名。 FLAG_ACTIVITY_NEW_TASK在默认情况下，目标Activity将与startActivity的调用者处于同一task中。但如果用户特别指定了FLAG_ACTIVITY_NEW_TASK，表明它希望为Activity重新开设一个Task。这时就有两种情况： 假如当前已经有一个Task，它的affinity与新Activity是一样的，那么系统会直接用此Task来完成操作，而不是另外创建一个Task； 否则系统需要创建一个Task。 allowTaskReparenting 什么意思Activity launch mode启动模式 Androidmanifest 设置 launch mode是对目标Activity而言 Intent flag比 Androidmanifest的优先级更高 4种启动模式我理解的启动模式，针对的是被启动的Activity standard 在不同的Task中打开同一个Activity，Activity会被创建多个实例。分别放进打开它的Task中。 例如: 点开短信中的电话号码， 新的 打电话的Activity会存在于 短信Task中。 singleTop singleTask The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance of the activity can exist at a time. 只会在一个Task出现,这个Task里只有一个这个Activity，全局唯一 singleInstance Same as &quot;singleTask&quot;, except that the system doesn’t launch any other activities into the task holding the instance. The activity is always the single and only member of its task; any activities started by this one open in a separate task. 除了全局唯一，还会独占一个Task taskAffinity每个Activity都有一个taskAffinity，默认取自Activity所在的Application的taskAffinity,而后者又默认取自app包名. 每个Task也有它自己的taskAffinity，它取自栈底的Activity的taskAffinity 默认情况下，Activity会直接进入当前的Task 但对于设置了 launchMode &#x3D; “singleTask”的Activity,系统会先比对Activity和当前Task的taskAffinity是否相同 如果相同，依然正常入栈. 如果不同，新Activity会去寻找和它 taskAffinity相同的Task后入栈。 如果找不到，系统就为它创建一个新的Task,或者创建一个新的Task. MainActivity启动FirstActivity 123&lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot; android:taskAffinity=&quot;com.comm.mytask&quot; /&gt; TaskRecord&#123;dff3f0b #4947 A=com.comm.util U=0 StackId=1 sz=2&#125; Run #4: ActivityRecord&#123;e52ebf7 u0 com.comm.util/.component.launchmode.FirstActivity t4947&#125; Run #3: ActivityRecord&#123;cd6b037 u0 com.comm.util/.MainActivity t4947&#125; 1234&lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot; android:launchMode=&quot;singleTask&quot; android:taskAffinity=&quot;com.comm.mytask&quot; /&gt; 1234TaskRecord&#123;3713c1e #4946 A=com.comm.mytask U=0 StackId=1 sz=1&#125; Run #4: ActivityRecord&#123;3d3bd58 u0 com.comm.util/.component.launchmode.FirstActivity t4946&#125; TaskRecord&#123;273cacc #4945 A=com.comm.util U=0 StackId=1 sz=1&#125; Run #3: ActivityRecord&#123;77277e0 u0 com.comm.util/.MainActivity t4945&#125; 添加完 android:launchMode=&quot;singleTask&quot;后 多了个task com.comm.mytask TaskAffinity和最近任务列表1adb shell dumpsys activity activities | sed -En -e &#x27;/Running activities/,/Run #0/p&#x27; SingleInstance 不设置taskAffinitySingleInstance会创建一个新的任务栈 12345678910111213&lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.component.launchmode.SecondActivity&quot; android:launchMode=&quot;singleInstance&quot; /&gt;&lt;activity android:name=&quot;.component.launchmode.ThirdActivity&quot; /&gt; 1234567891011121314151617D/FirstActivity LaunchModeActivity: onCreate() taskId 86D/FirstActivity LaunchModeActivity: onStart()D/FirstActivity LaunchModeActivity: onResume()D/FirstActivity LaunchModeActivity: onPause()D/SecondActivity LaunchModeActivity: onCreate() taskId 85D/SecondActivity LaunchModeActivity: onStart()D/SecondActivity LaunchModeActivity: onRestoreInstanceState()D/SecondActivity LaunchModeActivity: onNewIntent(Intent intent)D/SecondActivity LaunchModeActivity: onResume()D/FirstActivity LaunchModeActivity: onSaveInstanceState()D/FirstActivity LaunchModeActivity: onStop()D/SecondActivity LaunchModeActivity: onPause()D/ThirdActivity LaunchModeActivity: onCreate() taskId 86D/ThirdActivity LaunchModeActivity: onStart()D/ThirdActivity LaunchModeActivity: onResume()D/SecondActivity LaunchModeActivity: onSaveInstanceState()D/SecondActivity LaunchModeActivity: onStop() 可以看到 FirstActivity 、ThirdActivity在同一个栈中，SecondActivity单独在一个栈中 所以按返回键盘，先到 FirstActivity，然后到SecondActivity . 栈内Activity查看，设置taskAffinity123456789101112131415&lt;activity android:name=&quot;.component.launchmode.SerachActivity&quot; /&gt; &lt;activity android:name=&quot;.component.onactivityresult.SecondActivity&quot; android:launchMode=&quot;singleTask&quot; android:taskAffinity=&quot;&quot; /&gt; &lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot; android:configChanges=&quot;orientation&quot; android:launchMode=&quot;singleTask&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; adb shell dumpsys activity taskAffinity属性的值为字符串，且中间必须含有分隔符”.” standard模式，taskAffinity继承自Application的taskAffinity，而Application默认taskAffinity为包名，所以MainActivity的taskAffinity为包名。 https://developer.android.com/guide/components/activities/tasks-and-back-stack https://blog.csdn.net/zhangjg_blog/article/details/10923643 https://blog.csdn.net/javazejian/article/details/52072131 生命周期视图 http://yhz61010.iteye.com/blog/2389877 https://blog.csdn.net/qq_16628781/article/details/51539715 然而 ANDROID 4.4 启动模式会出现问题http://www.jianshu.com/p/2a9fcf3c11e4 http://blog.csdn.net/mynameishuangshuai/article/details/51491074 https://www.youtube.com/watch?v=r4T9zkhpmII 任务栈一 从图中我们看出前台任务栈分别为AB两个Activity，后台任务栈分别为CD两个任务栈，而且其启动模式均为singleTask，此时我们先启动CD，然后再启动AB，再有B启动D，此时后台任务栈便会被切换到前台，而且这个时候整个后退列表就变成了ABCD，请注意我们这里强调的是后退列表，而非栈合并。因此当用户点击back键时，列表中的Activity会依次按DCBA顺序出栈，如下图所示： 前面我们在分析singleTask模式时，提到过singleTask模式有些比较特殊的场景，现在我们就来了解了解它们。特殊情景一:现在我们假设有如下两个Task栈,分别为前台任务栈和后台任务栈 从图中我们看出前台任务栈分别为AB两个Activity，后台任务栈分别为CD两个任务栈，而且其启动模式均为singleTask，此时我们先启动CD，然后再启动AB，再有B启动D，此时后台任务栈便会被切换到前台，而且这个时候整个后退列表就变成了ABCD，请注意我们这里强调的是后退列表，而非栈合并。因此当用户点击back键时，列表中的Activity会依次按DCBA顺序出栈，如下图所示： 这里我们通过两个应用ActivityTask和ActivityTask2来测试重现这个现象。因为两个是不同的应用所以启动时所在的栈也是不同。我们先启动ActivityTask2的应用，其ActivityC和ActivityD都是singleTask模式，然后再启动应用ActivityTask，此时ActivityC和ActivityD所在任务栈会被退居后台，而打开的ActivityA和ActivityB会在前台，而且都是默认模式。我们通过 adb shell dumpsys activity activities 命令查看此时栈的情况： 我们可以看到由两个栈，分别为id&#x3D;222且栈名为“com.cmcm.activitytask”的任务栈其包含ActivityA和ActivityB（下面简称AB，栈名一般默认和包名相同），另外一个任务栈，id&#x3D;221，栈名为“com.cmcm.activitytask2”，其包含ActivityC和ActivityD（下面检测CD）。现在我们通过ActivityB去启动ActivityD，然后按back键回退 我们可以看到包含CD的任务栈被提前的，虽然CD隔开了，但是我们从id和栈名可以发现他们是同一个栈，而AB所在的栈则在CD所在栈的后面，所以此时我们按back回退时，退出顺序是这样的D-&gt;C-&gt;B-&gt;A，动态图如下： 到此我们对SingleTask模式又有了更深入的理解，但是我们发现上面的例子使用的是两个应用，所以才会有不同的任务栈，那么我们能不能在一个应用中存在多个不同的任务栈呢（暂时不考虑singleInstance 模式）？答案当然是肯定的啦，这就需要通过taskAffinity属性来设置不同的任务栈名称，不过这点将放在下篇来记录，本篇就先到这里告一段落哈。 任务栈二任务栈二这篇文章讲的很好 ​ 这个和allowTaskReparenting没关系 ​ 这个和allowTaskReparenting没关系 假如现在有这么一个需求,我们的客户端app正处于后台运行，此时我们因为某些需要，让微信调用自己客户端app的某个页面，用户完成相关操作后，我们不做任何处理，按下回退或者当前Activity.finish()，页面都会停留在自己的客户端（此时我们的app回退栈不为空），这显然不符合逻辑的，用户体验也是相当出问题的。我们要求是，回退必须回到微信客户端,而且要保证不杀死自己的app.这时候我们的处理方案就是，设置当前被调起Activity的属性为： LaunchMode&#x3D;””SingleTask” taskAffinity&#x3D;”com.tencent.mm” 其中com.tencent.mm是借助于工具找到的微信包名，就是把自己的Activity放到微信默认的Task栈里面，这样回退时就会遵循“Task只要有Activity一定从本Task剩余Activity回退”的原则，不会回到自己的客户端；而且也不会影响自己客户端本来的Activity和Task逻辑。 TaskAffinity与allowTaskReparenting应用场景 一个e-mail应用消息包含一个网页链接，点击这个链接将出发一个activity来显示这个页面，虽然这个activity是浏览器应用定义的，但是activity由于e-mail应用程序加载的，所以在这个时候该activity也属于e-mail这个task。如果e-mail应用切换到后台，浏览器在下次打开时由于allowTaskReparenting值为true，此时浏览器就会显示该activity而不显示浏览器主界面，同时actvity也将从e-mail的任务栈迁移到浏览器的任务栈，下次打开e-买了时并不会再显示该activity 到此TaskAffinity就全部介绍完了，最后我们再来了解几个跟任务栈相关的属性参数；","categories":[],"tags":[]},{"title":"viewBinding","slug":"viewBinding","date":"2022-12-27T13:04:33.000Z","updated":"2023-01-02T03:31:39.350Z","comments":true,"path":"2022/12/27/viewBinding/","link":"","permalink":"https://noteforme.github.io/2022/12/27/viewBinding/","excerpt":"","text":"https://www.cnblogs.com/pengxurui/p/16669380.html https://juejin.cn/post/6958346113552220173 编译生成的目录build/generated/data_binding_base_class_source_out/ ActivityCBinding.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public final class ActivityCBinding implements ViewBinding &#123; @NonNull private final LinearLayout rootView; @NonNull public final Button btC; @NonNull public final Button btD; private ActivityCBinding(@NonNull LinearLayout rootView, @NonNull Button btC, @NonNull Button btD) &#123; this.rootView = rootView; this.btC = btC; this.btD = btD; &#125; @Override @NonNull public LinearLayout getRoot() &#123; return rootView; &#125; @NonNull public static ActivityCBinding inflate(@NonNull LayoutInflater inflater) &#123; return inflate(inflater, null, false); &#125; @NonNull public static ActivityCBinding inflate(@NonNull LayoutInflater inflater, @Nullable ViewGroup parent, boolean attachToParent) &#123; View root = inflater.inflate(R.layout.activity_c, parent, false); if (attachToParent) &#123; parent.addView(root); &#125; return bind(root); &#125; @NonNull public static ActivityCBinding bind(@NonNull View rootView) &#123; // The body of this method is generated in a way you would not otherwise write. // This is done to optimize the compiled bytecode for size and performance. int id; missingId: &#123; id = R.id.bt_c; Button btC = ViewBindings.findChildViewById(rootView, id); if (btC == null) &#123; break missingId; &#125; id = R.id.bt_D; Button btD = ViewBindings.findChildViewById(rootView, id); if (btD == null) &#123; break missingId; &#125; return new ActivityCBinding((LinearLayout) rootView, btC, btD); &#125; String missingId = rootView.getResources().getResourceName(id); throw new NullPointerException(&quot;Missing required view with ID: &quot;.concat(missingId)); &#125;&#125; 从控件 Button btC; Button btD;可以很容易看到。id都是findbyid生成的。 123456789101112131415161718192021222324class FragmentViewBinding&lt;T : ViewBinding&gt;(classes: Class&lt;T&gt;, fragment: Fragment) : FragmentDelegate&lt;T&gt;(fragment) &#123; private val TAG = &quot;TAG&quot; private val layoutInflater = classes.inflateMethod() private val bindView = classes.bindMethod() //调用getValue属于属性代理,访问viewbiding属性调用getVaule方法 @Suppress(&quot;UNCHECKED_CAST&quot;) override fun getValue(thisRef: Fragment, property: KProperty&lt;*&gt;): T = viewBinding ?: let &#123; Log.i(TAG, &quot;getValue: $layoutInflater $bindView&quot;) val bind: T = (if (thisRef.view == null) &#123; layoutInflater.invoke(null, thisRef.layoutInflater) // 表示 ActivityCBinding.inflate() &#125; else &#123; bindView.invoke(null, thisRef.view) //表示 ActivityCBinding.bind() &#125;) as T viewBinding = bind bind &#125;&#125;","categories":[],"tags":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/tags/ANDROID/"}]},{"title":"LC-backtrack-combination","slug":"LC-backtrack-combination","date":"2022-10-30T02:27:10.000Z","updated":"2023-07-17T13:34:08.142Z","comments":true,"path":"2022/10/30/LC-backtrack-combination/","link":"","permalink":"https://noteforme.github.io/2022/10/30/LC-backtrack-combination/","excerpt":"","text":"组合 组合的元素是无序的[1,2] , [2,1]是一个组合 组合的元素是不能重复的 77. 组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 https://www.bilibili.com/video/BV1ti4y1L7cv 拿到第一个元素. 用上面的图很形象,在剩余的元素中取数据，和 二叉树路径很像,递归加回溯的过程. 这里一开始用的是 startIndex+1,不理解，这里回溯后,最第一次的for (i in startIndex..n)如果i ==2,或者3，或者4, 递归到底层，再回溯到第一次循环的时候，startIndex都是第一次的2,这样就导致剩余的元素不对 1234567891011121314151617fun combine(n: Int, k: Int): List&lt;List&lt;Int&gt;&gt; &#123; backTracking(n, k, 1) return result&#125;private fun backTracking(n: Int, k: Int, startIndex: Int) &#123; if (path.size == k) &#123; result.add(path.toMutableList()) return &#125; for (i in startIndex..n) &#123; path.add(i) backTracking(n, k, i + 1) // 这里一开始用的是 startIndex+1 path.remove(i) &#125;&#125; 组合剪枝https://www.bilibili.com/video/BV1wi4y157er/ https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96 来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。 12345for (i in startIndex..n) &#123; // 这里对应模拟就是,取1,取2 ,取3,取4 ,几个子孩子的操作. path.add(i) backTracking(n, k, i + 1) // 这里一开始用的是 startIndex+1 path.remove(i)&#125; 剪枝就是 i&lt; n这个范围里面做操作。 接下来看一下优化过程如下： 已经选择的元素个数：path.size(); 还需要的元素个数为: k - path.size(); 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历 为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。 举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。 从2开始搜索都是合理的，可以是组合[2, 3, 4]。 这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。 123456789101112131415161718val path = ArrayList&lt;Int&gt;()val result = ArrayList&lt;List&lt;Int&gt;&gt;()fun combine(n: Int, k: Int): List&lt;List&lt;Int&gt;&gt; &#123; backTracking1(n, k, 1) return result&#125;//剪枝操作private fun backTracking1(n: Int, k: Int, startIndex: Int) &#123; if (path.size == k) &#123; result.add(path.toMutableList()) return &#125; for (i in startIndex..(n - (k - path.size) + 1)) &#123; path.add(i) backTracking1(n, k, i + 1) // 这里一开始用的是 startIndex+1 path.remove(i) &#125;&#125; 216. 组合总和 III 只使用数字1到9 . 每个数字 最多使用一次 . 从1开始选取，每次循环往后选取，如果往前选数字入[1,2], [2,1]的情况，就重复了. 选取元素综合==n , 并且是k个，装入数组。 我的解法if (sum == n &amp;&amp; pathList.size == k)放一起不好 ，pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。 123456789101112131415161718192021private val result = ArrayList&lt;List&lt;Int&gt;&gt;()private var sum: Int = 0 //集合的和private val pathList = ArrayList&lt;Int&gt;() // 集合fun combinationSum3(k: Int, n: Int): List&lt;List&lt;Int&gt;&gt; &#123; blockTracking(k, n, 1) return result&#125;private fun blockTracking(k: Int, n: Int, startIndex: Int) &#123; if (sum == n &amp;&amp; pathList.size == k) &#123; // 相加之和为 n 的 k 个数的组合 result.add(pathList.toMutableList()) return &#125; for (i in startIndex..9) &#123; sum += i pathList.add(i) blockTracking(k, n, i + 1) sum -= i pathList.remove(i) &#125;&#125; 剪枝还没想好 pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。 (9 - (k - pathList.size) + 1) 分析 k - pathList.size : 从1开始选取,还差多少个元素 9 - (k - pathList.size) : 如果从1…9选取，为了避免重复，一直往大的数选取,第1次选到了8,如果k==2,那么过了8就没意义了，第一次的9就不需要选取了. (9 - (k - pathList.size) + 1) 处理下标值。 123456789101112131415161718192021222324252627private val result = ArrayList&lt;List&lt;Int&gt;&gt;()private var sum: Int = 0 //集合的和private val pathList = ArrayList&lt;Int&gt;() // 集合fun combinationSum3(k: Int, n: Int): List&lt;List&lt;Int&gt;&gt; &#123; blockTracking(k, n, 1) println(result) return result&#125;private fun blockTracking(k: Int, n: Int, startIndex: Int) &#123; if (pathList.size == k) &#123; //shuxiang if (sum == n) &#123; result.add(pathList.toMutableList()) &#125; return &#125; for (i in startIndex..(9 - (k - pathList.size) + 1)) &#123; // 横向剪枝 if (sum &gt; n) &#123; //剪枝 break &#125; sum += i pathList.add(i) blockTracking(k, n, i + 1) sum -= i pathList.remove(i) &#125;&#125; 123456789101112131415161718private fun blockTracking(k: Int, n: Int, startIndex: Int) &#123; if (sum &gt; n) &#123; return //sum &gt; n 直接返回，随想录的解法，这样更好. &#125; if (pathList.size == k) &#123; if (sum == n) &#123; result.add(pathList.toMutableList()) &#125; return &#125; for (i in startIndex..(9 - (k - pathList.size) + 1)) &#123; sum += i pathList.add(i) blockTracking(k, n, i + 1) sum -= i pathList.remove(i) &#125;&#125; 17.电话号码的字母组合前面的题目都是在一个数组里面取，看到这个问题，这个问题是在数组里面，再取里面的数组。 问题是，如果输入”235”,那么他们内部数组的索引startIndex怎么求出来. String中的数字转int1234val digits = &quot;23&quot;val c = digits[0] - &#x27;0&#x27; // 50 - 48println(digits[0].code) // ASCII是 50println(&#x27;0&#x27;.code) //ASCII是 48 39.组合总和这题目和前面的区别是，可以选取重复的元素. 选了2后，第二列选5这时候不能选2了，否则就会重复了。 看了随想录分析视频，在分析代码前，根据上面的图了解到的思路. 整体回溯架构和前面的都是一样的,选了2后，后面还是可以继续253, 选了5后只有53了，否则就有重复的。 一开始我的解法是backTrack(candidates.toList(), target,i),传入for循环中的i，这样会导致有漏掉前面的情况。要知道for循环的部分就是树的宽度。 后面的剪枝应该也是针对这部分。 123456789101112131415161718192021222324var sum = 0private val path = ArrayList&lt;Int&gt;()private val result = ArrayList&lt;List&lt;Int&gt;&gt;()fun combinationSum(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123; backTrack(candidates.toList(), target) return result&#125;private fun backTrack(candidates: List&lt;Int&gt;, target: Int) &#123; if (sum &gt; target) &#123; // 节点和 return &#125; if (sum == target) &#123; result.add(path.toList()) return &#125; for ((i, item) in candidates.withIndex()) &#123; path.add(item) sum += item backTrack(candidates.toMutableList().subList(i, candidates.size), target) // 只需要传入后面能选取的数组部分 path.remove(item) sum -= item &#125;&#125; 看了随想录的部分解法视频后，感觉这种更好，根据startIndex来取数组位置。传入startIndex后，后面的智能从startIndex后面取，和分割数组是一样的道理，感觉效率会更好。 1234567891011121314151617181920212223var sum = 0private val path = ArrayList&lt;Int&gt;()private val result = ArrayList&lt;List&lt;Int&gt;&gt;()fun combinationSum(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123; backTrack(candidates.toList(), target, 0) return result&#125;private fun backTrack(candidates: List&lt;Int&gt;, target: Int, startIndex: Int) &#123; if (sum &gt; target) &#123; return &#125; if (sum == target) &#123; result.add(path.toList()) return &#125; for (i in startIndex until candidates.size) &#123; path.add(candidates[i]) sum += candidates[i] backTrack(candidates, target, i) // i后分割元素，一开始写的是startIndex，这样for循环后面的就没过滤到了,只有startIndex过滤到了。 path.remove(candidates[i]) sum -= candidates[i] &#125;&#125; 剪枝 如果target ==4 可以看这张图，如果经过排序左边的 235,取了2,3已经 &gt;=4了，那么后面的5就不用去取了. 12345678910111213141516171819202122232425262728 var sum = 0 private val path = ArrayList&lt;Int&gt;() private val result = ArrayList&lt;List&lt;Int&gt;&gt;() fun combinationSum(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;// backTrack1(candidates.toList(), target) Arrays.sort(candidates) //剪枝前需要排序 backTrack(candidates.toList(), target, 0) return result &#125; private fun backTrack(candidates: List&lt;Int&gt;, target: Int, startIndex: Int) &#123; if (sum &gt; target) &#123; return &#125; if (sum == target) &#123; result.add(path.toList()) return &#125; for (i in startIndex until candidates.size) &#123; if (sum + candidates[i] &gt; target) &#123; // 剪枝操作 return &#125; path.add(candidates[i]) sum += candidates[i] backTrack(candidates, target, i) path.remove(candidates[i]) sum -= candidates[i] &#125; &#125; 123456789101112131415161718192021222324252627private fun backTrack1(candidates: IntArray, target: Int, startIndex: Int, used: BooleanArray, layer: Int) &#123; if (sum == target) &#123; result.add(path.toList()) println(path) return &#125; for (i in startIndex until candidates.size) &#123; if (sum + candidates[i] &gt; target) &#123; // 这样判断更好，因为是生序的数组，右边的枝没必要 return &#125; println(&quot;layer$layer i: $i candidates[i]: $&#123;candidates[i]&#125; used: $&#123;used[i]&#125;&quot;) if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) &#123; println(&quot;continue $&#123;candidates[i]&#125;&quot;) continue &#125; path.add(candidates[i]) sum += candidates[i] used[i] = true println(&quot;path $path&quot;) backTrack1(candidates, target, i + 1, used, layer + 1) // 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错 path.remove(candidates[i]) println(&quot;path backTrack $path&quot;) sum -= candidates[i] used[i] = false &#125;&#125; 40.组合总和 IIhttps://www.bilibili.com/video/BV12V4y1V73A/ 这一题的 [10,1,2,7,6,1,5]，有两个1，可能都和7组成了[1,7]就重复了，这里就是要去掉这种重复。 一开始想不到去重的思路 。 看了视频，对应这个图. 重复的原因在于树宽 第二次取1的地方，因为第1次取1，已经包括了第二次取1的所有树枝。所以把第二次取1的树枝剪掉既可。 剪枝条件1：candidates[i] == candidates[i - 1] 剪枝条件2: 通过设置used数组，只有used[i - 1] 是false才有意义, used[i - 1]= false ,说明数组的第一个1没有取，取的是第二个1，结果是[1,2]，所以可以舍弃掉，否则导致和第一次的取第一个1和下一层取2,结果是[1,2]重复了。这样判断就可以把 第二次取1的这个枝干给剪掉。 也叫 树层去重。 123456789101112131415161718192021222324252627282930313233343536373839var sum = 0val path = ArrayList&lt;Int&gt;()val result = ArrayList&lt;List&lt;Int&gt;&gt;()fun combinationSum2(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123; Arrays.sort(candidates) println(candidates.joinToString()) val used = BooleanArray(candidates.size) backTrack(candidates, target, 0, used, 0) return result&#125;private fun backTrack(candidates: IntArray, target: Int, startIndex: Int, used: BooleanArray, layer: Int) &#123; if (sum &gt; target) &#123; return &#125; if (sum == target) &#123; result.add(path.toList()) println(path) return &#125; for (i in startIndex until candidates.size) &#123; println(&quot;layer$layer i: $i candidates[i]: $&#123;candidates[i]&#125; used: $&#123;used[i]&#125;&quot;) if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) &#123; println(&quot;continue $&#123;candidates[i]&#125;&quot;) continue &#125; path.add(candidates[i]) sum += candidates[i] used[i] = true println(&quot;path $path&quot;) backTrack(candidates, target, i + 1, used, layer + 1) // 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错 path.remove(candidates[i]) println(&quot;path backTrack $path&quot;) sum -= candidates[i] used[i] = false &#125;&#125; 131.分割回文串12输入：s &#x3D; &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] 没想明白 [[“a”,”a”,”b”],[“aa”,”b”]] 这个数组是怎么弄出来的。 https://www.bilibili.com/video/BV1c54y1e7k6 这题是边看答案变做出来的。 根据上图可以这样理解 ， DFS递归是 纵向切割， a|ab 取[a], a|a|b 取 [a,a] , a|a|b| 最终到叶子节点取 [a,a,b]，到终点。 for循环是横向切割 。 val str = s.substring(startIndex,i+1) // 这个也很关键，startIndex作为分割的起点 这题类似于树中符合条件的所有的路径，一旦纵向路径中，有一个不符合条件[a,ab] ab不符合，就直接回溯去其他路径.所以放if里判断递归会更好。 12345678910111213141516171819202122232425262728293031323334353637383940val result = ArrayList&lt;List&lt;String&gt;&gt;()private val path = ArrayList&lt;String&gt;()fun partition(s: String): List&lt;List&lt;String&gt;&gt; &#123; backTrack(s, 0) return result&#125;private fun backTrack(s: String, startIndex: Int) &#123; if (startIndex &gt;= s.length) &#123; // 纵向到叶子节点，就网上回溯 result.add(path.toList()) return //可以用 &#125; for (i in startIndex until s.length) &#123; //for循环是 横向切割 if (isPalindromeNum(s,startIndex,i+1))&#123; // 判断startIndex,到 i+1是否是回文串 val str = s.substring(startIndex,i+1) // 这个也很关键，startIndex作为分割的起点 path.add(str) // backTrack(s, i + 1) //递归是 纵向切割，也没有循环。这个放if里面可能更好. // path.removeAt(path.size-1) &#125;else&#123; continue // 如ab不是回文串，也不用继续了 &#125; backTrack(s, i + 1) //递归是 纵向切割，也没有循环。这个放if里面可能更好. path.removeAt(path.size-1) &#125;&#125;fun isPalindromeNum(str: String,start:Int,end:Int): Boolean &#123; if (str.isEmpty()) &#123; return false &#125; val charArray = str.substring(start,end) for (i in 0 until charArray.length / 2) &#123; if (charArray[i] != charArray[charArray.length - 1 - i]) &#123; return false &#125; &#125; return true&#125; 优化解法对判断是否回文串的优化. 93.复原 IP 地址我的分析 这题和上面131类似，可以通过切割方式解决。 ip地址都有四位，需要切割4次，所以树的深度是4。也是回溯终止条件之一，startIndex是切割线。(应该是i+1是切割线，否则只能分割一个字母) 选取有效的ip, 前导不为0，只能是数字。 &lt;255 , 可以限制树的宽度。 我写完代码后，切割成这样 2.5.5.2， 不是全部的数字，没想到什么方式能切割所有的数字。 s.substring(startIndex, s.length) 先分割前三个，然后判断最后一个字符串，这样就能分割所有的字母。 startIndex解释，下面这张图更清楚，第一层取 元素2. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950val result = ArrayList&lt;String&gt;()val path = ArrayList&lt;String&gt;()fun restoreIpAddresses(s: String): List&lt;String&gt; &#123; backTrack(s, 0, 0) return result&#125;private fun backTrack(s: String, startIndex: Int, layer: Int) &#123; // 看了随想录解法，这里加上终止条件会更好。 if (layer == 3) &#123; // 第三个分割线 val substring = s.substring(startIndex, s.length) // 这里的方式就解决了，分割所有子串的问题，最后一次分割，直接到字符串的终点。 if (isValid(substring)) &#123; path.add(substring) result.add(path.toList().joinToString(separator = &quot;.&quot;)) path.removeAt(path.size-1) // 最后的字符串回溯 &#125; return &#125; for (i in startIndex until s.length) &#123; val substring = s.substring(startIndex, i + 1) if (isValid(substring)) &#123; path.add(substring) backTrack(s, i + 1, layer + 1) // 注意我这里经常传错用 startIndex,如果第一次已经分割到了超过第2个位置，那么就应该传这个位置， path.removeAt(path.size-1) &#125; &#125;&#125;// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法private fun isValid(s: String): Boolean &#123; val start = 0 val end = s.length - 1 if (start &gt; end) &#123; return false; &#125; if (s[start] == &#x27;0&#x27; &amp;&amp; start != end) &#123; // 0开头的数字不合法 return false; &#125; var num = 0; for (i in start..end) &#123; if (s[i] &gt; &#x27;9&#x27; || s[i] &lt; &#x27;0&#x27;) &#123; // 遇到非数字字符不合法 return false; &#125; num = num * 10 + (s[i] - &#x27;0&#x27;); if (num &gt; 255) &#123; // 如果大于255了不合法 return false; &#125; &#125; return true;&#125; 78. 子集 这题把上图画出来后，还是比较简单的。只要把所有步数情况添加就可以了。 123456789101112131415val result = ArrayList&lt;List&lt;Int&gt;&gt;()val path = ArrayList&lt;Int&gt;()fun subsets(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; backTrack(nums, 0) return result&#125;private fun backTrack(nums: IntArray, startIndex: Int) &#123; result.add(path.toList()) // 这棵树所有的步长，都添加 for (i in startIndex until nums.size) &#123; path.add(nums[i]) backTrack(nums, i + 1) // 注意 path.remove(nums[i]) &#125;&#125; 90.子集 II 第一层 第二列取元素2的时候，此时子集就有2了，第三列再取就重复了。 从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！ 123456789101112131415161718192021222324class Solution &#123; private val result = ArrayList&lt;List&lt;Int&gt;&gt;() private val path = ArrayList&lt;Int&gt;() fun subsetsWithDup(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; Arrays.sort(nums) val used = BooleanArray(nums.size) backTrack(nums, used, 0) return result &#125; private fun backTrack(nums: IntArray, used: BooleanArray, startIndex: Int) &#123; result.add(path.toList()) for (i in startIndex until nums.size) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue &#125; used[i] = true path.add(nums[i]) backTrack(nums,used,i+1) path.remove(nums[i]) used[i] = false &#125; &#125;&#125; !used[i - 1] 这个条件是判断树层的条件，否则会把树枝给剪掉了。 补充本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。 随想录这句没理解。 491.递增子序列 不能排序,所以子集中used解法不行 树枝中小心判断大小。 https://www.bilibili.com/video/BV1EG4y1h78v/ 一开始按照下面子集的解法做的,但是存在问题，子集是经过排序后的，然后nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]这样的条件判断，这题不能排序的，所以情况不一样。 123456789101112131415161718private fun backTrack(nums: IntArray, used: BooleanArray, startIndex: Int) &#123; if (path.size &gt; 1) &#123; result.add(path.toList()) &#125; for (i in startIndex until nums.size) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue &#125; if (i &gt; 0 &amp;&amp; nums[i] &lt; nums[i - 1])&#123; break &#125; path.add(nums[i]) used[i] = true backTrack(nums,used,i+1) path.remove(nums[i]) used[i] = false &#125;&#125; 上图可以看到，树层中是不能重复的，因为签名的 7包含后面7的所有情况。 123456789101112131415161718192021222324252627 private val result = ArrayList&lt;List&lt;Int&gt;&gt;() private val path = ArrayList&lt;Int&gt;() fun findSubsequences(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; backTrack(nums, 0, 0) return result &#125; private fun backTrack(nums: IntArray, startIndex: Int, layer: Int) &#123; if (path.size &gt; 1) &#123; // 至少有两个元素 result.add(path.toList()) &#125; val set = mutableSetOf&lt;Int&gt;() // 树层中是否包含 相同的元素。 for (i in startIndex until nums.size) &#123;// println(&quot;startIndex $startIndex set $set&quot;) if (layer == 0) &#123; println(&quot;layer set $set&quot;) &#125; if ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || set.contains(nums[i])) &#123; // 小于上一个元素，这个分支以下不用走了， set树层中包含相同的与元素。 continue &#125; set.add(nums[i]) //因为是判断树层，而且是每一层都局部会new 一个set，所以这个没有回溯。 path.add(nums[i]) backTrack(nums, i + 1, layer + 1) path.remove(nums[i]) &#125; &#125; 123456789101112131415private fun backTrack(nums: IntArray, startIndex: Int, layer: Int) &#123; if (path.size &gt; 1) &#123; result.add(path.toList()) &#125; val used = IntArray(201) // -100 &lt;= nums[i] &lt;= 100 ， 包括 0 for (i in startIndex until nums.size) &#123; if ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || used[nums[i] + 100] == 1) &#123; continue &#125; used[nums[i] + 100] = 1 path.add(nums[i]) backTrack(nums, i + 1, layer + 1) path.remove(nums[i]) &#125;&#125; 46全排列[1,2,3] 选了2之后， 1，3 就不知道从哪里开始了，子集问题有个startIndex 我的解法12345678910111213141516171819202122232425262728293031private val result = ArrayList&lt;List&lt;Int&gt;&gt;()private val path = ArrayList&lt;Int&gt;()fun permute(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; val size = nums.size val used = BooleanArray(size) backTrack(nums, used) return result&#125;private fun backTrack(nums: IntArray, used: BooleanArray) &#123; println(path) //if (totalUsed(used)) &#123; if (totalUsed(used)) &#123; result.add(path.toList()) return &#125; for ((index, value) in nums.withIndex()) &#123; if (used[index]) &#123; continue &#125; path.add(nums[index]) used[index] = true backTrack(nums, used) path.remove(nums[index]) used[index] = false &#125;&#125;private fun totalUsed(used: BooleanArray): Boolean &#123; return used.contains(false).not()&#125; 先画图分析 单测中把数据打印出来，能大概理清这种思路， 1234567891011121314151617[][1][1, 2][1, 2, 3][1, 3][1, 3, 2][2][2, 1][2, 1, 3][2, 3][2, 3, 1][3][3, 1][3, 1, 2][3, 2][3, 2, 1][[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] 47.全排列 II我的解法有一点点问题[2,2,1,1]这个跑步过去,path.removeAt(path.lastIndex),看了随想录的解法和我没区别，才发现这里的。 思路 和组合去重没区别 ,(index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])重复元素，树层去重 全排列使用过的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 private val path = ArrayList&lt;Int&gt;() private val result = ArrayList&lt;List&lt;Int&gt;&gt;() fun permuteUnique(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; Arrays.sort(nums)// nums.printIntArray() val used = BooleanArray(nums.size) backTrack(nums, used) return result &#125;// private fun backTrack(nums: IntArray, used: BooleanArray) &#123;// println(path)// if (path.size == nums.size) &#123;// result.add(path.toList())// return// &#125;// for ((index, value) in nums.withIndex()) &#123;// if (used[index] || (index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])) &#123;// continue// &#125;// used[index] = true// path.add(value)// backTrack(nums, used)// used[index] = false// path.remove(value)// &#125;// &#125; private fun backTrack(nums: IntArray, used: BooleanArray) &#123; println(path) if (path.size == nums.size) &#123; result.add(path.toList()) return &#125; for (index in nums.indices) &#123; if ((index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])) &#123; continue &#125; if (used[index]) &#123; continue &#125; used[index] = true path.add(nums[index]) backTrack(nums, used) path.removeAt(path.lastIndex) // 用path.remove(value)是有问题的，会把所有的这个元素删除掉，46没问题是因为没有重复元素，leetcode removeLast() cannot build used[index] = false &#125; &#125; 332.重新安排行程随想录解法那个数组处理没看明白 这里用到的回溯，就是目的地可能有多个。 https://leetcode.cn/problems/reconstruct-itinerary/solutions/654811/java-bu-yong-ou-la-zhi-yong-hui-su-si-lu-4v83/ 看了他的视频 给定的tickets转成 from to 的结构,就可以知道出发点对应的，到达点和到达点的线路数。 // 这个数据处理也是有点麻烦的。 根据多个到达点回溯，找到最合适的路径 如果到达点的是线路是0，那么找下一题跳线路。 遇到的机场个数path ==航班数量+ putIfAbsent https://blog.csdn.net/hbtj_1216/article/details/75093428 123456789101112131415161718192021222324252627282930313233343536373839404142val path = ArrayList&lt;String&gt;()fun findItinerary(tickets: List&lt;List&lt;String&gt;&gt;): List&lt;String&gt; &#123; //1. list转成 from to 的结构 //2. 回溯找到最合适的路径 //3. 遇到的机场个数path ==航班数量+ val hashMap = HashMap&lt;String, TreeMap&lt;String, Int&gt;&gt;() tickets.stream().forEach &#123; ticket -&gt; val from = ticket[0] // 出发地 val to = ticket[1] //目的地 hashMap.putIfAbsent(from, TreeMap()) val treeMap = hashMap[from] ?: TreeMap() //获取出发地对应的容器TreeMap,如果之前没用过的出发地key,那么新建一个容器TreeMap treeMap[to] = treeMap.getOrDefault(to, 0) + 1 // 容器内，目的地的个数++,一开始这里写的有问题。 &#125; path.add(&quot;JFK&quot;) // 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。 backTrack(hashMap, tickets.size) return path&#125;private fun backTrack(hashMap: HashMap&lt;String, TreeMap&lt;String, Int&gt;&gt;, ticketSize: Int): Boolean &#123; if (path.size == ticketSize + 1) &#123; return true &#125; // 1.根据path找到出发点,从hashmap根据出发点找到对应的 可能多个到达点 // 2. 多个可能的目的地进行回溯. val recentTo = path[path.size - 1] //path.last() LeetCode build failed val toDestinations = hashMap[recentTo] if (toDestinations.isNullOrEmpty()) return false for (to in toDestinations) &#123;// forEach也行, for习惯点 if (to.value == 0) &#123; continue &#125; path.add(to.key) to.setValue(to.value - 1) if (backTrack(hashMap, ticketSize)) &#123; return true &#125; path.removeAt(path.size - 1) to.setValue(to.value + 1) &#125; return false&#125; 51.N 皇后 这题思路不难，实现还是有难度，主要是皇后冲突代码不好理解，https://www.bilibili.com/video/BV1bK4y1n7iq 大概11分钟，判断 皇后位置的冲突情况。 这一题思路就是主要 首先行，然后列摆放皇后问题，然后回溯。 还一个就是将要放下皇后的位置之前，8个方向只用考虑3个,确定左上，正上方，右上方的皇后是否存在。当前行不用考了，因为每行一个，后面的更不看了，因为还没放皇后. 最后就是要注意边界的问题，二刷的时候尤其注意这个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //1. 初始化棋盘放上. char[][] chessBoard = new char[n][n]; for (char[] c : chessBoard) &#123; Arrays.fill(c, &#x27;.&#x27;); &#125; // 2. 开始放Queue,首先从行开始，一行一行回溯的放， 然后每一行开始从第1列开始。 // 3. 每次新的一行开始放Queue时，要考虑当前位置列的 前面的列有没有Queue, // 当前位置的左边45度和135度有没有Queue,对于当前行和后面的行和斜对角不用考虑，因为每一行只有一个Queue,后面的行更是没有。 //4 。只有能放下，才会放后续的，然后进行回溯. //5. 当放下的Queue时最后一行n时，递归结束，开始收集结果。 backTrack(n, 0, chessBoard); return result;&#125;private void backTrack(int n, int row, char[][] chessBoard) &#123; if (n == row) &#123; result.add(Array2List(chessBoard)); return; &#125; for (int column = 0; column &lt; n; ++column) &#123; if (isValid(row, column, chessBoard, n)) &#123; // row,column待放入Queue的位置 chessBoard[row][column] = &#x27;Q&#x27;; backTrack(n, row + 1, chessBoard); chessBoard[row][column] = &#x27;.&#x27;; &#125; &#125;&#125;private boolean isValid(int pRow, int pColumn, char[][] chessBoard, int n) &#123; for (int i = 0; i &lt; pRow; ++i) &#123; //列 if (chessBoard[i][pColumn] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; for (int x = pRow - 1, y = pColumn - 1; x &gt;= 0 &amp;&amp; y &gt;= 0; x--, y--) &#123; //左上角 首次==边界错了 if (chessBoard[x][y] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; for (int x = pRow - 1, y = pColumn + 1; x &gt;= 0 &amp;&amp; y &lt;= n - 1; x--, y++) &#123;//右上角 首次==,n-1边界错了 ,y &lt; n - 1一开始写成这样，找了半天 if (chessBoard[x][y] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; return true;&#125;public List Array2List(char[][] chessboard) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (char[] c : chessboard) &#123; list.add(String.copyValueOf(c)); &#125; return list;&#125; 这题for里面有x,y两个变量，kotlin不好弄，就用java了。 37.解数独随想录讲解. https://www.bilibili.com/video/BV1TW4y1471V/ https://xiaochen1024.com/video?id=6285f1b6ede03c002e46b218 根据下面公式可以找到 3 *3的开始位置。 val startRow = (row / 3) * 3 val startColumn = (column / 3) * 3 把红方框代入进去， val 3 = (4 / 3) * 3 就是红色箭头的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 1.先行 后列的顺序，找到字符位 &#x27;.&#x27;的空格，填入 1 - 9 的数字// 2.填入后，开始回溯// 3.填入空格的时候，如果没有返回true,if就返回false// 4. 如果全部填满了都没返回true,此时说明已经到了叶子节点，直接返回true.fun solveSudoku(board: Array&lt;CharArray&gt;): Unit &#123; backTrack(board)&#125;private fun backTrack(board: Array&lt;CharArray&gt;): Boolean &#123; for (i in board.indices) &#123; // 遍历行 for (j in board[0].indices) &#123;// 遍历列 if (board[i][j] == &#x27;.&#x27;) &#123; for (k in &#x27;1&#x27;..&#x27;9&#x27;) &#123; if (isValid(i, j, k, board)) &#123; board[i][j] = k if (backTrack(board)) &#123; return true &#125; board[i][j] = &#x27;.&#x27; &#125; &#125; return false //放上面一层，循环后直接返回false了,// 9个数都试完了，都不行，那么就返回false &#125; &#125; &#125; return true&#125;private fun isValid(row: Int, column: Int, k: Char, board: Array&lt;CharArray&gt;): Boolean &#123; for (i in board[0].indices) &#123; // 判断行里是否重复,一开始不理解很多解法包括，随想录用的是9,这样如果不是9*9就有问题了,原来题目给的就是9*9的方格 if (board[row][i] == k) &#123; return false &#125; &#125; for (i in board.indices) &#123; // 判断列里是否重复 if (board[i][column] == k) &#123; return false &#125; &#125; val startRow = (row / 3) * 3 val startColumn = (column / 3) * 3 for (i in startRow until (startRow + 3)) &#123; // 判断9方格里是否重复 for (j in startColumn until startColumn + 3) &#123; if (board[i][j] == k) &#123; return false &#125; &#125; &#125; return true&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"AppLink","slug":"AppLink","date":"2022-10-17T08:49:19.000Z","updated":"2023-01-02T03:31:38.944Z","comments":true,"path":"2022/10/17/AppLink/","link":"","permalink":"https://noteforme.github.io/2022/10/17/AppLink/","excerpt":"","text":"https://juejin.cn/post/7031143982960902157 https://developer.android.com/studio/write/app-link-indexing 唤醒App的几种方式Deep Linkhttps://developer.android.com/training/app-links/deep-linking URL Scheme 链接格式 1[scheme]:&#x2F;&#x2F;[host][:port]&#x2F;[path]?[query] 属性名 含义 scheme 协议名（由开发人员定义） host 网络域名 port 端口号 path 页面路径 query 请求参数 scheme only1234567891011&lt;!-- for deep-link --&gt;&lt;intent-filter&gt; &lt;!-- 必须加否否无法响应点击链接的 Intent--&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;ewallet&quot; /&gt;&lt;/intent-filter&gt; 在浏览器输入 ewallet:// 就能直接打开app 1ewallet:&#x2F;&#x2F; scheme host123456789101112&lt;intent-filter&gt; &lt;!-- 必须加否否无法响应点击链接的 Intent--&gt; &lt;action android:name&#x3D;&quot;android.intent.action.VIEW&quot; &#x2F;&gt; &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt; &lt;category android:name&#x3D;&quot;android.intent.category.BROWSABLE&quot; &#x2F;&gt; &lt;data android:host&#x3D;&quot;topic&quot; android:scheme&#x3D;&quot;com.great.jon&quot; &#x2F;&gt;&lt;&#x2F;intent-filter&gt; 在浏览器输入 12com.great.jon:&#x2F;&#x2F;topiccom.great.jon:&#x2F;&#x2F;topic?id &#x3D;11 id=11 这个可以不写 ADB TEST1adb shell am start -a android.intent.action.VIEW -d &quot;replace your link here&quot; Android系统级 Schemes有一些已经定义了URL Schemes，比如短信是 sms:、通话是tel:、email是mailto:，在定义自己APP的URL Schemes的时候要避免跟系统应用名称一样 各大平台简单查找了一下各大平台的 scheme，感兴趣的可以直接从手机浏览器中打开尝试一下。 QQ：qq://微信：weixin://淘宝：taobao://微博：sinaweibo://百瓶：billionbottle:// 页面调用方式 12window.location.href = schemeUrl;复制代码 直接跳转链接即可，简单方便。 负面情况 目前没有办法区分多个 App 都注册了相同 scheme 的情况； 不支持从其他 App 中的 WebView 直接跳转到目标 App； Android 端微信，无法直接通过 scheme 唤起 App，可以通过引导或微信开放标签来解决； 只能通过 hidden、blur 等事件监听到是否安装 App； 因此为了解决以上问题，iOS 和 Android 都有了自己的第二套解决方案，分别是 iOS 的 Universal Links，和 Android 的 App Links。 App Links在 2015 年的 Google I/O 大会上，Android M 宣布了一个新特性：App Links。它可以让用户在点击一个普通 Web 链接的时候可以打开指定 App 的对应页面，前提是这个 App 已经安装并且经过了验证，否则会显示一个打开确认选项的对话框，目前只支持 Android M 以上系统。 App Links 的出现其实也是为了优化用户体验，在使用它唤醒 App 时会弹出一个对话框提示用户是否打开，缺点就是如果用户勾选了取消之后，可能之后就再也唤醒不了了。 工作方式及流程 配置 AndroidManifest.xml； 配置 json 文件； 12345678[&#123; &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;], &quot;target&quot;: &#123; &quot;namespace&quot;: &quot;android_app&quot;, &quot;package_name&quot;: &quot;包名&quot;, &quot;sha256_cert_fingerprints&quot;: [&quot;签名&quot;] &#125;&#125;] 将 json 文件上传到指定域名的 .well-known 路径下，文件名定义为 assetlinks.json； 验证 App Links，可使用 AndroidStudio 里的 App Links Assistant 中的 Test App Links 进行测试或者在短信中输入链接点击测试，如果直接唤起 App 没有弹出对话框选择则说明 App Links 验证成功； 总的来说与 Universal Links 的配置和验证很相似，差异不大。 https://developer.android.com/studio/write/app-link-indexing http://www.androidchina.net/10135.html 第三方服务微信相关的友情提示微信已经成为大家日常必不可少的交流工具，用作推广 App 来说是再好不过的，但是微信内部通常是无法直接跳转至其他 App 的。那除了以上列出的技术方案，我们还可以如何去实现这个技术需求呢？ 应用宝如果你的页面需要能直接打开应用商店，可以把你的 App 上传到应用宝平台，因为应用宝和 AppStore 有合作，并且在内部实现了属于自己的一套流程，直接在微信中跳转应用宝的链接也是一个可选的方案。 微信开放标签微信在 2020 年 5 月推出了微信开放标签功能，用于在微信浏览器内直接唤醒 App，也能通过携带参数直接进入 App 相应的页面，只要按照文档规定接入微信 SDK 就可直接使用该功能。 具体要求可以参考官方开放平台：微信官方文档（ developers.weixin.qq.com/doc/oplatfo… ）。 https://cloud.tencent.com/developer/article/1652487 deeplin VS AppLink Deep Links 是一种允许用户进入应用某个特定Activity的intent filter。点击这类链接时，系统可能会弹出一个选择列表，让用户在一堆能够处理这类链接的应用里(包括你的)选择一个来处理该链接。图一展示了这样一种情况：用户点击了一个地图相关的链接，系统弹出一个选择列表，让用户选择是要使用地图应用来处理，还是使用Chrome浏览器来处理。 App Links 是一种基于你的网站地址且验证通过的Deep Links。因此，点击一个这样的链接会直接打开你的应用(如果已经安装)，系统将不会弹出选择列表。当然，后续用户可以更改配好设置，来指定由哪个应用程序处理这类链接。 item Deep Links App Links Intent URL Scheme https, http，或者自定义 需为http或https Intent Action 任意Action 需为android.intent.action.VIEW Intent Category 任意Category 需为android.intent.category.BROWSABLE和android.intent.category.DEFAULT 链接验证 不需要 需要在网站上放置一个数字资产链接，并能够通过HTTPS访问 用户体验 可能会弹出一个选择列表给用户选择用哪个应用处理连接 没有弹框，系统直接打开你的应用处理网站连接 兼容性 所有Android版本 Android 6.0及以上 https://juejin.cn/post/6844903954149539848 由于大部分应用，如微博、微信、第三方浏览器(包括Chrome)，都不会将URL抛给系统处理(对scheme进行屏蔽)，因此App Links生效的情况就很有限了，比如只能从记事本应用、短信应用这些进行跳转。一般商用实现的是打开系统浏览器，通过系统浏览器打开应用的对应页面。 作者：JinBeen链接：https://juejin.cn/post/6844903954149539848来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"LC-Tree-Search-22","slug":"LC-Tree-Search-22","date":"2022-10-05T14:00:07.000Z","updated":"2023-01-02T03:31:39.080Z","comments":true,"path":"2022/10/05/LC-Tree-Search-22/","link":"","permalink":"https://noteforme.github.io/2022/10/05/LC-Tree-Search-22/","excerpt":"","text":"二叉树搜索 BST根节点比左子树所有节点的数值都大，比右子树所有节点的数值都小. 700. 二叉搜索树中的搜索My idea DFS 先序遍历搜索，如果找到了直接返回当前节点。 123456789101112131415fun searchBST(root: TreeNode?, `val`: Int): TreeNode? &#123; if (root == null) return null if (root.`val` == `val`) &#123; return root &#125; val nodeLeft = searchBST(root.left, `val`) if (nodeLeft != null) &#123; return nodeLeft &#125; val nodeRight = searchBST(root.right, `val`) if (nodeRight != null) &#123; return nodeRight &#125; return null&#125; 看了官方解法,利用二叉搜索树的特性 1234567891011fun searchBST1(root: TreeNode?, `val`: Int): TreeNode? &#123; if (root == null) return null var node: TreeNode? = root.left if (root.`val` == `val`) &#123; //一开始没有做出来，这个条件没写,导致一直往下递归 return root &#125; if (root.`val` &lt; `val`) &#123; node = root.right &#125; return searchBST1(node, `val`)&#125; 迭代法二叉搜索树的迭代法相对简单，暂时先不看了 98. 验证二叉搜索树二叉搜索树是一个有序树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 注意==都不行 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。 一开始理解错了，只比较根节点和左右子树，导致下面这个testcase没通过，应该是根节点和所有的左右子树的节点数组 15, 4, 6, null, null, 3, 7 转数组把中序遍历转成数组很好理解 中序遍历递归 得到list数组 比较数组的前后节点大大小, 如果前面节点值更大，那么直接返回false, ==也不行 1234567891011121314151617val list = LinkedList&lt;Int&gt;()fun isValidBST3(root: TreeNode?): Boolean &#123; dfsTraversal(root) // 中序遍历递归 得到list数组 for (i in 0 until list.size - 1) &#123; // 比较数组的前后节点大大小 if (list[i] &gt;= list[i + 1]) &#123; // 如果前面节点值更大，那么直接返回false, ==也不行 return false &#125; &#125; return true&#125;private fun dfsTraversal(root: TreeNode?) &#123; if (root == null) return dfsTraversal(root.left) list.add(root.`val`) dfsTraversal(root.right)&#125; 递归解法随想录的递归解法，一开始怎么也理解不了，其实和上面 中序转数组的类似，就是把根据中序遍历遍历的节点，后一个节点一定比前一个节点的数值高。 中序遍历 后一个节点比前一个节点的值大，就可以了，所以存储前一个节点。 123456789101112131415var preNode: TreeNode? = nullfun isValidBST4(root: TreeNode?): Boolean &#123; if (root == null) return true if (!isValidBST4(root.left)) &#123; return false &#125; if (preNode != null &amp;&amp; preNode!!.`val` &gt;= root.`val`) &#123; return false &#125; preNode = root if (!isValidBST4(root.right)) &#123; return false &#125; return true&#125; 之前的题主要用到 后序和先序，二叉搜索这里开始用到了 中序遍历。 530. 二叉搜索树的最小绝对差My idea 这一题和上一题 98 思路差不多， 中序遍历的节点之间的数组相差最小，所以找出节点间的间隔最小值就可以了。 123456789101112131415var preNode: TreeNode? = nullvar miniNum = Int.MAX_VALUEfun getMinimumDifference(root: TreeNode?): Int &#123; if (root == null) return Int.MAX_VALUE getMinimumDifference(root.left) if (preNode != null) &#123; val gapNum = root.`val` - preNode!!.`val`//这一步可以简化 Math.min() if (gapNum &lt; miniNum) &#123; miniNum = gapNum &#125; &#125; preNode = root getMinimumDifference(root.right) return miniNum&#125; 也可以先中序遍历转成数组，然后求数组元素间的差值就可以了。 501. 二叉搜索树中的众数My idea 我的想法和上面的类似。 中序遍历相邻节点用map存下value和值的个数。 遍历map求得最大个事的数组。把map按照value个数进行数组排序 然后取排序后的前面的元素 。了。/其实上面这种方式，用先序 后序都可以，都不需要二叉搜索树。 其实上面我的想法也是 打算用二叉搜索树的特性，放到map中，然后把map排序,就不知道怎么处理更好。看了随想录的处理方式,理了下思路. 根据中序遍历的前后节点，他们的值相同的是一起的，进行遍历。 对value值进行count计数，如果count == 最大个数，加入集合。 如果count&gt;最大个数，清空集合. 一开始不知道放哪里, maxCount=count ，以为在前面if (preNode != null &amp;&amp; preNode!!.val == node.val) 前面的比较里面,还想着Math.max,但是都不合适。然后看了一半随想录是放在更新节点的位置，更好. 1234567891011121314151617181920212223242526272829303132val array = ArrayList&lt;Int&gt;()fun findMode(root: TreeNode?): IntArray &#123; inDFS(root) return array.toIntArray()&#125;var preNode: TreeNode? = nullvar maxCount = 0var count = 0private fun inDFS(node: TreeNode?) &#123; val printNode = node?.`val` println(&quot;printNode $printNode&quot;) if (node == null) &#123; return &#125; inDFS(node.left) if (preNode != null &amp;&amp; preNode!!.`val` == node.`val`) &#123; count++ &#125; else &#123; count = 1 &#125; if (count == maxCount) &#123; array.add(node.`val`) &#125; if (count &gt; maxCount) &#123; maxCount = count//这一步一开始不知道放哪里,看了一眼随想录答案 array.clear() // 有更大的值，清空之前的集合 array.add(node.`val`) &#125; preNode = node inDFS(node.right)&#125; 官方还有 o(1)的处理，while循环 https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/ 236. 二叉树的最近公共祖先这一题有两种想法 之前做的环形链表 走对方的路 先序遍历每一个节点，只要下面的节点都走过，只要下一个节点没有走到，就返回上一个节点，但是先序遍历DFS 两个节点都走了不知道怎么返回。 看了随想录视频思路后 https://www.bilibili.com/video/BV1jd4y1B7E2 后序遍历如果碰到p或q,就返回他们的节点. 如果一个节点的左右子树都不为空说明当前节点是他们的最近公共祖先. 还一种情况，有一个节点p就是祖先节点 debug调试，拼凑把代码写出来了 123456789101112131415161718 fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? &#123; if (root == null) return null // 随想录这里改成 碰到节点判断，直接在这里返回// val printData = root.`val`// println(printData) val leftNode = lowestCommonAncestor(root.left, p, q) val rightNode = lowestCommonAncestor(root.right, p, q) if (leftNode != null &amp;&amp; rightNode != null) &#123; // 如果左右子树都不为空，那么当前节点就是最近公共祖先节点 return root &#125; if (p != null &amp;&amp; root.`val` == p.`val`) &#123; //碰到了其中一个节点返回 return root &#125; else if (q != null &amp;&amp; root.`val` == q.`val`) &#123; return root //碰到了其中一个节点返回 &#125; if (leftNode != null) return leftNode //回溯之前碰到的节点 if (rightNode != null) return rightNode return null &#125; 终止条件写法 随想录这里改成 碰到节点判断，直接在这里返回，下次可以改成在终止条件这里，更简单 235. 二叉搜索树的最近公共祖先My idea 可以根据二叉搜索树的特性， 祖先节点的值大小有两种情况 在p和q之前, 如果p&lt;q, 祖先节点的值 等于p , 大于q 只要满足上述条件，用先序遍历或者后序遍历都可以，把节点返回 官方和随想录解法都是给出了相反的条件 ，当前节点&lt;p , &gt;q,在外面的情况（其实这里没想清楚,不存在这样的&lt;2 &gt;4的节点）, 但是我这里ide testcase也没问题。 https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/ 1234567891011121314151617181920212223242526272829303132/** * 很奇怪，IDE可以跑这个testcase没问题 *[2,1] * 2 * 1 */fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? &#123; if (root == null) return null if (p!!.`val` &gt; q!!.`val`) &#123; swap(p, q) &#125; if (root.`val` &gt; p.`val` &amp;&amp; root.`val` &lt; q.`val`) &#123; return root &#125; if (root.`val` == p.`val` &amp;&amp; root.`val` &lt; q.`val`) &#123; return root &#125; if (root.`val` == q.`val` &amp;&amp; root.`val` &gt; p.`val`) &#123; return root &#125; val leftNode = lowestCommonAncestor(root.left, p, q) if (leftNode != null) return leftNode val rightNode = lowestCommonAncestor(root.right, p, q) if (rightNode != null) return rightNode return null&#125;fun swap(p: TreeNode, q: TreeNode?) &#123; val temp = p.`val` p.`val` = q!!.`val` q.`val` = temp&#125; https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html https://www.bilibili.com/video/BV1Zt4y1F7ww 看了随想录视频，其实相反的就两种情况 当前节点 &lt;p , &lt;q， 那么p,q一定在右子树上，就去右子树去找 当前节点 &gt; p , &gt;q ,那么p,q一定在左子树上，就去左子树去找 12345678910111213fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? &#123; if (root == null) return null if (root.`val` &lt; p!!.`val` &amp;&amp; root.`val` &lt; q!!.`val`) &#123; // 当前节点比p和q的值都小，那么一定p,q一定在右子树上，就往右边遍历 val rightNode = lowestCommonAncestor(root.right, p, q) if (rightNode != null) return rightNode &#125; if (root.`val` &gt; p.`val` &amp;&amp; root.`val` &gt; q!!.`val`) &#123; val leftNode = lowestCommonAncestor(root.left, p, q) if (leftNode != null) return leftNode &#125; return root&#125; 701. 二叉搜索树中的插入操作DFSMy idea 可以用后序遍历，按照二叉树的特性，走到叶子节点后，连接到叶子节点，然后回溯到根节点并返回 后序遍历根据待插入值和当前节点比较，找到需要插入的位置。 如果需要插入的位置左或右节点刚好为空，就插入。 随想录其中一个解法和我的这个类似，不过感觉比我这个更复杂点 自己的做的解法 123456789101112131415161718fun insertIntoBST(root: TreeNode?, `val`: Int): TreeNode? &#123; if (root == null) return TreeNode(`val`) //有一个这个test case [] 5 ,空树的话返回 [5] if (`val` &lt; root.`val`) &#123; // 插入点小于当前节点，往左子树中插入 insertIntoBST(root.left, `val`) &#125; if (`val` &gt; root.`val`) &#123; insertIntoBST(root.right, `val`) &#125; // 一开始这个放前面导致添加了两个5的左节点，因为 insertIntoBST(root.left, `val`)又走了一次 val treeNode = TreeNode(`val`) // 只有一次机会走这个 if (root.right == null &amp;&amp; `val` &gt; root.`val`) &#123; // 待插入点大于当前节点，所以要插入右子树中，此时右子树为空，那么直接插入 root.right = treeNode &#125; else if (root.left == null &amp;&amp; `val` &lt; root.`val`) &#123; root.left = treeNode &#125; return root&#125; 看了随想录的解法，其实还可以每一个都被父节点接住更简单,也是后序遍历的精髓 123456789101112fun insertIntoBST(root: TreeNode?, `val`: Int): TreeNode? &#123; if (root == null) &#123; return TreeNode(`val`) &#125; if (`val` &lt; root.`val`) &#123; // 插入点小于当前节点，往左子树中插入 root.left = insertIntoBST1(root.left, `val`) &#125; if (`val` &gt; root.`val`) &#123; root.right = insertIntoBST1(root.right, `val`) &#125; return root&#125; 迭代法官方用迭代法 ,看起来也不难 https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/ 450. 删除二叉搜索树中的节点My idea 和上面思路类似，用后序遍历的 父节点接住，当前要删除节点的左或者右节点，那么当前节点就删除了，然后左右节点再改变指向。 后序遍历到要删除的节点. 当前节点的右节点指向它的左节点。被上一个节点回溯的父节点接住。 返回当前节点的左节点， [5,3,6,2,4,null,7]5优先还是需要右节点上去，否则就很麻烦，需要4上去 删除节点主要有这5种情况 第一种情况：没找到删除的节点，遍历到空节点直接返回了 找到删除的节点 第二种情况：删除的左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 第五种情况：删除节点的左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 12345678910111213141516171819202122232425262728293031323334353637383940fun deleteNode(root: TreeNode?, key: Int): TreeNode? &#123; if (root == null) return null //情况一 if (key &lt; root.`val`) &#123; root.left = deleteNode(root.left, key) &#125; else if (key &gt; root.`val`) &#123; root.right = deleteNode(root.right, key) &#125; if (key == root.`val`) &#123; if (root.right == null &amp;&amp; root.left == null) &#123; return null // 情况2 [0] 0 因为这个testcase 会返回[0]和预期不一致 &#125; else if (root.left != null &amp;&amp; root.right == null) &#123; //情况三 如果左节点不为空 val node = root.left // 左节点 2 推到删除的节点位置 if(root.right!=null)&#123; //这两句可以去掉 ，直接返回节点 node.right = root.right //此时左节点2在在删除节点位置，它的右子树指向之前右节点4 &#125; return node &#125; else if (root.right != null &amp;&amp; root.left == null) &#123; //情况四 如果右节点不为空 val node = root.right //右节点4 推到删除的节点位置 if(root.left!=null)&#123; //这两句可以去掉 node.left = root.left // 此时左节点4在在删除节点位置，它的左子树指向之前右节点2 &#125; return node &#125; else &#123; val rightNode = root.right //情况五 var leftNode = rightNode?.left while (leftNode?.left!= null) &#123; leftNode = leftNode.left &#125; if (leftNode != null) &#123; leftNode.left = root.left &#125; else &#123; rightNode.left = root.left &#125; root.left = null return rightNode // 这里返回的节点，可以被上面的左右子树接住 &#125; &#125; return root&#125; 普通二叉树的节点删除通用二叉树节点删除 要加if (leftNode != null)，否则删除报错 这个题目的leetcode的测试用例有问题,单独跑报错. 108. 将有序数组转换为二叉搜索树看了随想录的解答，从中取中间节点的位置就可以了，如果数字是偶数，中间节点的两个中的一个都可以， 但是问题来了，为什么取中间节点构造的二叉树就是高度平衡的二叉搜索树呢? 先按照这个思路，把代码写出来 按照先序遍历思路，先找到根节点，构造出中间节点。 根据中间节点划定新的数组的范围，左边和右边，然后递归找到新的数组的中间节点继续划出范围. 在这里 左闭右闭更合理 这题主要注意边界值,if (left &gt; right）这个要注意是&gt; 没有=,因为index-1和index+1了，所以最终一定会超过right 123456789101112131415fun sortedArrayToBST(nums: IntArray): TreeNode? &#123; return buildSearchTree(nums, 0, nums.size - 1)&#125;private fun buildSearchTree(nums: IntArray, left: Int, right: Int): TreeNode? &#123; if (left &gt; right) &#123; return null &#125; val index = /*(start + end) / 2*/ left + (right - left) / 2 val node = TreeNode(nums[index]) // println(&quot;node $&#123;node.`val`&#125; : start $left end $right&quot;) node.left = buildSearchTree(nums, left, index - 1) node.right = buildSearchTree(nums, index + 1, right) return node&#125; 538. 把二叉搜索树转换为累加树累加树: 按照中序遍历的到的 从小到大的数组 [1,2,3,4] ,累加树就是右到左的值相加 [10,9,7,4] https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92 中序遍历的树 : 左 中 右 2 , 5, 13 反中序遍历的: 右 中 左 13 , 5 , 2 然后按照反中序遍历的到节点累加就可以了。 这一题一开始没想上面的思路，看了随想录的思路后,写出来的 123456789var sum = 0fun convertBST(root: TreeNode?): TreeNode? &#123; if (root == null) return null convertBST(root.right) sum += root.`val` root.`val` = sum convertBST(root.left) return root&#125; 根据中序遍历的规则，写出反中序 右中左遍历节点。 拿到每次中序的到的节点累加，然后赋值给当前节点。 sum += root.`val` root.`val` = sum 这一段可以改进，可以保存前一个节点值，然后加上当前节点就可以了。 123456789var pre = 0fun convertBST1(root: TreeNode?): TreeNode? &#123; if (root == null) return null convertBST(root.right) root.`val` += pre pre = root.`val` convertBST(root.left) return root&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"Fragment_StateLoss","slug":"Fragment-StateLoss","date":"2022-09-15T02:25:12.000Z","updated":"2024-03-31T23:23:52.278Z","comments":true,"path":"2022/09/15/Fragment-StateLoss/","link":"","permalink":"https://noteforme.github.io/2022/09/15/Fragment-StateLoss/","excerpt":"","text":"问题 ，Activity恢复后 mStateSaved,是怎么恢复的？ 就是onSavedInstanceState 的官方API文档2 这里问题的场景是Activity已经关闭了,rpc请求很久再回来,导致了这个问题,所以我觉得判断livedate激活状态就可以了 可是这个改动应该只能在resume吧？ LiveData started 和 resumed 都可以 Livedata 会感知activity生命周期 这个有可能 activity 也在 started / resumed 状态下发出吧？ 这样的话，showDialog 应该也还会崩溃，因为onSavedInstanceState 是在 paused 时候发生的，这个时候应该还是 started 状态。 12345678910111213141516171819/*** 后续考虑做个技改把它加到[BaseDialogFragment]里面*/fun showWithLifecycle(fragmentActivity: FragmentActivity, tag: String? = null) &#123; val liveData = showWithLifecycleLiveData ?: MutableLiveData&lt;Boolean&gt;().also &#123; it.observe(fragmentActivity) &#123; this.show(fragmentActivity.supportFragmentManager, tag) &#125; showWithLifecycleLiveData = it &#125; liveData.value = true&#125; onSaveInstanceState保存分析 https://juejin.cn/post/6995791487426363405 状态恢复 https://www.jianshu.com/p/58579627f70a https://juejin.cn/post/7057564670567120903 can not perform this action after onsaveinstancestate dialogfragment show developer -&gt; 不保留活动 onSaveInstanceState以下5种情况被调用： 1、当用户按下手机home键的时候。 2、长按手机home键或者按下菜单键时。 3、手机息屏时。 4、FirstActivity启动SecondActivity，FirstActivity就会调用，也就是说打开新Activity时，原Activity就会调用。 5、默认情况下横竖屏切换时。 打开Activity -&gt; Home -&gt; 再从后台拿出来 既然状态的保存与恢复都必须要把Fragment带上，那么一旦当Fragment的状态已保存过了，那么就不应该再改变Fragment的状态。因此FragmentManager的每一个操作前，都会调用一个方法来检查状态是否保存过了： 12345678910private void checkStateLoss() &#123; if (mStateSaved) &#123; throw new IllegalStateException( &quot;Can not perform this action after onSaveInstanceState&quot;); &#125; if (mNoTransactionsBecause != null) &#123; throw new IllegalStateException( &quot;Can not perform this action inside of &quot; + mNoTransactionsBecause); &#125;&#125; 12345678910111213141516171819/** * This is the same as &#123;@link #onSaveInstanceState&#125; but is called for activities * created with the attribute &#123;@link android.R.attr#persistableMode&#125; set to * &lt;code&gt;persistAcrossReboots&lt;/code&gt;. The &#123;@link android.os.PersistableBundle&#125; passed * in will be saved and presented in &#123;@link #onCreate(Bundle, PersistableBundle)&#125; * the first time that this activity is restarted following the next device reboot. * * @param outState Bundle in which to place your saved state. * @param outPersistentState State which will be saved across reboots. * * @see #onSaveInstanceState(Bundle) * @see #onCreate * @see #onRestoreInstanceState(Bundle, PersistableBundle) * @see #onPause */public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) &#123; onSaveInstanceState(outState);&#125; 为什么会有这个异常 https://blog.csdn.net/lzf_acraftsman/article/details/108831949 https://juejin.cn/post/6844903458605105160 fragment重叠原因 Fragment懒加载Fragment和ViewPager一起使用会有个预加载机制，会把旁白的Fragment的生命周期方法前半段先执行，然后执行自身的生命周期方法 在项目终从其他页面回到MainAcitivty的时候，三个页面的生命周期方法都跑了一遍 123456 D/FinanceFragment Test: onStart()D/WealthFragment Test: onStart()D/MineFragment Test: onStart()D/FinanceFragment Test: onResume()D/WealthFragment Test: onResume()D/MineFragment Test: onResume() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 private boolean isPrepared; //判断view是否加载完成,在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常 private boolean isVisible; //判断当前Fragment是否可见状态,标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的 @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); isPrepared = true; lazyLoad(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123;// Log.d(TAG + &quot; Test&quot;, &quot; onCreateView()&quot;); if (rootView == null) &#123; int view = setLayoutId(); if (view != 0) &#123; rootView = inflater.inflate(view, container, false); &#125; &#125; else &#123; ViewGroup parent = (ViewGroup) rootView.getParent(); if (parent != null) &#123; parent.removeView(rootView); &#125; &#125; initView(rootView); return rootView; &#125; // http://www.10tiao.com/html/565/201702/2247483988/1.html // 标志位，标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的， // 在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常 private boolean isPrepared; //标志当前页面是否可见 private boolean isVisible; @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser);// Log.d(TAG + &quot; Test&quot;, &quot; setUserVisibleHint() is Visible : ? &quot; + isVisibleToUser); if (getUserVisibleHint()) &#123; isVisible = true; onVisible(); &#125; else &#123; isVisible = false; onInvisible(); &#125; &#125; protected void onInvisible() &#123; &#125; protected void onVisible() &#123; lazyLoad(); &#125; private void lazyLoad() &#123; if (!isVisible || !isPrepared) &#123; return; &#125; requestData(); &#125; /** * 请求数据 */ protected void requestData() &#123; Log.d(TAG + &quot; Test&quot;, &quot; requestData &quot;); &#125; http://www.10tiao.com/html/565/201702/2247483988/1.html Activity dialogFragment 的事件回调12345678910111213141516interface ISelectListener &#123; fun getItemPosition(position: Int)&#125;var mListener: ISelectListener? = nulloverride fun onAttach(context: Context) &#123; super.onAttach(context) if (parentFragment is ISelectListener)&#123; mListener = parentFragment as ISelectListener &#125;else if (context is ISelectListener) &#123; mListener = context &#125; else &#123; throw RuntimeException(context!!.toString() + &quot; must implement ISelectListener&quot;) &#125;&#125; https://developer.android.com/guide/components/fragments.html onHiddenChanged切换刷新 使用hide()/show()发现生命周期基本不执行，不过可以用到这个onHiddenChanged(); 看下执行的生命周期; 从 SecondFragment 页面开始到 -&gt;FirstFragment 07-18 15:53:25.128 7758-7758/com.mineutils D/SecondFragment: onAttach(Context context)07-18 15:53:25.129 7758-7758/com.mineutils D/SecondFragment: onCreate()07-18 15:53:25.142 7758-7758/com.mineutils D/SecondFragment: onCreateView()07-18 15:53:25.148 7758-7758/com.mineutils D/SecondFragment: onViewCreated onActivityCreated() onStart()​ onResume() 07-18 15:53:34.200 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden true07-18 15:53:34.207 7758-7758/com.mineutils D/FirstFragment: onCreateView()07-18 15:53:34.208 7758-7758/com.mineutils D/FirstFragment: onViewCreated onActivityCreated()​ onStart() 07-18 15:53:53.968 7758-7758/com.mineutils D/FirstFragment: onHiddenChanged hidden true07-18 15:53:53.968 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden false https://blog.csdn.net/cml_blog/article/details/41411451 导航栏https://wizardforcel.gitbooks.io/w3school-android/content/77.html https://juejin.im/post/5901b564570c35005804424b Fragment not attached to a contexthttps://weidianhuang.medium.com/android-fragment-not-attached-to-a-context-24d00fac4f3d","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"https://noteforme.github.io/tags/Fragment/"}]},{"title":"LC_TREE08","slug":"LC-TREE08","date":"2022-09-11T07:39:49.000Z","updated":"2023-01-02T03:31:39.080Z","comments":true,"path":"2022/09/11/LC-TREE08/","link":"","permalink":"https://noteforme.github.io/2022/09/11/LC-TREE08/","excerpt":"","text":"101. 对称二叉树层序遍历层序遍历是没法实现的 123456789101112131415161718192021 fun isSymmetric3(root: TreeNode?): Boolean &#123; val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layerSize = queue.size for (i in 0 until layerSize) &#123;// val lastIndex = layerSize - 1 - i // 这样不可以,poll取出元素后，就少了元素越界了 val headNode = queue.poll() val lastNode = queue.lastOrNull() if (headNode.`val` != lastNode?.`val`) &#123; return false &#125; headNode.left?.let &#123; queue.offer(it) &#125; headNode.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return true &#125; 递归// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了 12345678910private fun leftRightSymmetric(nodeLeft: TreeNode?, nodeRight: TreeNode?): Boolean &#123; if (nodeLeft?.`val` == nodeRight?.`val`) &#123; // 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了 return true &#125; else if (nodeLeft == nodeRight) &#123; // = null return true &#125; leftRightSymmetric(nodeLeft?.left, nodeRight?.right) leftRightSymmetric(nodeLeft?.right, nodeRight?.left) return false&#125; https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95 从根节点的左右子树开始，深度遍历比较 123456789101112131415161718fun isSymmetric(root: TreeNode?): Boolean &#123; return leftRightSymmetric(root?.left, root?.right)&#125;private fun leftRightSymmetric(nodeLeft: TreeNode?, nodeRight: TreeNode?): Boolean &#123; if (nodeLeft == null &amp;&amp; nodeRight != null) &#123; return false &#125; else if (nodeLeft != null &amp;&amp; nodeRight == null) &#123; return false &#125; else if (nodeLeft?.`val` != nodeRight?.`val`) &#123; return false &#125; else if (nodeLeft == null &amp;&amp; nodeRight == null) &#123; return true //这里需要，否则就递归 溢出了,如果根节点的左右节点为null,退出也是没问题的 &#125; val leftFlag = leftRightSymmetric(nodeLeft?.left, nodeRight?.right) val rightFlag = leftRightSymmetric(nodeLeft?.right, nodeRight?.left) return leftFlag &amp;&amp; rightFlag&#125; 队列 队列，一直向下按照对称的条件添加 12345678910111213141516171819202122fun isSymmetric1(root: TreeNode?): Boolean &#123; val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; root.left?.let &#123; queue.offer(it) &#125; // 官方解法中，根节点入队2次也可以 root.right?.let &#123; queue.offer(it) &#125; &#125; while (queue.isNotEmpty()) &#123; val node1 = queue.poll() val node2 = queue.poll() if(node1==null&amp;&amp;node2==null)&#123; // 一开始没写这个条件，提示超出时间限制 return true &#125; if (node1?.`val` != node2?.`val`) &#123; return false &#125; queue.offer(node1?.left) // 两边的节点比较 queue.offer(node2?.right) queue.offer(node1?.right) //中间的节点比较 queue.offer(node2?.left) &#125; return true&#125; 栈也是可以的，只要保证位置靠近 100. 相同的树递归12345678910fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean &#123; if (p == null &amp;&amp; q != null) &#123; return false &#125; else if (p != null &amp;&amp; q == null) &#123; return false &#125; else if (p == null &amp;&amp; q == null) &#123; return true &#125; return p?.`val` == q?.`val` &amp;&amp; isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)&#125; 队列 1234567891011121314151617181920212223242526fun isSameTree1(p: TreeNode?, q: TreeNode?): Boolean &#123; if (p == null &amp;&amp; q != null) &#123; return false &#125; else if (p != null &amp;&amp; q == null) &#123; return false &#125; val queue = LinkedList&lt;TreeNode&gt;() queue.offer(p) queue.offer(q) while (queue.isNotEmpty()) &#123; val node1 = queue.poll() val node2 = queue.poll() if (node1 == null &amp;&amp; node2 == null) &#123; // continue后，因为null,就不会加入新的节点 continue &#125; if (node1?.`val` != node2?.`val`) &#123; return false &#125; queue.offer(node1?.left) queue.offer(node2?.left) queue.offer(node1?.right) queue.offer(node2?.right) &#125; return true&#125; 572. 另一棵树的子树123456789101112131415161718192021222324fun isSubtree(root: TreeNode?, subRoot: TreeNode?): Boolean &#123; if (root == null &amp;&amp; subRoot == null) &#123; return true &#125; else if (root == null &amp;&amp; subRoot != null) &#123; return false &#125; else if (root != null &amp;&amp; subRoot == null) &#123; return false &#125; return isSameTree(root, subRoot) || isSubtree(root?.left, subRoot) || isSubtree(root?.right, subRoot) //subRoot和root相同,subRoot和root左子树相同，subRoot和右子树相同&#125;private fun isSameTree(node1: TreeNode?, node2: TreeNode?): Boolean &#123; if (node1 == null &amp;&amp; node2 == null) &#123; return true &#125; else if (node1 == null &amp;&amp; node2 != null) &#123; return false &#125; else if (node1 != null &amp;&amp; node2 == null) &#123; return false &#125; return node1?.`val` == node2?.`val` &amp;&amp; isSameTree(node1?.left, node2?.left) &amp;&amp; isSameTree( node1?.right, node2?.right )&#125; 222. 完全二叉树的节点个数DFS 普通二叉树解法123456fun countNodes(root: TreeNode?): Int &#123; if (root == null) return 0 val leftCount = countNodes(root.left) val rightCount = countNodes(root.right) return leftCount + rightCount + 1&#125; BFS1234567891011121314151617fun countNodes1(root: TreeNode?): Int &#123; val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; var count = 0 while (queue.isNotEmpty()) &#123; val size = queue.size for (i in 0 until size) &#123; val treeNode = queue.poll() count++ treeNode.left?.let &#123; queue.offer(it) &#125; treeNode.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return count&#125; DFS 完全二叉树特性一开始打算用先序遍历，但是这样不行, 如果一颗树 是平衡的，永远是得到 1, 想了一下，这种也不属于 先序遍历 12345678910111213fun countNodes(root: TreeNode?): Int &#123; val depth = 0 return postTraversal(root, depth)&#125;private fun postTraversal(root: TreeNode?, depth: Int): Int &#123; if (isBalanced(root)) &#123; return 2 shl (depth - 1) &#125; val leftNums = postTraversal(root?.left, depth + 1) val rightNums = postTraversal(root?.right, depth + 1) return leftNums + rightNums + 1&#125; 先序遍历123456789101112131415161718192021fun countNodes(root: TreeNode?): Int &#123; if (root == null) return 0 var leftNode = root.left var depthLeft = 0 //左子树深度 while (leftNode != null) &#123; leftNode = leftNode.left depthLeft++ &#125; var rightNode = root.right var depthRight = 0 while (rightNode != null) &#123; rightNode = rightNode.right depthRight++ &#125; if (depthLeft == depthRight) &#123; return (2 shl depthLeft) - 1 // 节点数 &#125; val leftNums = countNodes(root.left) val rightNums = countNodes(root.right) return leftNums + rightNums + 1&#125; 后序遍历123456789101112131415161718192021fun countNodes3(root: TreeNode?): Int &#123; if (root == null) return 0 var leftNode = root.left var depthLeft = 0 //左子树深度 while (leftNode != null) &#123; leftNode = leftNode.left depthLeft++ &#125; var rightNode = root.right var depthRight = 0 while (rightNode != null) &#123; rightNode = rightNode.right depthRight++ &#125; val leftNums = countNodes(root.left) val rightNums = countNodes(root.right) if (depthLeft == depthRight) &#123; return (2 shl depthLeft) - 1 // 节点数 &#125; return leftNums + rightNums + 1&#125; 110. 平衡二叉树一开始错误的解答是这样的 123456789101112131415 fun isBalanced(root: TreeNode?): Boolean &#123; return postTraversal(root) != -1 &#125; private fun postTraversal(node: TreeNode?): Int &#123; if (node == null) return 0 val leftDepth = postTraversal(node.left) val rightDepth = postTraversal(node.right) val isBalance = Math.abs(leftDepth - rightDepth) &lt;= 1 if (isBalance) &#123; return Math.max(leftDepth, rightDepth) + 1 &#125; return -1 &#125;&#125; 这里问题是 return -1，作为父节点的深度返回给了 depth，然后继续计算 Math.abs(leftDepth - rightDepth) &lt;= 1，出现了问题 改进解法 1234567891011121314151617fun isBalanced(root: TreeNode?): Boolean &#123; return postTraversal(root) != -1&#125;private fun postTraversal(node: TreeNode?): Int &#123; if (node == null) return 0 val leftDepth = postTraversal(node.left) val rightDepth = postTraversal(node.right) if (leftDepth == -1 || rightDepth == -1) &#123; // 子节点已经有不是平衡的节点 直接返回，来判断 return -1 &#125; val isBalance = Math.abs(leftDepth - rightDepth) &lt;= 1 if (isBalance) &#123; return Math.max(leftDepth, rightDepth) + 1 &#125; return -1&#125; 随想录迭代遍历，看起来很复杂，看起来是统一解法. https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D 257. 二叉树的所有路径隐藏回溯过程这一题 没理解透字符串怎么形成的和回溯的, 用到了先序遍历， https://www.bilibili.com/video/BV1ZG411G7Dh 视频包含了回溯过程 可以看下随想录回溯过程 12345678910111213141516171819202122232425262728fun binaryTreePaths(root: TreeNode?): List&lt;String&gt; &#123; val result = LinkedList&lt;String&gt;() if (root == null) return result dfs(root, result, root.`val`.toString()) return result&#125;/** * https://www.youtube.com/watch?v=swG70SQBJ-A * * 1. String不能用 StringBuilder,存在引用传递问题，会输出 * [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;2-&gt;5-&gt;3&quot;] * * 2. 在先序位置 val存到path也有问题,头节点会存在重复的情况 [&quot;1-&gt;1-&gt;2-&gt;5&quot;,&quot;1-&gt;1-&gt;2-&gt;5-&gt;3&quot;] */private fun dfs(node: TreeNode?, result: LinkedList&lt;String&gt;, path: String) &#123; if (node == null) return if (node.left == null &amp;&amp; node.right == null) &#123; result.add(path) &#125; if (node.left != null) &#123; dfs(node.left, result, &quot;$path-&gt;$&#123;node.left.`val`&#125;&quot;) &#125; if (node.right != null) &#123; dfs(node.right, result, &quot;$path-&gt;$&#123;node.right.`val`&#125;&quot;) &#125;&#125; 上面2的情况演示 12345678910111213private fun dfs(node: TreeNode?, result: LinkedList&lt;String&gt;, path: String?) &#123; if (node == null) return val mPath = &quot;$path-&gt; $&#123;node.`val`&#125;&quot; if (node.left == null &amp;&amp; node.right == null) &#123; result.add(mPath) &#125; if (node.left != null) &#123; dfs(node.left, result, mPath) &#125; if (node.right != null) &#123; dfs(node.right, result, mPath) &#125;&#125; 上面两种写法，回溯隐藏在参数里面. 显示回溯这是随想录的代码，二刷可以自己写, 1234567891011121314151617181920212223242526272829303132fun binaryTreePaths(root: TreeNode?): List&lt;String&gt;? &#123; val res: MutableList&lt;String&gt; = ArrayList() if (root == null) &#123; return res &#125; val paths: MutableList&lt;Int&gt; = ArrayList() traversal(root, paths, res) return res&#125;private fun traversal(root: TreeNode, paths: MutableList&lt;Int&gt;, res: MutableList&lt;String&gt;) &#123; paths.add(root.`val`) // 叶子结点 if (root.left == null &amp;&amp; root.right == null) &#123; // 碰到叶子节点，开始把path遍历放进string中 // 输出 val sb = StringBuilder() for (i in 0 until paths.size - 1) &#123; sb.append(paths[i]).append(&quot;-&gt;&quot;) &#125; sb.append(paths[paths.size - 1]) //也可以放到上面一起再把&quot;-&gt;&quot; 删除 res.add(sb.toString()) return &#125; if (root.left != null) &#123; traversal(root.left, paths, res) paths.removeAt(paths.size - 1) // 回溯 &#125; if (root.right != null) &#123; traversal(root.right, paths, res) paths.removeAt(paths.size - 1) // 回溯 &#125;&#125; 1paths.removeAt(paths.size - 1) 最初这里没理解，都删除了，为什么,上面还能遍历所有节点，其实递归是一致先走的，碰到叶子节点的时候，遍历path, 最后才开始 paths.removeAt(paths.size - 1) 回溯 到上面. https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html https://www.bilibili.com/video/BV1ZG411G7Dh 迭代法 后面再说吧 404. 左叶子之和这一题和【 222 完全二叉树的节点个数】很像，这里是普通的二叉树，所以我的想法就前两种做法 后序遍历 层序遍历 把根节点换成左子树的节点 看错了题目，其实是左子树叶子值的和 https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF 只看了随想录题解，自己这样写的代码 递归法12345678910111213141516fun sumOfLeftLeaves(root: TreeNode?): Int &#123; return dfsLeaves(root, 0)&#125;/** * @param direction 0 右子树， 1：左子树 */private fun dfsLeaves(node: TreeNode?, direction: Int): Int &#123; if (node == null) return 0 if (node.left == null &amp;&amp; node.right == null &amp;&amp; direction == 1) &#123; // 左右子树为空，根据父亲节点的传入，判断它是左子树 return node.`val` //这种情况返回值，根据后序规则，上层节点叠加 &#125; val leftCount = dfsLeaves(node.left, 1) val rightCount = dfsLeaves(node.right, 0) return leftCount + rightCount&#125; 看了随想录解法，可以直接看更下一层节点，就不用再传入方向了 123if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) &#123; leftValue = root-&gt;left-&gt;val;&#125; 迭代法 随想录统一迭代法 513. 找树左下角的值想了下 层序遍历可以解决 递归法还没想道，到了最底层，没想到如何判断 哪个是最左边的。 BFS先存下来每一层的第一个节点，知道queue为空，那么最后一层的头节点就是要返回的. 1234567891011121314151617fun findBottomLeftValue1(root: TreeNode?): Int &#123; val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; var leftNodeVal = root?.`val` while (queue.isNotEmpty()) &#123; val size = queue.size leftNodeVal = queue.peek().`val` //每一层的第一个节点 for (i in 0 until size) &#123; val node = queue.poll() node?.left?.let &#123; queue.offer(it) &#125; node?.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return leftNodeVal!! // queue为empty的时候退出，此时上一层存的节点就是最左边的节点&#125; DFSMy idea 一开始以为树的层级里，树的左边的值小于右边，来得出结果，但是这是二叉树，不是平衡形的，即使平衡这种思路也不一定对. 然后又看了树结构,想了下可以用 inorder traversal ,中序遍历, 层数最深，然后最先得到的数据就是要拿到的结果. 想下面8肯定是后面遍历到的 一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了 判断层级，如果大于之前的深度，那么就更新深度和值 中序和后序肯定没问题，但是先序不确定（随想录说是可以的）而且随想录 depth + 1 展开了用回溯 12345678910111213141516171819var mDepth = 0 //一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了var result = -1fun findBottomLeftValue(root: TreeNode?): Int &#123; if (root == null) return 0 inOrderTraversal(root, mDepth) return result&#125;// 最左边的节点最先访问到private fun inOrderTraversal(node: TreeNode?, depth: Int) &#123; if (node == null) return inOrderTraversal(node.left, depth + 1) if (depth + 1 &gt; mDepth) &#123; // 判断层级，如果大于之前的深度，那么就更新深度和值 mDepth = depth + 1 result = node.`val` &#125; inOrderTraversal(node.right, depth + 1)&#125; 112. 路径总和解决所有二叉树路径的问题文章 https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/ 这一题和 [112. 路径总和] 类似 使用回溯写法，因为添加和删除，回溯的规则，那么感觉用栈比较合适. 终止条件就是 到达了叶子节点，此时开始计算当前路径和 是否满足条件 手写判断是否有左子树，有的话继续判断，又继续preOrderTraversal, 这里用的是先序遍历,方法查看条件 遍历完叶子节点后判断，此时这条路径完成，开始回溯，回退上一层preOrderTraversal，继续判断右子树 12345678910111213141516171819202122232425262728293031323334353637fun hasPathSum(root: TreeNode?, targetSum: Int): Boolean &#123; val pathStack = Stack&lt;Int&gt;() if (root != null) &#123; pathStack.push(root.`val`) // root需要放在遍历外面，否则会push多次 &#125;else&#123; return false //按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句 &#125; return preOrderTraversal(root, targetSum, pathStack) // pathstack必须传进去，否则每次都new&#125;private fun preOrderTraversal(root: TreeNode?, targetSum: Int, pathStack: Stack&lt;Int&gt;): Boolean &#123; if (root?.left == null &amp;&amp; root?.right == null) &#123; var pathSum = 0 pathStack.forEach &#123; pathSum += it &#125; println(&quot;pathSum $pathSum&quot;) if (pathSum == targetSum) &#123; return true &#125; &#125; if (root?.left != null) &#123; pathStack.push(root.left.`val`) // 有左节点，加入当前路径 if (preOrderTraversal(root.left, targetSum, pathStack)) &#123; //有路径是和 == targetSum 直接返回 return true &#125; pathStack.pop() // 不会直接把上面的回退了，需要上一句遍历执行完回退后，才把自己回退了，此时已经到了叶子判断了 root?.left == null &amp;&amp; root?.right == null &#125; if (root?.right != null) &#123; pathStack.push(root.right.`val`) if (preOrderTraversal(root.right, targetSum, pathStack)) &#123; //有路径是和 == targetSum 直接返回 return true &#125; pathStack.pop() &#125; return false&#125; 1234567891011121314151617181920212223242526fun hasPathSum1(root: TreeNode?, targetSum: Int): Boolean &#123; if (root == null) &#123; return false //按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句 &#125; val pathSum = root.`val` return preOrderDFS(root, pathSum, targetSum) // pathstack必须传进去，否则每次都new&#125;private fun preOrderDFS(node: TreeNode, pathSum: Int, targetSum: Int): Boolean &#123; val nodeValue = node.`val` println(&quot;nodeValue $nodeValue&quot;) if (node.left == null &amp;&amp; node.right == null &amp;&amp; targetSum == pathSum) &#123; return true &#125; if (node.left != null) if (preOrderDFS(node.left, pathSum + node.left.`val`, targetSum)) &#123; // 这个直接放回，容易忘了 return true &#125; if (node.right != null) if (preOrderDFS(node.right, pathSum + node.right.`val`, targetSum)) &#123; return true &#125; return false&#125; 113. 路径总和 II如果是找路径和等于给定target的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，只需要用给定和target减去节点值，最终结束条件判断target==0即可 DFS这一题的思路和前面的差不多，就是他要求返回所有符合条件的集合，所以直接添加值觉得不合适，除非多加一个参数，不加一个参数就不好弄。 //这种解法要注意 值引用问题，即使最初加入到resultList的pathList是正确的，后序的回退也会把值给修改了. 12345678910111213141516171819202122232425262728293031323334val resultList = LinkedList&lt;List&lt;Int&gt;&gt;()fun pathSum(root: TreeNode?, targetSum: Int): List&lt;List&lt;Int&gt;&gt; &#123; if (root == null) return resultList val stackList = Stack&lt;Int&gt;() stackList.add(root.`val`) preDFS(root, stackList, targetSum) return resultList&#125;private fun preDFS(node: TreeNode, pathList: Stack&lt;Int&gt;, targetSum: Int) &#123; val data = node.`val` println(data) if (node.left == null &amp;&amp; node.right == null &amp;&amp; pathSum(pathList) == targetSum) &#123; resultList.add(pathList.toMutableList().toList()) // 注意引用传递 &#125; if (node.left != null) &#123; pathList.push(node.left.`val`) preDFS(node.left, pathList, targetSum) pathList.pop() &#125; if (node.right != null) &#123; pathList.push(node.right.`val`) preDFS(node.right, pathList, targetSum) pathList.pop() &#125;&#125;fun pathSum(pathList: Stack&lt;Int&gt;): Int &#123; var sum = 0 pathList.forEach &#123; sum += it &#125; return sum&#125; 这一题的官方DFS解法没看懂，感觉不好理解. 这是看完官方写法自己写的 1234567891011121314151617181920212223val pathList = LinkedList&lt;Int&gt;()fun pathSum1(root: TreeNode?, targetSum: Int): List&lt;List&lt;Int&gt;&gt; &#123; if (root == null) return resultList val stackList = Stack&lt;Int&gt;() stackList.add(root.`val`) preTraversal(root, targetSum - root.`val`) return resultList&#125;private fun preTraversal(node: TreeNode?, targetSum: Int) &#123; if (node == null) return val data = node.`val` println(data) pathList.offer(node.`val`) if (node.left == null &amp;&amp; node.right == null &amp;&amp; targetSum == 0) &#123; resultList.add(pathList.toMutableList()) &#125; if (node.left != null) preTraversal(node.left, targetSum - node.left.`val`) if (node.right != null) preTraversal(node.right, targetSum - node.right.`val`) pathList.pop()&#125; 这是官方解法，也很棒 123456789101112131415161718192021fun pathSum2(root: TreeNode?, targetSum: Int): List&lt;List&lt;Int&gt;&gt; &#123; if (root == null) return resultList val stackList = Stack&lt;Int&gt;() stackList.add(root.`val`) preDFSTraversal(root, targetSum) return resultList&#125;private fun preDFSTraversal(node: TreeNode?, targetSum: Int) &#123; if (node == null) return val data = node.`val` println(data) val targetSum = targetSum - node.`val` pathList.offer(node.`val`) if (node.left == null &amp;&amp; node.right == null &amp;&amp; targetSum == 0) &#123; resultList.add(pathList.toMutableList()) &#125; preDFSTraversal(node.left, targetSum) preDFSTraversal(node.right, targetSum) pathList.pop()&#125; 官方BFS 就很不好理解 构建树先序，中序 后序，中序 inOrder [L, 3 ,R ] PostOrder [L, R, 3] PreOrder [3,L ,R]可以看到 只有PostOrder ,PreOrder左右是分不清的. 123456 1 1 2 2 3 3 PreOrder 1,2,3 PreOrder 1,2,3PostOrder 3,2,1 PostOrder 3,2,1 106. 从中序与后序遍历序列构造二叉树效率低，但是好理解的方法 https://www.bilibili.com/video/BV1pp4y1k75Q/ 为什么post右子树是从 , [i , n-1],因为他是后序遍历，所以从 i开始 12inorder &#x3D; [9,3,15,20,7]postorder &#x3D; [9,15,7,20,3] 根据后序postorder 得到root 3, 然后根据中序知道 left branch [9] , right branch [15 , 20 , 7] 根据 left branch 的9,可以把 postorder后序分成[9], [15 , 20 , 7]两部分 然后 inorder= [15 , 20 , 7] , postorder=[15 , 20 , 7] 继续进行遍历 总的来说，就是这样 确定终止条件 构造节点 构造左子树， 构造右子树 123456789101112131415161718192021fun buildTree(inorder: IntArray, postorder: IntArray): TreeNode? &#123; if (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123; return null &#125; val node = TreeNode(postorder[postorder.size - 1]) //postorder.size用的地方多，可以提取出来 val index = getIndex(node, inorder) node.left = buildTree(inorder.copyOfRange(0, index), postorder.copyOfRange(0, index)) // copyOfRange数组效率低 node.right = buildTree( inorder.copyOfRange(index + 1, inorder.size), postorder.copyOfRange(index, postorder.size - 1) ) // 注意copyOfRange(0,2)获取的是index 0,1两个元素 return node&#125;private fun getIndex(node: TreeNode, inorder: IntArray): Int &#123; for (i in inorder.indices) &#123; if (node.`val` == inorder[i]) &#123; return i &#125; &#125; return 0&#125; 优化方法写出来还有问题,先pass这题耗时太久了,边界不好掌握可以考虑用日志调试 还可以再看下随想录的视频讲解 https://www.bilibili.com/video/BV1vW4y1i7dn 随想录代码优化前的写法，和上面代码写法是一样的，只是用了C++语言 https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html 最初错误的解法,上面的解法数组有变化所以 end位置就是数组的大小，但是这里不同，数组是没变化，就不能这样做 12345678910111213141516171819&#x2F;&#x2F; 数组不变，只改变下标private fun buildDFSTree( inorder: IntArray, postorder: IntArray, inStart: Int, inEnd: Int, postStart: Int, postEnd: Int): TreeNode? &#123; if (inStart &gt; inEnd || postStart &gt; postEnd || inEnd &lt; 0 || postEnd &lt; 0) &#123; return null &#125; val node &#x3D; TreeNode(postorder[postEnd]) &#x2F;&#x2F;postorder.size用的地方多，可以提取出来 val index &#x3D; getIndex(node, inorder) node.left &#x3D; buildDFSTree(inorder, postorder, inStart, index - 1, 0, index - 1) &#x2F;&#x2F;[0,index) 左闭右开 node.right &#x3D; buildDFSTree(inorder, postorder, index + 1, inEnd, index + 1, postEnd) return node&#125; 这一题花了不少时间，思路不难，主要是 切割后序的数组的时候，左右子树的边界值不好处理, map用来存储，中序value值和position的对应关系，这里value应该是唯一的. 采用的是左闭右闭的方案，所以inStart &gt; inEnd 不能用 &gt;=, 否则return了，叶子节点无法构造出来. 根据后序root节点，分割中序数组，拿到左子树后，再用左子树树的分割后序数组,因为左子树的长度是一样的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960val map = HashMap&lt;Int, Int&gt;()fun buildTree1(inorder: IntArray, postorder: IntArray): TreeNode? &#123; if (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123; return null &#125; val inStart = 0 val inEnd = inorder.size - 1 val postStart = 0 val postEnd = postorder.size - 1 inorder.forEachIndexed &#123; position, item -&gt; map[item] = position &#125; return buildDFSTree(inStart, inEnd, postStart, postEnd, inorder, postorder)&#125;// 数组不变，只改变下标private fun buildDFSTree( inStart: Int, inEnd: Int, postStart: Int, postEnd: Int, inorderArr: IntArray, postorderArr: IntArray): TreeNode? &#123; println(&quot; inStart $inStart inEnd $inEnd postStart $postStart postEnd $postEnd&quot;) if (inStart &gt; inEnd || postStart &gt; postEnd) &#123; // 因为是左闭右闭的方案，所以这里不能用 &gt;= ,否则叶子节点无法构造出来 return null &#125; val node = TreeNode(postorderArr[postEnd]) //postorder.size用的地方多，可以提取出来 val index = map[postorderArr[postEnd]] ?: 0 // 这里要改 /** * 切割左子树,这种坐标定义好更清晰 */ val leftInBegin = inStart val leftInEnd = index - 1 // 左闭右闭 val leftPostBegin = postStart val leftPostEnd = postStart + (index - inStart - 1) //(index - inStart) 左子树的长度, 因为选择是左闭右闭的方案，所以自身也-1 node.left = buildDFSTree( leftInBegin, leftInEnd, leftPostBegin, leftPostEnd, inorderArr, postorderArr ) /** * 切割右子树 */ val rightInBegin = index + 1 val rightInEnd = inEnd val rightPostBegin = postStart + index - inStart //(index - inStart) 这里不用-1,因为左子树的右边就是右子树，所以右子树就是从这个位置开始的 val rightPostEnd = postEnd - 1 node.right = buildDFSTree( rightInBegin, rightInEnd, rightPostBegin, rightPostEnd, inorderArr, postorderArr ) return node&#125; 官方 先构建右子树的想法好巧妙，要是先构建的是左子树还有个确定后序区间的步骤。 https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/ 官方解法很妙，根据后序数组pop，post_idx–;先开始右子树,然后左子树,构造方法也很简单，这样不用找后序数组的 开始和结束位置在哪. 做了上面的解法，也就是这个后序的边界值最难搞. 这种方式直接给省去了。 不得不说太妙了 官方迭代法后面再看吧 。 654. 最大二叉树输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示： [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 ,3的左边是[]没有节点, 右边是[0,5],所以树也是这样构造的. 空数组，无子节点。 [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 空数组，无子节点。 只有一个元素，所以子节点是一个值为 1 的节点。 [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 只有一个元素，所以子节点是一个值为 0 的节点。 空数组，无子节点。 preTraversal思路 : 因为需要构造中间节点，所以用先序遍历 先找到数组中最大值，然后切割成左右子树。 在切割后的左右子树中继续切割，直至无法切割为止 自己写的，做法和随想录类似 https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java 1234567891011121314151617181920212223fun constructMaximumBinaryTree(nums: IntArray): TreeNode? &#123; return buildTree(nums, 0, nums.size - 1)&#125;private fun buildTree(nums: IntArray, start: Int, end: Int): TreeNode? &#123; println(&quot;buildTree start $start end $end&quot;) if (start &gt; end) return null //分割的左右下标越界就退出 ,不能加==，否则叶子节点构造不到. val maxIndex = getMaxIndex(nums, start, end) val node = TreeNode(nums[maxIndex]) // 构造先序的父节点 node.left = buildTree(nums, start, maxIndex - 1) // 构造左节点 node.right = buildTree(nums, maxIndex + 1, end) return node&#125;fun getMaxIndex(nums: IntArray, start: Int, end: Int): Int &#123; var maxIndex = start for (i in start..end) &#123; // 在对应的数组范围内，找到最大值 if (nums[maxIndex] &lt; nums[i]) &#123; maxIndex = i &#125; &#125; return maxIndex&#125; 单调栈官方还有一种单调栈的写法，后面再看吧 https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/ 105. 从前序与中序遍历序列构造二叉树Idea 只分割中序数组按照上面106官方很妙的思路，下面解法 根据中序遍历。value和index构造hash map,方便后面获取中序位置 根据先序遍历数组从 左子树到右子树构造节点, 这样就不用分割先序数组，也是很麻烦的 根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树 然后是递归分割. 123456789101112131415161718192021val map = HashMap&lt;Int, Int&gt;()var preNodeIndex = 0fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? &#123; inorder.forEachIndexed &#123; position, item -&gt; // map[item] = position &#125; return buildDFS(preorder, inorder, 0, inorder.size - 1)&#125;private fun buildDFS(preorder: IntArray, inorder: IntArray, inBegin: Int, inEnd: Int): TreeNode? &#123; if (inBegin &gt; inEnd) &#123; return null &#125; val node = TreeNode(preorder[preNodeIndex]) // 根据先序遍历数组从 左子树到右子树构造节点 val inIndex = map[preorder[preNodeIndex]]!! // 根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树 println(&quot;$&#123;preorder[preNodeIndex]&#125; inBegin $inBegin inEnd $inEnd&quot;) preNodeIndex++ node.left = buildDFS(preorder, inorder, inBegin, inIndex - 1) node.right = buildDFS(preorder, inorder, inIndex + 1, inEnd) return node&#125; 分割先序 中序数组 根据中序数组构造，位置和值的hashmap 。 根据先序数组的中节点位置，分割中序数组，得到左右子树。 根据中序数组得到的左子树的长度，分割 先序数组的左右子树. 构造左右子树. 左闭右闭的情况 12345678910111213141516171819202122232425262728293031323334353637val map = HashMap&lt;Int, Int&gt;()var preNodeIndex = 0fun buildTree1(preorder: IntArray, inorder: IntArray): TreeNode? &#123; inorder.forEachIndexed &#123; position, item -&gt; map[item] = position // 获得 中序 value和index hash map.put(item,position) &#125; return splitPreInOrder(preorder, 0, preorder.size - 1, inorder, 0, inorder.size - 1)&#125;private fun splitPreInOrder( preorderArr: IntArray, preStart: Int, preEnd: Int, inorderArr: IntArray, inStart: Int, inEnd: Int): TreeNode? &#123; println(&quot; preStart $preStart preEnd $preEnd inStart $inStart inEnd $inEnd&quot;) if (preStart &gt; preEnd || inStart &gt; inEnd) return null val inIndex = map[preorderArr[preStart]]!! // 分割中序数组 val node = TreeNode(preorderArr[preStart]) val leftInBegin = inStart //左闭 val leftInEnd = inIndex-1 // 右闭 val leftPreBegin = preStart + 1 // 先序中节点的后一个位置，就是左子树的开始位置 val leftPreEnd = preStart + (inIndex - inStart) // 其实位置 + 中序中左子树的长度 node.left = splitPreInOrder(preorderArr, leftPreBegin, leftPreEnd, inorderArr, leftInBegin, leftInEnd) val rightInBegin = inIndex + 1 // 分割点的后一个位置 val rightInEnd = inEnd val rightPreBegin = preStart + (inIndex - inStart) + 1 // 先序数组 左子树位置+1 后一个位置 val rightPreEnd = preEnd node.right = splitPreInOrder(preorderArr, rightPreBegin, rightPreEnd, inorderArr, rightInBegin, rightInEnd) return node&#125; 感觉还是左闭右闭好点，右开的情况容易越界. 617. 合并二叉树DFS 合并二叉树，通过先序遍历，先构造根节点 然后再分别构造左右子树 1234567fun mergeTrees(root1: TreeNode?, root2: TreeNode?): TreeNode? &#123; if (root1 == null &amp;&amp; root2 == null) return null //这里还可以优化, 看官方解法和随想录的优化一样的 val node = TreeNode((root1?.`val` ?: 0) + (root2?.`val` ?: 0)) node.left = mergeTrees(root1?.left, root2?.left) node.right = mergeTrees(root1?.right, root2?.right) return node&#125; BFS 这题官方有一种BFS的解法,感觉有点麻烦，后面继续 https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"view_custom_attr","slug":"view_custom_attr","date":"2022-08-27T13:53:08.000Z","updated":"2023-12-17T13:10:53.515Z","comments":true,"path":"2022/08/27/view_custom_attr/","link":"","permalink":"https://noteforme.github.io/2022/08/27/view_custom_attr/","excerpt":"","text":"自定义属性类别 boolean 表示attr取值为true或者falsecolor 表示attr取值是颜色类型，例如#ff3344,或者是一个指向color的资源id，例如R.color.colorAccent.dimension 表示 attr 取值是尺寸类型，例如例如取值16sp、16dp，也可以是一个指向dimen的资源id，例 如R.dimen.dp_16float 表示attr取值是整形或者浮点型fraction 表示 attr取值是百分数类型，只能以%结尾，例如30%integer 表示attr取值是整型string 表示attr取值是String类型，或者一个指向String的资源id，例如R.string.testStringreference 表示attr取值只能是一个指向资源的id。enum 表示attr取值只能是枚举类型。 CustomView.kt 12345678910111213&lt;declare-styleable name=&quot;CustomView&quot;&gt; &lt;attr name=&quot;attr_boolean&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;attr_color&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;attr_dimension&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;attr_float&quot; format=&quot;float&quot; /&gt; &lt;attr name=&quot;attr_fraction&quot; format=&quot;fraction&quot; /&gt; &lt;attr name=&quot;attr_string&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;attr_reference&quot; format=&quot;reference&quot; /&gt; &lt;attr name=&quot;attr_enum&quot; format=&quot;enum&quot; &gt; &lt;enum name=&quot;left&quot; value=&quot;0&quot;/&gt; &lt;enum name=&quot;right&quot; value=&quot;1&quot;/&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 123456789101112val a = context.obtainStyledAttributes(attrs, R.styleable.CustomView, 0, defStyleAttr)val boolean = a.getBoolean(R.styleable.CustomAttribute_customBoolean, false)val color = a.getColor(R.styleable.CustomAttribute_customColorValue, R.color.colorPrimary)val dimension = a.getDimension(R.styleable.CustomAttribute_customDimension, 20F)val float = a.getFloat(R.styleable.CustomView_attr_float, 20f)val fraction = a.getFraction(R.styleable.CustomView_attr_fraction, 1, 2, 0f)val integer = a.getInteger(R.styleable.CustomAttribute_customIntegerValue, 0)val string = a.getString(R.styleable.CustomView_attr_string)resourceId = a.getResourceId(R.styleable.CustomAttribute_customReference, R.drawable.meitu13333)var textPos = a.getInteger(R.styleable.CustomView_attr_enum, 0)a.recycle() refrence , 表示attr取值只能是一个指向资源的id。 https://github.com/GcsSloop/AndroidNote/tree/master/CustomView https://segmentfault.com/a/1190000012253911 onDraw dispatchDrawhttps://www.jianshu.com/p/89efaf8bd3dd https://juejin.cn/post/6844903997917102093","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[]},{"title":"ADB","slug":"ADB","date":"2022-08-18T10:07:29.000Z","updated":"2023-01-02T03:31:38.914Z","comments":true,"path":"2022/08/18/ADB/","link":"","permalink":"https://noteforme.github.io/2022/08/18/ADB/","excerpt":"","text":"12345adb shell dumpsys window | grep mCurrentFocus &#x2F;&#x2F;当前Activityadb shell dumpsys activity | grep com.john.kotadb shell dumpsys activity | grep com.comm.util","categories":[],"tags":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/tags/TOOL/"}]},{"title":"view_round_image","slug":"view-round-image","date":"2022-08-14T02:55:00.000Z","updated":"2023-12-20T14:52:26.395Z","comments":true,"path":"2022/08/14/view-round-image/","link":"","permalink":"https://noteforme.github.io/2022/08/14/view-round-image/","excerpt":"","text":"https://blog.csdn.net/xiaohanluo/article/details/52945791 https://guides.codepath.com/android/Working-with-the-ImageView https://guides.codepath.com/android/Working-with-the-ImageView 全圆角OutLine12345&lt;ImageView android:id=&quot;@+id/img_test&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/music&quot; /&gt; 123456789mImg = findViewById(R.id.img_test);ViewOutlineProvider viewOutlineProvider = new ViewOutlineProvider() &#123; @Override public void getOutline(View view, Outline outline) &#123; outline.setOval(0,0,mImg.getWidth(), mImg.getHeight()); &#125;&#125;;mImg.setOutlineProvider(viewOutlineProvider);mImg.setClipToOutline(true); https://blog.csdn.net/weixin_43499030/article/details/92799689 CardView部分圆角ShapeableImageView这种方式官方的无风险 123456789&lt;!-- layout.xml 就是在布局中定义--&gt;&lt;com.google.android.material.imageview.ShapeableImageView android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot; android:strokeWidth=&quot;10dp&quot; android:strokeColor=&quot;@color/purple&quot; android:src=&quot;@drawable/ic_launcher_background&quot; app:shapeAppearance=&quot;@style/RoundAndCutImageStyle&quot; /&gt; 需要通过设置 app:shapeAppearance 才有用 12345678910&lt;!-- style.xml 可以单独给每个角设置属性--&gt; &lt;style name=&quot;RoundAndCutImageStyle&quot;&gt; &lt;item name=&quot;cornerFamilyTopLeft&quot;&gt;rounded&lt;/item&gt; &lt;item name=&quot;cornerFamilyBottomLeft&quot;&gt;rounded&lt;/item&gt; &lt;item name=&quot;cornerFamilyTopRight&quot;&gt;cut&lt;/item&gt; &lt;item name=&quot;cornerFamilyBottomRight&quot;&gt;cut&lt;/item&gt; &lt;item name=&quot;cornerSize&quot;&gt;50%&lt;/item&gt; &lt;item name=&quot;cornerSizeBottomLeft&quot;&gt;20dp&lt;/item&gt; &lt;item name=&quot;cornerSizeTopLeft&quot;&gt;20dp&lt;/item&gt; &lt;/style&gt; 左边是圆角，右边是“切角” https://juejin.cn/post/6913083202387050509 BitmapShadersetShader setShader，顾名思义，设置着色器，我们知道在Canvas中，我们调用drawXXX可以绘制出各种各样的图形，如圆形、矩形、扇形等等，而Shader是给Paint设置的属性，决定paint绘制图形的时候如何给图形上色，比如绘制一个矩形，我想要矩形中铺满一张图片，那这些平铺的图片就相当于是给这个矩形上色了。好了，概念先说到这，Shader是一个基类，setShader中设置的都是Shader的子类https://blog.csdn.net/huxin1875/article/details/89133025 12345678 Call this to create a new shader that will draw with a bitmap. Params: bitmap – The bitmap to use inside the shader tileX – The tiling mode for x to draw the bitmap in. tileY – The tiling mode for y to draw the bitmap in.public BitmapShader(@NonNull Bitmap bitmap, @NonNull TileMode tileX, @NonNull TileMode tileY) &#123; this(bitmap, tileX.nativeInt, tileY.nativeInt);&#125; 12345678910111213141516171819202122232425262728class BitmapShaderView @JvmOverloads constructor( context: Context?, attrs: AttributeSet?, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; private var mWidth by Delegates.notNull&lt;Int&gt;() private var mHeight by Delegates.notNull&lt;Int&gt;() private lateinit var bmpShader: BitmapShader private lateinit var mPaint: Paint private lateinit var bmpRect: RectF override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) mWidth = w //屏幕宽 mHeight = h //屏幕高 bmpRect = RectF(0f, 0f, mWidth.toFloat(), mHeight.toFloat()) val bitmap = BitmapFactory.decodeResource(resources, R.drawable.meitu122822234759011) //Shader.TileMode里有三种模式：CLAMP（拉伸）、MIRROR（镜像）、REPETA（重复） bmpShader = BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP) mPaint = Paint(Paint.ANTI_ALIAS_FLAG) mPaint.shader = bmpShader &#125; override fun onDraw(canvas: Canvas?) &#123; super.onDraw(canvas) canvas?.drawRect(bmpRect, mPaint) &#125;&#125; 先来看看BitmapShader属性的作用 bitmap 指的是要作为纹理的图片， tileX 指的是在ｘ方向纹理的绘制模式 tileY 指的是Ｙ方向上的绘制模式。 1234567891011121314151617181920212223242526public enum TileMode &#123; /** * Replicate the edge color if the shader draws outside of its * original bounds. */ CLAMP (0), /** * Repeat the shader&#x27;s image horizontally and vertically. */ REPEAT (1), /** * Repeat the shader&#x27;s image horizontally and vertically, alternating * mirror images so that adjacent images always seam. */ MIRROR(2), /** * Render the shader&#x27;s image pixels only within its original bounds. If the shader * draws outside of its original bounds, transparent black is drawn instead. */ DECAL(3); TileMode(int nativeInt) &#123; this.nativeInt = nativeInt; &#125; final int nativeInt;&#125; *CLAMP 拉伸*:设置x , 横向的最后一个横行像素，不断的重复，设置y，那么纵项的那一列像素，不断的重复；*REPEAT 重复*:就是横向、纵向不断重复这个bitmap*MIRROR 镜像*:横向不断翻转重复，纵向不断翻转重复； CLAMP1BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP) REPEAT 1BitmapShader(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT) MIRROR1BitmapShader(bitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR) 可以看到， x y 镜像映射 DECAL最后这种就是正常显示的了 https://juejin.cn/post/6844903480809766920 全部圆角有了scale，就可以设置给我们的matrix； 然后使用mBitmapShader.setLocalMatrix(mMatrix); 最后将bitmapShader设置给paint。 关于drawable转bitmap的代码： 1Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat()) View宽度 / 图片宽度 , View的高度/图片高度 他们取最大值，进行缩放，图片短的那一部分就会填满View,长的那一部分会被截掉,显示不全 计算scale 比如：view的宽高为50 * 100；图片的宽高为5*100 ； 最终我们应该按照宽的比例放大，而不是按照高的比例缩小；因为我们需要让缩放后的图片，自定大于我们的view宽高，并保证原图比例。 那么高度就被放大10倍到1000,值能显示到1/10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class RoundImageShaderView @JvmOverloads constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int = 0) : AppCompatImageView(context, attrs, defStyleAttr) &#123; private val TAG = &quot;RoundImageShaderView&quot; private lateinit var mRoundRect: RectF private lateinit var mBitmapShader: BitmapShader private val mMatrix = Matrix() private val mBitmapPaint = Paint(); override fun onDraw(canvas: Canvas?) &#123; canvas?.drawRoundRect(mRoundRect, 20f, 20f, mBitmapPaint) &#125; override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) setUpShader() mRoundRect = RectF(0f, 0f, width.toFloat(), height.toFloat()) &#125; /** * 初始化BitmapShader */ private fun setUpShader() &#123; val drawable: Drawable = drawable ?: return val bmp = drawableToBitamp(drawable) // 将bmp作为着色器，就是在指定区域内绘制bmp mBitmapShader = BitmapShader(bmp!!, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP) // 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值； val scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat()) // shader的变换矩阵，我们这里主要用于放大或者缩小 mMatrix.setScale(scale, scale) // 设置变换矩阵 mBitmapShader.setLocalMatrix(mMatrix) // 设置shader mBitmapPaint.shader = mBitmapShader &#125; /** * drawable转bitmap * * @param drawable * @return */ private fun drawableToBitamp(drawable: Drawable): Bitmap? &#123; if (drawable is BitmapDrawable) &#123; val bd: BitmapDrawable = drawable return bd.bitmap &#125; val w = drawable.intrinsicWidth val h = drawable.intrinsicHeight return Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888) &#125;&#125; 12345678910111213141516171819&lt;com.john.kot.view.RoundImageShaderView android:id=&quot;@+id/iv_girl1&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:layout_marginStart=&quot;20dp&quot; android:layout_marginTop=&quot;20dp&quot; android:src=&quot;@drawable/meitu122822234759011&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;com.john.kot.view.RoundImageShaderView android:id=&quot;@+id/iv_girl2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:layout_marginStart=&quot;20dp&quot; android:layout_marginTop=&quot;20dp&quot; android:src=&quot;@drawable/meitu122822234759011&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/iv_girl1&quot; /&gt; 可以看到，高度部分截取了 https://blog.csdn.net/lmj623565791/article/details/41967509 https://developer.android.com/reference/android/graphics/PorterDuff.Mode https://segmentfault.com/a/1190000012253911 部分圆角 第二张图就可以看到，这样做的原理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class RoundBottomBitmapShaderView @JvmOverloads constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int = 0) : AppCompatImageView(context, attrs, defStyleAttr) &#123; private lateinit var mBitmapShader: BitmapShader private val mMatrix = Matrix() private val mBitmapPaint = Paint(); val radius = resources.getDimension(R.dimen.round_bitmap_radius) private var outHeight by Delegates.notNull&lt;Int&gt;() private var outWidth by Delegates.notNull&lt;Int&gt;() override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) setUpShader() outWidth = w outHeight = h &#125; override fun onDraw(canvas: Canvas?) &#123;// super.onDraw(canvas) 要删除 super.onDraw(canvas)：否则Canvas又会在ImageView中重新绘制，将我们之前的操作都覆盖了 //绘制圆角 canvas?.drawRoundRect( RectF( 0f, (outHeight - 2 * radius), outWidth.toFloat(), outHeight.toFloat() ), radius, radius, mBitmapPaint )// 利用画笔绘制顶部上面直角部分 canvas?.drawRect( RectF( 0f, 0f, outWidth.toFloat(), (outHeight - radius) ), mBitmapPaint ) &#125; /** * 初始化BitmapShader */ private fun setUpShader() &#123; val drawable: Drawable = drawable ?: return val bmp = drawableToBitmap(drawable) // 将bmp作为着色器，就是在指定区域内绘制bmp mBitmapShader = BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP) // 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值； val scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat()) // shader的变换矩阵，我们这里主要用于放大或者缩小 mMatrix.setScale(scale, scale) // 设置变换矩阵 mBitmapShader.setLocalMatrix(mMatrix) // 设置shader mBitmapPaint.shader = mBitmapShader &#125; /** * drawable转bitmap * * @param drawable * @return */ private fun drawableToBitmap(drawable: Drawable): Bitmap &#123; if (drawable is BitmapDrawable) &#123; val bd: BitmapDrawable = drawable return bd.bitmap &#125; val w = drawable.intrinsicWidth val h = drawable.intrinsicHeight return Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888) &#125;&#125; 一个脚前两步绘制的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class RoundSingleBitmapShaderView @JvmOverloads constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int = 0) : AppCompatImageView(context, attrs, defStyleAttr) &#123; private lateinit var mBitmapShader: BitmapShader private val mMatrix = Matrix() private val mBitmapPaint = Paint(); val mRadius = resources.getDimension(R.dimen.round_bitmap_radius) private var outHeight by Delegates.notNull&lt;Int&gt;() private var outWidth by Delegates.notNull&lt;Int&gt;() override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) setUpShader() outWidth = w outHeight = h &#125; override fun onDraw(canvas: Canvas?) &#123;// super.onDraw(canvas) //否则Canvas又会在ImageView中重新绘制，将我们之前的操作都覆盖了 //绘制圆 canvas?.drawRoundRect( RectF(0f, 0f, 2 * mRadius, 2 * mRadius), mRadius, mRadius, mBitmapPaint ) //绘制矩形竖线 canvas?.drawRect(RectF(0f, mRadius, mRadius, height.toFloat()), mBitmapPaint) //绘制主要的图 canvas?.drawRect( RectF( mRadius, 0f, width.toFloat(), height.toFloat() ), mBitmapPaint ) &#125; /** * 初始化BitmapShader */ private fun setUpShader() &#123; val drawable: Drawable = drawable ?: return val bmp = drawableToBitmap(drawable) // 将bmp作为着色器，就是在指定区域内绘制bmp mBitmapShader = BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP) // 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值； val scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat()) // shader的变换矩阵，我们这里主要用于放大或者缩小 mMatrix.setScale(scale, scale) // 设置变换矩阵 mBitmapShader.setLocalMatrix(mMatrix) // 设置shader mBitmapPaint.shader = mBitmapShader &#125; /** * drawable转bitmap * * @param drawable * @return */ private fun drawableToBitmap(drawable: Drawable): Bitmap &#123; if (drawable is BitmapDrawable) &#123; val bd: BitmapDrawable = drawable return bd.bitmap &#125; val w = drawable.intrinsicWidth val h = drawable.intrinsicHeight return Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888) &#125;&#125; Xfermode绘制圆角概览先绘制 绘制黄色的圆 然后绘制蓝色正方形 模式 说明PorterDuff.Mode.CLEAR 所有绘制不会绘制到画布上PorterDuff.Mode.SRC 显示上层绘制图形PorterDuff.Mode.DST 显示下层绘制图形PorterDuff.Mode.SRC_OVER 图形叠加，上层盖住下层PorterDuff.Mode.DST_OVER 图形叠加，下层盖住上层PorterDuff.Mode.SRC_IN 显示上层交集部分PorterDuff.Mode.DST_IN 显示下层交集部分PorterDuff.Mode.SRC_OUT 显示上层非交集部分PorterDuff.Mode.DST_OUT 显示下层非交集部分PorterDuff.Mode.SRC_ATOP 显示下层非交集部分和上层交集部分PorterDuff.Mode.DST_ATOP 显示下层交集部分与上层非交集部分PorterDuff.Mode.XOR 去除交集部分PorterDuff.Mode.DARKEN 交集部分颜色加深PorterDuff.Mode.LIGHTEN 交集部分颜色变亮PorterDuff.Mode.MULTIPLY 显示交集部分，颜色混合叠加PorterDuff.Mode.SCREEN 取两图层全部区域，交集部分变为透明色 https://blog.csdn.net/xiaohanluo/article/details/52945791 https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 private class SampleXfermodeView(context: Context?) : View(context) &#123; private val mSrcB: Bitmap private val mDstB: Bitmap private val mBG // background checker-board pattern : Shader private val modeIndex = 1 // 模式 override fun onDraw(canvas: Canvas) &#123; canvas.drawColor(Color.WHITE) val labelP = Paint(Paint.ANTI_ALIAS_FLAG) labelP.textAlign = Paint.Align.CENTER val paint = Paint() paint.isFilterBitmap = false canvas.translate(15F, 35F) var x = 0f var y = 0f// for (modeIndex in sModes.indices) &#123; // draw the border paint.style = Paint.Style.STROKE paint.shader = null canvas.drawRect( x - 0.5f, y - 0.5f, x + W + 0.5f, y + H + 0.5f, paint ) // 外层正方形黑色框框 // draw the checker-board pattern paint.style = Paint.Style.FILL paint.shader = mBG canvas.drawRect(x, y, x + W, y + H, paint) // 正方形框框里的灰色小格子 // draw the src/dst example into our offscreen bitmap val sc: Int = canvas.saveLayer( x, y, x + W, y + H, null, ) // 保存 图层 canvas.translate(x, y) canvas.drawBitmap(mDstB, 0f, 0f, paint) // 绘制黄色的圆 paint.xfermode = sModes[modeIndex] canvas.drawBitmap(mSrcB, 0f, 0f, paint) //绘制蓝色正方形 paint.xfermode = null // 我猜否则下次循环会用到 canvas.restoreToCount(sc) // draw the label canvas.drawText( sLabels[modeIndex], x + W / 2, y - labelP.textSize / 2, labelP ) x += W + 10 // wrap around when we&#x27;ve drawn enough for one row if ((modeIndex % ROW_MAX) == ROW_MAX - 1) &#123; x = 0f y += H + 30 &#125;// &#125; &#125; companion object &#123; private val W = 200 private val H = 200 private val ROW_MAX = 4 // number of samples per row private val sModes: Array&lt;Xfermode&gt; = arrayOf&lt;Xfermode&gt;( PorterDuffXfermode(PorterDuff.Mode.CLEAR), PorterDuffXfermode(PorterDuff.Mode.SRC), PorterDuffXfermode(PorterDuff.Mode.DST), PorterDuffXfermode(PorterDuff.Mode.SRC_OVER), PorterDuffXfermode(PorterDuff.Mode.DST_OVER), PorterDuffXfermode(PorterDuff.Mode.SRC_IN), PorterDuffXfermode(PorterDuff.Mode.DST_IN), PorterDuffXfermode(PorterDuff.Mode.SRC_OUT), PorterDuffXfermode(PorterDuff.Mode.DST_OUT), PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP), PorterDuffXfermode(PorterDuff.Mode.DST_ATOP), PorterDuffXfermode(PorterDuff.Mode.XOR), PorterDuffXfermode(PorterDuff.Mode.DARKEN), PorterDuffXfermode(PorterDuff.Mode.LIGHTEN), PorterDuffXfermode(PorterDuff.Mode.MULTIPLY), PorterDuffXfermode(PorterDuff.Mode.SCREEN) ) private val sLabels = arrayOf( &quot;Clear&quot;, &quot;Src&quot;, &quot;Dst&quot;, &quot;SrcOver&quot;, &quot;DstOver&quot;, &quot;SrcIn&quot;, &quot;DstIn&quot;, &quot;SrcOut&quot;, &quot;DstOut&quot;, &quot;SrcATop&quot;, &quot;DstATop&quot;, &quot;Xor&quot;, &quot;Darken&quot;, &quot;Lighten&quot;, &quot;Multiply&quot;, &quot;Screen&quot; ) &#125; init &#123; mSrcB = makeSrc(W, H) mDstB = makeDst(W, H) // make a ckeckerboard pattern val bm: Bitmap = Bitmap.createBitmap( intArrayOf( -0x1, -0x333334, -0x333334, -0x1 ), 2, 2, Bitmap.Config.RGB_565 ) mBG = BitmapShader( bm, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT ) val m = Matrix() m.setScale(6f, 6f) mBG.setLocalMatrix(m) &#125; &#125; companion object &#123; // create a bitmap with a circle, used for the &quot;dst&quot; image fun makeDst(w: Int, h: Int): Bitmap &#123; val bm: Bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888) val c = Canvas(bm) val p = Paint(Paint.ANTI_ALIAS_FLAG) p.color = -0x33bc c.drawOval(RectF(0f, 0f, w * 3f / 4, h * 3f / 4), p) return bm &#125; // create a bitmap with a rect, used for the &quot;src&quot; image fun makeSrc(w: Int, h: Int): Bitmap &#123; val bm: Bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888) val c = Canvas(bm) val p = Paint(Paint.ANTI_ALIAS_FLAG) p.color = -0x995501 c.drawRect(w / 3f, h / 3f, w * 19f / 20, h * 19f / 20, p) return bm &#125; &#125;&#125; 圆角图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117private const val TYPE_CIRCLE = 0private const val TYPE_ROUND = 1class XfermodeView @JvmOverloads constructor( context: Context?, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; private var src: Bitmap? = null private var out: Bitmap? = null private var mWidth = 0 private var mHeight = 0 private var type = TYPE_ROUND //设置类型，是圆角图片还是圆角矩形 init &#123; // 禁止硬件加速，硬件加速会有一些问题，这里禁用掉 setLayerType(LAYER_TYPE_SOFTWARE, null) &#125; override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec) //自己计算控件的宽高 val widthSize = MeasureSpec.getSize(widthMeasureSpec) val widthMode = MeasureSpec.getMode(widthMeasureSpec) val heightSize = MeasureSpec.getSize(heightMeasureSpec) val heightMode = MeasureSpec.getMode(heightMeasureSpec) mWidth = if (widthMode == MeasureSpec.EXACTLY) &#123; widthSize &#125; else &#123; val imgWidth = (src!!.width + paddingLeft + paddingRight) if (widthMode == MeasureSpec.AT_MOST) &#123; Math.min(widthSize, imgWidth) &#125; else &#123; imgWidth &#125; &#125; mHeight = if (heightMode == MeasureSpec.EXACTLY) &#123; heightSize &#125; else &#123; val imgHeight = (src!!.height + paddingTop + paddingBottom) if (heightMode == MeasureSpec.AT_MOST) &#123; Math.min(heightSize, imgHeight) &#125; else &#123; imgHeight &#125; &#125; when (type) &#123; TYPE_CIRCLE -&gt; &#123; val min = Math.min(mWidth, mHeight) setMeasuredDimension(min, min) &#125; TYPE_ROUND -&gt; setMeasuredDimension(mWidth, mHeight) &#125; &#125; override fun onDraw(canvas: Canvas) &#123; xmodeImage() //把画好画的画布放到自定义的画板上面 canvas.drawBitmap(out!!, 0f, 0f, null) &#125; private fun xmodeImage() &#123; //根据原始的图片创建一个画布 out = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888) //创建一个画板，在画布的基础上 val canvas = Canvas(out!!) //创建一个画笔 val paint = Paint(Paint.ANTI_ALIAS_FLAG) when (type) &#123; TYPE_ROUND -&gt; //开始在有画板的画布上用画笔作画了，这里画了一个圆角矩形 canvas.drawRoundRect( RectF(0f, 0f, mWidth.toFloat(), mHeight.toFloat()), 60f, 60f, paint ) TYPE_CIRCLE -&gt; &#123; //画圆，取宽高的最小值作为圆的直径 val min = Math.min(mWidth, mHeight) //开始画圆 canvas.drawCircle( (min / 2).toFloat(), (min / 2).toFloat(), (min / 2).toFloat(), paint ) &#125; &#125; src = BitmapFactory.decodeResource(resources, R.drawable.meitu110468869) //设置Xfermode画笔模式为SRC_IN paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN) //然后有画了一个图片，最终实现两个图像的叠加 val zoomImg = zoomImg(src!!, mWidth, mHeight) canvas.drawBitmap(zoomImg!!, 0f, 0f, paint) &#125; fun zoomImg(bm: Bitmap, newWidth: Int, newHeight: Int): Bitmap? &#123; // 获得图片的宽高 val width = bm.width val height = bm.height // 计算缩放比例 val scaleWidth = newWidth.toFloat() / width val scaleHeight = newHeight.toFloat() / height // 取得想要缩放的matrix参数 val matrix = Matrix() matrix.postScale(scaleWidth, scaleHeight) // 得到新的图片 return Bitmap.createBitmap(bm, 0, 0, width, height, matrix, true) &#125;&#125;","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[]},{"title":"leetcode","slug":"Leetcode","date":"2022-07-26T06:58:38.000Z","updated":"2023-07-17T13:33:07.152Z","comments":true,"path":"2022/07/26/Leetcode/","link":"","permalink":"https://noteforme.github.io/2022/07/26/Leetcode/","excerpt":"","text":"20. 有效的括号123456789101112131415161718192021222324252627//官方 HashMap 解法更好 更清晰public boolean isValid(String s) &#123; Stack stack = new Stack(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if ((c == &#x27;(&#x27;) || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27;) &#123; stack.push(c); &#125; else &#123; if (stack.isEmpty()) &#123; return false; &#125; boolean p1 = (c == &#x27;)&#x27; &amp;&amp; (char) stack.peek() == &#x27;(&#x27;); boolean p2 = (c == &#x27;]&#x27; &amp;&amp; (char) stack.peek() == &#x27;[&#x27;); boolean p3 = (c == &#x27;&#125;&#x27; &amp;&amp; (char) stack.peek() == &#x27;&#123;&#x27;); if (p1 || p2 || p3) &#123; stack.pop(); &#125;else &#123; stack.push(c); &#125; &#125; &#125; if (stack.isEmpty()) &#123; return true; &#125; return false;&#125; 21. 合并两个有序链表递归解法12345678910111213141516171819202122public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode prevHead &#x3D; new ListNode(-1); ListNode prev &#x3D; prevHead; while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123; if (l1.val &lt; l2.val) &#123; prev.next &#x3D; l1; l1 &#x3D; l1.next; &#125; else &#123; prev.next &#x3D; l2; l2 &#x3D; l2.next; &#125; prev &#x3D; prev.next; &#125; if (l1 &#x3D;&#x3D; null) &#123; prev.next &#x3D; l2; &#125; if (l2 &#x3D;&#x3D; null) &#123; prev.next &#x3D; l1; &#125; return prevHead.next;&#125; 迭代解法待学习 160. 相交链表给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 123456789101112public class Solution_160 &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode la = headA; ListNode lb = headB; while(la!=lb)&#123; la = (la==null) ? headB : la.next; lb = (lb==null) ? headA : lb.next ; &#125; return la; &#125;&#125; 先走自己的路，再走对方的路，最终路程一样 可以这么理解，a，b两个链表，变更为 a+b 和 b+a，长度就相等了，然后等步遍历判断是否相等就行了 原始的数据 修改后的数据示意图 !() 101. 对称二叉树迭代法需要再写下","categories":[],"tags":[]},{"title":"Gradle","slug":"Gradle","date":"2022-07-26T06:58:38.000Z","updated":"2023-07-25T14:20:54.814Z","comments":true,"path":"2022/07/26/Gradle/","link":"","permalink":"https://noteforme.github.io/2022/07/26/Gradle/","excerpt":"","text":"可以研究下 Project Api DEBUG1.&#x2F;gradlew &quot;-Dorg.gradle.daemon&#x3D;false&quot; &quot;-Dorg.gradle.debug&#x3D;true&quot; :tasks 9:37 Gradle Lifecyclehttps://docs.gradle.org/current/userguide/build_lifecycle.html Initialization Detects the settings file.Evaluates the settings file to determine which projects and included builds participate in the build.Creates a Project instance for every project. Configuration Evaluates the build scripts of every project participating in the build.Creates a task graph for requested tasks. 本质上把build.gradle从上到下跑一遍。 Execution Schedules and executes each of the selected tasks in the order of their dependencies. 任务https://www.bilibili.com/video/BV1m54y1L7vK/ https://www.bilibili.com/video/BV1dK411K7Pg https://www.bilibili.com/video/BV1DE411Z7nt https://www.bilibili.com/video/BV1dp4y1e7W4 注意Android stuio默认关闭task 按钮 静态任务123456789println(&quot;gradle study&quot;)task(&quot;helloworld&quot;,&#123; println(&#x27;configure&#x27;) doLast &#123;&#123; println(&quot;Executing task&quot;) &#125;&#125;&#125;) ./gradlew helloworld 动态任务 “configure” 在生命周期Configuration 阶段就执行。 dolast dofirst只是加入到任务中，只有指定具体执行的任务，才会执行，就像上面的 ./gradlew helloworld，指明helloworld任务。 闭包 1234567891011121314151617181920212223242526task testGrdele&#123; println(&quot;testGrdele&quot;)&#125;&#x2F;&#x2F;闭包的概念, 像kotlin匿名函数task closure&#123; mEach&#123; println it &#125; mEachWithParams &#123; m, n -&gt;&#x2F;&#x2F; -&gt; 将闭包的参数和主体分离开 println &quot;$&#123;m&#125; is $&#123;n&#125;&quot; &#125;&#125;def mEach(closure)&#123; for (int i in 1..5)&#123; closure(i) &#125;&#125;def mEachWithParams(closure)&#123; def map &#x3D; [&#39;name&#39;:&#39;groovy&#39;,&#39;age&#39;:10] map.each &#123; closure(it.key,it.value) &#125;&#125; PluginScrpit PluginCustomGradlePlugin ./gradlew CustomGradlePlugin 12345678910111213//1.脚本插件//app模块下的build.gradle文件中定义的对象插件class CustomGradlePlugin implements Plugin&lt;Project&gt; &#123; @Override void apply(Project target) &#123; target.task(&quot;showCustomPlugin&quot;) &#123; doLast &#123; println(&quot;this is CustomGradlePlugin&quot;) &#125; &#125; &#125;&#125; ./gradlew scriptPlugin 1apply from: &quot;config.gradle&quot; 12345project.task(&quot;scriptPlugin&quot;) &#123; doLast &#123; println(&quot;$project.name:this is a scriptPlugin&quot;) &#125;&#125; ankotlin:this is a scriptPlugin MyAwesomePlugin1234567891011121314class MyAwesomePlugin implements Plugin&lt;Project&gt;&#123; @Override void apply(Project project) &#123; task(&quot;helloworld22&quot;,&#123; println(&#x27;configure&#x27;) doLast &#123;&#123; println(&quot;Executing task&quot;) &#125;&#125; &#125;) &#125;&#125;apply plugins : MyAwesomePlugin buildscript 可以把java complile的classpath加入到build.gradle中 Use Plungin in build.gradle123456789101112131415161718192021222324buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath group: &#39;org.apache.commons&#39;, name: &#39;commons-lang3&#39;, version: &#39;3.5&#39; &#125;&#125;allprojects &#123; repositories &#123; mavenCentral() &#125;&#125;apply plugin: &#39;java&#39;dependencies &#123; implementation group: &#39;org.apache.commons&#39;, name: &#39;commons-lang3&#39;, version: &#39;3.5&#39;&#125;if (StringUtils.isNoneEmpty())&#123; &#125; 这样就能使用java的方法在build.gradle中。 https://stackoverflow.com/questions/60550107/gradle-share-repository-configuration-between-settings-gradle-kts-and-buildsrc","categories":[],"tags":[]},{"title":"kotlin-inline","slug":"kotlin-inline","date":"2022-07-24T03:54:53.000Z","updated":"2023-01-02T03:31:39.282Z","comments":true,"path":"2022/07/24/kotlin-inline/","link":"","permalink":"https://noteforme.github.io/2022/07/24/kotlin-inline/","excerpt":"","text":"inline4:00分钟 12345fun main() &#123; hello &#123; println(&quot;Bye&quot;) &#125;&#125; 不加inline1234fun hello(postAction: () -&gt; Unit) &#123; println(&quot;Hello!&quot;) postAction()&#125; 实际编译结果大致 1234567fun main()&#123; val post. = object: Function0&lt;Unit&gt;&#123; override fun nvoke()&#123; return prinltn(&quot;Bye!&quot;) &#125; &#125;&#125; 如果在for(i in 1.. 100) 就会创建很对个对象 加 inline1234fun hello(postAction: () -&gt; Unit) &#123; println(&quot;Hello!&quot;) postAction()&#125; 不仅把函数内连过来,也会把它内部的函数的类型的参数 ，lambda表达式也内联过来. //编译代码 类似 1234fun main()&#123; println(&quot;Hello!&quot;); println(&quot;Bye!&quot;)&#125; 这样就不存在，对象的创建 noinline crossinline https://www.bilibili.com/video/BV1kz4y1f7sf","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[]},{"title":"LC-Tree","slug":"LC-Tree","date":"2022-07-17T10:51:21.000Z","updated":"2023-01-02T03:31:39.081Z","comments":true,"path":"2022/07/17/LC-Tree/","link":"","permalink":"https://noteforme.github.io/2022/07/17/LC-Tree/","excerpt":"","text":"二叉树算法思维 https://www.bilibili.com/video/BV1nG411x77H TreeOperation.java打印树 Tree https://www.bilibili.com/video/BV1JW411i731 完全二叉树数组存储方式 i 是数组下标 遍历 每个Node都有3次访问机会，谁先出现就代表什么序. 中间节点 在哪,代表的遍历方式 先序遍历 preorder traversal ：中左右 中序遍历 inorder traversal：左中右 后序遍历 postorder traversal：左右中 https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md preorder traversal 递归 二叉树的遍历动画 https://www.bilibili.com/video/BV1RR4y1j7kh B的左边遍历完成后，开始遍历B的右子树 遍历过程 访问根节点 先序遍历其左子树 先序遍历其右子树 1234567void PreOrderTraversal(BinTree BT)&#123; if(BT)&#123; printf(&quot;%d&quot;, BT -&gt; Data); PreOrderTraversal(BT-&gt;Left) PreOrderTraversal(BT-&gt;Right) &#125;&#125; https://www.bilibili.com/video/BV1JW411i731?p=34&amp;vd_source=d4c5260002405798a57476b318eccac9 非递归https://www.bilibili.com/video/BV15f4y1W7i2 构建和打印树https://blog.nowcoder.net/n/f3799d64ed764fd49c63947d617d4cd5 https://leetcode.cn/playground/VDCGQ8Ds/ https://leetcode.cn/circle/discuss/vpcMyM/ 中序遍历 层序遍历也叫 广度优先遍历 用队列实现 while遍历纵向层数 for遍历横向 确定二叉树必须有中序遍历，和先 后 序遍历之一 二叉搜索树 BST. Binary Search Tree 144. 二叉树的前序遍历递归 123456789101112fun preorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123; val linkedList = LinkedList&lt;Int&gt;() preTraversal(root, linkedList) return linkedList&#125;private fun preTraversal(node: TreeNode?, linkedList: LinkedList&lt;Int&gt;) &#123; if (node == null) return // 这样的递归基更好 linkedList.add(node.`val`) preTraversal(node.left, linkedList) preTraversal(node.right, linkedList)&#125; 迭代 随想录 前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。 为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。 5 4 1 2 6 1234567891011121314151617181920fun preorderTraversal1(root: TreeNode?): List&lt;Int&gt; &#123; val linkedList = LinkedList&lt;Int&gt;() val stack = Stack&lt;TreeNode&gt;() root?.let&#123; stack.push(it) &#125; while (!stack.empty()) &#123; val popNode = stack.pop() popNode.`val`.let&#123; linkedList.add(it) &#125; popNode.right?.let &#123; stack.push(it) &#125; popNode.left?.let &#123; stack.push(it) &#125; &#125; return linkedList&#125; 94. 二叉树的中序遍历递归 123456789101112fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123; val linkedList = LinkedList&lt;Int&gt;() orderRecursive(root, linkedList) return linkedList&#125;private fun orderRecursive(node: TreeNode?, linkedList: LinkedList&lt;Int&gt;) &#123; if (node == null) return orderRecursive(node.left, linkedList) linkedList.add(node.`val`) orderRecursive(node.right, linkedList)&#125; 迭代法 随想录 1234567891011121314151617fun inorderTraversal1(root: TreeNode?): List&lt;Int&gt; &#123; val linkedList = LinkedList&lt;Int&gt;() if (root == null) return linkedList val stack = Stack&lt;TreeNode&gt;() var node = root while (node != null || !stack.empty()) &#123; //node != null 第一次可以进来 if (node != null) &#123; stack.push(node) node = node.left &#125; else &#123; val resultNode = stack.pop() linkedList.add(resultNode.`val`) node = resultNode.right &#125; &#125; return linkedList&#125; 145. 二叉树的后序遍历递归 12345678910111213//recurivefun postorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123; val linkedList = LinkedList&lt;Int&gt;() recursiveTraversal(root, linkedList) return linkedList&#125;private fun recursiveTraversal(node: TreeNode?, linkedList: LinkedList&lt;Int&gt;) &#123; if (node == null) return recursiveTraversal(node.left, linkedList) recursiveTraversal(node.right, linkedList) linkedList.add(node.`val`)&#125; 迭代法 12345678910111213141516171819202122fun postorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123; var mRoot = root val resultList = LinkedList&lt;Int&gt;() val stack = Stack&lt;TreeNode&gt;() var preNode: TreeNode? = null while (mRoot != null || !stack.isEmpty()) &#123; while (mRoot != null) &#123; stack.push(mRoot) mRoot = mRoot.left &#125; mRoot = stack.pop() if (mRoot?.right == null || mRoot.right == preNode) &#123; // 一开始写成这样 mRoot == preNode,导致死循环 resultList.add(mRoot.`val`) preNode = mRoot mRoot = null &#125; else &#123; stack.push(mRoot) mRoot = mRoot.right &#125; &#125; return resultList &#125; https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/ 动图 官方题解 迭代法统一写法 https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dai-ma-sui-xiang-lu-che-di-chi-tou-qian-xjof1/ 这个统一法还没研究，先往后学吧，地铁上看了下，其实也不难 102. 二叉树的层序遍历 按照顺序，下一层的放在后面. 迭代写法12345678910111213141516171819fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123; val layerList = LinkedList&lt;List&lt;Int&gt;&gt;() val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layerSize = queue.size // queue大小，下面循环在不断变化，所以要先定义出来 val linkedList = LinkedList&lt;Int&gt;() for (i in 0 until layerSize) &#123; val headNode = queue.poll() linkedList.add(headNode.`val`) headNode.left?.let &#123; queue.offer(it) &#125; headNode.right?.let &#123; queue.offer(it) &#125; &#125; layerList.add(linkedList) &#125; return layerList&#125; 递归解法递归解法一开始没理解，再看了下，思路很妙 123456789101112131415161718192021222324fun levelOrder1(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123; val layerList = LinkedList&lt;LinkedList&lt;Int&gt;&gt;() if (root==null)&#123; return layerList &#125; val depth = 0 // 层级 return recursive(layerList, root, depth)&#125;private fun recursive(layerList: LinkedList&lt;LinkedList&lt;Int&gt;&gt;, node: TreeNode?, depth: Int): List&lt;List&lt;Int&gt;&gt; &#123; if (layerList.size &lt;= depth) &#123; //二维数组长度不超过这个层级,随想录这里是用 ==,不过我觉得&lt;=更好 val linkedList = LinkedList&lt;Int&gt;() layerList.add(linkedList) &#125; node?.`val`?.let &#123; layerList[depth].add(it) &#125; // 拿到当前层级节点的值 val mDepth = depth + 1 if (node?.left != null) &#123; recursive(layerList, node.left, mDepth) &#125; if (node?.right != null) &#123; recursive(layerList, node.right, mDepth) &#125; return layerList&#125; https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/ https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html 107. 二叉树的层序遍历 II123456789101112131415161718192021fun levelOrderBottom(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123; val resultList = LinkedList&lt;ArrayList&lt;Int&gt;&gt;() val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layerSize = queue.size // queue循环中 不断的变化 val arrayList = ArrayList&lt;Int&gt;() for (i in 0 until layerSize) &#123; val headNode = queue.poll() if (headNode != null) &#123; arrayList.add(headNode.`val`) headNode.left?.let &#123; queue.offer(it) &#125; headNode.right?.let &#123; queue.offer(it) &#125; &#125; &#125; resultList.addFirst(arrayList) &#125; return resultList&#125; 199. 二叉树的右视图广度优先遍历12345678910111213141516171819fun rightSideView(root: TreeNode?): List&lt;Int&gt; &#123; val resultList = LinkedList&lt;Int&gt;() val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.add(root) &#125; while (queue.isNotEmpty()) &#123; val layoutSize = queue.size for (i in 0 until layoutSize) &#123; val headNode = queue.poll() if (i == layoutSize - 1) &#123; resultList.add(headNode.`val`) &#125; headNode?.left?.let &#123; queue.offer(it) &#125; headNode?.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return resultList&#125; DFS 深度优先遍历这个DFS很妙，这次只是先理解,二刷的时候可以自己写写 123456789101112131415161718class Solutions&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; rightSideView(TreeNode root)&#123; dfs(root,0) return res; &#125; prvidate void dfs(TreeNode root, int depth)&#123; if(root ==null)&#123; return; &#125; if(depth == res.size())&#123; // 当前层级第一个右节点还没有，添加到结果中 res.add(root.val) &#125; depth++; dfs(root.right,depth) dfs(root.left,depth) &#125;&#125; 理解在官方视频中. https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/ 637. 二叉树的层平均值12345678910111213141516171819fun averageOfLevels(root: TreeNode?): DoubleArray &#123; val resultList = ArrayList&lt;Double&gt;() val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layoutSize = queue.size var layerSum = 0.toDouble() for (i in 0 until layoutSize) &#123; val node = queue.poll() layerSum += node.`val` node?.left?.let &#123; queue.offer(it) &#125; node?.right?.let &#123; queue.offer(it) &#125; &#125; val average = resultList.add(layerSum * 1.00000 / layoutSize) &#125; return resultList.toDoubleArray()&#125; 429. N 叉树的层序遍历1234567891011121314151617181920fun levelOrder(root: Node?): List&lt;List&lt;Int&gt;&gt; &#123; val result = LinkedList&lt;ArrayList&lt;Int&gt;&gt;() val queue = LinkedList&lt;Node&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layoutSize = queue.size // 该层级的节点数 val layerResult = ArrayList&lt;Int&gt;() for (i in 0 until layoutSize) &#123; val pollNode = queue.poll() layerResult.add(pollNode.`val`) pollNode.children.forEach &#123; // 只有这里有点不同 queue.offer(it) &#125; &#125; result.add(layerResult) &#125; return result&#125; 515. 在每个树行中找最大值12345678910111213141516171819fun largestValues(root: TreeNode?): List&lt;Int&gt; &#123; val answer = ArrayList&lt;Int&gt;() val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layerSize = queue.size var maxValue = Int.MIN_VALUE //最小值 , 每一层级都要初始化，否则拿到上一层级的值，就不是最小值，会有问题 for (i in 0 until layerSize) &#123; val pollNode = queue.poll() maxValue = pollNode.`val`.coerceAtLeast(maxValue) // 比较取最大值 pollNode?.left?.let &#123; queue.offer(it) &#125; pollNode?.right?.let &#123; queue.offer(it) &#125; &#125; answer.add(maxValue) &#125; return answer&#125; 116. 填充每个节点的下一个右侧节点指针 一开始用这种方式，但是会提示 “超出内存限制” 123456789101112131415161718192021222324252627 fun connect(root: Node?): Node? &#123;// val answerList = ArrayList&lt;String&gt;() //根据题意, 一开始以为要返回这个答案,其实只要连接后 返回root就好了 val queue = LinkedList&lt;Node&gt;() if (root != null) &#123; queue.offer(root) &#125; var preNode: Node?=null while (queue.isNotEmpty()) &#123; val layerSize = queue.size preNode = null for (i in 0 until layerSize) &#123; val curNode = queue.poll() preNode = curNode if (preNode != null) &#123; preNode.next = curNode &#125;// answerList.add(curNode.`val`.toString()) if (i == layerSize - 1) &#123; curNode.next = null // 最后个node 指向null // answerList.add(&quot;#&quot;) &#125; curNode?.left?.let &#123; queue.offer(it) &#125; curNode?.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return root &#125; 官方解法 还有另一种解法，二刷时可以研究研究 123456789101112131415161718fun connect(root: Node?): Node? &#123; val queue = LinkedList&lt;Node&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layerSize = queue.size for (i in 0 until layerSize) &#123; val curNode = queue.poll() if (i &lt; layerSize - 1) &#123; curNode.next = queue.peek() &#125; curNode?.left?.let &#123; queue.offer(it) &#125; curNode?.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return root&#125; https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/ 117. 填充每个节点的下一个右侧节点指针 II和116题唯一的区别，116是完美二叉树 104. 二叉树的最大深度广度优先 Breadth-First-Search12345678910111213141516171819fun maxDepth(root: TreeNode?): Int &#123; val queue = LinkedList&lt;TreeNode&gt;() var depth = 0 if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty()) &#123; val layerSize = queue.size for (i in 0 until layerSize) &#123; val pollNode = queue.poll() pollNode?.left?.let &#123; queue.add(it) &#125; pollNode?.right?.let &#123; queue.add(it) &#125; if (i == layerSize - 1) &#123; depth++ &#125; &#125; &#125; return depth&#125; 递归 Depth First Search这题用一个方法就可以了，遍历左右子树取最大值后 再加 1 这个其实也是先序遍历,左右中 https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95 1234int leftdepth = getdepth(node-&gt;left); // 左int rightdepth = getdepth(node-&gt;right); // 右int depth = 1 + max(leftdepth, rightdepth); // 中return depth; 可以看看随想录的解法，里面有回溯的过程，过程更详细 下面解法做了简化 1234567891011fun maxDepth(root: TreeNode?): Int &#123; val depth = 0 if (root == null) return depth return dfsDepth(root, depth)&#125;private fun dfsDepth(node: TreeNode?, depth: Int): Int &#123; if (node == null) return depth val maxDepth = Math.max(dfsDepth(node.left, depth + 1), dfsDepth(node.right, depth + 1)) // 用max函数更直观 return maxDepth&#125; https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/ 559. N 叉树的最大深度DFS 这个DFS解法 看了官方题解答案，自己再做一次 https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution/n-cha-shu-de-zui-da-shen-du-by-leetcode-n7qtv/ 123456789fun maxDepth(root: Node?): Int &#123; if (root == null) return 0 var maxDepth = 0 root.children.forEach &#123; val depth = maxDepth(it) maxDepth = Math.max(maxDepth, depth) &#125; return maxDepth +1&#125; BFS 123456789101112131415161718192021fun maxDepth1(root: Node?): Int &#123; val queue = LinkedList&lt;Node&gt;() if (root != null) &#123; queue.offer(root) &#125; var maxDepth = 0 while (queue.isNotEmpty()) &#123; val layerSize = queue.size for (i in 0 until layerSize) &#123; val pollNode = queue.poll() if (i == 0) &#123; // 这个条件可以去掉 maxDepth++ &#125; pollNode.children.forEach &#123; if (it != null) queue.offer(it) &#125; &#125; &#125; return maxDepth&#125; 12345678910111213141516171819fun maxDepth1(root: Node?): Int &#123; val queue = LinkedList&lt;Node&gt;() if (root != null) &#123; queue.offer(root) &#125; var maxDepth = 0 while (queue.isNotEmpty()) &#123; val layerSize = queue.size maxDepth++ //拿到外面更好，不用判断i==1了,每次layerSize 遍历完就是一层了 for (i in 0 until layerSize) &#123; val pollNode = queue.poll() pollNode.children.forEach &#123; if (it != null) queue.offer(it) &#125; &#125; &#125; return maxDepth&#125; 111. 二叉树的最小深度BFS 1234567891011121314151617181920fun minDepth(root: TreeNode?): Int &#123; val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; var depth = 0 while (queue.isNotEmpty()) &#123; val layerSize = queue.size depth++ // 不用放下面判断，直接是一层新的 for (i in 0 until layerSize) &#123; val pollNode = queue.poll() if (pollNode.left == null &amp;&amp; pollNode.right == null) &#123; return depth &#125; pollNode?.left?.let &#123; queue.offer(it) &#125; pollNode?.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return depth&#125; 官方题解看起来，更好 https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/ DFS https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/bfshe-dfsliang-chong-fang-shi-jie-jue-by-g4eh/ 用了这个视频的解法 1234567891011fun minDepth(root: TreeNode?): Int &#123; if (root == null) return 0 //左子节点和右子节点都不为空，然后取最小值才有意义，否则就是错的 if (root.left != null &amp;&amp; root.right != null) &#123; // 左右都不为空 return Math.min(minDepth(root.left), minDepth(root.right)) + 1 &#125; else if (root.left == null) &#123; //左不为空 return minDepth(root.right) + 1 &#125; return minDepth(root.left) + 1 //右不为空&#125; 理解了这个解法，再看官方的DFS解法，也简单明了 https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/ 226. 翻转二叉树递归 123456789101112131415//使用先序遍历fun invertTree(root: TreeNode?): TreeNode? &#123; if (root == null) return null swapNode(root) invertTree(root.left) invertTree(root.right) return root&#125;private fun swapNode(node: TreeNode?) &#123; val temp = node?.left node?.left = node?.right node?.right = temp&#125; 123456789public TreeNode invertTree(TreeNode root) &#123; if(root == null) return null; invertTree(root.left);//注意这里是left TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left);//这里还是left return root;&#125; ————————————————版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xsybg/article/details/122687168 注意两个递归调用的参数都是root.left, 因为在第二步是交换root的左右孩子，所以在第三步要处理的右孩子其实已经变成了root的左孩子，是不是很有趣？这个题目很简单，但是确实会稀里糊涂地通过，没搞清楚是树的哪一种遍历，看了代码随想录的解析感觉还挺惊喜的。代码随想录的链接贴在这里：————————————————版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xsybg/article/details/122687168 根据下面打印 4的坐子树中的1,3交换了两次， 6,9一次都没交换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\ 1 3 6 9 node 4 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\ 1 3 6 9 node 2 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\ 1 3 6 9 node 1 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\ 1 3 6 9 node 1 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\ 3 1 6 9 node 2 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\ 6 9 3 1 node 3 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\ 6 9 3 1 node 3 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\ 6 9 1 3 广度优先遍历(层序遍历)遍历左右节点就可以.然后交换就可以了 12345678910111213141516fun invertTree1(root: TreeNode?): TreeNode? &#123; val queue = LinkedList&lt;TreeNode&gt;() if (root != null) &#123; queue.offer(root) &#125; while (queue.isNotEmpty())&#123; val layerSize = queue.size for (i in 0 until layerSize)&#123; val pollNode = queue.poll() swapNode(pollNode) pollNode.left?.let &#123; queue.offer(it) &#125; pollNode.right?.let &#123; queue.offer(it) &#125; &#125; &#125; return root&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"LC-stack-queue","slug":"LC-stack-queue","date":"2022-07-03T04:16:17.000Z","updated":"2023-01-02T03:31:39.091Z","comments":true,"path":"2022/07/03/LC-stack-queue/","link":"","permalink":"https://noteforme.github.io/2022/07/03/LC-stack-queue/","excerpt":"","text":"232. 用栈实现队列最初写的 1234567891011121314151617181920212223242526272829303132333435363738val stack = Stack&lt;Int&gt;() // 元素栈val tempStack = Stack&lt;Int&gt;() // 备用fun push(x: Int) &#123; stack.push(x)&#125;fun pop(): Int &#123; while (!stack.empty()) &#123; tempStack.push(stack.pop()) &#125; var pop = 0 if (!tempStack.isEmpty()) &#123; pop = tempStack.pop() // 这里取的就是头元素 &#125; while (!tempStack.empty()) &#123; stack.push(tempStack.pop()) &#125; return pop&#125;fun peek(): Int &#123; while (!stack.empty()) &#123; tempStack.push(stack.pop()) &#125; var peek = 0 if (!tempStack.isEmpty()) &#123; peek = tempStack.peek() // 这里取的就是头元素,不会删除 &#125; while (!tempStack.empty()) &#123; stack.push(tempStack.pop()) &#125; return peek&#125;fun empty(): Boolean &#123; return stack.empty()&#125; 在LC232基础上进行的优化，之前每次pop后，还得把元素放回去,这里只有push判断 tempStack有没有元素 https://leetcode.cn/problems/implement-queue-using-stacks/solution/wen-zi-shi-pin-de-fang-shi-xiang-xi-jiang-jie-li-2/ 123456789101112131415161718192021222324252627282930val stackIn = Stack&lt;Int&gt;() // 元素栈val tempStack = Stack&lt;Int&gt;() // 备用fun push(x: Int) &#123; while (!tempStack.empty())&#123; // stackIn.push(tempStack.pop()) &#125; stackIn.push(x)&#125;fun pop(): Int &#123; while (!stackIn.empty()) &#123; tempStack.push(stackIn.pop()) &#125; var pop = -1 // 需要-1 if (!tempStack.isEmpty()) &#123; pop = tempStack.pop() // 这里取的就是头元素 &#125; return pop&#125;fun peek(): Int &#123; val pop = this.pop() stackIn.push(pop) // 复用pop，拿出来 再放回去 return pop&#125;fun empty(): Boolean &#123; return tempStack.empty()&amp;&amp;stackIn.empty()&#125; 随想录写法 https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC 在LC232_01基础上进行的优化，push的时候不用每次都判断，只有stackOut是空的时候，才需要取后面的元素 1234567891011121314151617181920212223242526272829private val stackIn = Stack&lt;Int&gt;() // 输入栈private val stackOut = Stack&lt;Int&gt;() // 输出栈fun push(x: Int) &#123; stackIn.push(x)&#125;fun pop(): Int &#123; if (stackOut.isEmpty()) &#123; while (!stackIn.empty()) &#123; stackOut.push(stackIn.pop()) &#125; &#125; var data = -1 if (!stackOut.isEmpty()) &#123; data = stackOut.pop() &#125; return data&#125;fun peek(): Int &#123; val pop = this.pop() stackOut.push(pop) // 复用pop，拿出来 再放回去 return pop&#125;fun empty(): Boolean &#123; return stackOut.empty() &amp;&amp; stackIn.empty()&#125; 225. 用队列实现栈我的解法123456789101112131415161718192021222324252627282930313233343536private val mainDeque = ArrayDeque&lt;Int&gt;()private val tempDeque = ArrayDeque&lt;Int&gt;()fun push(x: Int) &#123; while (!tempDeque.isEmpty()) &#123; mainDeque.offerLast(tempDeque.poll()) &#125; mainDeque.offerLast(x)&#125;fun pop(): Int &#123; var data = -1 while (!mainDeque.isEmpty()) &#123; if (mainDeque.size == 1) &#123; data = mainDeque.poll() &#125; else &#123; data = mainDeque.poll() tempDeque.offerLast(data) &#125; &#125; while (!tempDeque.isEmpty()) &#123; mainDeque.offerLast(tempDeque.poll()) &#125; return data&#125;fun top(): Int &#123; val pop = this.pop() mainDeque.offerLast(pop) return pop&#125;fun empty(): Boolean &#123; return tempDeque.isEmpty() &amp;&amp; mainDeque.isEmpty()&#125; 两个队列https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/ 这里的视频教程更好理解. 1234567891011121314151617181920212223242526private var mainDeque = LinkedList&lt;Int&gt;()private var tempDeque = LinkedList&lt;Int&gt;()fun push(x: Int) &#123; tempDeque.offer(x) while (!mainDeque.isEmpty()) &#123; tempDeque.offerLast(mainDeque.poll()) &#125; val temp = mainDeque //此时mainDeque一定是空的,不过没关系，不用再创建一个 mainDeque = tempDeque //交换队列元素, tempDeque的元素给mainDeque tempDeque = temp&#125;fun pop(): Int &#123; return mainDeque.poll() //删除并返回元素&#125;fun top(): Int &#123; return mainDeque.peek() // 返回元素&#125;fun empty(): Boolean &#123; return tempDeque.isEmpty() &amp;&amp; mainDeque.isEmpty()&#125; 一个队列也是上面官方教程 1234567891011121314151617181920private var mainDeque = LinkedList&lt;Int&gt;()fun push(x: Int) &#123; mainDeque.offer(x) for (i in 0 until mainDeque.size - 1) &#123; // 注意这里要-1,这样最后入队的就在头部.否则就没有意义了 mainDeque.offer(mainDeque.poll()) &#125;&#125;fun pop(): Int &#123; return mainDeque.poll() //删除并返回元素&#125;fun top(): Int &#123; return mainDeque.peek() // 返回元素&#125;fun empty(): Boolean &#123; return mainDeque.isEmpty()&#125; 123456789101112131415val queue = LinkedList&lt;Int&gt;()queue.offer(0)queue.offer(1)queue.offer(2)queue.offer(3)for (i in 0 until queue.size - 1) &#123; queue.offer(queue.poll()) println(queue)&#125;//看到这个入队结果// [1, 2, 3, 0]//[2, 3, 0, 1]//[3, 0, 1, 2] 20. 有效的括号123456789101112fun isValid(s: String): Boolean &#123; val mapOf = mapOf(&#x27;(&#x27; to &#x27;)&#x27;, &#x27;&#123;&#x27; to &#x27;&#125;&#x27;, &#x27;[&#x27; to &#x27;]&#x27;) val stack = Stack&lt;Char&gt;() s.chars().forEach &#123; if (!stack.empty() &amp;&amp; mapOf[stack.peek()] == it.toChar()) &#123; //stack 为空 取出会抛出异常, mapOf应该取左边的符号也就是stack里的 stack.pop() &#125; else &#123; stack.push(it.toChar()) &#125; &#125; return stack.empty()&#125; 1047. 删除字符串中的所有相邻重复项而且在企业项目开发中，尽量不要使用递归！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！） 1234567891011fun removeDuplicates(s: String): String &#123; val stack = Stack&lt;Char&gt;() s.chars().forEach &#123; if(!stack.empty()&amp;&amp;stack.peek()==it.toChar())&#123; stack.pop() &#125;else&#123; stack.push(it.toChar()) &#125; &#125; return stack.joinToString(separator = &quot;&quot;)&#125; 150. 逆波兰表达式求值1234567891011121314151617181920212223242526fun evalRPN(tokens: Array&lt;String&gt;): Int &#123; val stack = Stack&lt;Int&gt;() tokens.forEach &#123; if (it == &quot;+&quot; || it == &quot;-&quot; || it == &quot;*&quot; || it == &quot;/&quot;) &#123; val pop1 = stack.takeUnless &#123; p1 -&gt; p1.empty() &#125;?.pop() val pop2 = stack.takeUnless &#123; p2 -&gt; p2.empty() &#125;?.pop() if (pop1 != null &amp;&amp; pop2 != null) &#123; val result = getResult(it, pop2.toInt(), pop1.toInt()) // stack取的第二个数放前面 stack.push(result) &#125; &#125; else &#123; stack.push(it.toInt()) &#125; &#125; return stack.peek()&#125;private fun getResult(operator: String, pop1: Int, pop2: Int): Int &#123; return when (operator) &#123; &quot;+&quot; -&gt; pop1 + pop2 &quot;-&quot; -&gt; pop1 - pop2 &quot;*&quot; -&gt; pop1 * pop2 &quot;/&quot; -&gt; pop1 / pop2 else -&gt; throw RuntimeException(&quot;oh something went wrong&quot;) &#125;&#125; 239. 滑动窗口最大值存储元素坐标https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html nums[index - k]是队列头部最大元素，此时最大元素出队列,因为最大元素一定改窗口的最左侧元素， 如果不是最大元素，因为滑动窗口可能没有k个元素,也不用担心是不是留在窗口里，这种情况下其实在下面push已经早出去了 这样更好理解 移动窗口,队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出 这种也是官方解法 123456789101112131415161718fun maxSlidingWindow2(nums: IntArray, k: Int): IntArray &#123; val linkedList = LinkedList&lt;Int&gt;() val resultArray = IntArray(nums.size - (k - 1)) // 如果窗口是3个元素，结构数组就需要少两个元素 var i = 0 nums.forEachIndexed &#123; index, value -&gt; if (!linkedList.isEmpty() &amp;&amp; linkedList.peek() &lt; index - (k - 1)) &#123; //这样更好理解 移动窗口,队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出 linkedList.pop() &#125; while (!linkedList.isEmpty() &amp;&amp; value &gt; nums[linkedList.last()]) &#123; // 如果大于最后一个元素 linkedList.removeLast() //最后一个元素出队列 &#125; linkedList.offer(index) //否则直接入队,这样保持队列元素单调递减 if (index &gt;= (k - 1)) &#123; //如果是3个元素，从位置2开始存最大值，如果是1个元素，就从0存最大值 resultArray[i++] = nums[linkedList.peek()] &#125; &#125; return resultArray&#125; https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-de-zui-da-zhi-bao-mu-9eci/ MyQueue随想录定义Myquue,更好，单一指责，更有层次感 // 注意先将前k的元素放进队列,此时push方法，放完后已经是按照单调递减队列来的了 二刷来刷刷刷 347. 前 K 个高频元素大顶堆 看官方题解理解了 但是大顶堆 小顶堆区别不是很明白，学完树再来继续做这个题目","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"","slug":"TouchEvent1","date":"2022-06-12T03:17:58.728Z","updated":"2024-06-03T11:28:15.725Z","comments":true,"path":"2022/06/12/TouchEvent1/","link":"","permalink":"https://noteforme.github.io/2022/06/12/TouchEvent1/","excerpt":"","text":"今天学习Android的是事件分发机制的部分内容。 Android事件分发机制是指在Android系统中，如何将触摸事件（TouchEvent）从系统分发到各个View组件。这个过程主要涉及三个方法：dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent。下面是对这三个方法及其工作流程的详细介绍： 1. dispatchTouchEvent 定义：所有的ViewGroup和View都会重写这个方法。它是整个事件分发链的起点。 作用：决定是否将事件传递给子View，如果子View没有处理，则调用自己的onTouchEvent方法进行处理。 2. onInterceptTouchEvent 定义：只有ViewGroup有这个方法。普通的View是没有的。 作用：用于决定是否拦截子View的事件。如果返回true，表示拦截事件，不再向子View传递，而是由当前ViewGroup处理。 3. onTouchEvent 定义：所有的View和ViewGroup都有这个方法。 作用：最终处理触摸事件的地方。可以在这里定义具体的触摸事件响应逻辑，如点击、长按、滑动等。 事件分发流程 Activity级别： Activity.dispatchTouchEvent()接收到事件。 如果返回true，表示事件被处理，停止向下传递。 如果返回false，事件继续传递给当前窗口的顶级View。 ViewGroup级别： ViewGroup.dispatchTouchEvent()接收到事件。 调用onInterceptTouchEvent()来判断是否拦截事件。 如果onInterceptTouchEvent()返回true，则调用自身的onTouchEvent()进行处理。 如果返回false，则将事件传递给子View的dispatchTouchEvent()。 View级别： View.dispatchTouchEvent()接收到事件。 调用自身的onTouchEvent()进行处理。 示例代码以下是一个简单的示例，展示了事件分发机制的基本工作原理： 1234567891011121314151617181920212223242526272829303132333435363738394041public class CustomViewGroup extends ViewGroup &#123; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;CustomViewGroup&quot;, &quot;dispatchTouchEvent: &quot; + ev.getAction()); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.d(&quot;CustomViewGroup&quot;, &quot;onInterceptTouchEvent: &quot; + ev.getAction()); return true; // 拦截所有事件 &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; Log.d(&quot;CustomViewGroup&quot;, &quot;onTouchEvent: &quot; + ev.getAction()); return true; // 处理事件 &#125; // 省略布局相关代码...&#125;public class CustomView extends View &#123; public CustomView(Context context) &#123; super(context); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;CustomView&quot;, &quot;dispatchTouchEvent: &quot; + ev.getAction()); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; Log.d(&quot;CustomView&quot;, &quot;onTouchEvent: &quot; + ev.getAction()); return true; // 处理事件 &#125;&#125; 项目中guideview用到了 ShouldDelayChildPressedState 这个你也看一下是否要加 系统级别的延迟,别看了 你继承的class 不会延迟 Question手机屏幕是由一个个像素点渲染而成的，不同的布局类似于幕布一层层叠上去形成了屏幕上显示的效果，The action is from DOWN、MOVE、UP, How they formed while we used like longClick , touch, click? a button on the listview item，why the listview item don’t response while we click the button in a interview ? but I cann’t answer the key point. multible listview or recycleview in a Scrollview ,how to resolve it? Android provide NestedScrollView for us now,how does it work? AnswerImage clear I found it very useful when i looked it.it make me have global view.and then I read Activity ViewGroup and View source code from framework. But I found some place could do better ,so I draw another Image. 开发中常用的事件分发 ListView item 上有Button ,item上的onItemClick事件得不到响应，可以看看官方ViewGroup 描述 item Button 页面搜索 android:descendantFocusability android:descendantFocusability属性共有三个取值，分别为beforeDescendants：viewgroup会优先其子类控件而获取到焦点afterDescendants：viewgroup 只有当其子类控件不需要获取焦点时才获取焦点blocksDescendants：viewgroup 会覆盖子类控件而直接获得焦点 原因 : 在View onTouchEvent(MotionEvent event) 中,只要view可点击就返回true,事件就被消费掉了, set isClickable &#x3D; true 才可以收到 action move up事件 1234567891011121314151617181920public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn&#x27;t respond to them. return clickable; &#125; &#125; 按钮是可以点击的直接被onTouchEvent消费","categories":[],"tags":[]},{"title":"PerformanceJank","slug":"PerformanceJank","date":"2022-06-09T03:23:50.000Z","updated":"2022-07-16T15:07:08.241Z","comments":true,"path":"2022/06/09/PerformanceJank/","link":"","permalink":"https://noteforme.github.io/2022/06/09/PerformanceJank/","excerpt":"","text":"https://www.bilibili.com/video/BV1T44y1u7g6 6:41 数据到屏幕，渲染机制 https://www.jianshu.com/p/8a296b75d95f https://juejin.cn/post/6844904062610046990 https://testerhome.com/topics/29134 卡顿优化https://blog.csdn.net/JArchie520/article/details/106710663 布局优化布局加载原理 https://blog.csdn.net/JArchie520/article/details/106563639 https://androidperformance.com/2019/10/22/Android-Choreographer/#/%E5%B8%A7%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96","categories":[],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://noteforme.github.io/tags/Performance/"}]},{"title":"PerformanceANR","slug":"PerformanceANR","date":"2022-06-07T06:41:30.000Z","updated":"2023-01-02T03:31:39.095Z","comments":true,"path":"2022/06/07/PerformanceANR/","link":"","permalink":"https://noteforme.github.io/2022/06/07/PerformanceANR/","excerpt":"","text":"ANR https://play.google.com/console/u/0/developers/5313279702199603526/app/4975846927718251228/vitals/crashes?installedFrom=PLAY_STORE&amp;days=30 https://developer.android.com/topic/performance/vitals/anr.html ANR 全称 Application Nor Responding,在debug的时候经常会出现的一个框框，询问关闭或等待，在正常环境下出现的情况 主线程IO 操作 主线程耗时任务 主线程错误的操作 Thread.wait或Thread.sleepAndroid系统监控程序的响应状况，出现下面两种情况弹出ANR对话框*应用在5秒内未响应用户的输入事件(按键或者触摸)*BroadcastReceiver未在 10秒内完成相关的处理 Android Vitals 将连续丢帧超过 700 毫秒定义为冻帧，也就是连续丢帧 42 帧以上 https://time.geekbang.org/column/article/72642 卡顿优化 https://www.bilibili.com/video/BV1T44y1u7g6?spm_id_from=333.337.search-card.all.click Block canary https://blog.csdn.net/JArchie520/article/details/106710663 这里有ANR场景模拟 ANR产生原因和类型有以下几种： 1、Activity在5秒钟之内无法响应屏幕触摸事件挥着键盘输入事件就会产生ANR。KeyDispatchTimeout Reason：Input event dispatching timed out 2、BroadcastReceiver在10秒钟之内还未执行完成就会产生ANR。BroadcastTimeout Reason：Timeout of broadcast BroadcastRecord 3、Service各个生命周期在20秒钟之内没有执行完成就会产生ANR。ServiceTimeout Reason：Timeout executing service 4、ContentProvider在10秒钟之内没有执行完成就会产生ANR。ContentProviderTimeout Reason：timeout publishing content providers 在以上这几种原因中出现最多的一般是第一种，而且往往都是因为在写代码时不注意，在主线程做了耗时的操作。 链接：https://juejin.cn/post/6844904069731975176 各主流方案 BlockCanary 主要是检测主线程的耗时操作，后面会写卡顿监控，主要基于Handler的打印 某些场景监控不到, ANR-WatcheDog主要是往主线程插入一条监控消息， 隔一段时间来引爆这个炸弹,今天手写 轮询时间不好定呀,时间5s, 5s - 10s的有可能监控不到 SafeLooer去代理了主线程Looper，这个不讲 FileObserver高版本没有权限,所以用不了","categories":[],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://noteforme.github.io/tags/Performance/"}]},{"title":"PerformanceMemory","slug":"PerformanceMemory","date":"2022-06-07T02:34:22.000Z","updated":"2022-06-12T03:17:58.711Z","comments":true,"path":"2022/06/07/PerformanceMemory/","link":"","permalink":"https://noteforme.github.io/2022/06/07/PerformanceMemory/","excerpt":"","text":"https://developer.android.com/studio/profile/memory-profiler?hl=zh-cn 查看内存限制，下面的命令不起作用 1234adb shell cat&#x2F;system&#x2F;build.prop &#x2F;&#x2F; 需要root权限，没用adb shell getprop &#x2F;&#x2F; 可以看全部的adb shell getprop dalvik.vm.heapsize &#x2F;&#x2F;迷你裙可以看到 内存抖动分析Android profile https://www.bilibili.com/video/BV1n44y1K7xS?p=5&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1oz4y1m7Gw?p=6 https://www.youtube.com/watch?v=7ls28uGMBEs&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=73 Android 内存泄漏 https://www.bilibili.com/video/BV1n44y1K7xS?p=6 video 25分钟泄漏分析 leakcanary https://github.com/square/leakcanary AndroidStudio Profiler工具 这个视频 讲解了找出内存泄漏的步骤 还有AndroidStudio3.0的图文方法 https://mp.weixin.qq.com/s/b_lFfL1mDrNVKj_VAcA2ZA 抖音内存监控框架 (kenzo) 内存优化操作1:25分钟 https://www.bilibili.com/video/BV1T44y1u7g6?p=4&amp;spm_id_from=pageDriver https://juejin.cn/post/6844904099998089230#heading-6 https://blog.csdn.net/JArchie520/article/details/106418561","categories":[],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://noteforme.github.io/tags/Performance/"}]},{"title":"LC-string","slug":"LC-string","date":"2022-06-05T03:06:28.000Z","updated":"2023-01-02T03:31:39.091Z","comments":true,"path":"2022/06/05/LC-string/","link":"","permalink":"https://noteforme.github.io/2022/06/05/LC-string/","excerpt":"","text":"344. 反转字符串双指针 123456789101112131415fun reverseString(s: CharArray): Unit &#123; var left = 0 var right = s.size - 1 while (left &lt; right) &#123; swap(s, left, right) left++ right-- &#125;&#125;fun swap(s: CharArray, left: Int, right: Int) &#123; val temp = s[left] s[left] = s[right] s[right] = temp&#125; 541. 反转字符串 II12345678910111213141516fun reverseStr(s: String, k: Int): String &#123; val charArray = s.toCharArray() for (i in s.indices step 2 * k) &#123; var left = i // 每次的left指针设置好 var right = (i + k - 1) //接着设置每次的 右指针 if (right &gt; s.length - 1) &#123; // 如果字符串长度小于 这次的右指针，使用字符串的右边界作为右指针 right = s.length - 1 &#125; while (left &lt; right) &#123; //反转 LC344().swap(charArray, left, right) left++ right-- &#125; &#125; return String(charArray)&#125; 随想录感觉解法不太好 https://leetcode.cn/problems/reverse-string-ii/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-p88f/ 这个解法和我的差不多，更优雅 剑指 Offer 05. 替换空格https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution/zhe-dao-ti-mu-zhen-de-you-zhe-yao-jian-dan-ma-qing/ 151. 颠倒字符串中的单词这题的难点，主要就是去除 字符串中间的空格 栈或双端队列解法123456789101112131415161718192021222324252627282930313233 /* 栈或双端队列解法 * 1. 设置left , right指针，移动指针，类似移除两端的空格 * 2. 从第一个元素开始遍历,添加到StringBuilder,直到遇到第一个空格，StringBuilder的数据加入队列,清空StringBuilder * 3. 直到最后一个加入队列 * * if (s[left] != &#x27; &#x27;) 中的&#x27; &#x27;是Ascii十进制32,单测中有验证 * */ fun reverseWords(s: String): String &#123; var left = 0 var right = s.length - 1 while (s[left] == &#x27; &#x27;) &#123; left++ &#125; while (s[right] == &#x27; &#x27;) &#123; right-- &#125; val deque: Deque&lt;String&gt; = ArrayDeque() val sb = StringBuilder() for (i in left..right) &#123; if (s[left] != &#x27; &#x27;) &#123; sb.append(s[left])// &#125; else if (s[left] == &#x27; &#x27; &amp;&amp; sb[sb.length - 1] != &#x27; &#x27;) &#123; // 一开始以为官方也是这样写的，其实也是下面我这种的 &#125; else if (s[left] == &#x27; &#x27; &amp;&amp; sb.isNotEmpty()) &#123; // 这里改成这样是因为加入 &quot;the sky is blue&quot; ， left==3走到了空格， deque.offerFirst(sb.toString()) //就初始化sb,然后left==4走到了s,如果两个空格，sb[sb.length - 1]就会越界 sb.setLength(0) &#125; left++ &#125; deque.offerFirst(sb.toString()) return java.lang.String.join(&quot; &quot;, deque) &#125; 官方题解，文字版的感觉更好点，因为有java的版本的，视频的c++的不用stringbuilder https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/ 两次反转字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 1. 去除空格，并且用StringBuilder组合 * 2. 翻转整个StringBuilder * 3. 翻转StringBuilder中的单个字符 */fun reverseWords2(s: String): String &#123; val sb = deleteStartEndSpace(s) reverseStringBuilder(sb, 0, sb.length - 1) var wStart = 0 var wEnd = 0 while (wStart &lt; sb.length) &#123; if (sb.getOrElse(wEnd) &#123; &#x27; &#x27; &#125; == &#x27; &#x27;) &#123; reverseStringBuilder(sb, wStart, wEnd - 1) wStart = ++wEnd &#125; else &#123; wEnd++ &#125; &#125; return sb.toString()&#125;private fun deleteStartEndSpace(s: String): StringBuilder &#123; var left = 0 var right = s.length - 1 while (s[left] == &#x27; &#x27;) &#123; left++ &#125; while (s[right] == &#x27; &#x27;) &#123; right-- &#125; val sb = StringBuilder() while (left &lt;= right) &#123; // 注意这里最右边的字符是需要添加的 if (s[left] != &#x27; &#x27;) &#123; sb.append(s[left]) &#125; else if (s[left] == &#x27; &#x27; &amp;&amp; s[left - 1] != &#x27; &#x27;) &#123; //不提前去掉空格，如果字符左边&quot; hello world &quot;有空格就会越界， sb.append(s[left]) //而且StringBuilder右边空格也会添加空格，而且不好去掉 &#125; left++ &#125; return sb&#125;private fun reverseStringBuilder(sb: StringBuilder, leftP: Int, rightP: Int) &#123; var left = leftP var right = rightP while (left &lt; right) &#123; val temp = sb[left] sb.setCharAt(left, sb[right]) sb.setCharAt(right, temp) left++ right-- &#125;&#125; 官方解法，翻转子字符串这种更妙 public void reverseEachWord(StringBuilder sb) &#123; int n = sb.length(); int start = 0, end = 0; while (start &lt; n) &#123; // 循环至单词的末尾 while (end &lt; n &amp;&amp; sb.charAt(end) != &#39; &#39;) &#123; ++end; &#125; // 翻转单词 reverse(sb, start, end - 1); // 更新start，去找下一个单词 start = end + 1; ++end; &#125; &#125; 剑指 Offer 58 - II. 左旋转字符串数组System.arraycopy深入分析用到了汇编指令,后面可以加强学习,其实底层的知识还是需要的，要不然没法深入下去了 https://blog.csdn.net/jackgo73/article/details/111866491 12345678fun reverseLeftWords(s: String, n: Int): String &#123; val sb = StringBuilder(s) for (i in 0 until n) &#123; sb.append(s[i]) sb.deleteCharAt(0) &#125; return sb.toString()&#125; 不能申请额外空间，只能在本串上操作 我觉得用carl的方法更好 反转区间为前n的子串 反转区间为n到末尾的子串 反转整个字符串 https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC 28. 实现 strStr()暴力解法aabaabaaf aabaaf 整体移动底下的字串，然后匹配 1234567891011121314151617fun strStr(haystack: String, needle: String): Int &#123; var needleIndex = 0 for (i in haystack.indices) &#123; var hayIndex = i while (needleIndex &lt; needle.length) &#123; if (haystack.getOrNull(hayIndex) == needle[needleIndex]) &#123; if (needleIndex == needle.length - 1) return i hayIndex++ needleIndex++ &#125; else &#123; needleIndex = 0 break &#125; &#125; &#125; return -1&#125; 这个暴力解法，也有更好的写法 kmphttps://noteforme.github.io/2021/06/17/kmp/ 12345678910111213141516171819202122232425262728293031323334fun strStrKmp(haystack: String, needle: String): Int &#123; var j = 0 var nextArray = initNext(needle) // 初始化next数组 for (i in haystack.indices) &#123; // 文本串指针i 移动 while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123; j = nextArray[j - 1] // 模式串 指针 根据next数组的下标回退 &#125; if (haystack[i] == needle[j]) &#123; // 文本串 模式串对应的字符相等 j++ &#125; if (j == needle.length) &#123; return i - j + 1 &#125; &#125; return -1&#125;/** * 模式串 * i指向后缀末尾位置 * j 指向前缀末尾位置， 也代表 i和i之前的 最长公共前后缀的长度 */fun initNext(needle: String): IntArray &#123; var nextArray = IntArray(needle.length) var j = 0 // j 前缀0开始初始化 for (i in 1 until needle.length) &#123; // i后缀末尾 ，从1开始初始化 while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123; j = nextArray[j - 1] // 前一个位置下标 回退 &#125; if (needle[i] == needle[j]) j++ // 找到新的相等字符， 在之前最长公共前后缀长度 +1 nextArray[i] = j // 更新next下标 &#125; return nextArray&#125; 459. 重复的子字符串这题根据随想录的 公式 套的 https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC next[len - 1] = 7，next[len - 1] + 1 = 8 这句话的意思是. 这里数组统一减1，所以需要加1 == 8 12345678910111213141516171819202122fun repeatedSubstringPattern(s: String): Boolean &#123; val nxtArrr = initNext(s) val len = s.length if (nxtArrr[len - 1] != 0 &amp;&amp; len % (len - nxtArrr[len - 1]) == 0) &#123; //这两句 是根据随想录的公式抄的 return true &#125; return false&#125;private fun initNext(s: String): IntArray &#123; var j = 0 val nxt = IntArray(s.length) nxt[0] = 0 for (i in 1 until s.length) &#123; while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123; j = nxt[j - 1] &#125; if (s[i] == s[j]) j++ nxt[i] = j &#125; return nxt&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"location","slug":"location","date":"2022-05-24T06:48:58.000Z","updated":"2025-01-01T06:32:08.888Z","comments":true,"path":"2022/05/24/location/","link":"","permalink":"https://noteforme.github.io/2022/05/24/location/","excerpt":"","text":"Location Permission changesBackground locationThe background location precision is the same as the foreground location precision, which depends on the location permissions that your app declares. user closes the app or uses the home button to return to their main screen. On Android 10 (API level 29) and higher, you must declare the ACCESS_BACKGROUND_LOCATION permission in your app’s manifest in order to request background location access at runtime. On earlier versions of Android, when your app receives foreground location access, it automatically receives background location access as well. 12345&lt;manifest ... &gt; &lt;!-- Required only when requesting background location access on Android 10 (API level 29) and higher. --&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&lt;/manifest&gt; https://support.google.com/googleplay/android-developer/answer/9799150#zippy= foregroundwhile an app is open and visible to the user. https://www.youtube.com/watch?v=xTVeFJZQ28c https://github.com/baurine/android-location-study/blob/master/note/location-note.md https://blog.csdn.net/dxiaolai/article/details/81588921 https://blog.csdn.net/qq_32770809/article/details/115914021 https://blog.csdn.net/u013334392/article/details/91971758 其实在上面我已经提到了，所有上面的解决的方案都没有解决根本问题，那就是当你在室内开发时，你的手机根本就没法获取位置信息，你叫系统如何将位置信息通知给你的程序。所以要从根本上解决这个问题，就要解决位置信息获取问题。刚刚也提到了，只有NETWORK_PROVIDER这种模式才是室内定位可靠的方式，只不过由于大陆的怪怪网络，且大部分厂商也不会用google的服务，这种定位方式默认是没法用的。那怎么办？好办，找个替代的服务商就可以了，百度的位置信息sdk就可以解决这个问题。它的基本原理在上面已经提到过了，就是搜集你的wifi节点信息和你的手机基站信息来定位。 #detect installed app https://stackoverflow.com/questions/72123141/how-to-check-exists-app-in-device-on-android https://medium.com/@GoogleDroids/how-to-check-if-an-android-app-is-installed-on-your-device-f8f0f1d4fb6a 123456789101112131415161718fun isPackageInstalled(context: Context, packagename: String): Boolean &#123; var result = false try &#123; // is the application installed? context.packageManager.getPackageInfo(packagename, PackageManager.GET_ACTIVITIES) result = true &#125; catch (e: PackageManager.NameNotFoundException) &#123; //Not installed &#125; return result&#125; val checkInstallation = isPackageInstalled(this, &quot;com.google.android.apps.maps&quot;) Log.i(TAG, &quot;googleMap: $checkInstallation&quot;) Log.i(TAG, &quot;gaodemap: $&#123;isPackageInstalled(this, &quot;com.autonavi.minimap&quot;)&#125;&quot;) Log.i(TAG, &quot;baidumap: $&#123;isPackageInstalled(this, &quot;com.baidu.BaiduMap&quot;)&#125;&quot;) Log.i(TAG, &quot;waze: $&#123;isPackageInstalled(this, &quot;com.waze&quot;)&#125;&quot;) Androidmanifest.xml 12345678910 &lt;queries&gt; &lt;package android:name=&quot;com.google.android.apps.maps&quot; /&gt; &lt;package android:name=&quot;com.google.android.youtube&quot; /&gt;&lt;!-- &lt;package android:name=&quot;com.autonavi.minimap&quot; /&gt; &lt;package android:name=&quot;com.baidu.BaiduMap&quot; /&gt; --&gt; &lt;package android:name=&quot;com.waze&quot; /&gt; &lt;/queries&gt; it also can be used , but it seems not recommend in office 12345678&lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; tools:ignore=&quot;QueryAllPackagesPermission&quot; /&gt;&lt;queries&gt; &lt;intent&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;/intent&gt;&lt;/queries&gt; huawei OS install others map , except google mapresult: googleMap: falsegaodemap: falsebaidumap: falsewaze: true if remove Androidmanifest comment googleMap: falsegaodemap: truebaidumap: truewaze: true AccuracyApproximateProvides a device location estimate. If this location estimate is from the LocationManagerService or FusedLocationProvider, this estimate is accurate to within about 3 square kilometers (about 1.2 square miles). Your app can receive locations at this level of accuracy when you declare the ACCESS_COARSE_LOCATION permission but not the ACCESS_FINE_LOCATION permission. PreciseProvides a device location estimate that is as accurate as possible. If the location estimate is from LocationManagerService or FusedLocationProvider, this estimate is usually within about 50 meters (160 feet) and is sometimes as accurate as within a few meters (10 feet) or better. Your app can receive locations at this level of accuracy when you declare the ACCESS_FINE_LOCATION permission. Google play Policyhttps://support.google.com/googleplay/android-developer/answer/10144311#zippy=%2Cexamples-of-common-violations An app that accesses a user’s inventory of installed apps and doesn’t treat this data as personal or sensitive data subject to the above Privacy Policy, data handling, and Prominent Disclosure and Consent requirements. Android 11 introduced changes related to package visibility. These changes affect applications, only if they target Android 11 and above. For more information on these changes, please view the official documentation about package visibility on Android. https://developer.android.com/training/package-visibility https://developer.android.com/about/versions/11/privacy/package-visibility But be aware that Play Store has new policy and common apps with this perm declared won’t be pulished in there. You have to provide good reason for accepting your app - this permission must be used for starting user-initiated key feature of app https://stackoverflow.com/questions/72123141/how-to-check-exists-app-in-device-on-android lanuch Google MapMaps URLs (recommended)Using Maps URLs, you can build a universal, cross-platform URL to launch Google Maps and perform searches, get directions and navigation, and display map views and panoramic images. These universal URLs allow for broader handling of the maps requests no matter which platform the user is on. Google Maps Intents for AndroidUsing intents in your Android app, you can start an activity in another app by describing a simple action you’d like to perform (such as “display a map” or “show directions to the airport”) in an Intent object. The Google Maps app for Android supports several different intents, allowing you to launch the Google Maps app in display, search, navigation, or Street View modes. https://developers.google.com/maps/documentation/android-sdk/intents","categories":[],"tags":[]},{"title":"LC-hash","slug":"LC-hash","date":"2022-05-21T13:53:24.000Z","updated":"2023-01-02T03:31:39.088Z","comments":true,"path":"2022/05/21/LC-hash/","link":"","permalink":"https://noteforme.github.io/2022/05/21/LC-hash/","excerpt":"","text":"242. 有效的字母异位词1234567891011121314151617fun isAnagram(s: String, t: String): Boolean &#123; val record = IntArray(26) // 存整数，就用整形数 s.toCharArray().forEachIndexed &#123; _, char -&gt; record[char - &#x27;a&#x27;]++ &#125; t.toCharArray().forEachIndexed &#123; _, char -&gt; record[char - &#x27;a&#x27;]-- &#125; record.forEach &#123; if (it != 0) &#123; return false &#125; &#125; return true&#125; 383. 赎金信https://blog.csdn.net/c15158032319/article/details/78209740 12345678910111213141516fun canConstruct(ransomNote: String, magazine: String): Boolean &#123; val record = IntArray(26) magazine.toCharArray().forEach &#123; char -&gt; record[char - &#x27;a&#x27;] += 1 // 这里可以优化下 &#125; ransomNote.toCharArray().forEach &#123; char -&gt; record[char - &#x27;a&#x27;] -= 1 //同上 &#125; record.forEach &#123; if (it &lt; 0) &#123; //就这里和242.有效的字母异位词 不一样，数量不够就&lt;0 return false &#125; &#125; return true&#125; //若 a = i++; 则等价于 a=i;i=i+1;//而 a = ++i; 则等价于 i=i+1;a=i;//a += 1 和 a = a + 1 12345678910111213141516fun canConstruct(ransomNote: String, magazine: String): Boolean &#123; val record = IntArray(26) magazine.toCharArray().forEach &#123; char -&gt; record[char - &#x27;a&#x27;] ++ &#125; ransomNote.toCharArray().forEach &#123; char -&gt; record[char - &#x27;a&#x27;] -- &#125; record.forEach &#123; if (it &lt; 0) &#123; //就这里和242.有效的字母异位词 不一样，数量不够就&lt;0 return false &#125; &#125; return true&#125; 49. 字母异位词分组用的官方题解 https://leetcode.cn/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/ 题解一1234567891011121314fun groupAnagrams(strs: Array&lt;String&gt;): List&lt;List&lt;String&gt;&gt; &#123; val ansMap = HashMap&lt;String, ArrayList&lt;String&gt;&gt;() // 相同异位词的key, 和所有异位词的数组 strs.forEach &#123; str -&gt; val char = str.toCharArray() // String to char 进行排序，结果相同异位词key一致 Arrays.sort(char) val key = String(char) if (!ansMap.containsKey(key)) &#123; // map不存在，就创建新的ArrayList() ansMap[key] = ArrayList() &#125; ansMap[key]?.add(str) //拿到ArrayList(),添加元素 &#125; return ArrayList(ansMap.values)&#125; 题解二官方题解2 和题解一差不多，题解一进行排序的相同key,题解二用的散列计数，中间用#间隔作为 key. 其他的都类似，后面再写吧 。 复杂度分析 时间复杂度：O(nk \\log k)O(nklogk)，其中 nn 是 \\textit{strs}strs 中的字符串的数量，kk 是 \\textit{strs}strs 中的字符串的的最大长度。需要遍历 nn 个字符串，对于每个字符串，需要 O(k \\log k)O(klogk) 的时间进行排序以及 O(1)O(1) 的时间更新哈希表，因此总时间复杂度是 O(nk \\log k)O(nklogk)。 空间复杂度：O(nk)O(nk)，其中 nn 是 \\textit{strs}strs 中的字符串的数量，kk 是 \\textit{strs}strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。 438. 找到字符串中所有字母异位词https://leetcode.cn/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/ 解法一123456789101112131415161718192021222324252627282930fun findAnagrams(s: String, p: String): List&lt;Int&gt; &#123; val sLength = s.length val pLength = p.length if (sLength &lt; pLength) &#123; // 如果字符s的长度 小于p 直接返回 return emptyList() &#125; val ansList = arrayListOf&lt;Int&gt;() val sCount = IntArray(26) val pCount = IntArray(26) val sCharArray = s.toCharArray() val pCharArray = p.toCharArray() for (i in 0 until pLength) &#123; //初始情况， p s字符相同，看是否相等. sCount[sCharArray[i] - &#x27;a&#x27;]++ // 对于位置字符个数 pCount[pCharArray[i] - &#x27;a&#x27;]++ &#125; if (sCount.contentEquals(pCount)) &#123; //比较初始数量 ansList.add(0) &#125; for (i in 0 until (sLength - pLength)) &#123; // 从0开始，s的字符 左边-1 右边+1 字符，调整相应位置字符数量， sCount[sCharArray[i] - &#x27;a&#x27;]-- sCount[sCharArray[i + pLength] - &#x27;a&#x27;]++ if (sCount.contentEquals(pCount)) &#123; ansList.add(i + 1) //如果 i==0, 那么0位置字符去掉， p.length + 0 字符+1, 新的字符开始位置就是1了 &#125; &#125; return ansList&#125; 解法二diff方式，感觉没太明白 , 而且感觉作用不大,后面可以试试 解法三这个滑动窗口，解法很高级，但是没明白 12345678910111213141516171819202122232425262728public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; int[] cnt = new int[128]; for (char c : p.toCharArray()) cnt[c]++; int lo = 0, hi = 0; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 该循环确保[lo, hi)的区间中的出现的字符总是p的一个子集 // PS1: &quot;na&quot;是&quot;and&quot;的子集，而&quot;nn&quot;则不是&quot;and&quot;的子集 // PS2: 除了评论中那个边际条件，前面已经有评论解释过了 while (hi &lt; s.length()) &#123; char c = s.charAt(hi); if (cnt[c] &gt; 0) &#123; // 子集条件满足，右移增大窗口 char c1 = s.charAt(hi++); cnt[c1]--; // 窗口长度 == p.len，且窗口内字符是p的子集 // &lt;=&gt; (充要条件) s.substring(lo, hi)是p的同字母异序词 if (hi - lo == p.length())&#123; res.add(lo); &#125; &#125; else &#123; // 再右移hi不可能满足子集条件， // 右移左边界lo、复位计数器，直到这个条件（子集条件）再次满足 char c1 = s.charAt(lo++); cnt[c1]++; &#125; &#125; return res;&#125; 349. 两个数组的交集计算两个数组的交集，直观的方法是遍历数组 nums1，对于其中的每个元素，遍历数组 nums2 判断该元素是否在数组 nums2 中，如果存在，则将该元素添加到返回值。假设数组 nums1 和 nums2 的长度分别是 mm 和 nn，则遍历数组 nums1 需要 O(m)O(m) 的时间，判断 nums1 中的每个元素是否在数组 nums2 中需要 O(n)O(n) 的时间，因此总时间复杂度是 O(mn)O(mn)。 如果使用哈希集合存储元素，则可以在 O(1)的时间内判断一个元素是否在集合中，从而降低时间复杂度。 if (set.contains(it))这句是o(1)? 首先使用两个集合分别存储两个数组中的元素，然后遍历较小的集合，判断其中的每个元素是否在另一个集合中，如果元素也在另一个集合中，则将该元素添加到返回值。该方法的时间复杂度可以降低到 O(m+n) 1234567891011val set = hashSetOf&lt;Int&gt;()nums1.forEach &#123; set.add(it)&#125;val anSet = hashSetOf&lt;Int&gt;()nums2.forEach &#123; if (set.contains(it)) &#123; // hashmap是怎么hash表是怎么存储的，为什么这样时间复杂度低, 因为在hash表中存储 anSet.add(it) &#125;&#125;return anSet.toIntArray() https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#_349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86 https://leetcode.cn/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/ 350. 两个数组的交集 II解法一自己的思路 12345678910111213141516171819202122232425262728fun intersect(nums1: IntArray, nums2: IntArray): IntArray &#123; val ansArray = arrayListOf&lt;Int&gt;() val map1 = hashMapOf&lt;Int, Int&gt;() nums1.forEach &#123; map1[it] = (map1[it] ?: 0).plus(1) // key是 nums1 数组的值，value是个数 &#125; val map2 = hashMapOf&lt;Int, Int&gt;() nums2.forEach &#123; map2[it] = (map2[it] ?: 0).plus(1) //key是 nums2 数组的值，value是个数 &#125; val map3 = hashMapOf&lt;Int, Int&gt;() val keySet2 = map2.keys map1.entries.forEach &#123; entry -&gt; if (keySet2.contains(entry.key)) &#123; if (entry.value &lt; map2[entry.key]!!) &#123; // 存在相同的值，比较数组的个数 map3[entry.key] = entry.value &#125; else &#123; map3[entry.key] = map2[entry.key]!! //较小的放给新的map &#125; &#125; &#125; map3.entries.forEach &#123; entry -&gt; for (i in 0 until entry.value) &#123; // entry.value是map的个数，然后添加的list ansArray.add(entry.key) &#125; &#125; return ansArray.toIntArray()&#125; 解法二12345678910111213141516fun intersect1(nums1: IntArray, nums2: IntArray): IntArray &#123; val ansArray = arrayListOf&lt;Int&gt;() val map = hashMapOf&lt;Int, Int&gt;() nums1.forEach &#123; map[it] = (map[it] ?: 0).plus(1) // key是 nums1 数组的值，value是个数 &#125; nums2.forEach &#123; if ((map[it] ?: 0) &gt; 0) &#123; // 判断是否存在相同的元素 ansArray.add(it) // 添加 map[it] = map[it]!!.minus(1) // 原来的元素-1 &#125; else &#123; map.remove(it) &#125; &#125; return ansArray.toIntArray()&#125; 解法三12345678910111213141516171819fun intersect3(nums1: IntArray, nums2: IntArray): IntArray &#123; Arrays.sort(nums1) Arrays.sort(nums2) val ansArray = arrayListOf&lt;Int&gt;() var index1 = 0 var index2 = 0 // 排序后，设置两个指针，指向数组头节点 while (index1 &lt; nums1.size &amp;&amp; index2 &lt; nums2.size) if (nums1[index1] &gt; nums2[index2]) &#123; // 谁小，谁走 index2++ &#125; else if (nums1[index1] &lt; nums2[index2]) &#123; index1++ &#125; else &#123; //相等的情况，就添加到结果数组中 ansArray.add(nums1[index1]) index2++ index1++ &#125; return ansArray.toIntArray()&#125; 还有进阶题目 https://leetcode.cn/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/ 202. 快乐数可以看作一个链表， 不是快乐数会形成环, 否则就是快乐数了 最终会得到 11。 最终会进入循环。 值会越来越大，最后接近无穷大。 根据题解猜测，第3种情况不会发生 https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/ Hash表解法1234567891011121314151617181920212223fun isHappy(n: Int): Boolean &#123; val set = hashSetOf&lt;Int&gt;() var value = n while (!set.contains(value)) &#123; // 没有环，就继续下一个 if (value == 1) &#123; return true &#125; set.add(value) // 把中间数加入hash表，为了判断是否有环的情况 value = nextSquareSum(value) &#125; return false&#125;private fun nextSquareSum(n: Int): Int &#123; var sum = 0 var num = n while (num &gt; 0) &#123; val balance = num % 10 //每次都获取余数 sum += balance * balance num = (num / 10) // 拿到上一位，然后求余 &#125; return sum&#125; 双指针解法123456789101112131415fun isHappy2(n: Int): Boolean &#123; var slow = n var fast = n do &#123; slow = nextSquareSum(slow) //每个数据可以看作一个node, 然后设置快慢节点 fast = nextSquareSum(fast) fast = nextSquareSum(fast) if (slow == 1 || fast == 1) &#123; return true &#125; &#125; while (slow != fast) return false&#125; 1. 两数之和暴力解法当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过(这个一句一开始不理解，其实如果i = 6, j = 5+1(1+1 , 2+1.. 4+1) 之前的都没匹配上，所以说x之前的都没匹配)，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。 1234567891011121314 public int[] twoSum(int[] nums, int target) &#123; int n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return new int[0]; &#125;链接：https://leetcode.cn/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ Hash法2, 7, 11, 15 12345678910fun twoSum(nums: IntArray, target: Int): IntArray &#123; val map = hashMapOf&lt;Int, Int&gt;() nums.forEachIndexed &#123; index, value -&gt; if (map.containsKey(target - nums[index])) &#123; //假如index = 0加入map,当index==2时, 9 - 7 = 2 就可以在map中找到，就匹配上了 return intArrayOf(index, map[target - nums[index]]!!) //相当于另一个数先加入map，找对应的数 &#125; map[value] = index &#125; throw RuntimeException(&quot;do not have the array&quot;)&#125; 454. 四数相加 II这题不是很明白 123456789101112131415161718fun fourSumCount(nums1: IntArray, nums2: IntArray, nums3: IntArray, nums4: IntArray): Int &#123; val map = hashMapOf&lt;Int, Int&gt;() nums1.forEach &#123; n1 -&gt; nums2.forEach &#123; n2 -&gt; map[n1 + n2] = map.getOrDefault(n1 + n2, 0) + 1 &#125; &#125; var ans = 0 nums3.forEach &#123; n3 -&gt; nums4.forEach &#123; n4 -&gt; if (map.containsKey(-n3 - n4)) &#123; // 6, 12 , -7 , -11 4个数2 2相加 不管怎么组合，结果都一样 ans += map[-n3 - n4] ?: 0 // 根据当前的key,区前面num1 num2找个数 &#125; &#125; &#125; return ans&#125; 15. 三数之和i 位置为target = nuts[-i] , 剩下的left right就是 twosum的问题 解法11234567891011121314151617181920212223 fun threeSum(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; Arrays.sort(nums) val hashSetOf &#x3D; hashSetOf&lt;List&lt;Int&gt;&gt;() nums.forEachIndexed &#123; i, value -&gt; val target &#x3D; -nums[i] var left &#x3D; i + 1 var right &#x3D; nums.size - 1 while (left &lt; right) &#123; if (nums[left] + nums[right] &lt; target) &#123; left++ &#125; else if (nums[left] + nums[right] &gt; target) &#123; right-- &#125; else &#123; val list &#x3D; arrayListOf(nums[i], nums[left], nums[right]) hashSetOf.add(list) right-- &#x2F;&#x2F; 为了防止重复元素，所以这两个也需要移动 left++ &#125; &#125; &#125;&#x2F;&#x2F; return hashSetOf.toList() return ArrayList(hashSetOf) &#x2F;&#x2F; 这里时间复杂度是 o(n),第2种解法是对这里进行优化 &#125; 解法2优化后的第二种解法，竟然超出时间限制，刷第2遍再看看 12345678910111213141516171819202122232425262728&#x2F;&#x2F;超出时间限制fun threeSum2(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; Arrays.sort(nums) val ans &#x3D; ArrayList&lt;List&lt;Int&gt;&gt;() for (i in nums.indices) &#123; if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123; &#x2F;&#x2F; 相同的target元素直接pass continue &#125; val target &#x3D; -nums[i] var left &#x3D; i + 1 var right &#x3D; nums.size - 1 while (left &lt; right) &#123; if (nums[left] + nums[right] &lt; target) &#123; left++ &#125; else if (nums[left] + nums[right] &gt; target) &#123; right-- &#125; else &#123; val list &#x3D; arrayListOf(nums[i], nums[left], nums[right]) ans.add(list) right-- &#x2F;&#x2F; 为了防止重复元素，所以这两个也需要移动 left++ while (left &lt; right &amp;&amp; nums[left] &#x3D;&#x3D; nums[left - 1]) continue &#x2F;&#x2F; 这两句放在while循环外面 退出不了,拿到结果后， 相同的元素pass while (left &lt; right &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) continue &#125; &#125; &#125; return ans&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"fastjson","slug":"fastjson","date":"2022-05-13T08:13:34.000Z","updated":"2024-01-22T14:24:14.422Z","comments":true,"path":"2022/05/13/fastjson/","link":"","permalink":"https://noteforme.github.io/2022/05/13/fastjson/","excerpt":"","text":"https://zonghaishang.gitbooks.io/fastjson-source-code-analysis/content/ FastJson为什么快https://tobebetterjavaer.com/gongju/fastjson.html#_05%E3%80%81%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB 为什么要进行序列化 每个实体bean都必须实现serializabel接口吗 实现序列化的两个原因：1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；2、按值将对象从一个应用程序域发送至另一个应用程序域。实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复，所以你想如果你的对象没实现序列化怎么才能进行持久化和网络传输呢，要持久化和网络传输就得转为字节流，所以在分布式应用中及设计数据持久化的场景中，你就得实现序列化。 第二个问题，是不是每个实体bean都要实现序列化，答案其实还要回归到第一个问题，那就是你的bean是否需要持久化存储媒体中以及是否需要传输给另一个应用，没有的话就不需要，例如我们利用fastjson将实体类转化成json字符串时，并不涉及到转化为字节流，所以其实跟序列化没有关系。 Fastjson 示例没有 实现serializabel 1234567891011121314public class AutoTypeTest0 extends TestCase &#123; public void test_0() throws Exception &#123; String text = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.alibaba.json.bvt.parser.autoType.AutoTypeTest0$Model\\&quot;,\\&quot;id\\&quot;:123&#125;&quot;; Model model = JSON.parseObject(text, Model.class); assertEquals(123, model.id); Model model2 = (Model) JSON.parse(text); assertEquals(123, model2.id); &#125; public static class Model &#123; public int id; &#125;&#125; 针对第2个问题，那么json字符串最终网络传输有没有转化成 字节流，是怎么转的呢？,还是在网络协议中转的。 https://blog.csdn.net/weixin_44203158/article/details/88382770 原理FastJson的序列化过程，就是把一个内存中的Java Bean转换成JSON字符串，得到字符串之后就可以通过数据库等方式进行持久化了。 那么，FastJson是如何把一个Java Bean转换成字符串的，一个Java Bean中有很多属性和方法，哪些属性要保留，哪些要剔除，到底遵循什么样的原则呢？ 其实，对于JSON框架来说，想要把一个Java对象转换成字符串，可以有两种选择： 基于成员变量 基于setter/getter方法 常用的JSON序列化框架中，FastJson和jackson在把对象序列化成json字符串的时候，是通过遍历出该类中的所有getter方法进行的。Gson是通过反射遍历该类中的所有属性，并把其值序列化成json。 https://codeantenna.com/a/vGtiZACEWS https://codeantenna.com/a/JCFJvwdTsd 源码分析https://blog.csdn.net/shangzonghai/article/details/79187455 https://github.com/zonghaishang/fastjson 注释版本 Android版本 https://github.com/alibaba/fastjson/wiki/Android%E7%89%88%E6%9C%AC Fastjson修bug 讲解怎么打印ASM字节数据 https://www.bilibili.com/video/BV1JJ41197UK?spm_id_from=333.337.search-card.all.click ​ Fastjson 为什么用 IdentityHashMap 序列化流程通过asm 获取对象上的属性的get方法集合，然后通过调用相应的方法拼装出json字符串。 123456789101112131415161718public final void write(Object object) &#123; if (object == null) &#123; /** 如果对象为空，直接输出 &quot;null&quot; 字符串 */ out.writeNull(); return; &#125; Class&lt;?&gt; clazz = object.getClass(); /** 根据对象的Class类型查找具体序列化实例 */ ObjectSerializer writer = getObjectWriter(clazz); try &#123; /** 使用具体serializer实例处理对象 */ writer.write(this, object, null, null, 0); &#125; catch (IOException e) &#123; throw new JSONException(e.getMessage(), e); &#125;&#125; 123456789101112private ObjectSerializer getObjectWriter(Class&lt;?&gt; clazz, boolean create) &#123; if (create) &#123; /** 没有精确匹配，使用通用JavaBeanSerializer 序列化(假设不启用asm) */ writer = createJavaBeanSerializer(clazz); put(clazz, writer); &#125; if (writer == null) &#123; /** 尝试在已注册缓存找到特定class的序列化实例 */ writer = serializers.get(clazz); &#125;&#125; User ASM 在这里生成 12345678910public JavaBeanSerializer createJavaBeanSerializer(SerializeBeanInfo beanInfo) throws Exception &#123; byte[] code = cw.toByteArray(); // 这里就是动态生成的字节码文件 Class&lt;?&gt; serializerClass = classLoader.defineClassPublic(classNameFull, code, 0, code.length); Constructor&lt;?&gt; constructor = serializerClass.getConstructor(SerializeBeanInfo.class); Object instance = constructor.newInstance(beanInfo); return (JavaBeanSerializer) instance;&#125; 这是生成的ASM类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class ASMSerializer_1_User extends JavaBeanSerializer implements ObjectSerializer &#123; public Type id_asm_fieldType = ASMUtils.getMethodType(User.class, &quot;getId&quot;); public ObjectSerializer id_asm_ser_; public ASMSerializer_1_User(SerializeBeanInfo var1) &#123; super(var1); &#125; public void write(JSONSerializer var1, Object var2, Object var3, Type var4, int var5) throws IOException &#123; if (var2 == null) &#123; var1.writeNull(); &#125; else &#123; SerializeWriter var9 = var1.out; if (!this.writeDirect(var1)) &#123; this.writeNormal(var1, var2, var3, var4, var5); &#125; else if (var9.isEnabled(32768)) &#123; this.writeDirectNonContext(var1, var2, var3, var4, var5); &#125; else &#123; User var10 = (User)var2; if (!this.writeReference(var1, var2, var5)) &#123; if (var9.isEnabled(2097152)) &#123; this.writeAsArray(var1, var2, var3, var4, var5); &#125; else &#123; SerialContext var11 = var1.getContext(); var1.setContext(var11, var2, var3, 0); char var12 = &#x27;&#123;&#x27;; String var6 = &quot;id&quot;; Long var13 = var10.getId(); if (var13 == null) &#123; if (var9.isEnabled(260)) &#123; var9.write(var12); var9.writeFieldNameDirect(var6); var9.writeNull(0, 256); var12 = &#x27;,&#x27;; &#125; &#125; else &#123; var9.write(var12); var9.writeFieldNameDirect(var6); var1.writeWithFieldName(var13, var6, this.id_asm_fieldType, 0); var12 = &#x27;,&#x27;; &#125; var6 = &quot;name&quot;; String var14 = var10.getName(); if (var14 == null) &#123; if (var9.isEnabled(132)) &#123; var9.write(var12); var9.writeFieldNameDirect(var6); var9.writeNull(0, 128); var12 = &#x27;,&#x27;; &#125; &#125; else &#123; var9.writeFieldValueStringWithDoubleQuoteCheck(var12, var6, var14); var12 = &#x27;,&#x27;; &#125; if (var12 == &#x27;&#123;&#x27;) &#123; var9.write(123); &#125; var9.write(125); var1.setContext(var11); &#125; &#125; &#125; &#125; &#125;&#125; https://www.jianshu.com/p/824f8f4df15d 反序列化 通过asm 获取对象上的属性的set方法集合，然后调用set方法集合，赋值到相应的属性。 1Files.write(code,new File(&quot;ASMDeserializer.class&quot;)) Token定义Token是Fastjson中定义的json字符串的同类型字段，即”{“、”[“、数字、字符串等，用于分隔json字符串不同字段。 例如，{“姓名”：“张三”,“年龄”:“20”}是一个json字符串，在反序列化之前，需要先将其解析为 &#123; 、 姓名、 ：、 张三、 ,、 年龄、 ：、 20、 &#125;这些字段的Token流，随后再根据class反序列化为响应的对象。 在进行Token解析之前，json字符串对程序而言只是一个无意义的字符串。需要将json字符串解析为一个个的Token，并以Token为单位解读json数据。 在package com.alibaba.fastjson.parser包中，给出了所有Token的定义。 稍后继续分析 https://blog.csdn.net/qq_45854465/article/details/120626835 https://blog.csdn.net/lllhhhyyy999/article/details/120896574 https://blog.csdn.net/shangzonghai/article/details/79187455","categories":[],"tags":[]},{"title":"JVM-VALUE-DELIVER","slug":"JVM-VALUE-DELIVER","date":"2022-05-05T04:46:27.000Z","updated":"2022-06-12T03:17:58.660Z","comments":true,"path":"2022/05/05/JVM-VALUE-DELIVER/","link":"","permalink":"https://noteforme.github.io/2022/05/05/JVM-VALUE-DELIVER/","excerpt":"","text":"再做leetcode时也遇到了，java时引用传递还是值传递的问题，这方面 指针就很清楚, https://segmentfault.com/a/1190000016773324 这里讲解很清楚 1. 基本数据类型的存储： A. 基本数据类型的局部变量 B. 基本数据类型的成员变量 C. 基本数据类型的静态变量 2. 引用数据类型的存储 A.基本数据类型的局部变量 定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的“虚拟机栈”，数据本身的值就是存储在栈空间里面。 123456789101112131415161718public class JavaValue &#123; //测试 public static void main(String[] args) &#123; Person p = new Person(); p.setName(&quot;我是马化腾&quot;); p.setAge(45); PersonCrossTest(p); System.out.println(&quot;方法执行后的name：&quot; + p.getName()); &#125; public static void PersonCrossTest(Person person) &#123; System.out.println(&quot;Before new Person 传入的person的name：&quot; + person.getName()); person = new Person(); System.out.println(&quot;After new Person 传入的person的name：&quot; + person.getName()); person.setName(&quot;我是张小龙&quot;); System.out.println(&quot;方法内重新赋值后的name：&quot; + person.getName()); &#125;&#125; person = new Person();一旦执行这一步操作后，把之前的指向就去掉了","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"LC-LinkedList","slug":"LC-LinkedList","date":"2022-05-04T05:40:18.000Z","updated":"2023-01-02T03:31:39.079Z","comments":true,"path":"2022/05/04/LC-LinkedList/","link":"","permalink":"https://noteforme.github.io/2022/05/04/LC-LinkedList/","excerpt":"","text":"https://leetcode.cn/circle/discuss/jq9Zke/ 203. 移除链表元素迭代法12345678910111213fun removeElements(head: ListNode?, target: Int): ListNode? &#123; val dummyHead = ListNode() dummyHead.next = head var p: ListNode? = dummyHead while (p?.next != null) &#123; // 从真正的头节点 开始判断，因为实际没移动，所以没问题 if (p.next?.`val` == target) &#123; p.next = p.next?.next &#125; else &#123; p = p.next // 放最外面会跳过连续为target的Node [7,7,7,7] 7 &#125; &#125; return dummyHead.next&#125; 递归法https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/ 707. 设计链表some notice 注意这里不是dummyHead.next // 注意： 之前这个放在上边的if里面 注意这里之前是 index &gt;= size 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class MyLinkedList() &#123; private val dummyHead = ListNode() var size = 0 //length fun get(index: Int): Int &#123; if (index &lt; -1 || index &gt; size - 1) return -1 // 3.注意这里之前是 index &gt;= size var pIndex = index var curr = dummyHead.next while (pIndex-- &gt; 0) &#123; curr = curr?.next &#125; return curr?.`val` ?: -1 &#125; fun addAtHead(`val`: Int) &#123; val newNode = ListNode(`val`) // 新的节点 val headNode = dummyHead.next // 之前的头节点 dummyHead.next = newNode // 虚拟头节点 指向新的头节点 if (headNode != null) &#123; newNode.next = headNode // 新的头节点指向 之前的头节点 &#125; size++ // 注意： 之前这个放在上边的if里面 &#125; fun addAtTail(`val`: Int) &#123; val newNode = ListNode(`val`) // 新的节点 var p: ListNode? = dummyHead // 1.注意这里不是dummyHead.next while (p != null) &#123; if (p.next == null) &#123; p.next = newNode size++ break // 必须停止，否则一直在尾部添加 新的节点 &#125; p = p.next &#125; &#125; fun addAtIndex(index: Int, `val`: Int) &#123; if (index &gt; size) return //2. 注意这里之前是 index &gt;= size val newNode = ListNode(`val`) // 新的节点 var pIndex = index var curr = dummyHead // 1.注意这里不是dummyHead.next while (pIndex-- &gt; 0) &#123; curr = curr.next!! &#125; val temp = curr.next curr.next = newNode newNode.next = temp size++ &#125; fun deleteAtIndex(index: Int) &#123; if (index &gt;= size || index &lt; 0) &#123; return &#125; var pIndex = index var curr: ListNode? = dummyHead //1. 注意这里之前是 index &gt;= size while (pIndex-- &gt; 0) &#123; curr = curr?.next &#125; if (curr?.next != null) &#123; curr.next = curr.next?.next &#125; size-- // 注意： 之前这个放在上边的if里面 &#125;&#125; 206. 反转链表双指针1234567891011121314fun reverseList(head: ListNode?): ListNode? &#123; var pre = head var curr: ListNode? = null while (pre != null) &#123; val termPre = pre.next pre.next = curr curr = pre if (termPre == null) &#123; // 到了最后一个note下一个note,不能赋值了，否则pre就是null作为头节点了 return pre &#125; pre = termPre &#125; return pre // 最后一个node,指向前面的node&#125; after watching the https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/ return curr point is better 12345678910111213141516171819202122/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; * var next: ListNode? = null * &#125; */class Solution &#123; fun reverseList(head: ListNode?): ListNode? &#123; var pre = head var curr: ListNode? = null while (pre != null) &#123; val termPre = pre.next pre.next = curr curr = pre pre = termPre &#125; return curr // 最后一个node not null,指向前面 &#125;&#125; 递归写法24. 两两交换链表中的节点迭代法1234567891011121314fun swapPairs(head: ListNode?): ListNode? &#123; val dumpNode = ListNode() dumpNode.next = head var temp = dumpNode while (temp.next?.next != null) &#123; val n1 = temp.next val n2 = n1?.next n1?.next = n2?.next temp.next = n2 n2?.next = n1 temp = n1!! &#125; return dumpNode.next&#125; accoding the idea https://leetcode.cn/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/ the subject most inportant is temp = n1 , I didn’t know how to do the next cycle before like author said 如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换. is also important 19. 删除链表的倒数第 N 个结点双指针 fast Node go n steps firstly, then fast slow Node go , at last slow point at the delete Node that last Node (慢指针 指向待删除指针的上一个指针) 123456789101112131415161718192021fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? &#123; val dumpNode = ListNode() dumpNode.next = head var fp = dumpNode var sp = dumpNode var lastIndex = n while (lastIndex-- &gt; 0) &#123; if (fp.next != null) &#123; fp = fp.next!! &#125; &#125; while (dumpNode.next != null) &#123; if (fp.next == null) &#123; // 必须终止，否则会是死循环 break &#125; fp = fp.next!! sp = sp.next!! &#125; sp.next = sp.next?.next return dumpNode.next&#125; 栈 https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/ 160. 相交链表 走对方的路，两条链表相加 路程相等 相互第2个连接的链表走完后，下个节点都是null 循环就结束了 123456789101112131415161718192021fun getIntersectionNode(headA: ListNode?, headB: ListNode?): ListNode? &#123; var pA = headA var pB = headB if (pA == null || pB == null) &#123; return null &#125; while (pA != pB) &#123; // 相互第2个连接的链表走完后，下个节点都是null 循环就结束了 pA = if (pA == null) &#123; headB &#125; else &#123; pA.next &#125; pB = if (pB == null) &#123; headA &#125; else &#123; pB.next &#125; &#125; return pA&#125; https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/ https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/shuang-zhi-zhen-yyds-dai-ma-jian-ji-teng-0bch/ 142. 环形链表 IIhttps://leetcode.cn/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-jian-hua-gong-shi-jia-2/ 很生动的图 因为fast已经在环里, Slow只能走一圈，fast不能跳过，所以 slow的 步数 是 x+y 而不是 x + 若干环的长度 + y 根据公式推到结果 ,有环的话，先相遇，然后分别从head 相遇点 往相交点走. 下面这个答案就是拼出来的 解法一1234567891011121314151617181920 fun detectCycle(head: ListNode?): ListNode? &#123;// val dumpNode: ListNode? = ListNode() // 不设置的话，如果有指针next是null,赋值就有问题,这个不能有，必须从head出发的,因为fast point走两部 var fp = head var sp = head while (true) &#123; fp = fp?.next?.next sp = sp?.next if (fp == null) &#123; return null // 走到底了，no cycle, 需要放前面，否则都是null的话，下面的fp == sp条件就匹配了 &#125; else if (fp == sp) &#123; break &#125; &#125; var secondPoint = head while (sp?.next != null &amp;&amp; secondPoint != sp) &#123; // 看了随想录答案，这个可以放到上面的while循环里面,明天重写下 secondPoint = secondPoint?.next!! sp = sp.next &#125; return secondPoint &#125; 解法二下面写法，看了随想录的思路，第二天重写的。 可以在第一个循环的内部，head point 和相遇点开始走. 公式推导过程理解了就好了，然后记住结论。 123456789101112131415161718 fun detectCycle(head: ListNode?): ListNode? &#123;// val dumpNode: ListNode? = ListNode() // 1.不设置?的话，如果有指针next是null,赋值就有问题,2.dumpNode这个不能有，必须从head出发的,因为fast point走两部 var fp = head var sp = head while (fp != null &amp;&amp; sp != null) &#123; // 循环条件盘空就可以了，没有环就一定会走到null, 一直想到条件 fp != sp fp = fp.next?.next sp = sp.next if (fp!=null&amp;&amp;fp == sp) &#123; // fp!=null不加，没环的话，就null==null 了 var node1 = head while (sp?.next != null &amp;&amp; node1 != sp) &#123; node1 = node1?.next!! sp = sp.next &#125; return node1 &#125; &#125; return null &#125; 复杂度分析 时间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。在最初判断快慢指针是否相遇时，\\textit{slow}slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)O(N)+O(N)=O(N)。 空间复杂度：O(1)O(1)。我们只使用了 \\textit{slow}, \\textit{fast}, \\textit{ptr}slow,fast,ptr 三个指针。 作者：LeetCode-Solution链接：https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"LC-array","slug":"LC-array","date":"2022-05-02T05:07:27.000Z","updated":"2023-10-21T14:43:16.486Z","comments":true,"path":"2022/05/02/LC-array/","link":"","permalink":"https://noteforme.github.io/2022/05/02/LC-array/","excerpt":"","text":"Array结构数组为什么从0开始. 123int foo[5] = &#123;1,2,3,4,5&#125;;foo[0] *(foo + 0) // 因为c语言指针偏移量从0开始 12a[3][4]a[0][0], a[0][1] , a[0][2] , a[0][3] https://developer.51cto.com/article/649423.html LEETCODE 26https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 解法： 双指针 首先注意数组是有序的，那么重复的元素一定会相邻。 要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。 考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下： 比较 p 和 q 位置的元素是否相等。 如果相等，q 后移 1 位如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位重复上述过程，直到 q 等于数组长度。 返回 p + 1，即为新数组长度。 Nums[p] == nums[q] q 后移1位 Nums[p] != nums[q]. Nums[p+1] = nums[q]. p 后移1位， q后移1位 Nums[p] != nums[q] 。。。。 上图向下的箭头，只代表步骤，不代表指针位置 123456789101112131415161718192021222324252627282930//这个更好理解 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/fun removeDuplicates1(nums: IntArray): Int &#123; if (nums.isEmpty())&#123; return 0 &#125; var slowIndex = 0 for (fastIndex in 1 until nums.size) &#123; if (nums[fastIndex] != nums[slowIndex]) &#123; nums[slowIndex + 1] = nums[fastIndex] // 慢指针的后一个位置，放上 快指针不同的值 slowIndex++ &#125; &#125; return slowIndex+1&#125;//官方解法，不好理解fun removeDuplicates(nums: IntArray): Int &#123; if (nums.isEmpty())&#123; return 0 &#125; var slowIndex = 1 for (fastIndex in 1 until nums.size) &#123; if (nums[fastIndex] != nums[slowIndex - 1]) &#123; nums[slowIndex] = nums[fastIndex] slowIndex++; &#125; &#125; return slowIndex&#125; 283. 移动零123456789101112fun moveZeroes(nums: IntArray): Unit &#123; var slowIndex = 0 for (fastIndex in 1 until nums.size) &#123; if (nums[fastIndex] != 0 &amp;&amp; nums[slowIndex] == 0) &#123; //符合条件就交换位置，慢指针让它在后面的条件移动 nums[slowIndex] = nums[fastIndex] nums[fastIndex] = 0 &#125; if (nums[slowIndex] != 0) &#123; // 慢指针 !=0就移动 slowIndex++ &#125; &#125;&#125; 844. 比较含退格的字符串栈123456789101112131415161718192021222324fun backspaceCompare1(s: String, t: String): Boolean &#123; val sStack = Stack&lt;Char&gt;() for (i in s.indices) &#123; if (s[i] == &#x27;#&#x27;) &#123; if (sStack.isNotEmpty()) &#123; sStack.pop() &#125; &#125; else &#123; sStack.push(s[i]) &#125; &#125; val tStack = Stack&lt;Char&gt;() for (j in t.indices) &#123; if (t[j] == &#x27;#&#x27;) &#123; // 复制还不如自己写，一开始写成s[i] if (tStack.isNotEmpty()) &#123; //放上面if,tStack是空的情况，会把 #添加进来 tStack.pop() &#125; &#125; else &#123; tStack.push(t[j])// 复制还不如自己写，一开始写成s[i] &#125; &#125; return sStack == tStack&#125; 双指针112345678910111213141516171819202122232425262728293031323334353637383940414243fun backspaceCompare(s: String, t: String): Boolean &#123; var i = s.length - 1 var j = t.length - 1 var skipS = 0 var skipT = 0 while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; while (i &gt;= 0) &#123; if (s[i] == &#x27;#&#x27;) &#123; // 碰到这个先累计 skipS++ i-- &#125; else if (skipS &gt; 0) &#123; // 把#处理 skipS-- i-- &#125; else &#123; break &#125; &#125; while (j &gt;= 0) &#123; if (t[j] == &#x27;#&#x27;) &#123; skipT++ j-- &#125; else if (skipT &gt; 0) &#123; skipT-- j-- &#125; else &#123; break &#125; &#125; if (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; //上面有可能 i, j有可能到-1 if (s[i] != t[j]) &#123; return false &#125; &#125; else if (i &gt;= 0 || j &gt;= 0) &#123; // i ,j有多余的，也有问题 return false &#125; i-- j-- &#125; return true&#125; https://leetcode-cn.com/problems/backspace-string-compare/solution/shuang-zhi-zhen-bi-jiao-han-tui-ge-de-zi-8fn8/ 双指针2这种双指针写法也不错,只是最后的String.valueOf不同语言有出入，和这个题目意思有点对不上 1234567891011121314151617181920212223242526class Solution &#123; public boolean backspaceCompare(String s, String t) &#123; // equals()判断返回的两个字符串是否相等 return changeString(s).equals(changeString(t)); &#125; public static String changeString (String str) &#123; // 先将字符串转为数组，方便使用双指针法 char[] x = str.toCharArray(); int slow = 0; for (int fast = 0; fast &lt; x.length; fast++) &#123; // 当x[fast] != &#x27;#&#x27;时，x[fast]覆盖x[slow]，然后slow++ if (x[fast] != &#x27;#&#x27;) x[slow++] = x[fast]; // 当x[fast] = &#x27;#&#x27;且slow!=0时，slow-- else if(x[fast] == &#x27;#&#x27; &amp;&amp; slow != 0) slow--; &#125; // 返回字符串 return String.valueOf(x, 0, slow); &#125;&#125;https://leetcode-cn.com/problems/backspace-string-compare/solution/shuang-zhi-zhen-fa-si-lu-jian-dan-rong-y-bmn6/ 有序数组的平方977. 有序数组的平方left ,right 左右两端比较大小，大的放新数组的最右端 123456789101112131415161718fun sortedSquares(nums: IntArray): IntArray &#123; var left = 0 var right = nums.size - 1 var index = nums.size - 1 val arrayNew = IntArray(nums.size) while (left &lt;= right) &#123; val leftSquare = nums[left] * nums[left] val rightSquare = nums[right] * nums[right] if (leftSquare &lt;= rightSquare) &#123; arrayNew[index--] = rightSquare right-- &#125; else &#123; arrayNew[index--] = leftSquare left++ &#125; &#125; return arrayNew&#125; https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/c-dong-hua-yan-shi-977-you-xu-shu-zu-de-gxlvm/ 209. 长度最小的子数组双指针（滑动窗口）滑动窗口主要找到移动左指针的条件 其实就是精简出暴力解法 123456789101112131415fun minSubArrayLen(target: Int, nums: IntArray): Int &#123; var sum = 0 var leftP = 0; var result = Int.MAX_VALUE for (rightP in nums.indices) &#123; sum += nums[rightP] while (sum &gt;= target) &#123; val subLength = rightP - leftP + 1 if (subLength &lt; result) result = subLength sum -= nums[leftP++] &#125; &#125; if (result == Int.MAX_VALUE) result = 0 return result&#125; **一些录友会疑惑为什么时间复杂度是O(n)**。 不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是 2 × n 也就是O(n)。 对于这个解释 o(n)其实我还是有一些不理解. https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-7/ 暴力解法先移动前面的，再移动后面的遍历找出。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int result = INT32_MAX; // 最终的结果 int sum = 0; // 子序列的数值之和 int subLength = 0; // 子序列的长度 for (int i = 0; i &lt; nums.size(); i++) &#123; // 设置子序列起点为i sum = 0; for (int j = i; j &lt; nums.size(); j++) &#123; // 设置子序列终止位置为j sum += nums[j]; if (sum &gt;= s) &#123; // 一旦发现子序列和超过了s，更新result subLength = j - i + 1; // 取子序列的长度 result = result &lt; subLength ? result : subLength; break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break &#125; &#125; &#125; // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; &#125;&#125;;时间复杂度：O(n^2)空间复杂度：O(1)作者：carlsun-2链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处. 904. 水果成篮双指针（滑动窗口） 题目不好懂 [1,2,3,2,2]. , 1 ,2,3,数字大小分别表示水果树类别 1234567891011121314151617181920212223242526272829303132fun totalFruit(fruits: IntArray): Int &#123; var leftP = 0 var basketList = mutableMapOf&lt;Int, Int&gt;() // key存元素，value存出现的次数 var result = 0 var subLength: Int for (rightP in fruits.indices) &#123; val element = fruits[rightP] //快指针扫到的元素 if (basketList.containsKey(element)) &#123; //包含这个元素 个数+1 basketList[element] = basketList[element]!!.plus(1) &#125; else &#123; basketList[element] = 1 &#125; while (true) &#123; if (basketList.size &gt; 2) &#123; // 元素类型&gt;2,就开始移动左指针 basketList[fruits[leftP]] = basketList[fruits[leftP]]!!.minus(1) //左指针次数-1 if (basketList[fruits[leftP]] == 0) &#123; basketList.remove(fruits[leftP]) //删除移动的左指针 &#125; leftP++ &#125; else &#123; subLength = rightP - leftP + 1 // 子序列长度 if (subLength &gt; result) &#123; //比较找出最长的子序列 result = subLength &#125; break &#125; &#125; &#125; return result&#125; 123456789上面解法 if (basketList.containsKey(element)) &#123; //包含这个元素 个数+1 basketList[element] = basketList[element]!!.plus(1) &#125; else &#123; basketList[element] = 1 &#125;可以用这一句替换basketList[element] = basketList.getOrDefault(element, 0).plus(1) 76. 最小覆盖子串滑动窗口 (sliding window) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253** * 核心思想: s的 left right,已经覆盖了t字串，那么就移动left,看看是否还在范围内 * 通过判断T中A B C都 &gt;0没被抵消， &lt;0说明 s有多余这个字符个数 */class LC76 &#123; fun minWindow(s: String, t: String): String &#123; val map = mutableMapOf&lt;Char, Int&gt;() for (element in t) &#123; map[element] = map.getOrDefault(element, 0).plus(1) &#125; var leftP = 0 // 左指针 var rightLast = 0 //最后匹配的最短的右指针 var resultLength = Int.MAX_VALUE var resultStr = &quot;&quot; // 最短结果字符 for (rightP in s.indices) &#123; if (map.containsKey(s[rightP])) &#123; // t字符包含该元素， 元素+1 map[s[rightP]] = map.getOrDefault(s[rightP], 0).minus(1) &#125; while (isMatch(map, t)) &#123; // 判断这个S的left right中是否含有t所有字符 val subLength = rightP - leftP + 1 if (subLength &lt; resultLength) &#123; rightLast = rightP resultLength = subLength resultStr = s.substring( leftP, rightLast + 1 ) &#125; if (map.containsKey(s[leftP])) &#123; // 向右移动left,如果元素是 map t中的，就+1，因为这个不算了 map[s[leftP]] = map.getOrDefault(s[leftP], 0).plus(1) &#125; leftP++ &#125; &#125; return resultStr// the beginning index, inclusive ,endIndex – the ending index, exclusive. [begin,end) &#125; /** * map中有元素&gt;0,说明有元素还没有,map&lt;0才全部抵消了 */ private fun isMatch(map: Map&lt;Char, Int&gt;, t: String): Boolean &#123; for (element in t) &#123; if (map[element]!! &gt; 0) &#123; return false &#125; &#125; return true &#125;&#125; 视频讲解很清晰 https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/ 这道题参考去看看 labuladong解法,我没找到，后面再看看, 螺旋矩阵59. 螺旋矩阵 II12345678910111213141516171819202122fun generateMatrix(n: Int): Array&lt;IntArray&gt; &#123; var left = 0 var top = 0 var right = n - 1 var bottom = n - 1 var num = 1 val target = n * n var arr = Array(n) &#123; IntArray(n) &#125; while (num &lt;= target) &#123; for (i in left..right) arr[top][i] = num++ // 从左到右 // 这里不是从0开始，是从left开始 top++ // 上边向下收窄1 for (i in top..bottom) arr[i][right] = num++ // 从上到下 right-- // 右边收窄1 for (i in right downTo left) arr[bottom][i] = num++ // 从右到左 bottom-- for (i in bottom downTo top)&#123; // 从底到上 arr[i][left] = num++ &#125; left++ //收缩左边 &#125; return arr&#125; 题解根据下面这个解法，简单巧妙 https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"}]},{"title":"Animation-Lottie","slug":"Animation-Lottie","date":"2022-04-27T01:56:05.000Z","updated":"2022-05-06T11:24:51.147Z","comments":true,"path":"2022/04/27/Animation-Lottie/","link":"","permalink":"https://noteforme.github.io/2022/04/27/Animation-Lottie/","excerpt":"","text":"anim in RecycleView https://www.jianshu.com/p/af6df7e55834 https://developer.android.com/topic/libraries/architecture/lifecycle","categories":[],"tags":[{"name":"anim","slug":"anim","permalink":"https://noteforme.github.io/tags/anim/"}]},{"title":"coroutie_channel6","slug":"coroutie_channel6","date":"2022-04-23T13:16:43.000Z","updated":"2024-04-28T13:56:27.523Z","comments":true,"path":"2022/04/23/coroutie_channel6/","link":"","permalink":"https://noteforme.github.io/2022/04/23/coroutie_channel6/","excerpt":"","text":"channelThere are four types of channels Unlimited channel , Buffered channel , Rendezvous channel , Conflated channel Rendezvous channelBy default, a “Rendezvous” channel is created. 12345678910111213141516171819202122232425import kotlinx.coroutines.channels.Channelimport kotlinx.coroutines.*fun main() = runBlocking&lt;Unit&gt; &#123; val channel = Channel&lt;String&gt;() launch &#123; channel.send(&quot;A1&quot;) channel.send(&quot;A2&quot;) log(&quot;A done&quot;) &#125; launch &#123; channel.send(&quot;B1&quot;) log(&quot;B done&quot;) &#125; launch &#123; repeat(3) &#123; val x = channel.receive() log(x) &#125; &#125;&#125;fun log(message: Any?) &#123; println(&quot;[$&#123;Thread.currentThread().name&#125;] $message&quot;)&#125; Watch this video for a better understanding of channels. https://www.youtube.com/watch?v=HpWQUoVURWQ channel是并发安全的队列,队列一定存在缓冲区满了，并且没有人调用receive取走函数，send就挂起 produce与actor 复用多个await多路复用 网络和本地缓存获取数据，哪一个先返回就先用那个做展示 1234567891011121314151617181920212223fun CoroutineScope.getUserFromLocal() = async(Dispatchers.IO) &#123; // 模拟读取本地数据 delay(1000) &quot;getUserFromLocal&quot;&#125;fun CoroutineScope.getUserFromNetwork() = async(Dispatchers.IO) &#123; // 模拟读取网络数据 delay(500) &quot;getUserFromNetwork&quot;&#125;fun testSelectAwait() = runBlocking &#123; GlobalScope.launch &#123; val userFromLocal = getUserFromLocal() val userFromNetwork = getUserFromNetwork() val select = select&lt;String&gt; &#123; userFromLocal.onAwait &#123; it &#125; userFromNetwork.onAwait &#123; it &#125; &#125; println(select) &#125;.join()&#125; https://kotlinlang.org/docs/coroutines-and-channels.html#channels","categories":[],"tags":[{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"}]},{"title":"coroutie_operator4","slug":"coroutie-operator4","date":"2022-04-23T13:03:37.000Z","updated":"2023-01-02T03:31:39.121Z","comments":true,"path":"2022/04/23/coroutie-operator4/","link":"","permalink":"https://noteforme.github.io/2022/04/23/coroutie-operator4/","excerpt":"","text":"先看小结 转换操作符 transform 限长操作符 take(2) 末端操作符 Collect tolist toset first single reduce fold 组合操作符 zip 展平流 flatmapconcat 连接模式 Flatmapmerge 合并模式 faltMapLatest 最新展平模式 流的异常处理 Try/ catch块 catch函数 流的完成 流手机完成时(普通情况或异常情况) 命令式finally块 onCompletion声明式处理 ​","categories":[],"tags":[{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"}]},{"title":"coroutie-flow5","slug":"coroutie-flow5","date":"2022-03-20T12:46:54.000Z","updated":"2023-01-02T03:31:39.097Z","comments":true,"path":"2022/03/20/coroutie-flow5/","link":"","permalink":"https://noteforme.github.io/2022/03/20/coroutie-flow5/","excerpt":"","text":"如何表示多个值 挂起函数可以异步的返回单个值，但是该如何异步的返回多个计算好的值呢？ 异步返回多个值的方案 集合 序列。挂起函数。Flow Flow 异步流 56异步返回多个值 集合 序列 挂起函数集合 , 序列 , 挂起函数 ,Flow 1234567891011121314151617181920212223242526 fun simpleList(): List&lt;Int&gt; = listOf(1, 2, 3) fun simpleSequence(): Sequence&lt;Int&gt; = sequence &#123; for (i in 1..3) &#123;// Thread.sleep(1000) // 阻塞，假装在计算// delay(1000) yield(i) &#125; &#125; suspend fun simpleList2(): List&lt;Int&gt; &#123; delay(1000) return listOf(1, 2, 3) &#125; @Test fun `test multiple values`() &#123;// simpleList().forEach &#123; values -&gt; println(values) &#125; // 返回了多个值，但不是异步 simpleSequence().forEach &#123; value -&gt; println(value) &#125;// 返回了多个值，是同步 &#125; @Test fun `test multiple values2`() = runBlocking &#123; simpleList2().forEach &#123; values -&gt; println(values) &#125; // 返回了多个值，是异步，但是是一次性返回的 &#125; 57-通过Flow异步返回多个值1234567891011121314151617suspend fun simpleFlow() = flow&lt;Int&gt; &#123; for (i in 1..3) &#123; delay(1000) // 怎么证明没有阻塞，而是挂起 emit(i) // 发生，产生一个元素 &#125;&#125;@Testfun `test multiple values3`() = runBlocking &#123; launch &#123; //再起一个任务，确认线程是否阻塞 for (k in 1..3)&#123; println(&quot;I am not blocked $k&quot;) delay(1500) &#125; &#125; simpleFlow().collect &#123; value -&gt; println(value) &#125;&#125; 返回多个值 而且是异步的 I am not blocked 11I am not blocked 22I am not blocked 33 58 Flow与其他方式的区别 59 Flow应用 流的特性60 冷流Flow是一种类似于序列的冷流，flow够坚强中的代码知道流被收集的时候才运行 类似于懒加载, 点了Button，collect才开始下载 12345678910111213141516fun simpleFlow2() = flow&lt;Int&gt; &#123; println(&quot;Flow started&quot;) for (i in 1..3) &#123; delay(1000) // 怎么证明没有阻塞，而是挂起 emit(i) // 发生，产生一个元素 &#125;&#125;@Testfun `test flow is cold`() = runBlocking &#123; val flow = simpleFlow2() println(&quot;Calling collect...&quot;) flow.collect &#123; value -&gt; println(value) &#125; println(&quot;Calling collect again&quot;) flow.collect &#123; value -&gt; println(value) &#125;&#125; 只要执行 还会再执行一次。 12345678910Calling collect...Flow started123Calling collect againFlow started123 61.流的连续性 1234567(1..5).asFlow().filter &#123; it % 2 == 0&#125;.map &#123; &quot;string $it&quot;&#125;.collect&#123; println(&quot;Collect $&#123;it&#125;&quot;)&#125; 12Collect string 2Collect string 4 流构建器flowOf构建器定义了一个发射固定值集的流 使用asFlow()拓展函数，可以将各种集合与序列转换为流 123456789flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) .onEach &#123; delay(1000) &#125; .collect &#123; println(it) &#125;(1..3).asFlow().collect &#123; println(it)&#125; 123456onetwothree123 63.流上下文flowOn 1234567891011121314fun simpleFlow3()= flow&lt;Int&gt; &#123; println(&quot;Flow started $&#123;Thread.currentThread().name&#125;&quot;) for (i in 1..3)&#123; delay(1000) emit(i) &#125;&#125; @Test fun `test flow context`() = runBlocking &#123; simpleFlow3().collect&#123; println(&quot;Collected $it $&#123;Thread.currentThread().name&#125;&quot;) &#125; &#125; 构建流和保存流在同一个上下文 构建的时候用协程启动的后台线程 1234567891011121314151617fun simpleFlow4() = flow&lt;Int&gt; &#123; withContext(Dispatchers.IO) &#123; println(&quot;Flow started $&#123;Thread.currentThread().name&#125;&quot;) for (i in 1..3) &#123; delay(1000) emit(i) &#125; &#125;&#125;@Testfun `test flow context4`() = runBlocking &#123; simpleFlow4().collect &#123; println(&quot;Collected $it $&#123;Thread.currentThread().name&#125;&quot;) &#125;&#125; Flow started DefaultDispatcher-worker-1 @coroutine#1 Flow invariant is violated: // 报错 用flowOn可以解决这个问题。flowon可以更改流发射的上下文。 1234567891011121314fun simpleFlow5() = flow&lt;Int&gt; &#123; println(&quot;Flow started $&#123;Thread.currentThread().name&#125;&quot;) for (i in 1..3) &#123; delay(1000) emit(i) &#125;&#125;.flowOn(Dispatchers.Default)@Testfun `test flow context5`() = runBlocking &#123; simpleFlow5().collect &#123; println(&quot;Collected $it $&#123;Thread.currentThread().name&#125;&quot;) &#125;&#125; 1234Flow started DefaultDispatcher-worker-1 @coroutine#2Collected 1 Test worker @coroutine#1Collected 2 Test worker @coroutine#1Collected 3 Test worker @coroutine#1 发送在后台线程，收集在主线程 64.在指定协程中收集流使用launchIn(),替换collect 我们可以在单独的协程中启动流的收集 1234567891011121314151617 fun events() = (1..3) .asFlow() .onEach &#123; delay(100) &#125; .flowOn(Dispatchers.Default) @Test fun `test flow launch`() = runBlocking&lt;Unit&gt; &#123; val job = events().onEach &#123; events -&gt; println(&quot;Event: $events $&#123;Thread.currentThread().name&#125;&quot;) &#125;// .collect() .launchIn(CoroutineScope(Dispatchers.IO)) // 单独的协程中，启动流的收集 .join() delay(200)// job.cancelAndJoin() &#125; Event: 1 DefaultDispatcher-worker-3 @coroutine#2Event: 2 DefaultDispatcher-worker-3 @coroutine#2Event: 3 DefaultDispatcher-worker-2 @coroutine#2 65. 流的取消 12345678910111213141516fun simpleFlow6() = flow&lt;Int&gt; &#123; println(&quot;Flow started $&#123;Thread.currentThread().name&#125;&quot;) for (i in 1..3) &#123; delay(1000) emit(i) println(&quot;Emitting $i&quot;) &#125;&#125;.flowOn(Dispatchers.Default)@Testfun `test cancel flow`() = runBlocking&lt;Unit&gt; &#123; withTimeoutOrNull(2500)&#123; // 2.5s超时 simpleFlow6().collect&#123;value-&gt; println(value)&#125; &#125; println(&quot;Done&quot;)&#125; withTimeoutOrNull 123456Flow started DefaultDispatcher-worker-1 @coroutine#2Emitting 11Emitting 22Done 协程被取消 3没有打印 66流的取消检测 1234567891011121314151617fun simpleFlow7() = flow&lt;Int&gt; &#123; for (i in 1..5) &#123; delay(1000) emit(i) println(&quot;Emitting $i&quot;) &#125;&#125;@Testfun `test cancel flow check`() = runBlocking&lt;Unit&gt; &#123; withTimeoutOrNull(2500) &#123; // 2.5s超时 simpleFlow7().collect &#123; value -&gt; println(value) if (value == 3) cancel() &#125; &#125;&#125; 1Emitting 12Emitting 2BUILD SUCCESSFUL in 3s 背压 buffer stateFlow sharedFlow","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"}]},{"title":"Corouties_context","slug":"Corouties-context3","date":"2022-03-20T09:48:54.000Z","updated":"2023-01-02T03:31:38.956Z","comments":true,"path":"2022/03/20/Corouties-context3/","link":"","permalink":"https://noteforme.github.io/2022/03/20/Corouties-context3/","excerpt":"","text":"协程的上下文 P38 协程的上下文 P39 123456@Testfun `test CoroutineContext `() = runBlocking&lt;Unit&gt; &#123; launch (Dispatchers.Default + CoroutineName(&quot;test&quot;))&#123; println(&quot;you are great $&#123;Thread.currentThread().name&#125;&quot;) &#125;&#125; you are great DefaultDispatcher-worker-1 @test#2 P40协程上下文的继承 12345678val scope = CoroutineScope(Job() + Dispatchers.IO + CoroutineName(&quot;test&quot;))val job = scope.launch &#123; println(&quot;$&#123;coroutineContext[Job]&#125; $&#123;Thread.currentThread().name&#125;&quot;) val result = async &#123; println(&quot;$&#123;coroutineContext[Job]&#125; $&#123;Thread.currentThread().name&#125;&quot;) &#125;.await()&#125;job.join() “test#2”:StandaloneCoroutine{Active}@4d3fac66 DefaultDispatcher-worker-1 @test#2“test#3”:DeferredCoroutine{Active}@43e36bfa DefaultDispatcher-worker-3 @test#3 P41协程上下文继承公式 1234567val coroutineExceptionHandler = CoroutineExceptionHandler &#123; _, exception -&gt; println(&quot;caught $exception&quot;)&#125;val scope = CoroutineScope(Job() + Dispatchers.Main + coroutineExceptionHandler)val job = scope.launch(Dispatchers.IO) &#123; //新协程&#125; 异常P42学习协程异常处理的必要性 43自动传播异常 与向用户暴露异常 1234567891011121314151617 val job = GlobalScope.launch &#123; try &#123; throw IndexOutOfBoundsException() &#125; catch (e: Exception) &#123; println(&quot;Caught IndexOutOfBoundsException&quot;) &#125; &#125; job.join() val deferred = GlobalScope.async &#123; throw ArithmeticException() &#125;// try &#123;// deferred.await()// &#125; catch (e: Exception) &#123;// println(&quot;Caught ArithmeticException&quot;)// &#125; delay(1000) 对于async ，根协程GlobalScope 调用.wait才会抛出异常,才能捕获异常 44 非根协程的异常传播123456val scope = CoroutineScope(Job())val job = scope.launch &#123; throw IllegalArgumentException() //如果async抛出异常，launch就会立即抛出异常，而需要调用 .await&#125;job.join() Exception in thread “DefaultDispatcher-worker-1 @coroutine#2” java.lang.IllegalArgumentException at com.john.kot.coroutine.dongnao.CoroutineTest44$test CoroutineContext $1$job$1.invokeSuspend(CoroutineTest44.kt:24) 45异常的传播特性 46 SupervisorJob打破P45的异常传播特性 一个协程有问题 不会影响其他的协程 123456789101112131415val supervisor = CoroutineScope(SupervisorJob())val job1 = supervisor.launch &#123; delay(100) println(&quot;child 1&quot;) throw IllegalArgumentException()&#125;val job2 = supervisor.launch &#123; try &#123; delay(Long.MAX_VALUE) &#125; finally &#123; println(&quot;child 2 finished.&quot;) &#125; throw IllegalArgumentException()&#125;joinAll(job1, job2) SupervisorJob()缓存 job(),都能正常打印了. Supervisor.cancel() ,后所有协程都会取消 47 SupervisorScope当作业自身执行失败的时候，所有子作业将会被全部取消 123456789101112val child = supervisorScope &#123; launch &#123; try &#123; println(&quot;The child is sleeping&quot;) delay(Long.MAX_VALUE) &#125; finally &#123; println(&quot;The child is cancelled&quot;) &#125; &#125; yield() println(&quot;Throwing an exception from the scope&quot;) throw AssertionError() The child is sleepingThrowing an exception from the scopeThe child is cancelled 作用域抛出异常，导致子协程取消 异常的捕获P48-异常的捕获的时机与位置 P49- 异常捕获常见错误12345678val handler = CoroutineExceptionHandler &#123; _, exception -&gt; println(&quot;Caught $exception&quot;) &#125;val job = GlobalScope.launch(handler) &#123; throw AssertionError()&#125;val deferred = GlobalScope.async(handler) &#123; throw ArithmeticException() &#125;job.join()deferred.await() 被捕获 Caught java.lang.AssertionError java.lang.ArithmeticException at com.john.kot.coroutine.dongnao.CoroutineTest48$test SupervisorJob $1$deferred$1.invokeSuspend(CoroutineTest48.kt:28) 123456789val handler = CoroutineExceptionHandler &#123; _, exception -&gt; println(&quot;Caught $exception&quot;) &#125;val scope = CoroutineScope(Job())val job = scope.launch(handler) &#123; launch &#123; throw IllegalArgumentException() &#125;&#125;job.join() Caught java.lang.IllegalArgumentException handler放在内部的情况 123456789val handler = CoroutineExceptionHandler &#123; _, exception -&gt; println(&quot;Caught $exception&quot;) &#125;val scope = CoroutineScope(Job())val job = scope.launch &#123; launch(handler) &#123; throw IllegalArgumentException() &#125;&#125;job.join() 这种情况捕获不到, 异常处理器不能安装到内部协程，要安装到外部协程 50 异常捕获 防止App闪退 51Android全局异常处理 52取消与异常 异常取消顺序， 先自己 12345678910111213141516171819202122@Testfun `test cancel and exception`() = runBlocking &#123; val job = launch &#123; val child = launch &#123; try &#123; try &#123; delay(Long.MAX_VALUE) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; &#125; finally &#123; println(&quot;Child is cancelled.&quot;) &#125; &#125; yield() println(&quot;Cancelling child&quot;) child.cancelAndJoin() yield() println(&quot;Parent is cancelled.&quot;) &#125; job.join()&#125; Cancelling child Child is cancelled.Parent is cancelled. 1234567891011121314151617181920212223val handler = CoroutineExceptionHandler &#123; _, exception -&gt; println(&quot;Caught $exception&quot;)&#125;val job = GlobalScope.launch(handler) &#123; launch &#123; try &#123; delay(Long.MAX_VALUE) &#125; finally &#123; withContext(NonCancellable)&#123; println(&quot;Children are cancelled , but exception is not handled until &quot;) delay(100) println(&quot;The first child finished its non cancellable block&quot;) &#125; &#125; &#125; launch &#123; delay(10) println(&quot;Second child throws an exception&quot;) throw ArithmeticException() &#125;&#125;job.join() Second child throws an exceptionChildren are cancelled , but exception is not handled untilThe first child finished its non cancellable blockCaught java.lang.ArithmeticException 第2个协程取消，第1个也被取消，最后处理外面的异常 p53异常聚合suppressed 捕获多个异常 12345678910111213141516171819202122232425val handler = CoroutineExceptionHandler &#123; _, excetption -&gt; println(&quot;Caught $excetption $&#123;excetption.suppressed.contentToString()&#125;&quot;)&#125;val job = GlobalScope.launch(handler) &#123; launch &#123; try &#123; delay(Long.MAX_VALUE) &#125; finally &#123; throw ArithmeticException() // 2 &#125; &#125; launch &#123; try &#123; delay(Long.MAX_VALUE) &#125; finally &#123; throw ArithmeticException() // 2 &#125; &#125; launch &#123; delay(100) throw IndexOutOfBoundsException() // 3 &#125;&#125;job.join() 一床存在数组中 Caught java.lang.IndexOutOfBoundsException [java.lang.ArithmeticException, java.lang.ArithmeticException]","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"}]},{"title":"battery-research","slug":"battery-research","date":"2022-03-13T12:39:05.000Z","updated":"2022-05-06T11:24:51.271Z","comments":true,"path":"2022/03/13/battery-research/","link":"","permalink":"https://noteforme.github.io/2022/03/13/battery-research/","excerpt":"","text":"耗电提醒 耗电问题难点 缺乏现场，无法复现。 用户上传某个截图，你的应用耗电占比 30%。通过电量的详细使用情况，我们可能会有一些猜测。但是用户也无法给出更丰富的信息，以及具体是在什么场景发生的，可以说是毫无头绪。 信息不全，难以定位。 如果是开发人员或者厂商可以提供 bug report，利用 Battery Historian 可以得到非常全的耗电统计信息。但是 Battery Historian 缺失了最重要的堆栈信息，代码调用那么复杂，可能还有很多的第三方 SDK，我们根本不知道是哪一行代码申请了 WakeLock、使用了 Sensor、调用了网络等。 无法评估结果。 通过猜测，我们可能会尝试一些解决方案。但是从 Android 4.4 开始，我们无法拿到应用的耗电信息。尽管我们解决了某个耗电问题，也很难去评估它是否已经生效，以及对用户产生的价值有多大。 信息不全，难以定位 如果是开发人员或者厂商可以提供 bug report，利用 Battery Historian 可以得到非常全的耗电统计信息。但是 Battery Historian 缺失了最重要的堆栈信息，代码调用那么复杂，可能还有很多的第三方 SDK，我们根本不知道是哪一行代码申请了 WakeLock、使用了 Sensor、调用了网络等。 系统如何计算 App 电量电量 = 功率 * 时间 = 电压 * 电流 * 时间 模块电量（mAh） = 模块电流（mA）* 模块耗时（h） App电量 = SUM(模块功率 * 模块时间) 各模块的功率 BatteryStatusService：用来统计电量工作的，各模块的功率在 power_profile.xml 中，再加上各模块的使用耗时就能统计出电量了 https://android.googlesource.com/platform/frameworks/base/+/master/core/res/res/xml/power_profile.xml 功率：功率在 power_profile.xml 中 时长：StopWatch 用来计算 App 各硬件模块的使用时长，怎么计算 Wifi 使用了多久？ WifiManager.startScan() –&gt; WifiscanningServiceImp –&gt; BatteryStatsImpl.noteWifiScanStartedFromSource(mScanWorkSource); 埋点 计算：PowerCalculators ，每个硬件都有相应的命名对象， 主要用来计算电量 WifiPowerCalculator -&gt; calculateApp https://www.jianshu.com/p/672d008c4ad3 https://juejin.cn/post/6844904195523346439 系统限制提醒情况从 Android 9.0 开始,，Google 对电源管理引入了几个更加严格的限制。 应用分组根据DeepMind调整应用待机分组，各个厂商可选择使用DeepMind的提供的模型. Active : App基本不会受到后台限制。 Rare : Jobs和Alarms都会受到延迟,访问网络的频率也会受到限制。 Frequent rare ： 发送过量的高优先级FCM message, 系统会把这些信息降级为 普通优先级. 后台限制 Android Vitals 的规则 : Android P 是通过 Android Vitals 监控后台耗电 https://developer.android.google.cn/topic/performance/vitals Android Vitals 核心指标： ANR 发生率崩溃率唤醒次数过多部分唤醒锁定被卡住 其他指标： 后台 Wi-Fi 扫描次数过多后台网络使用量过高应用启动时间呈现速度缓慢冻结的帧权限遭拒 可参考规则 华为公开过他们后台资源使用的“红线” 例如长时间获取 WakeLock、WiFi 和蓝牙的扫描等。为什么说耗电优化第一个方向就是优化应用后台耗电，因为大部分厂商预装项目要求最严格的正是应用后台待机耗电。 ​ 虽然上面的标准可能随时会改变，但是可以看到，Android 系统目前比较关心后台 Alarm 唤醒、后台网络、后台 WiFi 扫描以及部分长时间 WakeLock 阻止系统后台休眠。 https://blog.dreamtobe.cn/2016/08/15/android_scheduler_and_battery/ 后台操作原则 减少 : 减少后台运行 延迟 : 延迟到合适的时间，例如设备充上电 合并: 合并后台操作 ​ WorkManager : 后台操作的首选 耗电优化方式 灭屏时停止动画 我们可以监听灭屏以及亮屏的广播，在灭屏的时候停止 surfaceView 的动画绘制。在亮屏的时候，恢复动画的绘制。 监听手机充电状态 这里我们就需要思考，根据具体的业务，考虑将一些不需要及时地和用户交互的操作放到充电 的时候去做。比如：360 手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人 等到云端，从而避免当用户手机低电量时，任然继续进行耗电操作。 123456IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);Intent batteryStatus = context.registerReceiver(null, ifilter);//获取用户是否在充电的状态或者已经充满电了int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL; Sync Adapter 用于同步服务端与本地设备中的数据。通常是用于同步较多的数据，如系统联系人信息、Dropbox等。 找到需求场景的替代方案 以推送为例，我们是否可以更多地利用厂商通道，或者定时的拉取最新消息这种模式。如果真是迫不得已，是不是可以使用 foreground service 或者引导用户加入白名单。后台任务的总体指导思想是减少、延迟和合并，可以参考微信一个小伙写的《Android 后台调度任务与省电》。在后台运行某个任务之前，我们都需要经过下面的思考： 插桩写一个基础类，然后在统一的调用接口中增加监控逻辑。 以 WakeLock 为例： 12345678910111213public class WakelockMetrics &#123; // Wakelock 申请 public void acquire(PowerManager.WakeLock wakelock) &#123; wakeLock.acquire(); // 在这里增加Wakelock 申请监控逻辑 &#125; // Wakelock 释放 public void release(PowerManager.WakeLock wakelock, int flags) &#123; wakelock.release(); // 在这里增加Wakelock 释放监控逻辑 &#125;&#125; 电量监控工具 Battery Historian ​ 无法评估结果 Energy Profiler XHook(爱奇艺), 拿到所有线程的 cpu 耗时时间 。 facebook Battery-Metrics 它监控的数据非常全，包括 Alarm、WakeLock、Camera、CPU、Network 等，而且也有收集电量充电状态、电量水平等信息。Battery-Metrics 只是提供了一系列的基础类，在实际使用中，接入者可能需要修改大量的源码。但对于一些第三方 SDK 或者后续增加的代码，我们可能就不太能保证可以监控到了。这些场景也就无法监控了，所以 Facebook 内部是使用插桩来动态替换。 Facebook 并没有开源它们内部的插桩具体实现方案，可以使用 ASM、Aspectj 这两种插桩方案了。 matrix BatteryCanary ANR 内存使用 优化好了， 电量肯定没问题， 如果电量不行，程序有问题","categories":[],"tags":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/tags/ANDROID/"}]},{"title":"deeplink","slug":"deeplink","date":"2022-02-25T05:51:15.000Z","updated":"2024-02-25T09:03:32.160Z","comments":true,"path":"2022/02/25/deeplink/","link":"","permalink":"https://noteforme.github.io/2022/02/25/deeplink/","excerpt":"","text":"deeplink same as arouer, 维护了一个id(一个deeplink)和microApp的映射表，app启动后 读取映射表,id和microapp. 123456789101112private void parseApps(Context context, InputStream is, String routerScheme, String routerDomain) &#123; JSONArray jsonArray = new JSONArray(read(is)); int length = jsonArray.length(); for(int i = 0; i &lt; length; ++i) &#123; MetaData metaData = (MetaData)JSON.parseObject(jsonArray.getString(i), MetaData.class); String scheme = String.format(&quot;%s://%s/app/%s&quot;, routerScheme, routerDomain, metaData.id); this.parseMicroApp(context, metaData, metaData.entry.android, scheme); &#125; &#125; &#125; 解析id和app，通过反射拿到microapp,把映射表的id和app进行映射。 1234567891011121314private boolean parseMicroApp(Context context, MetaData metaData, String clazzName, String scheme) &#123; Resources resources = context.getResources(); Class clazz = Class.forName(clazzName); Constructor constructor = clazz.getDeclaredConstructor(); Object object = constructor.newInstance(); BaseMicroApp microApp = (BaseMicroApp)object; microApp.setMetaData(metaData); microApp.setApplicationContext(context); microApp.setIcon(metaData.icon); microApp.setScheme(scheme); microApp.setAppDisplayName(metaData.getDisplayName(resources.getConfiguration().locale, &quot;Unknown&quot;)); MicroAppManagerImpl.getInstance().registerMicroApp(metaData.id, microApp); return true;&#125; 事件发出后，通过启动id,link拿到microapp,启动还有一个判断启动web还是uriHandler,acitivty,这里启动activity,来通过调用microapp的方法，来触发activity. 123456789101112131415 public boolean dispatchURI(@Nullable Activity activity, String uriString) &#123; Uri uri = Uri.parse(uriString); URIHandler uriHandler = this.findDispatchHandler(uri); List&lt;String&gt; pathComponents = uri.getPathSegments(); if (pathComponents.size() &gt; 0) &#123; Map&lt;String, String&gt; parameters = URIDispatcherUtils.calcParameters(uri); boolean shouldIntercept = this.mInterceptor.shouldIntercept(activity, pathComponents, parameters, uriString); if (shouldIntercept) &#123; return false; &#125; &#125; boolean result = uriHandler.handleURI(activity, uriString); &#125;&#125;","categories":[],"tags":[]},{"title":"battery","slug":"battery","date":"2022-02-23T05:50:10.000Z","updated":"2022-06-12T03:17:58.729Z","comments":true,"path":"2022/02/23/battery/","link":"","permalink":"https://noteforme.github.io/2022/02/23/battery/","excerpt":"","text":"性能与功耗https://github.com/JsonChao/Awesome-Android-Performance https://developer.android.google.cn/topic/performance battery historyhttps://developer.android.com/topic/performance/power/setup-battery-historian?hl=zh-cn 123adb shell dumpsys batterystats &gt; &#x2F;Users&#x2F;m&#x2F;Documents&#x2F;BATTELY&#x2F;batterystats.txtadb bugreport &#x2F;Users&#x2F;m&#x2F;Documents&#x2F;BATTELY&#x2F;bugreport.zip 指标查看 https://juejin.cn/post/6844903779268034574 三种情况 省电模式 应用待机分组 后台限制 这三种情况，开发者都需要对App进行测试，保证正常运行 https://www.bilibili.com/video/BV1Ut411d7U3/ 应用分组 开发者保证无论哪个分组 App都没问题 测试通知是否发送 Api接口： 获取运行时应用所在的分组 省电模式该模式App正常运行 ![Screen Shot 2022-03-08 at 2.27.35 PM](/Users/m/Documents/BLOG/source/_posts/battery/Screen Shot 2022-03-08 at 2.27.35 PM.png) 原则减少 : 减少后台运行 延迟 : 延迟到合适的时间，例如设备充上电 合并: 尽量合并后台操作 WorkManager : 后台操作的首选 工具Android Vitals根据描述的不良行为来优化分组 https://developer.android.google.cn/topic/performance/vitals Energy profiler 场景操作监听手机充电状态这里我们就需要思考，根据具体的业务，考虑将一些不需要及时地和用户交互的操作放到充电 的时候去做。比如：360 手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人 等到云端，从而避免当用户手机低电量时，任然继续进行耗电操作。 屏幕唤醒 (继续研究我们App细节)当 Android 设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止 CPU 的运行，这样可以防 止电池电量掉的快。但有些时候我们需要改变 Android 系统默认的这种状态:比如玩游戏时我 们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要 CPU 一直运行直到任务完成。 保持屏幕常亮比较好的方式是在 Activity 中使用 FLAG_KEEP_SCREEN_ON 的 Flag。 这个方法的好处是不像唤醒锁(wake locks)，需要一些特定的权限(permission)。并且能 正确管理不同 app 之间的切换，不用担心无用资源的释放问题。 另一个方式是在布局文件中使用 android:keepScreenOn 属性: android:keepScreenOn = “true”的作用和 FLAG_KEEP_SCREEN_ON 一样，使用代码的好 处是你允许你在需要的地方关闭屏幕。 注意:一般不需要人为的去掉 FLAG_KEEP_SCREEN_ON 的 flag，windowManager 会管理好程序进入 后台回到前台的的操作。如果确实需要手动清掉常亮的 flag，使用 所以这里我们需要根据自己的 APP 实际情况，根据业务来控制好是否保持屏幕常量。比如 APP 需要支持视频播放。那么在播放的界面需要控制好不熄屏，当退出播放时，当然就没有了 这个设置。 JobScheduler (现在应该用WorkManger)自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的很好的方式，其工作方式有 利于用户在适当的时机执行正确的事情。应用可以在安排作业的同时允许系统基于内存、电源 和连接情况进行优化。JobSchedule 的宗旨就是把一些不是特别紧急的任务放到更合适的时机 批量处理。这样做有两个好处: 避免频繁的唤醒硬件模块，造成不必要的电量消耗。 避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的 任务消耗电量。 GPSAndroid 系统支持多个 Location Provider: GPS_PROVIDER: GPS 定位，利用 GPS 芯片通过卫星获得自己的位置信息。定位精准度高，一般在 10 米左右， 耗电量大;但是在室内，GPS 定位基本没用。 NETWORK_PROVIDER: 网络定位，利用手机基站和 WIFI 节点的地址来大致定位位置，这种定位方式取决于服务器， 即取决于将基站或 WIF 节点信息翻译成位置信息的服务器的能力。 PASSIVE_PROVIDER: 被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接 收到消息后直接读取就可以了。 如果 App 只是需要一个粗略的定位那么就不需要使用 GPS 进行定位，既耗费电量，定位的耗 时也久。 及时注销定位监听 (怎么注销定位) 链接：https://juejin.cn/post/6844903779268034574 电量分析 https://developer.android.google.cn/topic/performance/vitals https://www.youtube.com/watch?v=dx6LBaFqEHU&amp;t=3s https://tech.meituan.com/2018/03/11/dianping-shortvideo-battery-testcase.html https://www.jianshu.com/p/3dc2ea40ed5a docker – run -p 1234:9999 gcr.io/android-battery-historian/stable:3.0 –port 9999 YouTuBe VideoBattery HistorianBattery Historian Part 1: Basics and Installation Using Docker Tool-box https://www.youtube.com/watch?v=6NQwtj0GZRo Battery Historian Part 2: Steps to Collect BatteryStat logs and Creating Report on Console https://www.youtube.com/watch?v=ZTzdrvYO8sM Battery Historian Part 3: Report Analysis and Error Checks https://www.youtube.com/watch?v=d_VFXzBhuuc Battery Historian Parthttps://www.youtube.com/watch?v=11aJfiqqBAk https://www.youtube.com/watch?v=PK2VBuMMkn8 https://www.youtube.com/watch?v=6LuPsbwH3HE https://www.youtube.com/watch?v=-v4NL5oqBq0 耗电优化建议（实用）https://juejin.cn/post/7034751791866576904 https://github.com/JsonChao/Awesome-Android-Notebook/blob/master/notes/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md#APP%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96 https://www.bilibili.com/video/BV1Ut411d7U3/ 具体处理主要是优化后台：Alarm 一定时间内的启动次数，WakeLock 一定时间内的时间/次数，Sensor，Wifi Scans ，Bluetooth , GPS，Camera，NetWork，CPU ，退到后台监控次数和时间，定义一个阀值超过提醒输出 其次是监控优化前台：监控线程 Cpu 时间，Gpu 绘制，拿到所有线程的 cpu 耗时时间 ANR dump 微信：优化，异步加载（比较长）1 分钟，io 读取 ANR （子线程）极端情况下死循环 耗电量是怎么计算的？ 如果 app 需要监控应该怎么监控？ 怎么监控异常耗电并且输出方便排查的信息？ 监控工具wechat matrixhttps://kaedea.com/2021/08/14/android-apm-battery-stats-opt/ https://blog.csdn.net/chuyouyinghe/article/details/117223373 分享做业务怎么脱颖而出？道理都是一样，最后进来的，项目基本完工了，不考核的三流业务，绩效业务。 尽最大的努力去支持他，1200条+，邮箱 WXG ，推荐了我，尽可能积极乐观主动。 熬，低调厚积薄发，做别人不愿意做的事情，摆正好心态 http://www.moyck.com/articles/2019/10/14/1571046711964.html http://www.woshipm.com/it/855066.html https://xiaojianchen.gitbook.io/performance-optimization/android-xing-neng-you-hua-zhi-dian-liang https://juejin.cn/post/6844904195523346439 https://www.bilibili.com/video/BV1st411N7cC?p=5","categories":[],"tags":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/tags/ANDROID/"}]},{"title":"DateTime","slug":"DateTime","date":"2022-01-23T14:56:05.000Z","updated":"2022-01-23T15:05:11.747Z","comments":true,"path":"2022/01/23/DateTime/","link":"","permalink":"https://noteforme.github.io/2022/01/23/DateTime/","excerpt":"","text":"","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"RecyclerView_Divider","slug":"RecyclerView-Divider","date":"2021-12-19T13:12:53.000Z","updated":"2023-02-23T14:17:11.782Z","comments":true,"path":"2021/12/19/RecyclerView-Divider/","link":"","permalink":"https://noteforme.github.io/2021/12/19/RecyclerView-Divider/","excerpt":"","text":"RecyclerView 分割线https://juejin.cn/post/6998712972856000543 ItemDecorationonDrawvoid onDraw(Canvas c, RecyclerView parent, State state) 参数的含义： Canvas c 》 canvas 绘制对象 RecyclerView 》 parent RecyclerView 对象本身 State state 》 当前 RecyclerView 的状态 作用就是绘制，可以在任何位置绘制，如果只是想绘制到每一项里面，那么就需要计算出对应的位置。 void onDrawOver(Canvas c, RecyclerView parent, State state) 跟上面一样，不同的地方在于绘制的总是在最上面，也就是绘制出来的不会被遮挡。 getItemOffsetsvoid getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) 参数的含义： Rect outRect 》item 四周的距离对象 View view 》 当前 view RecyclerView 》 parent RecyclerView 本身 State state 》 RecyclerView 状态 这里可以设置 item 到 RecyclerView 各边的距离。这里需要说明一下，我这里说的到各边的距离指的是啥？ 1234567891011121314151617181920212223class SimpleItemDecoration : RecyclerView.ItemDecoration() &#123; /** * @param outRect 全为0的rect，用来指定偏移区域 * @param view 指RecyclerView中的Item * @param parent 指RecyclerView本身 * @param state 状态 */ override fun getItemOffsets( outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State ) &#123; super.getItemOffsets(outRect, view, parent, state) if (parent.getChildAdapterPosition(view) == 0) &#123; outRect.top = 10 outRect.left = 30 outRect.right = 60 outRect.bottom = 90 &#125; &#125;&#125; 1234567891011121314151617181920212223biding.recyclerView.addItemDecoration(object : RecyclerView.ItemDecoration() &#123; override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123; super.onDraw(c, parent, state) paint.color = (Color.BLUE) c.drawRect(0F, 0f, 400f, 200f, paint) &#125; override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123; super.onDrawOver(c, parent, state) paint.color = Color.RED c.drawRect(0F, 0f, 200f, 100f, paint) &#125; override fun getItemOffsets( outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State ) &#123; super.getItemOffsets(outRect, view, parent, state) outRect.set(20, 100, 0, 20) &#125;&#125;) https://blog.csdn.net/w855227/article/details/80973321 https://www.jianshu.com/p/4eff036360da https://www.jianshu.com/p/b2ef4f8e859f https://github.com/YoKeyword/IndexableRecyclerView https://juejin.im/post/5eae33a26fb9a043586c7f19 https://juejin.cn/post/6844903855335931911 分割线高度和颜色123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;size android:height=&quot;1dp&quot; /&gt; &lt;solid android:color=&quot;@color/color_FFE4E7EA&quot; /&gt;&lt;/shape&gt; ItemDividerRfid.kt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class ItemDividerRfid(var context: Context, val orientation: Int = VERTICAL_LIST) : RecyclerView.ItemDecoration() &#123; companion object &#123; const val HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL const val VERTICAL_LIST = LinearLayoutManager.VERTICAL &#125; private var mDivider: Drawable? = null init &#123; mDivider = context.getDrawable(R.drawable.transportation_divider_item_color) &#125; override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123; if (orientation == VERTICAL_LIST) &#123; drawVertical(c, parent) &#125; &#125; private fun drawVertical(c: Canvas, parent: RecyclerView) &#123; val left = parent.paddingLeft val right = parent.width - parent.paddingRight val childCount = parent.childCount for (i in 0 until childCount) &#123; val child = parent.getChildAt(i) val params = child.layoutParams as RecyclerView.LayoutParams val top = child.bottom + params.bottomMargin val bottom = top + (mDivider?.intrinsicHeight ?: 0) mDivider?.setBounds(left +ITEM_DIVIDER_HEIGHT_16, top, right-ITEM_DIVIDER_HEIGHT_16, bottom) mDivider?.draw(c) &#125; &#125; override fun getItemOffsets( outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State ) &#123; if (orientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider?.intrinsicHeight ?: 0) &#125; &#125;&#125; https://blog.51cto.com/zhaoyanjun/3814502#3_453","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://noteforme.github.io/tags/RecyclerView/"}]},{"title":"coroutie-start2","slug":"coroutie-start2","date":"2021-12-14T00:05:39.000Z","updated":"2023-01-02T03:31:39.122Z","comments":true,"path":"2021/12/14/coroutie-start2/","link":"","permalink":"https://noteforme.github.io/2021/12/14/coroutie-start2/","excerpt":"","text":"runblocking会等待子协程执行完成. https://www.bilibili.com/video/BV1uo4y1y7ZF?p=24&amp;spm_id_from=pageDriver P20 launch asyncLaugh 返回一个Job Async , 返回Deffrred. Async 返回执行结果 12345Job1 finished.Job2 finishedJob2 finished P21 join与await等待协程的作业12345678910111213141516171819202122232425262728293031323334@Testfun `test coroutine join`() = runBlocking &#123; val job1 = launch() &#123; delay(200) println(&quot;One&quot;) &#125; job1.join() // job1执行完，再执行job2 job3 val job2 = launch() &#123; delay(200) println(&quot;Two&quot;) &#125; val job3 = launch() &#123; delay(200) println(&quot;Three&quot;) &#125;&#125;@Testfun `test coroutine await`() = runBlocking &#123; // 刷新界面，拿到执行结果后，再执行其他的。 val job1 = async() &#123; delay(200) println(&quot;One&quot;) &#125; job1.await() // job1执行完，再执行job2 job3 val job2 = async() &#123; delay(200) println(&quot;Two&quot;) &#125; val job3 = async() &#123; delay(200) println(&quot;Three&quot;) &#125;&#125; 区别是await可以拿到执行结果， 接口1请求成功，拿到接口，再请求其他接口。 launch启动用 join() async启动用 await() P22 async组合并发1234567891011121314151617181920212223242526272829@Testfun `test sync`() = runBlocking &#123; val time = measureTimeMillis &#123; val one = doOne() // 同步，串行任务 val two = doTwo() println(&quot;The result : $&#123;one + two&#125;&quot;) &#125; println(&quot;completed in $time ms&quot;)&#125;@Testfun `test combine async`() = runBlocking &#123; val time = measureTimeMillis &#123; val one = async&#123;doOne()&#125; // 并发的两个异步任务 val two = async&#123;doTwo()&#125; println(&quot;The result : $&#123;one.await() + two.await()&#125;&quot;) &#125; println(&quot;completed in $time ms&quot;)&#125;private suspend fun doOne(): Int &#123; delay(1000) return 14&#125;private suspend fun doTwo(): Int &#123; delay(1000) return 25&#125; 执行的结果相加 协程的启动模式 CoroutineStart.DEFAULT p24 协程的作用域构建器runBlocking阻塞当前线程等待 12345678910coroutineScope &#123; val job1 = launch &#123; delay(1000) println(&quot;Job1 finished.&quot;) &#125; val job2 = async &#123; delay(1000) println(&quot;Job2 finished.&quot;) &#125;&#125; coroutineScope 也需要等待子协程执行结束，和 runBlocking很像. 区别coroutineScope是挂起函数. coroutineScope与supervisorScope 还有SupervisorJob 1234567891011coroutineScope &#123; val job1 = launch &#123; delay(400) println(&quot;Job1 finished.&quot;) &#125; val job2 = async &#123; delay(200) println(&quot;Job2 finished.&quot;) &quot;job2 result&quot; &#125;&#125; Job2 finished.Job1 finished. job2中断 job1也中断 12345678910111213141516@Testfun `test coroutineScope scope builder`() = runBlocking &#123; coroutineScope &#123; val job1 = launch &#123; delay(400) println(&quot;job1 finished.&quot;) &#125; val job2 = launch &#123; delay(200) println(&quot;job2 finished.&quot;) &quot;job2 result&quot; throw IllegalArgumentException() &#125; &#125;&#125; job2 finished. java.lang.IllegalArgumentException 两个协程都退出 job2中断 job1继续 123456789101112131415@Testfun &#96;test supervisorScope scope builder&#96;() &#x3D; runBlocking &#123; supervisorScope &#123; val job1 &#x3D; launch &#123; delay(400) println(&quot;job1 finished.&quot;) &#125; val job2 &#x3D; launch &#123; delay(200) println(&quot;job2 finished.&quot;) &quot;job2 result&quot; throw IllegalArgumentException() &#125; &#125;&#125; job2 finished.Exception in thread “Test worker @coroutine#3” Job1 finished. 25 Job的生命周期 协程的取消 26-取消作用域1234567891011121314 @Test fun `test scope cancel`() = runBlocking&lt;Unit&gt; &#123; val scope = CoroutineScope(Dispatchers.Default) scope.launch &#123; delay(1000) println(&quot;Job 1.&quot;) &#125; scope.launch &#123; delay(1000) println(&quot;Job 2.&quot;) &#125;// delay(2000) //需要加这个才能看到 打印,CoroutineScope没有继承runBlocking的上下文 &#125; 12345678910111213141516@Testfun `test scope cancel`() = runBlocking&lt;Unit&gt; &#123; val scope = CoroutineScope(Dispatchers.Default) scope.launch &#123; delay(1000) println(&quot;Job 1.&quot;) &#125; scope.launch &#123; delay(1000) println(&quot;Job 2.&quot;) &#125; delay(100) //需要加这个才能看到 打印 scope.cancel() delay(2000)&#125; CorountineScope和corountineScope的区别(大小写的区别，大写的可以取消) P27-取消兄弟协程12345678910111213141516@Testfun `test scope cancel`() = runBlocking&lt;Unit&gt; &#123; val scope = CoroutineScope(Dispatchers.Default) val job1 = scope.launch &#123; delay(1000) println(&quot;Job 1.&quot;) &#125; val job2=scope.launch &#123; delay(1000) println(&quot;Job 2.&quot;) &#125; delay(100) //需要加这个才能看到 打印 job1.cancel() delay(2000)&#125; 被取消的协程，不会影响其余的兄弟协程 1Job 2. 28-协程取消的异常1234567891011121314@Testfun `test CancellationException `() = runBlocking&lt;Unit&gt; &#123; val job1 = GlobalScope.launch &#123; try &#123; delay(1000) println(&quot;Job 1.&quot;) &#125;catch (e:Exception)&#123; e.printStackTrace() &#125; &#125; delay(100) job1.cancel(CancellationException(&quot;取消&quot;)) job1.join() // 否则不会打印GlobalScope不在runBlocking上下文&#125; java.util.concurrent.CancellationException: 取消 cpu密集型任务取消29cpu密集型任务取消 isActive isActive判断取消，否则还是计算5次,这个和线程while操作很像 p30- cpu密集型任务取消 - ensureActive 退出循环 p31-yiled取消 p32-coroutine取消副作用 p33 标准函数use自动关闭文件对象 34不能取消的任务NonCancellable 35超时任务网络请求超时 超时1300后的处理","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"}]},{"title":"Font","slug":"Font","date":"2021-11-23T14:15:14.000Z","updated":"2021-12-05T12:11:41.185Z","comments":true,"path":"2021/11/23/Font/","link":"","permalink":"https://noteforme.github.io/2021/11/23/Font/","excerpt":"","text":"https://segmentfault.com/a/1190000011299402 https://www.jianshu.com/p/4f9db19d9383 https://github.com/WaterYuanData/Camera2New/tree/SwitchLanguage/testlanguage https://www.jianshu.com/p/7a81e5ef268d https://blog.csdn.net/jdfkldjlkjdl/article/details/106279151 https://proandroiddev.com/change-language-programmatically-at-runtime-on-android-5e6bc15c758","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"coroutine_begin1","slug":"coroutine-begin1","date":"2021-11-08T13:18:20.000Z","updated":"2023-01-02T03:31:39.184Z","comments":true,"path":"2021/11/08/coroutine-begin1/","link":"","permalink":"https://noteforme.github.io/2021/11/08/coroutine-begin1/","excerpt":"","text":"协程是什么 03 协程的挂起与恢复 08 挂起阻塞的区别 09 协程的调度器 P13 Dispatchers.Main Dispatchers.IO Dispatchers.Default 任务泄漏 P14 结构化并发 p15使用结构化并发可以做到 CoutineScope P16GlobalScope mainscope协程 可以通过抛出异常取消.","categories":[],"tags":[{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"}]},{"title":"Language","slug":"Language","date":"2021-11-06T08:06:32.000Z","updated":"2021-11-07T08:19:37.360Z","comments":true,"path":"2021/11/06/Language/","link":"","permalink":"https://noteforme.github.io/2021/11/06/Language/","excerpt":"","text":"方式Android &lt; 7.0一下和以上不同, 7.0以下只要设置一次语言就可以 7.0或以上，必须在BaseActivity设置 BaseActivity处理所有的省事的做法，调用attachBaseContext,一起设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354object LanguageUtil &#123; @JvmStatic fun attachBaseContext(context: Context, language: String?): Context? &#123; val resources = context.resources val configuration = resources.configuration val locale = getLocaleByLanguage(language!!) configuration.setLocale(locale) return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; configuration.setLocales(LocaleList(locale)) context.createConfigurationContext(configuration) &#125; else &#123; //获取想要切换的语言类型 // updateConfiguration val dm = resources.displayMetrics resources.updateConfiguration(configuration, dm) context &#125; &#125; fun getLocaleByLanguage(language: String): Locale &#123; var locale: Locale if (language == TNGLanguageEnumType.CN.language) &#123; locale = Locale.SIMPLIFIED_CHINESE &#125; else if (language == TNGLanguageEnumType.MY.language) &#123; locale = Locale.forLanguageTag(&quot;ms&quot;) &#125; else &#123; locale = Locale.ENGLISH &#125; return locale &#125; @TargetApi(Build.VERSION_CODES.N) private fun updateResources(context: Context, language: String): Context &#123; val resources = context.resources val locale = getLocaleByLanguage(language) val configuration = resources.configuration configuration.setLocale(locale) configuration.setLocales(LocaleList(locale)) return context.createConfigurationContext(configuration) &#125; @JvmStatic fun setFontScaleLimit(context: Context): Context? &#123; val config = Configuration(context.resources.configuration) if (config.fontScale &gt; 1.2f || config.fontScale &lt; 1.0f) &#123; config.setToDefaults() config.fontScale = 1.1f &#125; return context.createConfigurationContext(config) &#125;&#125; 小于7.0设置一次changeAppLanguage() 调这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class LanguageUtil &#123; private static final String TAG = &quot;LanguageUtil&quot;; /** * @param context * @param newLanguage 想要切换的语言类型 比如 &quot;en&quot; ,&quot;zh&quot; */ @SuppressWarnings(&quot;deprecation&quot;) public static void changeAppLanguage(Context context, String newLanguage) &#123; if (TextUtils.isEmpty(newLanguage)) &#123; return; &#125; Resources resources = context.getResources(); Configuration configuration = resources.getConfiguration(); //获取想要切换的语言类型 Locale locale = getLocaleByLanguage(newLanguage); configuration.setLocale(locale); // updateConfiguration DisplayMetrics dm = resources.getDisplayMetrics(); resources.updateConfiguration(configuration, dm); &#125; public static Locale getLocaleByLanguage(String language) &#123; Locale locale = Locale.ENGLISH; if (language.equals(LanguageType.CHINESE.getLanguage())) &#123; locale = Locale.SIMPLIFIED_CHINESE; &#125; else if (language.equals(LanguageType.ENGLISH.getLanguage())) &#123; locale = Locale.ENGLISH; &#125; else if (language.equals(LanguageType.MY.getLanguage())) &#123; locale = Locale.forLanguageTag(language); &#125; Log.d(TAG, &quot;getLocaleByLanguage: &quot; + locale.getDisplayCountry()); return locale; &#125; public static Context attachBaseContext(Context context, String language) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; return updateResources(context, language); &#125; else &#123; return context; &#125; &#125; @RequiresApi(api = VERSION_CODES.N) private static Context updateResources(Context context, String language) &#123; Resources resources = context.getResources(); Locale locale = LanguageUtil.getLocaleByLanguage(language); Configuration configuration = resources.getConfiguration(); configuration.setLocale(locale); configuration.setLocales(new LocaleList(locale)); return context.createConfigurationContext(configuration); &#125; public static Context updateBaseContext(Context context, String language) &#123; Resources resources = context.getResources(); Configuration configuration = resources.getConfiguration(); Locale locale = LanguageUtil.getLocaleByLanguage(language); configuration.setLocale(locale); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; configuration.setLocales(new LocaleList(locale)); return context.createConfigurationContext(configuration); &#125;else &#123; //获取想要切换的语言类型 // updateConfiguration DisplayMetrics dm = resources.getDisplayMetrics(); resources.updateConfiguration(configuration, dm); return context; &#125; &#125;&#125; https://github.com/wisnukurniawan/changelanguage.git https://www.jianshu.com/p/4f9db19d9383","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"LC_binary_search_1","slug":"LC_binary_search_1","date":"2021-10-31T09:01:21.000Z","updated":"2023-11-07T14:28:55.924Z","comments":true,"path":"2021/10/31/LC_binary_search_1/","link":"","permalink":"https://noteforme.github.io/2021/10/31/LC_binary_search_1/","excerpt":"","text":"correct sentence grammar 704. Binary Search防止溢出 计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。 边界 leetcode收藏了 力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 代码随想录 First, solve the problem, and then review the one below. https://www.youtube.com/watch?v=6ysjqCUv3K4 https://www.youtube.com/watch?v=KXJSjte_OAI 考虑到边界情况，注意是 mid 是val mid = left + (right - left) / 2 , 而不是 val mid = right - (right - left) / 2 解法一 [left,right] while(left&lt;=right) 0 1 2 3 4 5 -1 0 3 5 9 12 left mid right target = 0 In my opinion, when the target is not equal to the midpoint, it’s better to understand left and right as open intervals. 12345678910111213141516fun search(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size -1 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 // consider left right border if (target == nums[mid]) &#123; return mid &#125; else if (target &gt; mid) &#123; left = mid + 1 &#125; else &#123; right = mid - 1 &#125; println(&quot;mid $mid left $left right $right&quot;) &#125; return -1&#125; I was thinking about the above answer, but if left = 0 and right = 1, if (1 == target), you will never get the right answer because (left + right) / 2 equals 0, so right cannot use nums.size -1. “It was incorrect in this scenario because when left is set to mid + 1, which is 1, it will correctly hit the desired result on the next iteration.” 1 2 3 4 7 9 10 find 2 0 1 2 3 4 5 6 1 2 3 4 7 9 10 Left Middle Right Middle Right [0,6] 12345678910111213141516//解法1 [0,nums.length-1]public int binarySearch1(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int middle = (left + right) / 2; if (target == nums[middle]) &#123; return middle; &#125; else if (target &lt; nums[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; return -1;&#125; 解法二while (left &lt; right)left == right在区间[left, right) [0,7) the size is 7, so while (left &lt; right) can easily understand, if (nums[middle]&gt;target) right = middle can not understand at first,but we need consider outside condition is while (left &lt; right) , next time is same , so right = middle , not middle - 1. target ==2 0 1 2 3 4 5 6 7 1 2 3 4 7 9 10 Left Middle Right Left Middle Right (0+7)/2 = 3 (0+3)/2=1 1234567891011121314// 解法2 [0,nums.length) fun search(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size while (left &lt; right) &#123; val mid = left + (right - left) / 2 if (nums[mid] &gt; target) &#123; right = mid &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1 &#125; else return mid &#125; return -1 &#125; 感觉还是解法1更好理解 ,不会容易出错。 35. 搜索插入位置(right - left) / 2 如果用 ((right - left) shr 2) 那么(right - left)要括起来，否则会符号优先级有问题. 这题没想到是插入left位置，最后一步right是可以移到 left位置或超过left, 力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 I am thinking that, after the while loop finishes, we compare the last ‘mid’ value to the target. If the target is less than the ‘mid’ value, then return ‘mid - 1’. 12345678910111213141516171819fun searchInsert(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 var mid = 0 while (left &lt;= right) &#123; // 1. missing &quot;==&quot; at firstly println(&quot;before left $left right $right&quot;) mid = left + (right - left) / 2 println(&quot;mid $mid &quot;) if (nums[mid] == target) &#123; return mid &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1 &#125; else if (target &gt; nums[mid]) &#123; left = mid + 1 &#125; println(&quot;after left $left right $right&quot;) &#125; return left //或者right+1 &#125; 69.x 的平方根​ 这题我的解法是这样的，但是还有问题 没通过 mid * mid.toLong() ,为什么 right - left + 1 即使退出循环 123456789101112131415161718192021222324 fun mySqrt(x: Int): Int &#123; var left = 0 var right = x while (left &lt; right) &#123; val mid = left + (right - left + 1) / 2 // 调试语句开始// try &#123;// Thread.sleep(1000);// &#125; catch (e: InterruptedException) &#123;// e.printStackTrace()// &#125;// println(&quot;left = $left, right = $right, mid = $mid&quot;)// 链接：https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/ if (mid * mid == x) &#123; return mid &#125; else if (mid * mid.toLong() &lt; x) &#123; left = mid &#125; else if (mid * mid.toLong() &gt; x) &#123; right = mid - 1 &#125; &#125; return left; &#125; 力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 有为什么产生死循环的讲解 367.有效的完全平方数 解答1234567891011121314151617class LC367 &#123; fun isPerfectSquare(num: Int): Boolean &#123; var left = 1 var right = num while (left &lt;= right) &#123; var mid = left + (right - left) / 2 if (mid * mid == num) &#123; return true &#125; else if (mid * mid &gt; num) &#123; right = mid - 1 &#125; else if (mid * mid &lt; num) &#123; left = mid + 1 &#125; &#125; return false &#125;&#125; ​ 测试用例超出限制 2147483647. , 因为mid *mid 超出int ​ 34.在排序数组中查找元素的第一个和最后一个位置(opens new window)https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/ 有符号 无符号的区别 对于有符号整数，每一次右移操作，高位补充的是1； 对于无符号整数，每一次右移操作，高位补充的则是0； 0x80000000 0xc0000000 0x40000000 https://juejin.cn/post/6844903969915944973","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[]},{"title":"kotlin-senior2","slug":"kotlin-senior2","date":"2021-09-11T10:04:06.000Z","updated":"2021-11-30T01:40:14.920Z","comments":true,"path":"2021/09/11/kotlin-senior2/","link":"","permalink":"https://noteforme.github.io/2021/09/11/kotlin-senior2/","excerpt":"","text":"Lambda表达式Lambda表达式、匿名函数、双冒号+函数名这三个东西，都是函数类型的对象，他们都能够赋值给变量以及当作函数的参数传递！ Lambda表达式的格式 Lambda表达式被大括号包围着 Lambda表达式的参数在-&gt;的左边，如果没有参数，则只保留函数体 Lambda表达式的函数体在-&gt;的后面 Lambda表达式的返回类型值总为函数体最后一行代码的返回值类型 无参数，无返回值的Lambda表达式123val test01Lambda = &#123; print(&quot;无参数,无返回值&quot;)&#125; 我们同样将Lambda表达式赋值给了变量，这个变量是函数类型（() -&gt; Unit）的对象。 有参数，无返回值的Lambda表达式123val test02Lambda = &#123; name: String -&gt; print(&quot;有参数,无返回值，参数值为：$name&quot;)&#125; 这个变量是函数类型（(String) -&gt; Unit）的对象。 如果我们手动给这个变量指明了类型，那么Lambda的参数类型还可以不写： 注意这个name参数 是回调方法传过来的参数. 123val test02Lambda: (String) -&gt; Unit = &#123; name -&gt; print(&quot;有参数,无返回值，参数值为：$name&quot;)&#125; 这个时候，Kotlin可以自动为我们推断出Lambda中这个参数的类型是String类型。 如果Lambda表达式的参数只有一个，我们甚至连这个参数都可以省略不写，那…我想使用这个参数的时候怎么办呢？我们可以用it来代替： 123val test02Lambda: (String) -&gt; Unit = &#123; print(&quot;有参数,无返回值，参数值为：$it&quot;)&#125; 有参数，有返回值的Lambda表达式12345val test03Lambda = &#123; doubleValue: Double -&gt; print(&quot;parameter is Double,Value is:$doubleValue&quot;) print(&quot;now parse Double into String&quot;) doubleValue.toString()&#125; Lambda表达式的最后一行代码将作为返回值，因此它对应的函数类型为：(Double) -&gt; String。同样，如果变量已经确切的指定了类型，则Lambda表达式的参数类型可以省略，又由于只有一个参数，所以连参数都可以省略，Kotlin将使用it代替这个参数名。 123456789101112131415161718192021222324252627val method: (String, String) -&gt; Unit = &#123; aStr, bStr -&gt; println(&quot;a : $aStr, b:$bStr&quot;) &#125;method(&quot;john&quot;,&quot;男&quot;)val method02 = &#123; println(&quot;john&quot;)&#125;val method03:(String)-&gt;Unit=&#123; println(&quot;传入的是:$it&quot;)&#125;method03(&quot;Jon&quot;)val method04:(Int)-&gt;Unit=&#123; when(it)&#123; 1-&gt; println(&quot;等于1&quot;) in 20.. 30 -&gt; println(&quot;20 - 30的数字&quot;) else -&gt; println(&quot;都不满足&quot;) &#125;&#125;method04(1)val method05 : (Int,Int)-&gt; Unit = &#123;aNumber,bNumber-&gt; println(&quot;第一个: $aNumber, 第二个 : $bNumber&quot;)&#125;method05(1,9)val method06 : (Int,Int)-&gt; Unit = &#123;aNumber,_-&gt; println(&quot;第一个: $aNumber&quot;)&#125;method06(99,88)val method07 : (String)-&gt;String = &#123;str -&gt; str&#125;println(method07(&quot;Jon&quot;)) 函数类型函数类型的书写格式所有函数类型都有一个圆括号括起来的参数类型列表，以及一个返回类型：(A, B) -&gt; C ，参数列表与返回值类型之间通过 -&gt; 符号连接。(A, B) -&gt; C表示接收类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 1val f: (Int) -&gt; String (Int) -&gt; String这就是一个函数类型。另外需要注意的是，即使函数类型的参数列表为空，也必须保留小括号，例如() -&gt; String；即使函数类型的返回值类型为Unit，也不可省略Unit不写，例如：(Int) -&gt; Unit。 函数类型的对象使用sum(1, 2)这我可以理解，毕竟sum是一个函数，但是block(1, 2)这样也行？block可是一个函数类型的对象啊，函数类型的对象后面可以加括号调用？ 没错，只有函数类型的对象可以，其实这是Kotlin为我们提供的一个语法糖，它本质上还是会去调用invoke函数，也就是说 12345val block: (Int, Int) -&gt; Int = ::sumfun sum(firstNumber: Int, secondNumber: Int): Int &#123; return firstNumber + secondNumber&#125; 12345678910val block: (Int, Int) -&gt; Int = ::sum// 以下调用都是有返回值的,因为(Int, Int) -&gt; Int这个函数类型是有返回值的block(1, 2)// 等价于block.invoke(1, 2)// 等价于(::sum)(1, 2)// 等价于(::sum).invoke(1, 2) Kotlin使用这种（函数类型对象能够使用括号访问）语法让我们感觉，嗯，block就是sum函数的替身，而实际上它是一个对象，一个函数类型的对象。 高阶函数什么是高阶函数12345btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 有没有想过为什么需要传一个匿名类过去？因为Framework会在该View被点击的时候调用我们在匿名类中实现的那个onClick方法，以便于执行我们自己的处理逻辑。 要是我们能直接将方法传过去就好了…梦该醒了，这是Java，只能通过接口 + 匿名内部类这种折中的方案来实现这样的需求。 而Kotlin有了函数类型，又有了高阶函数，意味着我们可以传入一段代码给函数了，函数可以在适当的时候执行我们传入的那段代码，完美的解决了这一痛点。 高阶函数的使用案例虽然都是过滤找出符合要求的苹果，但是条件是不一样的。这个怎么做呢？最简单的方法就是写三个循环，每个循环中针对不同的条件对苹果集合进行筛选。但是我们完全可以使用高阶函数和函数类型优雅的实现这个功能： 1data class AppleBean(val color:Int, val weight:Int) 123456789private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; val destination = mutableListOf&lt;AppleBean&gt;() for (appleBean in appleList) &#123; if (predicate(appleBean))&#123; destination.add(appleBean) &#125; &#125; return destination&#125; ，filterApple函数主要的功能只是遍历集合，以及把符合条件的苹果添加到新的集合中返回，至于筛选的条件，filterApple函数并不知道，而是完全取决于predicate这个函数类型的参数，只要predicate返回true，则符合条件。这样我们可以在调用函数时动态地传入不同的过滤规则 123456789101112131415161718192021fun main() &#123; filterApple(appleList, ::filterColorPredicate) filterApple(appleList, ::filterWeightPredicate) filterApple(appleList, ::filterColorAndWeightPredicate)&#125;private fun filterColorPredicate(appleBean: AppleBean): Boolean = appleBean.color == 0xFF0000private fun filterWeightPredicate(appleBean: AppleBean): Boolean = appleBean.weight &gt; 6private fun filterColorAndWeightPredicate(appleBean: AppleBean): Boolean = appleBean.color == 0xFF0000 &amp;&amp; appleBean.weight &gt; 6private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; val destination = mutableListOf&lt;AppleBean&gt;() for (appleBean in appleList) &#123; if (predicate(appleBean)) &#123; destination.add(appleBean) &#125; &#125; return destination&#125; 这…太麻烦了吧，我每次调用高阶函数，传入函数类型的时候，还必须要先定义一个函数，然后再使用::函数名传入吗？其实不必这么麻烦的，现在我们学习的只不过是其中的一种方式而已。下面我们就要来学习更加简单的方式：匿名函数。 Lambda表达式与高阶函数现在大家已经对Lambda表达式的写法了如指掌了，现在是时候来看看Lambda表达式如何与高阶函数配合使用了。还记得之前的那个筛选苹果的例子吗？我们定义了一个高阶函数，它的名字叫：filterApple，代码如下： 123456789private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; val destination = mutableListOf&lt;AppleBean&gt;() for (appleBean in appleList) &#123; if (predicate(appleBean)) &#123; destination.add(appleBean) &#125; &#125; return destination&#125; 这个高阶函数的第二个参数接收了一个函数类型的参数，在之前，我们分别使用了两种方式进行调用： 双冒号的方式： 12345fun main() &#123; filterApple(appleList, ::filterColorPredicate)&#125;private fun filterColorPredicate(appleBean: AppleBean): Boolean = appleBean.color == 0xFF0000 匿名函数的方式： 1filterApple(appleList, fun(appleBean: AppleBean): Boolean = appleBean.weight &gt; 6) 完整的写法 1filterApple(appleList, &#123; appleBean: AppleBean -&gt; appleBean.weight &gt; 6 &#125;) 简化的写法 我们怎么知道哪个参数需要传入Lambda表达式呢？当然是看被调用的这个高阶函数的定义啊，还记的这个高阶函数的样子吗？ 我们怎么知道哪个参数需要传入Lambda表达式呢？当然是看被调用的这个高阶函数的定义啊，还记的这个高阶函数的样子吗？ 123private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; // ...&#125; 显然第二个形参是一个函数类型的参数，并且已经明确的指出了形参的函数类型：(AppleBean) -&gt; Boolean（实际上也必须明确指出，否则报错）。根据我们前面所学习的知识，这种情况下，我们可以直接省略Lambda表达式中的参数类型，Kotlin会根据上下文自动推断： 1filterApple(appleList, &#123; appleBean -&gt; appleBean.weight &gt; 6 &#125;) 再简化的写法 由于这个函数类型只需要一个参数，因此我们还可以省略参数的名字，Kotlin会使用it代替，这在之前的Lambda讲解中，都是讲过的： 1filterApple(appleList, &#123; it.weight &gt; 6 &#125;) 再再简化的写法 第一个是：如果Lambda表达式作为函数的最后一个参数传入，那么它可以单独放在调用函数的括号后面： 1filterApple(appleList) &#123; it.weight &gt; 6 &#125; 第二个是：如果函数只接收一个函数类型的参数，我们传入Lambda表达式时，连函数调用的括号都可以去掉： 123456789fun main() &#123; test &#123; num1, num2 -&gt; // ... &#125;&#125;private fun test(block: (Int, Int) -&gt; Unit) &#123; // ...&#125; ​ 作者：HurryYu_YZH​ 链接：https://www.jianshu.com/p/8eb0623f08c6 项目实例Login01.kt123456789101112131415161718//传入一个具名函数，被调用后，获取参数fun test(resModel: ResModel)&#123; println(resModel.int)&#125;class LoginModelImpl &#123; fun loginOptions( mobileNo: String, metaInfo: String, block: (model: ResModel) -&gt; Unit ) &#123; val model = ResModel(8) block(model) // block.invoke(model) 这样写也可以 &#125;&#125;class ResModel(val int: Int) 1234567 val loginModelImpl = LoginModelImpl() val responseModel = ResModel(0) loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,::test) // 可以看到 fun test(resModel: ResModel)也被调用,可以理解被回调// loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;model: ResModel -&gt; model.toString() &#125;)// loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;model -&gt; model.toString() &#125;) loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;println(it.int)&#125;) //lambda只有一个参数，传入参数也可以省略,&#123;&#125;里面用it代替// loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;&#125;) // it可以用也可以不用 Login02.kt1234567891011121314151617181920fun main() &#123; loginAction(&quot;Jo1n&quot;, &quot;123456&quot;) &#123; if (it) &#123; println(&quot;登录成功&quot;) &#125; else println(&quot;登录失败&quot;) &#125;&#125;fun loginAction(userName: String, pwd: String, loginResponseResult: (Boolean) -&gt; Unit) &#123; if (userName == null || pwd == null) return loginEngine(userName, pwd, loginResponseResult)&#125;fun loginEngine(userName: String, pwd: String, loginResponseResult: (Boolean) -&gt; Unit) &#123; if (&quot;Jon&quot; == userName &amp;&amp; &quot;123456&quot; == pwd) &#123; loginResponseResult(true) &#125; else loginResponseResult(false)&#125; https://www.bilibili.com/video/BV1xv411k7Dd?p=3&amp;spm_id_from=pageDriver updateFastClickTime这个方法很形象, 匿名函数的参数 ,是回调时候传的 123456789fun updateFastClickTime(callback: ((currentTime: Long, lastClickTime: Long) -&gt; Unit)? = null): Long &#123; val curClickTime = System.currentTimeMillis() callback?.invoke( curClickTime, lastClickTime ) lastClickTime = curClickTime return curClickTime&#125; getOrElse 匿名函数的参数 ,是回调时候传的,返回T类型. 12345678910111213inline fun &lt;T&gt; List&lt;T&gt;.getOrElse( index: Int, defaultValue:(Int) -&gt; T //这个 (Int) -&gt; T 看不明白): Tpublic inline fun &lt;T&gt; Array&lt;out T&gt;.getOrElse(index: Int, defaultValue: (Int) -&gt; T): T &#123; return if (index &gt;= 0 &amp;&amp; index &lt;= lastIndex) get(index) else defaultValue(index)&#125; https://bbs.csdn.net/topics/399173319","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[]},{"title":"Dagger","slug":"Dagger","date":"2021-08-29T12:45:53.000Z","updated":"2023-01-02T03:31:39.066Z","comments":true,"path":"2021/08/29/Dagger/","link":"","permalink":"https://noteforme.github.io/2021/08/29/Dagger/","excerpt":"","text":"https://developer.android.google.cn/training/dependency-injection/dagger-basics https://www.bilibili.com/video/BV1hF411W7aj 动脑 注入3要素 注入流程 构造方法对象注入 创建User4对象 1class User4 @Inject constructor() 创建ApplicationComponent4 1234@Componentinterface ApplicationComponent4 &#123; fun inject(mainActivity: MainActivity4?)&#125; 执行注入. 123456789101112class MainActivity4 : AppCompatActivity() &#123; var TAG = javaClass.simpleName @Inject lateinit var user:User4 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main3) DaggerApplicationComponent4.create().inject(this) Log.i(TAG, &quot;onCreate: user= $user&quot;) &#125;&#125; 第三方对象注入(一)Module :Module可以提供多个对象，返回类型要不一样 。 Component :IOC容器, 用来注入对象,module集成到component身上,再由Component把对象注入到平时用的Activity或者目的类身上。 依赖的查找顺序为：先找@Module，如果找到了就停止，如果找不到就去找@Inject 1234567891011121314151617181920212223242526272829303132333435class HttpObject // 也可直接在这里提供对象,不用Module@Moduleclass HttpModule &#123; @Provides fun provideHttpObject():HttpObject&#123; // 针对第三方sdk的对象，可以灵活提供 return HttpObject() &#125;&#125;@Component(modules = [HttpModule::class, DataBaseModule::class])interface MyComponent &#123; //注入点 fun inject(activity: DaggerxxActivity)&#125;class DaggerxxActivity : AppCompatActivity() &#123; private val binding by lazy &#123; ActivityDaggerXxBinding.inflate(layoutInflater) &#125; private val TAG = &quot;DaggerxxActivity&quot; @Inject lateinit var httpObject: HttpObject @Inject lateinit var databaseObject: DatabaseObject override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(binding.root) DaggerMyComponent.create().inject(this) Log.i(TAG, &quot;onCreate: httpObject $httpObject databaseObject $databaseObject &quot;) &#125;&#125; https://juejin.cn/post/6844903850319544328 第三方对象注入(一)1class User6 1234567@Moduleclass AppModule6 &#123; @Provides fun provideUser(): User6 &#123; return User6() &#125;&#125; 12345@Singleton@Component(modules = [AppModule6::class])interface ApplicationComponent6 &#123; fun inject(mainActivity: MainActivity6)&#125; 1234567class MainActivity6 : AppCompatActivity() &#123; @Inject lateinit var user: User6 override fun onCreate(savedInstanceState: Bundle?) &#123; DaggerApplicationComponent6.create().inject(this) &#125;&#125; 依赖注入概念 构造方法注入 Setter注入(字段注入) 123456789101112131415161718192021public class Car &#123; Engine engine; //构造方法注入 public Car(Engine engine) &#123; this.engine = engine; &#125; // setter注入(字段注入) public void setEngine(Engine engine) &#123; this.engine = engine; &#125; public void start()&#123; engine = new Engine(); engine.start(); &#125; &#125;class Engine&#123; public void start()&#123;&#125;&#125; IOC框架 基于反射的方式实现： Spring IOC(动态的进行依赖关系的建立) 静态方式 ： 程序在编译时就已经提供好了建立依赖关系的类。Dagger2 两种注入方式 Dagger注入构造方法注入构造方法构造实例注入步骤 使用 @Inject注解在构造方法上；就是告知Dagger可以通过构造方法来创建并获取到User的实例 12// 1.使用 @Inject注解在构造方法上；就是告知Dagger可以通过构造方法来创建并获取到User的实例class User @Inject constructor() 当作IOC容器,把对象注入到目标类中 12345// 2. Component可以当作IOC容器,然后把对象注入到目标类中@Componentinterface ApplicationComponent &#123; fun inject(daggerActivity: DaggerActivity?) //指定DaggerActivity作为要注入的目标类&#125; 设置Inject注解 DaggerActivity.java 123//3.设置Inject注解@InjectUser user; 执行注入动作 12345678910111213 //3.设置Inject注解@InjectUser user; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger2);//4.执行注入动作 DaggerApplicationComponent.create().inject(this);//DaggerApplicationComponent相当于DaggerApplication的实现类 // DaggerApplicationComponent.create()获取到实例,inject(this)注入到Activity中 Log.i(TAG, &quot;user: &quot; + user); &#125; Dagger Module注入第三方框架的类，实现依赖注入， 上面User是我们自己定义的类， 第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 1234567891011121314@Moduleclass NetModule &#123; fun providerUser(): User &#123; return User() &#125; //第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 @Provides fun provideRetrofit(): Retrofit &#123; return Retrofit.Builder() .baseUrl(&quot;http://www.google.com&quot;) .build() &#125;&#125; compoent 123456&#x2F;&#x2F; 2. Component可以当作IOC容器,然后把对象注入到目标类中&#x2F;&#x2F; 设置作用域和ApplicationComponent组件的生命周期一致@Component(modules &#x3D; [NetModule::class]) &#x2F;&#x2F;模块装载到组件上去interface ApplicationComponent &#123; fun inject(daggerActivity: DaggerActivity?) &#x2F;&#x2F;指定DaggerActivity作为要注入的目标类&#125; DaggerActivity.java 1234567891011public class DaggerActivity extends AppCompatActivity &#123; String TAG = &quot;DaggerActivity&quot;; //3.设置Inject注解 @Inject Retrofit retrofit; Log.i(TAG, &quot;retrofit: &quot; + retrofit);&#125; Retrofit注入12345public interface ApiService &#123; @GET(&quot;/user/info&quot;) Call&lt;String&gt; requestInfo();&#125; 12345678//Module已经知道怎么获取retrofit实例//接着同一个Module中的方法，就可以作为参数直接传入 使用// 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例// 然后从当前容器直接获取@Providespublic ApiService provideApiService(Retrofit retrofit)&#123; return retrofit.create(ApiService.class);&#125; 12345@InjectApiService apiService;Log.i(TAG, &quot;apiService: &quot; +apiService); Module已经知道怎么获取retrofit实例接着同一个Module中的方法，就可以作为参数直接传入 使用// 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例// 然后从当前容器直接获取 123456789101112131415161718192021222324252627@Modulepublic class NetModule &#123; //第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 @Provides public Retrofit provideRetrofit()&#123; return new Retrofit.Builder() .baseUrl(&quot;http://www.google.com&quot;) .build(); &#125; //Module已经知道怎么获取retrofit实例 //接着同一个Module中的方法，就可以作为参数直接传入 使用 // 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例 // 然后从当前容器直接获取 @Provides public ApiService provideApiService(Retrofit retrofit)&#123; return retrofit.create(ApiService.class); &#125; @Provides public OkHttpClient provideOkHttpClient() &#123; return new OkHttpClient.Builder().build(); &#125;&#125; 局部单例实现 作用域 将某个对象的生命周期限定为其组件的生命周期。 下面User，Retrofit ,ApiService, OkHttpClient对象实例指定了作用域是Singleton,那么载入这些对象的组建ApplicationComponent1也必须用作用域是Singleton. 要么不使用 作用域 即默认的作用域， 如果使用的话，就必须保证他们的作用域一致。 局部实例112345678910111213141516171819202122232425262728293031323334353637383940414243//Dagger模块@Modulepublic class NetModule1 &#123; public User providerUser() &#123; return new User(); &#125; //第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 //@Provides //public Retrofit provideRetrofit() &#123; // return new Retrofit.Builder() // .baseUrl(&quot;http://www.google.com&quot;) // .build(); //&#125; @Singleton @Provides public Retrofit provideRetrofit(OkHttpClient okHttpClient) &#123; return new Retrofit.Builder() .client(okHttpClient) .baseUrl(&quot;http://www.google.com&quot;) .build(); &#125; //Module已经知道怎么获取retrofit实例 //接着同一个Module中的方法，就可以作为参数直接传入 使用 // 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例 // 然后从当前容器直接获取 @Singleton @Provides public ApiService provideApiService(Retrofit retrofit) &#123; return retrofit.create(ApiService.class); &#125; //@Singleton是Dagger提供的一种作用域 // 作用域就是用来管理Component来获取对象实例的生命周期 @Singleton @Provides public OkHttpClient provideOkHttpClient() &#123; return new OkHttpClient.Builder().build(); &#125;&#125; 12345678// 2. 当作IOC容器,把对象注入到目标类中@Singleton // 设置作用域和ApplicationComponent组件的生命周期一致@Component(modules = &#123;NetModule1.class&#125;) //模块装载到组件上去public interface ApplicationComponent1 &#123; void inject(DaggerActivity daggerActivity);//指定目标类 void inject(SecondActivity secondActivity);&#125; 1234567891011121314151617181920212223242526272829303132333435public class DaggerActivity extends AppCompatActivity &#123; String TAG = &quot;DaggerActivity&quot;; //3.设置Inject注解 @Inject User user; @Inject User user2; @Inject Retrofit retrofit; @Inject ApiService apiService; @Inject ApiService apiService2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger2); //4.执行注入动作 DaggerApplicationComponent.create().inject(this);//DaggerApplicationComponent相当于DaggerApplication的实现类 Log.i(TAG, &quot;user: &quot; + user); Log.i(TAG, &quot;user2: &quot; + user2); Log.i(TAG, &quot;retrofit: &quot; + retrofit); Log.i(TAG, &quot;apiService: &quot; +apiService); Log.i(TAG, &quot;apiService2: &quot; +apiService2); &#125;&#125; 运行结构 123452092-2092&#x2F;com.comm.util I&#x2F;DaggerActivity: user: com.comm.util.dagger.dn.di.User@2129cef2092-2092&#x2F;com.comm.util I&#x2F;DaggerActivity: user2: com.comm.util.dagger.dn.di.User@d97d3fc2092-2092&#x2F;com.comm.util I&#x2F;DaggerActivity: retrofit: retrofit2.Retrofit@d243a852092-2092&#x2F;com.comm.util I&#x2F;DaggerActivity: apiService: retrofit2.Retrofit$1@a1fa0da2092-2092&#x2F;com.comm.util I&#x2F;DaggerActivity: apiService2: retrofit2.Retrofit$1@a1fa0da 可以看到 user 是2个实例 apiService用了同一个对象实例,所以可以看到和DaggerApplicationComponent组件生命周期一致。 局部实例2添加一个Activity 1234567891011121314151617public class SecondActivity extends AppCompatActivity &#123; String TAG = &quot;SecondActivity&quot;; @Inject ApiService apiService3; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second2); //DaggerApplicationComponent相当于DaggerApplication的实现类 DaggerApplicationComponent.create().inject(this); Log.i(TAG, &quot;apiService3: &quot; + apiService3); &#125;&#125; 1void inject(SecondActivity secondActivity); 1startActivity(new Intent(this,SecondActivity.class)); 1237410-7410&#x2F;com.comm.util I&#x2F;DaggerActivity: apiService: retrofit2.Retrofit$1@a1fa0da7410-7410&#x2F;com.comm.util I&#x2F;DaggerActivity: apiService2: retrofit2.Retrofit$1@a1fa0da2021-08-29 22:28:35.812 7410-7410&#x2F;com.comm.util I&#x2F;SecondActivity: apiService3: retrofit2.Retrofit$1@84eb79a 不同的DaggerApplicationComponent组件，不同的实例 全局实例保证组件全局实例 Module作用域生命周期和 ApplicationComponent保持一致。 MyApplication.java 12345static ApplicationComponent applicationComponent = DaggerApplicationComponent.create();public static ApplicationComponent getApplicationComponent() &#123; return applicationComponent;&#125; 1MyApplication.getApplicationComponent().inject(this); 1238044-8044&#x2F;com.comm.util I&#x2F;DaggerActivity: apiService: retrofit2.Retrofit$1@516190b8044-8044&#x2F;com.comm.util I&#x2F;DaggerActivity: apiService2: retrofit2.Retrofit$1@516190b8044-8044&#x2F;com.comm.util I&#x2F;SecondActivity: apiService3: retrofit2.Retrofit$1@516190b 使用作用域遵循的规则 组件ApplicationComponent指定了作用域,组件中的模块modules = {NetModule.class}，也要指定相同的作用域。 NetModule中的方法设置@Singleton 那么ApplicationComponent也必须设置@Singleton NetModule中的方法设置@MyScope 那么ApplicationComponent也必须设置@MyScope 12345678@Singleton // 设置作用域和ApplicationComponent组件的生命周期一致，@Component(modules = &#123;NetModule.class&#125;)public interface ApplicationComponent &#123; void inject(DaggerActivity daggerActivity);//指定目标类 void inject(SecondActivity secondActivity);&#125; 组件依赖因为,一个Acitivty不能有两个组件直接注入,不如ApplicationComponent 和UserComponent. 组建依赖与子组建主要解决了不同作用域时组建之间复用问题. 在一个组件置顶作用域后，就已经确定了该组建创建对象的生命周期。 但是有些对象的实例可能生命周期更短。这个时候就需要定义新的组建。 新组件需要使用原组建的部分资源 两种实现方式 为@Component添加dependencies参数,指定该组建依赖新的组件。 直接使用@Subcomponent注解创建新的组件，并装载到父组件中。 https://www.bilibili.com/video/BV1Ki4y1A7hA?p=07 来看方式一 实例部分全局实现 Retrofit ,ApiService 进程下全局, User2类 Activity全局 MyScope是自定义的作用域，用Singleton也可以，主要是保证组建作用域全局单例，感觉和hilt有点不同 12345678910@MyScope // 设置作用域和ApplicationComponent组件的生命周期一致,如果ApplicationComponent是全局的，那么就是全局的@Component(modules = &#123;NetModule2.class&#125;) //模块装载到组件上去public interface ApplicationComponent2 &#123; void inject(DaggerUserActivity daggerActivity);//指定目标类 //dependencies = &#123;ApplicationComponent1.class&#125; Retrofit retrofit(); ApiService apiService();&#125; 123456@UserScope@Component(modules = [UserModule2::class], dependencies = [ApplicationComponent2::class])interface UserComponent2 &#123; fun inject(activity: DaggerUserActivity2) fun inject(activity: DaggerSecondActivity2)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940@Moduleclass NetModule2 &#123; fun providerUser(): User2 &#123; return User2() &#125; //第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 //@Provides //public Retrofit provideRetrofit() &#123; // return new Retrofit.Builder() // .baseUrl(&quot;http://www.google.com&quot;) // .build(); //&#125; @MyScope @Provides fun provideRetrofit(okHttpClient: OkHttpClient?): Retrofit &#123; return Retrofit.Builder() .client(okHttpClient) .baseUrl(&quot;http://www.google.com&quot;) .build() &#125; //Module已经知道怎么获取retrofit实例 //接着同一个Module中的方法，就可以作为参数直接传入 使用 // 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例 // 然后从当前容器直接获取 @MyScope @Provides fun provideApiService(retrofit: Retrofit): ApiService &#123; return retrofit.create(ApiService::class.java) &#125; //@Singleton是Dagger提供的一种作用域 // 作用域就是用来管理Component来获取对象实例的生命周期 @MyScope @Provides fun provideOkHttpClient(): OkHttpClient &#123; return OkHttpClient.Builder().build() &#125;&#125; 注意ApplicationComponent2要提供对应Module的方法 123456789@MyScope // 设置作用域和ApplicationComponent组件的生命周期一致，NetModule设置@Singleton 那么ApplicationComponent也必须设置@Component(modules = [NetModule2::class]) //模块装载到组件上去interface ApplicationComponent2 &#123; fun inject(daggerActivity: DaggerUserActivity) //指定目标类 //dependencies = &#123;ApplicationComponent1.class&#125; fun retrofit(): Retrofit fun apiService(): ApiService fun provideContext(): Context&#125; 12345678910111213public class MyApplication extends Application &#123; static ApplicationComponent2 applicationComponent = DaggerApplicationComponent2.create(); private static MyApplication app; public static ApplicationComponent2 getApplicationComponent2() &#123; return applicationComponent; &#125; //Dagger public static MyApplication getInstance() &#123; return app; &#125;&#125; 1234567891011121314151617181920212223242526272829303132class DaggerUserActivity2 : AppCompatActivity() &#123; var TAG = javaClass.simpleName @Inject lateinit var user1: User2 @Inject lateinit var user2: User2 @Inject lateinit var apiService1: ApiService @Inject lateinit var apiService2: ApiService var userComponent: UserComponent2? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_dagger_user) userComponent = DaggerUserComponent2.builder().applicationComponent2( MyApplication.getApplicationComponent2() ).build() userComponent?.inject(this) Log.i(TAG, &quot;user1: $user1&quot;) Log.i(TAG, &quot;user2: $user2&quot;) Log.i(TAG, &quot;apiService1: $apiService1&quot;) Log.i(TAG, &quot;apiService2: $apiService2&quot;) startActivity(Intent(this, DaggerSecondActivity2::class.java)) &#125;&#125; 从结果上, Retrofit 是全局单例，User2对象是Activity单例 123456399 10821-10821&#x2F;com.comm.util I&#x2F;DaggerUserActivity2: user1: com.comm.util.dagger.dn.di.User2@1da0e9b399 10821-10821&#x2F;com.comm.util I&#x2F;DaggerUserActivity2: user2: com.comm.util.dagger.dn.di.User2@1da0e9b399 10821-10821&#x2F;com.comm.util I&#x2F;DaggerUserActivity2: apiService1: retrofit2.Retrofit$1@12da238399 10821-10821&#x2F;com.comm.util I&#x2F;DaggerUserActivity2: apiService2: retrofit2.Retrofit$1@12da238438 10821-10821&#x2F;com.comm.util I&#x2F;DaggerSecondActivity2: user3: com.comm.util.dagger.dn.di.User2@8233396438 10821-10821&#x2F;com.comm.util I&#x2F;DaggerSecondActivity2: apiService3: retrofit2.Retrofit$1@12da238 提供全局Applicationdemo代码有问题 NPR 子组件方式优势 12345下面的interface ApplicationComponent3 父组件不用定义 这些方法 fun retrofit(): Retrofit fun apiService(): ApiService fun context(): Context 12345678// 2. 当作IOC容器,把对象注入到目标类中@MyScope // 设置作用域和ApplicationComponent组件的生命周期一致，NetModule设置@Singleton 那么ApplicationComponent也必须设置@Component(modules = [SubComponentModule::class]) //模块装载到组件上去interface ApplicationComponent3 &#123; fun inject(daggerActivity: DaggerUserActivity) //指定目标类 fun studentComponent():StudentComponent.Factory&#125; 12@Module(subcomponents = [StudentComponent::class])class SubComponentModule 1234567@Moduleclass StudentModule &#123; @Provides fun provideStudent(): Student &#123; return Student() &#125;&#125; 12345678910@Subcomponent(modules = [StudentModule::class])interface StudentComponent &#123; @Subcomponent.Factory interface Factory &#123; fun create(): StudentComponent &#125; fun inject(activity: DaggerSecondActivity3)&#125; 123456789101112131415class DaggerSecondActivity3 : AppCompatActivity() &#123; var TAG &#x3D; javaClass.simpleName @Inject lateinit var student: Student override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second2) DaggerApplicationComponent3.create().studentComponent().create().inject(this) Log.i(TAG, &quot;student: $student &quot;) &#125;&#125; 结果同样注入成功 /com.comm.util I/DaggerSecondActivity3: student: com.comm.util.dagger.dn.di.Student@6c29d80 Binds注入接口实例之前用的是 module总 provide对象提供方式 ,想下面这种的。 1234567@Moduleclass StudentModule &#123; @Provides fun provideStudent(): Student &#123; return Student() &#125;&#125; 通过这种方式注入的优势是,直接使用接口，不需要具体的实现, AInterfaceImpl01改成AInterfaceImpl02就能改注入实例 12@Injectlateinit var aInterface: AInterface 还一个优势是子组件StudentComponent也可以用来处理注入 1234567891011@Subcomponent(modules = [StudentModule::class])interface StudentComponent &#123; @Subcomponent.Factory interface Factory &#123; fun create(): StudentComponent &#125; fun inject(activity: DaggerSecondActivity3) fun inject(activity: DaggerSecondActivity4)&#125; 12class AInterfaceImpl01 : AInterfaceclass AInterfaceImpl02 : AInterface 1234567891011121314151617181920@Moduleabstract class TestModule &#123; @Binds abstract fun bindAInterface(impl: AInterfaceImpl01): AInterface // AInterfaceImpl01改成AInterfaceImpl02就能改注入 companion object &#123; @JvmStatic @Provides fun provideAInterfaceImpl01(): AInterfaceImpl01 &#123; return AInterfaceImpl01() &#125; @JvmStatic @Provides fun provideAInterfaceImpl02(): AInterfaceImpl02 &#123; return AInterfaceImpl02() &#125; &#125;&#125; 1234567@MyScope // 设置作用域和ApplicationComponent组件的生命周期一致@Component(modules = [SubComponentModule::class,TestModule::class]) //模块装载到组件上去interface ApplicationComponent3 &#123; fun inject(daggerActivity: DaggerUserActivity) //指定目标类 fun studentComponent():StudentComponent.Factory&#125; 123456789101112131415161718class DaggerSecondActivity4 : AppCompatActivity() &#123; var TAG = javaClass.simpleName @Inject lateinit var student: Student @Inject lateinit var aInterface: AInterface override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second2) DaggerApplicationComponent3.create().studentComponent().create().inject(this) Log.i(TAG, &quot;student: $student &quot;) Log.i(TAG, &quot;aInterface: $aInterface &quot;) &#125;&#125; 相同类创建不同的对象123456789101112131415@Moduleclass StudentModule &#123; @Named(&quot;student1&quot;) // @Named 是Qualifier的实现 @Provides fun provideStudent(): Student &#123; return Student() &#125; @Named(&quot;student2&quot;) @Provides fun provideStudent2(): Student &#123; return Student(&quot;John&quot;) &#125;&#125; 1234567891011121314151617181920212223class DaggerSecondActivity4 : AppCompatActivity() &#123; var TAG = javaClass.simpleName @Named(&quot;student1&quot;) @Inject lateinit var student1: Student @Named(&quot;student2&quot;) @Inject lateinit var student2: Student override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second2) DaggerApplicationComponent3.create().studentComponent().create().inject(this) Log.i(TAG, &quot;StudentQualifier1: $StudentQualifier1 &quot;) Log.i(TAG, &quot;StudentQualifier2: $StudentQualifier2 &quot;) &#125;&#125; 也可以自定义标识,注解标识，通过标识找到对象 12345@Qualifier@Documented@Retention(RUNTIME)public @interface StudentQualifier1 &#123;&#125; 123456789101112131415161718192021222324252627282930313233@Moduleclass StudentModule &#123; @Provides fun provideStudent1(): Student &#123; return Student() &#125; @Named(&quot;student1&quot;) // @Named 是Qualifier的实现 @Provides fun provideStudent(): Student &#123; return Student() &#125; @Named(&quot;student2&quot;) @Provides fun provideStudent2(): Student &#123; return Student(&quot;John&quot;) &#125; @StudentQualifier1 // @Named 是Qualifier的实现 @Provides fun provideQualifierStudent(): Student &#123; return Student() &#125; @StudentQualifier2 @Provides fun provideQualifierStudent2(): Student &#123; return Student(&quot;Qualifier2 John&quot;) &#125;&#125; 123456789101112131415161718192021class DaggerSecondActivity4 : AppCompatActivity() &#123; var TAG = javaClass.simpleName @StudentQualifier1 @Inject lateinit var StudentQualifier1: Student @StudentQualifier2 @Inject lateinit var StudentQualifier2: Student override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second2) DaggerApplicationComponent3.create().studentComponent().create().inject(this) Log.i(TAG, &quot;StudentQualifier1: $StudentQualifier1 &quot;) Log.i(TAG, &quot;StudentQualifier2: $StudentQualifier2 &quot;) Log.i(TAG, &quot;aInterface: $aInterface &quot;) &#125;&#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"kotlin-ext-func","slug":"kotlin-ext-func","date":"2021-08-22T05:27:15.000Z","updated":"2023-01-02T03:31:39.226Z","comments":true,"path":"2021/08/22/kotlin-ext-func/","link":"","permalink":"https://noteforme.github.io/2021/08/22/kotlin-ext-func/","excerpt":"","text":"拓展函数 1234567891011//给字符串追加若干个 !fun String.addExt(amount:Int=1)= this + &quot; !&quot;.repeat(amount)fun Any.easyPrint() = println(this) //默认是public//fun Any.easyPrint() = println(this) //不能定义两次fun main() &#123; println(&quot;abc&quot;.addExt(2)) &quot;abc&quot;.easyPrint() 15.easyPrint()&#125; 类型别名 typealias 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。 https://www.kotlincn.net/docs/reference/type-aliases.html 泛型拓展函数 1234567891011121314//给字符串追加若干个 !fun String.addExt(amount:Int=1)= this + &quot; !&quot;.repeat(amount)fun &lt;T&gt; T.easyPrint():T&#123; println(this) return this&#125;fun main() &#123; &quot;abc&quot;.addExt(2).easyPrint() 15.easyPrint() 15.also &#123; &#125; val let = &quot;abc&quot;.let &#123; 50 &#125;&#125; Let源码12345678// &quot;abc&quot;调用let，传进来参数就是&quot;abc&quot;类型T为String// let返回lambda表达式执行的结果 50 类型R为Intpublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block(this)&#125; 拓展属性给String类添加一个拓展 12345678910111213141516//给字符串追加若干个 !fun String.addExt(amount: Int = 1) = this + &quot; !&quot;.repeat(amount)val String.numVowels get() = count &#123; &quot;aeiou&quot;.contains(it) &#125;fun &lt;T&gt; T.easyPrint(): T &#123; println(this) return this&#125;fun main() &#123; &quot;abc&quot;.addExt(2).easyPrint() &quot;The people&#x27;s Republic of China&quot;.numVowels.easyPrint()&#125; 可空类拓展可以定义拓展函数用于可空类型，在可空类型上定义拓展函数，你可以直接在拓展函数体内借鉴可能出现的空值问题。 12345678//就是String后加?fun String?.printWithDefault(default:String) =print(this ?: default) //null打印默认值,不为null 打印自身fun main() &#123;// val nullableString:String? = null val nullableString:String? = &quot;hehe&quot; nullableString.printWithDefault(&quot;abc&quot;) // nullableString?就不会设置默认值&#125; Infix 12345678910infix fun String?.printWithDefault(default:String) =print(this ?: default) //null打印默认值,不为null 打印自身fun main() &#123;// val nullableString:String? = null val nullableString:String? = &quot;hehe&quot; nullableString.printWithDefault(&quot;abc&quot;) // nullableString?就不会设置默认值 nullableString printWithDefault &quot;abc&quot; // 加了infix可以简化成这样 &quot;girl&quot;.to(18) mapOf(&quot;girl&quot; to 18)&#125; 12//to是拓展函数，返回 Pair&lt;A,B&gt;public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 定义拓展文件1234567891011package com.util.kotin.extensionfun &lt;T&gt; Iterable&lt;T&gt;.randomTake(): T = this.shuffled().first()fun main() &#123; var list = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) var set = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) list.shuffled().first() list.randomTake()&#125; 重命名拓展123456789import com.util.kotin.extension.randomTake as Randomizerfun main() &#123; var list = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) var set = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) list.shuffled().first()// list.randomTake() list.Randomizer()&#125; Apply源码T.()什么意思 这个就是 带接收者的函数字面量，拓展函数里自带了接收者对象的this隐式调用 123456public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block() return this&#125;T.() -&gt; Unit //T.() 表示 任何类型无参数的拓展函数，匿名函数也可以是拓展函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.File//fun String.addExt(amount: Int = 1) = this + &quot; !&quot;.repeat(amount)fun String.addExt() = &quot; !&quot;.repeat(this.count())// 泛型的拓展函数fun &lt;T&gt; T.easyPrint(): Unit = println(this)// T.apply 返回的还是T// T.() -&gt; Unit 传入拓展函数(泛型), 而不是普通的匿名函数() -&gt; Unit ,没用泛型T就会报错,T表示可以用任意类型// 拓展函数里自带了接收者对象的this隐式调用// 匿名函数，也可以是 拓展函数//普通的匿名函数 ()-&gt;Unit//匿名函数内部this指向一个File对象,隐式调用，File.() -&gt; Unitpublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block() return this&#125;/*public inline fun &lt;File&gt; File.apply(block: File.() -&gt; Unit): File &#123; block() return this&#125;*/fun main() &#123; val file = File(&quot;xx&quot;).apply &#123; this.setReadable(true) //默认又一个对象指向File &#125; val file = File(&quot;xx&quot;).apply &#123; this.setReadable(true) //如果是 () -&gt; Unit这样，这里就会报错，没有File类型了 &#125; //这里分解一下 //1. 定义拓展函数 fun File.ext(): Unit &#123; setReadable(true) &#125; //2.给block变量赋值 val block = File::ext //3.传入apply函数 File(&quot;xxx&quot;).apply &#123; block &#125; doSomething &#123; goFix() &#125; &quot;abcefg&quot;.addExt().easyPrint() // &quot;abcefg&quot;调用addExt() ,addExt()有一个对象指向&quot;abcefg&quot; &quot;abc&quot;.apply &#123; &#125;&#125;fun doSomething(fix: () -&gt; Unit) &#123; fix&#125;fun goFix(): Unit &#123; &quot;goFxi&quot;&#125; 案例LoginModel.kt1234RpcExpress.pack &#123; request.mobileNo = mobileNo request.metaInfo = metaInfo&#125; 12345678inline fun &lt;reified T : RpcRequest, reified R : RpcResult, reified E : RpcTask&gt; pack( build: RpcPackage&lt;T, R, E&gt;.() -&gt; Unit): RpcExecutor&lt;T, R, E&gt; &#123; val rpcPackage = RpcPackage&lt;T, R, E&gt;(T::class.java.newInstance(), R::class.java, E::class.java) build(rpcPackage) // 也可以写成 rpcPackage?.build() , 给rpcPackage赋值 return this.pack(rpcPackage)&#125; 函数式编程 函数类别 Map变换 123456789val animals = listOf(&quot;zebra&quot;, &quot;giraffe&quot;, &quot;elephant&quot;, &quot;rat&quot;)val banies = animals.map &#123; animal -&gt; &quot;A baby $animal&quot;&#125;.map &#123; baby -&gt; &quot;$baby , with the cutest little tail ever!&quot;&#125;println(animals)println(banies) 12val animalsLength = animals.map &#123; it.length &#125;println(animalsLength) flatMapfaltMap函数操作一个集合的集合，将其中多个集合中的元素的合并后返回一个包含所有元素的单一集合。 12val result = listOf(listOf(1, 2, 3), listOf(4, 5, 6)).flatMap &#123; it &#125;println(result) 过滤 1234val result = listOf(&quot;Jack&quot;,&quot;Jimmy&quot;,&quot;Rose&quot;,&quot;Tom&quot;).filter &#123; it.contains(&quot;J&quot;)&#125;println(result) 1234567val items = listOf( listOf(&quot;rea apple&quot;, &quot;green apple&quot;, &quot;blue apple&quot;), listOf(&quot;red fish&quot;, &quot;blue fish&quot;), listOf(&quot;yellow banana&quot;, &quot;teal banana&quot;))val redItems = items.flatMap &#123; it.filter &#123; it.contains(&quot;red&quot;) &#125; &#125;println(redItems) 找素数找素数，除了1和它本身，不能被任何数整除的数。 1234567// 除了1和它本身， 不梦被任何数整除的数// 取模等于0，说明能够整除，如果没有一个是等于0的，说明是素数。val numbers = listOf(7, 4, 8, 4, 3, 22, 18, 11)val primes = numbers.filter &#123; number -&gt; (2 until number).map &#123; number % it &#125;.none &#123; it == 0 &#125;&#125;println(primes) 合并合并是函数式编程的第三大类函数，合并能将不同的集合合并成一个新的集合。这个接收者是包含集合的的集合的flatmap函数不同。 zip12345val list1 = listOf(&quot;jon&quot;, &quot;john1&quot;, &quot;john2&quot;)val list2 = listOf(&quot;l1&quot;, &quot;l2&quot;, &quot;l3&quot;)val toMap = list1.zip(list2).toMap()println(toMap) {jon=l1, john1=l2, john2=l3} Fold可以用来合并值的合并函数是fold，这个合并函数接受一个初始累加器值，随后会根据匿名函数的结构更新。 fold(0) accumulator从0开始 123456//将每个元素值 乘以3后累加起来val foldedValue = listOf(1, 2, 3, 4).fold(0) &#123; accumulator, number -&gt; println(&quot;Accmulator value: $accumulator&quot;) accumulator + (number * 3)&#125;println(&quot;Find value: $foldedValue&quot;) Accmulator value: 0Accmulator value: 3Accmulator value: 9Accmulator value: 18Find value: 30 序列 123456789101112131415161718192021//判断是否是素数fun Int.isPrime(): Boolean &#123; (2 until this).map &#123; if (this % it == 0) &#123; return false &#125; &#125; return true&#125;fun main() &#123; //产生头1000个元素 //假定 0 - 5000之内，可以找到1000个元素 val toList = (1..5009).toList().filter &#123; it.isPrime() &#125;.take(1000) println(toList.size) val oneThousandPrimes = generateSequence(2) &#123; value -&gt; value + 1 &#125;.filter &#123; it.isPrime() &#125;.take(1000) println(oneThousandPrimes.toList().size)&#125; 互操作性与可空性 1234567891011121314151617181920212223public class Jhava &#123; private int hitPoints = 3232320; public int getHitPoints() &#123; System.out.println(&quot;----hitPoints-----&quot;); return hitPoints; &#125; public String utterGreeting() &#123; return &quot;HELLO&quot;; &#125; public static void main(String[] args) &#123;// System.out.println(HeroKt.makeProclamation()); &#125; @Nullable public String determineFriends() &#123; return null; &#125;&#125; 123456789fun main() &#123; val adversary = Jhava() println(adversary.utterGreeting()) // determineFriends String! 平台类型// val level = adversary.determineFriends().toLong()// level?.toLong() println(adversary.hitPoints)&#125; HELLO—-hitPoints—–3232320 @JvmName注解指定编译类的名字​ 12345@file:JvmName(&quot;Hero&quot;)import senior.Jhavafun makeProclamation() = &quot;Greetings , beast!&quot; @JvmField 123456class SpellBook &#123; val spells = listOf(&quot;Magic Ms . L&quot;, &quot;Lay onHans&quot;) @JvmField val spells1 = listOf(&quot;Magic Ms . L&quot;, &quot;Lay onHans&quot;)&#125; 1234SpellBook spellBook = new SpellBook();List&lt;String&gt; spells = spellBook.getSpells();List&lt;String&gt; spells1 = spellBook.spells1; // 直接用这个属性名，不用加get前缀 @JvmOverloads12345//调用者可以指定英雄左手或右手拿什么食物，或者使用默认的配置 - 左手拿浆果，右手拿牛肉@JvmOverloadsfun handoverFood(leftHand: String = &quot;berries&quot;, rightHand: String = &quot;beef&quot;) &#123; println(&quot;Mmmm... you hand over some delicious $leftHand and $rightHand&quot;)&#125; 可以看到编译器默认对类添加了重载 123456789@JvmOverloadspublic static final void handoverFood(@NotNull String leftHand) &#123; handoverFood$default(leftHand, (String)null, 2, (Object)null);&#125;@JvmOverloadspublic static final void handoverFood() &#123; handoverFood$default((String)null, (String)null, 3, (Object)null);&#125; 但是代码中我获取不到 Herokt 类。 https://www.bilibili.com/video/BV1wf4y1s7TG?p=144&amp;spm_id_from=pageDriver @JvmStatic@JvmField注解还能用来以静态方式提供伴生对象里定义的值 @JvmStatic注解的作用类似于@JvmField, 允许你直接调用伴生对象里的函数 12345678class SpellBook &#123; companion object&#123; @JvmField val MAX_SPELL_COUNT = 10 fun getSpellbookGreeting() = println(&quot;I am the Great man!&quot;) &#125;&#125; 加了@JvmField注解 就不用加 Companion调用 12345//伴生对象SpellBook.Companion.getSpellbookGreeting();//添加@JvmField 支持静态调用int maxSpellCount = SpellBook.MAX_SPELL_COUNT; @Throws ​ 123456public class Jhava &#123; public void extendHandInFriendship() throws IOException &#123; throw new IOException(); &#125;&#125; Java异常 java处理123456try &#123; //在java里面强制 在编译器处理的异常 new Jhava().extendHandInFriendship();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Java异常 kotlin处理Hero.kt 12345try &#123; adversary.extendHandInFriendship()&#125;catch (e:Exception)&#123; println(&quot;exception&quot;)&#125; kotlin异常Java处理 Hero.kt 123fun acceptApology() &#123; throw IOException()&#125; 12345try &#123; HeroKt.acceptApology();&#125; catch (IOException e) &#123; //报错 Exception &#x27;java.io.IOException&#x27; is never thrown in the corresponding try block e.printStackTrace();&#125; 编译器把kotlin转成了Throwable 123public static final void acceptApology() &#123; throw (Throwable)(new IOException());&#125; 所以catch Throwable异常没问题 12345try &#123; HeroKt.acceptApology();&#125; catch (Throwable e) &#123; e.printStackTrace();&#125; 添加throws注解处理1234@Throws(IOException::class)fun acceptApology1() &#123; throw IOException()&#125; 12345try &#123; HeroKt.acceptApology1();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Function 12345//添加一个translator的函数，接收一个字符串//将其改为小写字面，再大写第一个字符，最后打印结构var translator : (String)-&gt;Unit = &#123; utterance: String -&gt; println(utterance.toLowerCase().capitalize())&#125; 12Function1&lt;String, Unit&gt; translator &#x3D; HeroKt.getTranslator();translator.invoke(&quot;TRUECE&quot;);","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[]},{"title":"kotlin-object-generic","slug":"kotlin-object-generic","date":"2021-08-21T13:02:57.000Z","updated":"2023-01-02T03:31:39.283Z","comments":true,"path":"2021/08/21/kotlin-object-generic/","link":"","permalink":"https://noteforme.github.io/2021/08/21/kotlin-object-generic/","excerpt":"","text":"https://www.bilibili.com/video/BV1wf4y1s7TG?p=95 generic object目录下 对象相关继承类默认是封闭的，要让某个类开放继承，必须使用opem关键字修饰它 123456789101112open class Product(val name:String) &#123; fun description() = &quot;Product: $name&quot; open fun load() = &quot;Nothing..&quot;&#125;class LuxuryProduct : Product(&quot;Luxury&quot;)&#123; override fun load() =&quot; LuxuryProduct loading&quot;&#125;fun main() &#123; val p : Product = LuxuryProduct() println(p.load())&#125; 类型检测 智能类型转换 12345678println(p is Product)println(p is LuxuryProduct)println(p is File)if (p is LuxuryProduct)&#123; println((p as LuxuryProduct).special()) println(p.special()) //只要转换一次，后面就直接可以使用，不用转换&#125; Kotlin层次无须在代码里显示指定，每一个类都会继承一个共同的叫做Any的超类。 Object关键字定义一个能产生一个实例的类- 单例 Object关键字有三种方式 对象声明 有利于组织代码和管理状态，尤其是管理整个应用运行生命周期内的某些一致性状态 对象表达式 1234567891011open class Player &#123; open fun load() = &quot;loading nothing..&quot;&#125;fun main() &#123; //匿名内部类，实例p对象 val p = object : Player()&#123; override fun load()= &quot;anonymous nothing..&quot; &#125; println(p.load())&#125; 伴生对象 123456789101112131415/** * 只要调用load() 或者实例化ConfigMap, 这个companion object才会被实例化 * 而且也是单例的 */class ConfigMap &#123; companion object&#123; private const val PATH = &quot;xxxx&quot; fun load() = File(PATH).readBytes() &#125;&#125;fun main() &#123; // 类似于Java static ConfigMap.load()&#125; 类相关嵌套类 在Java中，当你在另一个类中声明一个类时，它会默认变成内部类。而在Kotlin中，没有显式修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用inner修饰符。 嵌套类和内部类在Java与Kotlin中的对应关系 类A在另一个类B中声明 在Java中 在Kotlin中 嵌套类（不存储外部类的引用） static class A class A 内部类（存储外部类的引用） class A inner class A https://blog.csdn.net/weixin_41953808/article/details/112450204 https://juejin.cn/post/6844903910084182030 123456789101112class InnerClassTest &#123; class Equipment(var name:String)&#123; fun show() = println(&quot;equipment:$name&quot;) &#125; fun battle()&#123; &#125;&#125;fun main() &#123; InnerClassTest.Equipment(&quot;shap knife&quot;).show()&#125; 在Kotlin中引用外部类实例的语法，需要使用this@Outer从Inner类去访问Outer类： 12345class Outer &#123; inner class Inner&#123; fun getOuterReference():Outer = this@Outer &#125;&#125; 数据类 数据类使用条件 12345678data class Coordinate(var x:Int,var y:Int) &#123; val isInBounds = x &gt; 0 &amp;&amp; y &gt; 0&#125;fun main() &#123; println(Coordinate(10,20)) println(Coordinate(10,20)==Coordinate(10,20)) //data默认重写equals方法&#125; 结果 Coordinate(x=10, y=20) // 说明默认提供了toString方法 重写了equals方法 123456789101112131415 public boolean equals(@Nullable Object var1) &#123; if (this != var1) &#123; if (var1 instanceof Coordinate) &#123; Coordinate var2 = (Coordinate)var1; if (this.x == var2.x &amp;&amp; this.y == var2.y) &#123; return true; &#125; &#125; return false; &#125; else &#123; return true; &#125; &#125;&#125; Copy 注意:次构造函数数据不会copy过来 1234567891011121314151617181920212223242526272829data class Student( var name: String, val age: Int //age 主构造函数里声明的属性)&#123; private val hobby = &quot;music&quot; val subject:String var score = 0 init &#123; println(&quot;initializing student&quot;) subject = &quot;english&quot; //Init初始化块里的属性赋值和函数调用 &#125; constructor(_name: String):this(_name,10)&#123; score = 10; //次构造函数数据不会copy过来 &#125; override fun toString(): String &#123; return &quot;Student(name=&#x27;$name&#x27;, age=$age, hobby=&#x27;$hobby&#x27;, subject=&#x27;$subject&#x27;, score=$score)&quot; &#125;&#125;fun main() &#123; val s = Student(&quot;Jon&quot;) val copy = s.copy(&quot;girl&quot;) var s2 = s.copy(name = &quot;girl2&quot;, age = 18) println(s) println(s2) println(copy)&#125; 解构声明 普通类 123456789class PlayerScore(val experience:Int,val level:Int) &#123; operator fun component1() = experience operator fun component2() = level&#125;fun main() &#123; val (x,y) = PlayerScore(10, 20) println(&quot;$x, $y&quot;)&#125; Data数据类 数据类自动生成解构语法 1234567891011data class Coordinate(var x:Int,var y:Int) &#123; val isInBounds = x &gt; 0 &amp;&amp; y &gt; 0&#125;fun main() &#123; println(Coordinate(10,20)) println(Coordinate(10,20)==Coordinate(10,20)) val(x,y) = Coordinate(10,20) //数据类自动生成解构语法 println(&quot;$x , $y&quot;)&#125; 运算符重载如果要将内置运算符应用在自定义类身上，你必须重写运算符函数，告诉编译器该如何操作自定义类 1234567891011data class Coordinate2(var x:Int,var y:Int) &#123; val isInBounds = x &gt; 0 &amp;&amp; y &gt; 0 operator fun plus(other:Coordinate2) = Coordinate2(x + other.x,y+other.y)&#125;fun main() &#123; val c1=Coordinate2(10, 20) val c2=Coordinate2(10, 20) println(c1 + c2)&#125; 枚举类用来定义常量集合特殊的类 枚举类是一个实例 1234567891011enum class Direction &#123; EAST, WEST, SOUTH, NORTH&#125;fun main() &#123; println(Direction.EAST) println(Direction.EAST is Direction)&#125; 枚举类定义函数123456789101112131415enum class Direction2(private val coordinate: Coordinate) &#123; // 枚举里可以有属性 EAST(Coordinate(1, 0)), //EAST()是Direction2的实例 WEST(Coordinate(-1, 0)), SOUTH(Coordinate(-1, 0)), NORTH(Coordinate(1, 0)); //枚举里可以定义函数 fun updateCoordinate(playerCoordinate: Coordinate) = Coordinate(playerCoordinate.x + coordinate.x, playerCoordinate.y + coordinate.y)&#125;fun main() &#123; println(Direction2.EAST.updateCoordinate(Coordinate(10, 20)))&#125;//打印 11 20 代数数据类型可以用来表示一组子类型的闭集，枚举类就是一种简单的ADT 密封类 class Qualified(val licenseId:String):LicenseStatus2() 保存数据，如果用emum类 会很麻烦 123456789101112131415161718192021222324//密封类sealed class LicenseStatus2 &#123; //下面3个类都是 密封类的子类 object UnQualified:LicenseStatus2() // 没有属性 用单例，否则每次够构建新的对象 object Learning:LicenseStatus2() class Qualified(val licenseId:String):LicenseStatus2() //密封类的特性 用来保存数据,可能licenseId不一样，所以用class&#125;class Driver2(var status: LicenseStatus2)&#123; fun checkLicense():String&#123; return when(status)&#123; is LicenseStatus2.UnQualified -&gt; &quot;没资格&quot; is LicenseStatus2.Learning -&gt; &quot;在学&quot; is LicenseStatus2.Qualified -&gt; &quot;有资格，驾驶证编号: $&#123;((this.status as LicenseStatus2.Qualified).licenseId)&#125;&quot; &#125; &#125;&#125;fun main() &#123; val status1 = LicenseStatus2.Learning val status = LicenseStatus2.Qualified(&quot;2333003&quot;) // 可以直接传驾驶证编号 val driver = Driver2(status) println(driver.checkLicense())&#125; 接口 InterfaceTest.kt 123456789101112131415interface Movable&#123; var maxSpeed:Int var wheels:Int fun move(movable:Movable):String&#125;class Car(_name:String,override var wheels:Int=4):Movable&#123; override var maxSpeed: Int get() = TODO(&quot;Not yet implemented&quot;) set(value) &#123;&#125; override fun move(movable: Movable): String &#123; TODO(&quot;Not yet implemented&quot;) &#125;&#125; 默认实现可以在接口里提供默认属性getter方法和函数实现 123456789101112131415161718interface Movable&#123; val maxSpeed:Int get() = (1..500).shuffled().last() var wheels:Int fun move(movable:Movable):String&#125;class Car(_name:String,override var wheels:Int=4):Movable&#123; override var maxSpeed: Int get() = super.maxSpeed set(value) &#123;&#125; override fun move(movable: Movable): String &#123; TODO(&quot;Not yet implemented&quot;) &#125;&#125; 抽象类 123456789101112abstract class Gun(val range: Int) &#123; abstract fun pullTrigger(): String protected fun doSomething() &#123; println(&quot;doSomething&quot;) &#125;&#125;class AK47(val price: Int) : Gun(range = 500)&#123; override fun pullTrigger(): String &#123; TODO() &#125;&#125; 泛型定义泛型类 magicBox1.kt 12345678910class MagicBox&lt;T&gt;(item:T)&#123; protected var subject:T = item&#125;class Boy(val name:String,val age:Int)class Dog(val weight:Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20)) val box2 = MagicBox(Dog( 20))&#125; 泛型函数 泛型参数也可以用于函数。 定义一个函数用于获取元素，当且仅当MagicBox可用时，才能获取元素。 magicBox2.kt 12345678910111213141516171819class MagicBox&lt;T&gt;(item: T) &#123; var available = false protected var subject: T = item fun fetch(): T? &#123; // 泛型函数 return subject.takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125;&#125;class Boy(val name: String, val age: Int)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20)) val box2 = MagicBox(Dog(20)) box1.available = true box1.fetch()?.run &#123; println(&quot;you find $name&quot;) &#125;&#125; 多泛型参数magicBox3.kt 12345678910111213141516171819202122232425262728293031class MagicBox&lt;T&gt;(item: T) &#123; var available = false protected var subject: T = item fun fetch(): T? &#123; return subject.takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject).takeIf &#123; available &#125; &#125;&#125;class Boy(val name: String, val age: Int)class Man(val name: String, val age: Int)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20)) val box2 = MagicBox(Dog(20)) box1.available = true box1.fetch()?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch &#123; Man(it.name, it.age.plus(15)) // Boy 转成Man了 &#125;&#125; 泛型类型约束确保MagicBox只能装指定类型的物品， 如Human类型，咋弄? magicBox4.kt 1234567891011121314151617181920212223242526272829303132class MagicBox4&lt;T:Human&gt;(item: T) &#123; //这里添加约束 var available = false protected var subject: T = item fun fetch(): T? &#123; return subject.takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject).takeIf &#123; available &#125; &#125;&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)class Man(val name: String, age: Int):Human(age)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox4(Boy(&quot;John&quot;, 20))// val box2 = MagicBox4(Dog(20)) //因为约束类型，导致这里会报错 box1.available = true box1.fetch()?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch &#123; Man(it.name, it.age.plus(15)) &#125;&#125; vararg关键字与get函数MagicBox能存放任何类型的Human实例，但一次只能放一个，如果要存放多个实例呢？ 12345678910111213141516171819202122232425262728293031class MagicBox&lt;T : Human&gt;(vararg item: T) &#123; var available = false protected var subject: Array&lt;out T&gt; = item //可变参数 必须写out fun fetch(index: Int): T? &#123; return subject[index].takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(index: Int, subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject[index]).takeIf &#123; available &#125; &#125;&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)class Man(val name: String, age: Int) : Human(age)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20), Boy(&quot;Jack&quot;, 20), Boy(&quot;Jon&quot;, 20)) box1.available = true box1.fetch(1)?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch(2) &#123; Man(it.name, it.age.plus(15)) &#125;&#125; []操作符运算符重载 12345678910111213141516171819202122232425262728293031323334class MagicBox&lt;T : Human&gt;(vararg item: T) &#123; var available = false protected var subject: Array&lt;out T&gt; = item //可变参数 必须写out fun fetch(index: Int): T? &#123; return subject[index].takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(index: Int, subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject[index]).takeIf &#123; available &#125; &#125; operator fun get(index: Int): T? = subject[index]?.takeIf &#123; available &#125; //运算符重载&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)class Man(val name: String, age: Int) : Human(age)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20), Boy(&quot;Jack&quot;, 20), Boy(&quot;Jon&quot;, 20)) box1.available = true box1.fetch(1)?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch(2) &#123; Man(it.name, it.age.plus(15)) &#125; box1[0] //运算符重载后 重写get，就能这样操作了&#125; invariant 不变如果泛型类即将泛型类型作为函数参数，又将泛型类型作为函数的输出，那么即不用out也不用in. 1234interface ProductionConsumer&lt;T&gt; &#123; fun product(): T fun consume(item: T)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// outinterface Production&lt;out T&gt; &#123; fun product(): T&#125;// ininterface Consumer&lt;in T&gt; &#123; // fun consume(item:T):T //Type parameter T is declared as &#x27;in&#x27; but occurs in &#x27;out&#x27; position in type T fun consume(item: T)&#125;//不变interface ProductionConsumer&lt;T&gt; &#123; fun product(): T fun consume(item: T)&#125;open class Foodopen class FastFood:Food()open class Burger :FastFood()//生产者class FoodStore : Production&lt;Food&gt;&#123; override fun product(): Food &#123; println(&quot;Product food&quot;) return Food() &#125;&#125;class FastFoodStore : Production&lt;FastFood&gt;&#123; override fun product(): FastFood &#123; println(&quot;Product FastFood&quot;) return FastFood() &#125;&#125;class BurgerFoodStore : Production&lt;Burger&gt;&#123; override fun product(): Burger &#123; println(&quot;Product Burger&quot;) return Burger() &#125;&#125;//消费者class EveryBody : Consumer&lt;Food&gt;&#123; override fun consume(item: Food) &#123; println(&quot;Eat food.&quot;) &#125;&#125;class ModernPeople : Consumer&lt;FastFood&gt;&#123; override fun consume(item: FastFood) &#123; println(&quot;Eat fastFood&quot;) &#125;&#125;class AmericanPeople : Consumer&lt;Burger&gt;&#123; override fun consume(item: Burger) &#123; println(&quot;Eat Burger&quot;) &#125;&#125; Out生产123interface Production&lt;out T&gt; &#123; fun product(): T&#125; 子类泛型对象可以赋值给父类泛型对象 如 下面production2 java. T extends Food 等于kotlin T : Food 泛型有继承关系，可以直接赋值，java做不到,只能强转 ArrayList list = new ArrayList(); // java里面这种写法报错 java只有 ? super Food 和 ? extends Food , 没有对泛型T , in out这种操作 123456fun main() &#123; val production1 : Production&lt;Food&gt; = FoodStore() // 理解时，别看方法只看类就可以了，父子类关系 //子类泛型对象可以赋值给父类泛型对象，用out val production2 : Production&lt;Food&gt; = FastFoodStore() // 就是因为有 out，out删除就报错, java这种写法直接报错&#125; 为什么需要 out 如果泛型有继承关系，可以直接赋值, Java只能用具体类 123456public class GenericTypeTest &#123; public static void main(String[] args) &#123; //String是CharSequence的子类// ArrayList&lt;CharSequence&gt; list = new ArrayList&lt;String&gt;(); // java里面这种写法报错 &#125;&#125; In 输入 1234interface Consumer&lt;in T&gt; &#123; // fun consume(item:T):T //Type parameter T is declared as &#x27;in&#x27; but occurs in &#x27;out&#x27; position in type T fun consume(item: T)&#125; 父类泛型对象可以赋值给子类泛型对象 ， 用in 12345678910fun main()&#123; //父类泛型对象可以赋值给子类泛型对象 ， 用in val consumer1:Consumer&lt;Burger&gt; = EveryBody()// val consumer2:Consumer&lt;Food&gt; = ModernPeople()//Required:Consumer&lt;Food&gt; Found : ModernPeople java里面必须要具体的类型,像上面的ArrayList val consumer2:Consumer&lt;Burger&gt; = ModernPeople() consumer2.consume(Burger())// consumer2.consume(Food()) val consumer3:Consumer&lt;Burger&gt; = AmericanPeople()&#125; Reified 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MagicBox&lt;T : Human&gt;() &#123; // 这里的T类型没用 //随机产生一个对象，如果不是指定类型的对象，就通过backup函数生成一个指定类型的对象// fun &lt;T&gt; randomOrBackup(backup: () -&gt; T): T &#123; // backup: ()-&gt;T 函数 和randomOrBackup返回的都是T类型// val items = listOf(Boy(&quot;jocnk&quot;, 20), Man(&quot;john&quot;, 20))// val random = items.shuffled().first()// return if (random is T) &#123;// random// &#125; else &#123;// backup()// &#125;// &#125; //随机产生一个对象，如果不是指定类型T的对象，就通过backup函数生成一个指定类型T的对象 // 根据传进来的Man对象类型，推断T类型为Man // backup: ()-&gt;T 函数 和randomOrBackup返回的都是T类型 //inline reified一起使用 inline fun &lt;reified T&gt; randomOrBackup(backup: () -&gt; T): T &#123; val items = listOf(Boy(&quot;jocnk&quot;, 20), Man(&quot;john&quot;, 20)) val random = items.shuffled().first() println(random) return if (random is T) &#123; random &#125; else &#123; backup() &#125; &#125;&#125;fun main() &#123; val box1: MagicBox&lt;Man&gt; = MagicBox() // 这里T类型不起作用 // 由backup函数推断出来T的类型 val subject = box1.randomOrBackup &#123; Man(&quot;Jimmy&quot;, 28) &#125; //根据传进来的Man对象类型，推断T类型为Man println(subject)&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)&#123; override fun toString(): String &#123; return &quot;Boy(name=&#x27;$name&#x27;)&quot; &#125;&#125;class Man(val name: String, age: Int) : Human(age)&#123; override fun toString(): String &#123; return &quot;Man(name=&#x27;$name&#x27;)&quot; &#125;&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[]},{"title":"kotlin-collection-class","slug":"kotlin-collection-class","date":"2021-08-21T08:48:52.000Z","updated":"2023-01-02T03:31:39.214Z","comments":true,"path":"2021/08/21/kotlin-collection-class/","link":"","permalink":"https://noteforme.github.io/2021/08/21/kotlin-collection-class/","excerpt":"","text":"集合ListList.kt List创建与元素获取 1234val list = listOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;)println(list.getOrElse(3) &#123; &quot;Unknown&quot; &#125;)println(list.getOrNull(3))println(list.getOrNull(3) ?: &quot;Unknown&quot;) 可变列表 1234567val mutableList = mutableListOf(&quot;Jason&quot;, &quot;Jack&quot;, &quot;girl1&quot;)mutableList.add(&quot;Jimmy&quot;)mutableList.remove(&quot;Jack&quot;)println(mutableList)list.toMutableList() // 不可变转可变mutableList.toList() // 可变转不可变 mutator函数 1234mutableList += &quot;John&quot;mutableList -= &quot;girl1&quot;mutableList.removeIf&#123;it.contains(&quot;Jack&quot;)&#125; //包含Jack就把 Jack移除println(mutableList) 集合遍历 for in forEach forEachIndexed遍历时要获取索引 123456789for (s in list)&#123; println(s)&#125;list.forEach&#123; println(it)&#125;list.forEachIndexed&#123;index,item-&gt; println(&quot;$index $item&quot;)&#125; 解构通过_符号过滤不想要的元素 12// val(girl1,girl2,girl3) = list val(girl1,_,girl3) = list //如果不需要girl2,用_，这个字节码也不会取出 Set集合elementAt获取元素12345val set = setOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;)println(set.elementAt(2))val mutableSet = mutableSetOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;)mutableSet += &quot;girl5&quot; List去重通过toSet去重 12345val list = mutableSetOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;).toSet().toList()println(list)val distinct = mutableSetOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;).distinct()println(distinct) 数组类型 kotlin提供了各种Array,虽然是引用类型，但最终编译成Java基本数据类型 123val intArray = intArrayOf(10, 30, 40)listOf(10, 30, 40).toIntArray()val array = arrayOf(File(&quot;xxx&quot;), File(&quot;yyyy&quot;)) Map集合 map获取1234println(map[&quot;lucy1&quot;])println(map.getValue(&quot;lucy2&quot;))println(map.getOrElse(&quot;Jon&quot;)&#123;&quot;Unknown&quot;&#125;) //没有Jon，返回Unknownprintln(map.getOrDefault(&quot;Jon&quot;,0)) //没有Jon，返回默认值0 map遍历123456map.forEach&#123; println(&quot;$&#123;it.key&#125;, $&#123;it.value&#125;&quot;)&#125;map.forEach&#123;(key:String,value:Int)-&gt; println(&quot;$&#123;key&#125;, $&#123;value&#125;&quot;)&#125; mutableMap12345val mutableMap = mutableMapOf(&quot;lucy1&quot; to 18, &quot;lucy2&quot; to 19, &quot;lucy3&quot; to 20)mutableMap += &quot;jon&quot; to 22mutableMap.put(&quot;jon2&quot;,35)mutableMap.getOrPut(&quot;Rose&quot;)&#123;30&#125; // 如果没有Rose,就添加进来println(mutableMap) 定义类 12345678Class Player&#123; var name:String? = &quot;jack&quot; // 编译后生成了get. set方法&#125;fun main()&#123; var p = Player() p.name = &quot;rose&quot; //编译生成了 setName方法&#125; 计算属性12345678910111213class Player &#123; var name: String = &quot;jack&quot; get() = field.capitalize() set(value) &#123; field = value.trim() &#125; //计算属性是通过一个覆盖的get或set运算符来定义，这时field就不需要了。 val rolledValue get() = (1..6).shuffled().first() &#125; 防范竞态条件1234567// 如果一个类属性即可空又可变，那么引用它之前必须保证它非空，一个办法是用also标准函数 var words:String? = &quot;hello&quot; fun saySomething()&#123; words?.also &#123; println(&quot;Hello $&#123;it.uppercase()&#125;&quot;) &#125; &#125; 构造函数12345678910111213141516171819202122class Student( _name: String, _age: Int, _isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125; var age = _age //临时变量用 _表示 只用一次 get() = age.absoluteValue set(value) &#123; field = value.absoluteValue &#125; var isNormal = _isNormal&#125;fun main() &#123; val p = Student(&quot;john&quot;, 19, true)// p.name = &quot;rose&quot; //Cannot assign to &#x27;name&#x27;: the setter is private in &#x27;Student&#x27;&#125; 主构造函数里定义属性12345678910111213141516class Student2( _name: String, val age: Int, val isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125;&#125;fun main() &#123; val p = Student2(&quot;john&quot;, 19, true)// p.name = &quot;rose&quot; //Cannot assign to &#x27;name&#x27;: the setter is private in &#x27;Student&#x27;&#125; 次构造函数Student2.kt 123456789constructor(_name:String):this(_name,age=100,isNormal = false)constructor(_name:String,age: Int):this(_name,age=100,isNormal = false)&#123; //定义初始化代码逻辑 this.name = name.uppercase()&#125;fun main()&#123; val p2 = Student2(&quot;Rose&quot;) val p3 = Student2(&quot;Rose&quot;,20)&#125; 构造函数给默认值123456789101112131415class Student3( _name: String, val age: Int = 20, val isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125;&#125;fun main() &#123; Student3(isNormal = false, _name = &quot;Jon&quot;)&#125; 初始化块初始化块可以设置变量或值，以及执行有效性检查，如果检查传给某构造函数的值是否有效，初始化块代码会在构造类实例时执行。 12345678910111213141516171819202122class Student3( _name: String, val age: Int = 20, val isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125; init&#123; require(age&gt;0)&#123;&quot;age must be positive&quot;&#125; require(name.isNotBlank())&#123;&quot;player must have a name.&quot;&#125; &#125;&#125;fun main() &#123; Student3(isNormal = false, _name = &quot;Jon&quot;) Student3(isNormal = false, _name = &quot;&quot;)&#125; 初始化顺序 主构造函数里声明的属性 类级别的属性赋值 Init初始化块里的属性赋值和函数调用 次构造函数里的属性赋值和函数调用 123456789101112131415161718192021class Student4( _name: String, val age: Int //age 主构造函数里声明的属性)&#123; var name = _name //类级别的属性赋值 name , score, hobby var score = 10; private val hobby = &quot;music&quot; val subject:String init &#123; println(&quot;initializing student&quot;) subject = &quot;english&quot; //Init初始化块里的属性赋值和函数调用 &#125; constructor(_name: String):this(_name,10)&#123; score = 20 //次构造函数里的属性赋值和函数调用 &#125;&#125;fun main()&#123; Student4(&quot;jon&quot;)&#125; 反编译字节码后 123456789101112131415161718public Student4(@NotNull String _name, int age) &#123; Intrinsics.checkNotNullParameter(_name, &quot;_name&quot;); super(); this.age = age; //主构造函数里声明的属性 this.name = _name; //类级别的属性赋值 name , score, hobby this.score = 10; this.hobby = &quot;music&quot;; String var3 = &quot;initializing student&quot;; //Init初始化块里的属性赋值和函数调用 boolean var4 = false; System.out.println(var3); this.subject = &quot;english&quot;; &#125;public Student4(@NotNull String _name) &#123; //调用这个构造方法 Intrinsics.checkNotNullParameter(_name, &quot;_name&quot;); this(_name, 10); this.score = 20; //次构造函数里的属性赋值和函数调用&#125; 延迟初始化 123456789101112131415class Player4 &#123; lateinit var equipment:String fun ready()&#123; equipment = &quot;sharp knife&quot; &#125; fun battle()&#123; if (::equipment.isInitialized) println(equipment) &#125;&#125;fun main() &#123; val p = Player4() p.ready() p.battle()&#125; 惰性初始化延迟初始化并不是推后初始化的唯一方式，也可以暂时不初始化某个变量，直到首次使用它才初始化，这个叫做惰性初始化。 1234567891011121314151617class Player5(_name: String) &#123; var name = _name val config by lazy &#123; loadConfig() &#125; // 懒汉式// val config = loadConfig() //饿汉式 private fun loadConfig(): String &#123; println(&quot;loading...&quot;) return &quot;beauty girl&quot; &#125;&#125;fun main() &#123; val p = Player5(&quot;girl&quot;) Thread.sleep(5000) println(p.config)&#125; Java不会有这种陷阱 初始化陷阱1顺序非常重要，必须保证块中的所有属性已完成初始化 1234init &#123; val bloodBonus = blood.times(4)&#125;val blood = 100 //必须保证块中的所有属性已完成初始化 初始化陷阱2123456789101112class Player7 &#123; val name:String //类级别属性 private fun firstLetter() = name[0] init &#123; println(firstLetter()) name= &quot;john&quot; //初始化块代码排第三 &#125;&#125;fun main() &#123; Player7()&#125; 初始化陷阱3initPlayerName() 初始化 playerName时，name属性还未完初始化。 123456789class InitTrapTest3(_name:String) &#123; val playerName:String = initPlayerName() val name:String = _name //这个要放第一句 private fun initPlayerName() = name&#125;fun main() &#123; println(InitTrapTest3(&quot;John&quot;).playerName)&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[]},{"title":"kotlin-func","slug":"kotlin-func","date":"2021-08-19T14:29:06.000Z","updated":"2023-01-02T03:31:39.256Z","comments":true,"path":"2021/08/19/kotlin-func/","link":"","permalink":"https://noteforme.github.io/2021/08/19/kotlin-func/","excerpt":"","text":"https://www.jianshu.com/p/8eb0623f08c6 类型Kotlin内置数据类型 类型推断对于已经声明并赋值的变量，它允许你省略类型定义. 编译时常量编译时常量只能再函数外定义，因为编译时常量必须在编译时赋值，而函数时在运行时才调用，函数内的变量也是在运行时赋值，编译时常量要在这些变量赋值前就已存在。 1234const val MAX =200;fun main() &#123; const val MAX =200;//报错 Modifier &#x27;const&#x27; is not applicable to &#x27;local variable&#x27;&#125; 基本表达式age表达式1234567891011val score = 6;if (score in 9..10)&#123; println(&quot;Big美女&quot;)&#125;else if (score in 6..8)&#123; println(&quot;美女&quot;)&#125;else&#123; println(&quot;who knows&quot;)&#125;if(score !in 1..5)&#123; println(&quot;good&quot;)&#125; 美女good when123456789val school = &quot;0小学&quot;;val level = when (school) &#123; &quot;幼儿园&quot; -&gt; &quot;幼儿&quot; &quot;小学&quot; -&gt; &quot;少儿&quot; &quot;中学&quot; -&gt; &quot;青少年&quot; else -&gt; &#123; &quot;未知&quot; &#125;&#125; 类似于 if else条件语句 1234567var osd = when &#123; isOdd() -&gt; print(&quot;x is odd&quot;) isEven() -&gt; print(&quot;y is even&quot;) else -&gt; print(&quot;x+y is odd&quot;)&#125;println(&quot;osd $osd&quot;) 123456fun isOdd():Boolean&#123; return false&#125;fun isEven():Boolean&#123; return false&#125; String模版12val flag = falseprintln(&quot;Answer is : $&#123;if (flag) &quot;我可以&quot; else &quot;I can play&quot;&#125;&quot;) 函数,函数参数12345printUser(&quot;Jon&quot;)printUser(name = &quot;john&quot;)fun printUser(name:String,age:Int=2)&#123; println(name+age)&#125; Nothing类型终止代码运行 1TODO(&quot;nothing&quot;) 反引号 ``可以用来测试 某一段代码 123fun `**~ special function with test util ~**`()&#123;&#125; Kotlin和Java保留不同的关键字，使用反引号括住函数名能避免任何冲突 12345public class KeyWordJava &#123; public static void is()&#123; //is时关键字 System.out.println(&quot;is invoked&quot;); &#125;&#125; 1KeyWordJava.`is`() 匿名函数匿名函数可以当作变量赋值给函数类型变量。函数的类型，由传入的参数和返回值类型决定。 和具名函数不一样，除极少情况外，匿名函数不需要return关键字，来返回数据，匿名函数会隐式或自动返回函数体最后一行语句的结果。 通过匿名函数给标准函数 制定规则 1234567val total = &quot;Mississippi&quot;.count()//通过匿名函数给标准函数 制定规则val totalS = &quot;Mississippi&quot;.count(&#123;letter-&gt; //letter变量 letter ==&#x27;s&#x27;//函数体&#125;)println(total)println(totalS) 函数类型与隐式返回 123456789101112131415//变量的类型是一个匿名函数,一个函数类型的变量val helloFunction:()-&gt;String //任意函数 无传入参数，返回类型String ,都可以 =helloFunctionhelloFunction = &#123; val greet = &quot; how is going. &quot; &quot;hello girl , $greet &quot; //默认返回这行语句的结果&#125;val helloFunction1:()-&gt;String = &#123;//任意函数 无传入参数，返回类型String ,都可以 =helloFunction val greet = &quot; how is going. &quot; val hah = &quot;haha&quot; &quot;hello beauty girl, $greet &quot; //默认返回这行语句的结果&#125;println(helloFunction())println(helloFunction1()) hello girl , how is going.hello beauty girl, how is going. 匿名函数参数 12345val helloFunction2:(String)-&gt;String = &#123;name-&gt; // name传入参数,String参数类型 val hah = &quot;haha&quot; &quot;hello beauty girl, I am $&#123;name&#125; &quot; //默认返回这行语句的结果&#125;println(helloFunction2(&quot;Jon&quot;)) it关键字定义只有一个参数的匿名函数时，可以用it来表示参数名。当需要传入两个值参，就不能用了。 12345val helloFunction3:(String)-&gt;String = &#123; // name传入参数,String参数类型, 只有一个参数name可以省略，用it替代 val hah = &quot;haha&quot; &quot;hello beauty girl, I am $&#123;it&#125; &quot; //默认返回这行语句的结果&#125;println(helloFunction3(&quot;John&quot;)) 类型推断定义一个变量时，如果已把匿名函数作为变量赋值给它, 就不需要显示指明变量类型了。 12345val helloFunction4 = &#123; val holiday = &quot;New Year&quot; &quot;Happy $holiday&quot;&#125;println(helloFunction4()) 类型推断也支持带参数的匿名函数，但为了帮助编译器更准确的推断变量类型，匿名函数的参数名和参数类型必须有。 123456789101112val helloFunction5:(String,Int) -&gt; String = &#123;name,year -&gt; val holiday = &quot;New Year&quot; &quot;$name Happy $holiday $year&quot;&#125;println(helloFunction5(&quot;jon&quot;,2023))//使用类型推断val helloFunction6 = &#123;name:String,year:Int -&gt; val holiday = &quot;New Year&quot; &quot;$name Happy $holiday $year&quot;&#125;println(helloFunction6(&quot;jon&quot;,2023)) 匿名函数成为lambda,将它的定义成为lambda表达式，它返回的数据成为lambda结果。 lambda由来：在定义匿名函数时，使用了lambda演算记法。 一个函数作为另一个函数的参数123456789101112131415fun main() &#123; //定义参数是函数 的函数 val disCountWord = &#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot; &#125; showOnBoard(&quot;小玩具&quot;, disCountWord)&#125;//getDiscountWord是第二个参数,类型时是(String, Int) -&gt; String 函数类型fun showOnBoard(goodsName: String, getDiscountWords: (String, Int) -&gt; String) &#123; val hour = (1..24).shuffled().last(); print(getDiscountWords(goodsName, hour))&#125; java实现传递函数1234567891011121314public static void main(String[] args) &#123; showOnBoard(&quot;牙膏&quot;,((goodsName, hour) -&gt; &#123; int currentYear = 2023; return String.format(&quot;%s年，双11 %s 促销倒计时 %d小时 &quot;,currentYear,goodsName,hour); &#125;));&#125;public interface DiscountWords&#123; String getDiscountWords(String goodsName,int hour);&#125;public static void showOnBoard(String goodsName,DiscountWords discountWords)&#123; int hour = new Random().nextInt(24); System.out.println(discountWords.getDiscountWords(goodsName,hour));&#125; 简略写法如果一个函数的lambda函数排在最后，或者是唯一的参数，那么括住的lambda值参的一对圆括号就可以省略. 唯一的参数 AnonymousFunc2.kt 1234567val totalS = &quot;Mississippi&quot;.count(&#123;letter-&gt; //letter变量 letter ==&#x27;s&#x27;//函数体&#125;)val totalS1 = &quot;Mississippi&quot;.count&#123;letter-&gt; //letter变量 letter ==&#x27;s&#x27;//函数体&#125; AnonymousFunc2.kt 排在最后,一对圆括号就可以省略 123456789showOnBoard(&quot;小玩具&quot;, &#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot;&#125;)showOnBoard(&quot;小玩具&quot;) &#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot;&#125; 内联函数类似于宏替换 1234567891011121314151617fun main() &#123; //定义参数是函数 的函数 val disCountWord = (&#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot; &#125;) showOnBoard(&quot;小玩具&quot;, disCountWord)&#125;//getDiscountWord是第二个参数,类型时是(String, Int) -&gt; String 函数类型 fun showOnBoard(goodsName: String, getDiscountWords: (String, Int) -&gt; String) &#123; val hour = (1..24).shuffled().last(); println(getDiscountWords(goodsName, hour))&#125; 123456789101112131415161718192021public final class AnonymousFunc2Kt &#123; public static final void main() &#123; Function2 disCountWord = (Function2)null.INSTANCE; showOnBoard(&quot;小玩具&quot;, disCountWord); &#125; // $FF: synthetic method public static void main(String[] var0) &#123; main(); &#125; public static final void showOnBoard(@NotNull String goodsName, @NotNull Function2 getDiscountWords) &#123; Intrinsics.checkNotNullParameter(goodsName, &quot;goodsName&quot;); Intrinsics.checkNotNullParameter(getDiscountWords, &quot;getDiscountWords&quot;); byte var3 = 1; int hour = ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(new IntRange(var3, 24))))).intValue(); Object var5 = getDiscountWords.invoke(goodsName, hour); boolean var4 = false; System.out.println(var5); &#125;&#125; 内联后，代码直接替换 12345678910111213141516171819202122232425262728public final class AnonymousFunc2Kt &#123; public static final void main() &#123; Function2 disCountWord = (Function2)null.INSTANCE; String goodsName$iv = &quot;小玩具&quot;; int $i$f$showOnBoard = false; byte var3 = 1; //这里开始 后面代码直接复制过来了 int hour$iv = ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(new IntRange(var3, 24))))).intValue(); Object var6 = disCountWord.invoke(goodsName$iv, hour$iv); boolean var5 = false; System.out.println(var6); &#125; // $FF: synthetic method public static void main(String[] var0) &#123; main(); &#125; public static final void showOnBoard(@NotNull String goodsName, @NotNull Function2 getDiscountWords) &#123; int $i$f$showOnBoard = 0; Intrinsics.checkNotNullParameter(goodsName, &quot;goodsName&quot;); Intrinsics.checkNotNullParameter(getDiscountWords, &quot;getDiscountWords&quot;); byte var4 = 1; int hour = ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(new IntRange(var4, 24))))).intValue(); Object var6 = getDiscountWords.invoke(goodsName, hour); boolean var5 = false; System.out.println(var6); &#125;&#125; 函数引用12345678910111213141516//函数引用fun main() &#123; showOnBoard(&quot;小玩具&quot;,::getDiscountWords)&#125;//普通 具名函数private fun getDiscountWords(goodsName: String, hour: Int): String &#123; val currentYear = 2023; return &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot;&#125;//getDiscountWord是第二个参数,类型时是(String, Int) -&gt; String 函数类型private fun showOnBoard(goodsName: String, getDiscountWords: (String, Int) -&gt; String) &#123; val hour = (1..24).shuffled().last(); println(getDiscountWords(goodsName, hour))&#125; 函数类型作为返回类型 函数类型也是有效的返回类型，也就是说可以定义一个能返回函数的函数。 123456789101112fun main() &#123; val getDiscountWords = configDiscountWords() println(getDiscountWords(&quot;小玩具&quot;))&#125;fun configDiscountWords(): (String) -&gt; String &#123;//返回一个传入字符串 返回类型也是函数的字符串,的返回类型 val currentYear = 2023; val hour = (1..24).shuffled().last(); return &#123; goodsName: String -&gt; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot; &#125;&#125; 闭包作用: 控制作用域 匿名函数引用着定义自身函数里的变量 kotlin中的lambda就是闭包,上面 currentYear,hour 在configDiscountWords()中定义 { goodsName: String -&gt; “${currentYear}年, 双11 ${goodsName}促销倒计时: $hour 小时} 也在configDiscountWords()定义 2 引用了currentYear,hour变量. 所以形成闭包 https://www.bilibili.com/video/BV1wf4y1s7TG?p=34&amp;spm_id_from=pageDriver 35 lambda与匿名内部类 java传递函数的方式 1234567891011121314151617181920public class JavaAnonymousClass &#123; public static void main(String[] args) &#123; showOnBoard(&quot;牙膏&quot;, new DiscountWords() &#123; @Override public String getDiscountWords(String goodsName, int hour) &#123; int currentYear = 2023; return String.format(&quot;%s年，双11 %s 促销倒计时 %d小时 &quot;, currentYear, goodsName, hour); &#125; &#125;); &#125; public interface DiscountWords &#123; String getDiscountWords(String goodsName, int hour); &#125; public static void showOnBoard(String goodsName, DiscountWords discountWords) &#123; int hour = new Random().nextInt(24); System.out.println(discountWords.getDiscountWords(goodsName, hour)); &#125;&#125; Null编译时出错的方式，提前在编译期强迫开发者重视起来，而不是等到运行时报错。 ?变量为null，不会执行后面的方法 let匿名函数，返回lambda最后一行 可以支持函数链式调用 12345678910 var str:String? = &quot;butterfly&quot;// var str=&quot;&quot; str = str?.let &#123; if (it.isNotBlank())&#123; it.capitalize() &#125;else&#123; &quot;butterfly&quot; &#125; &#125; println(str) !!当变量为null,会抛出KotlinNullPointerException 空合并操作符 ?:类似三目运算符 1234str=nullstr=&quot;guy&quot;str = str?.let &#123; it.capitalize()&#125; ?:&quot;butterfly&quot; //和let一起使用println(str ?: &quot;girl&quot;) // str=null,就是girl,不为null就是自己 异常执行之前，先进行检查，可以自定义异常 123456789101112131415fun main() &#123; var number: Int? = null try &#123; checkOperation(number) number!!.plus(1) &#125; catch (e: Exception) &#123; println(e) &#125;&#125;fun checkOperation(number: Int?) &#123; number ?: throw UnskilledException()&#125;//自定义异常class UnskilledException : IllegalArgumentException(&quot;操作不当&quot;) 先决条件函数kotlin标准库 提供了一些便利函数，使用这些内置函数，可以跑出带自定义信息的异常，这些便利函数叫做先决条件函数。也可以用它定义先决条件，条件必须满足，目标代码才能执行。 1234fun checkOperation(number: Int?) &#123;// number ?: throw UnskilledException() checkNotNull(number,&#123;&quot;Something is no good.&quot;&#125;)&#125; 字符串String.kt substringsubstring支持IntRange类型的参数，until创建的范围不包括上限值。 1234567const val NAME =&quot;Jimmy&#x27;s friend&quot;fun main() &#123; val index = NAME.indexOf(&#x27;\\&#x27;&#x27;) // \\转义 &#x27; NAME.substring(0,index) // java写法 val str = NAME.substring(0 until index) println(str)&#125; spiltsiilt返回的是List集合数据，List集合又支持解构语法特性，它允许你在一个表达式里给多个变量赋值，解构常用来简化变量的赋值。 123val data = NAMES.split(&quot;,&quot;)val (girl1,girl2,girl3,girl4) = NAMES.split(&quot;,&quot;)println(&quot;$girl1 $girl2 $girl3 $girl4 &quot;) replcae123456789101112131415161718 /** * 加密替换一个字符串 */val str1 = &quot;The people&#x27;s Republic of China.&quot; //第一个参数是正则表达式，用来决定要替换哪些字符 //第二个参数是匿名函数，用来确定如何替换正则表达式搜索到的字符val str2 = str1.replace(Regex(&quot;[aeiou]&quot;)) &#123; when (it.value) &#123; &quot;a&quot; -&gt; &quot;8&quot; &quot;e&quot; -&gt; &quot;6&quot; &quot;i&quot; -&gt; &quot;9&quot; &quot;o&quot; -&gt; &quot;1&quot; &quot;u&quot; -&gt; &quot;3&quot; else -&gt; it.value &#125;&#125;println(str1)println(str2) 结果 The people’s Republic of China.Th6 p61pl6’s R6p3bl9c 1f Ch9n8. 字符串的比较用 == 检查两个字符串中的字符是否匹配， 用 === 检查两个变量是否指向内存堆上的同一对象， 而在Java中 ==做引用比较，做结构比较时用equals方法. 1234567val str3 = &quot;Jason&quot;val str4 = &quot;Jason&quot;println(str3==str4)println(str3===str4) //相同字符串的字符串，使用字符串常量池中相同的对象val str5 = &quot;jason&quot;.capitalize() //这种情况会创建新的对象，why?println(str3===str5) 结果 truetruefalse 字符串遍历123str1.forEach &#123; print(&quot;$it &quot;)&#125; 数字类型kotlin所有的数字类型都是有符号的，也就是既可以表示正数，也可以表示负数。 安全转换函数NumberConvert toDoubleOrNull和toIntOrNull这样的安全转换函数，如果数值不能正确转换，与其触发异常不如干脆返回null值。 12345678// val number1 = &quot;6.66&quot;.toInt() val number1:Int? = &quot;6.66&quot;.toIntOrNull() println(number1) println(8.956765.toInt()) println(8.956765.roundToInt()) //四舍五入 val s = &quot;%.2f&quot;.format(8.956765) println(s) 结果 null898.96 标准库函数StandLibFunc.kt applyapply函数可看作一个配置函数，传入一个接收者，然后调用一系列的函数来配置它以便使用，如果提供lambda给apply函数执行，它会返回配置好的接收者。 配置file对象，传入file对象配置它，配置完file对象返回. 123456789101112// 配置一个File实例val file = File(&quot;E// I have a dream.txt&quot;)file.setReadable(true)file.setWritable(true)file.setExecutable(false)//使用applyval file1 = File(&quot;E// I have a dream.txt&quot;).apply &#123; setReadable(true) setWritable(true) setExecutable(false)&#125; Lambda表达式里，apply能让每个配置函数都作用于接收者，这种行为又叫相关作用于，因为lambda表达式里的所有函数调用都是针对接收者的，或者说他们是针对接收者的隐式调用。 letlet函数能是某个便利作用于lambda表达式里，让it关键字能引用它。let与apply比较，let会把接收者传给lambda，而apply什么都不传，匿名函数执行完，apply会发挥当前接收者，而let会返回lambda的最后一行。 12345678910111213141516171819202122 var result = listOf(3, 2, 1).first().let &#123; it * it &#125; // val firstElement = listOf(3, 2, 1).first() //java 方式 // val result = firstElement * firstElement println(formatGreeting(null)) println(formatGreeting(&quot;Jack&quot;)) fun formatGreeting(guestNmae: String?): String &#123; return guestNmae?.let &#123; &quot;Welcom, $it&quot; &#125; ?: &quot;What&#x27;s your name&quot;&#125;// Java方式fun formatGreeting2(guestNmae: String?): String &#123; return if (guestNmae != null) &#123; &quot;Welcom, $guestNmae&quot; &#125; else &#123; &quot;What&#x27;s your name&quot; &#125;&#125; run 光看作用域行为， run和apply差不多，但与apply不同，run函数不返回接收者，run返回的是lambda结果. run也能用来执行函数引用å 12345678910111213141516171819202122232425var file = File(&quot;THINKKOTLIN/I have a dream.txt&quot;)val result = file.run &#123; readText().contains(&quot;great&quot;) //最后一行执行结果返回 &quot;xxx&quot;&#125;println(result)val result2 = &quot;The people&#x27;s Republic of china.&quot;.run(::isLong)println(result2)&quot;The people&#x27;s Republic of china.&quot; .run(::isLong) .run(::showMessage) .run(::println)fun isLong(name: String) = name.length&gt;10fun showMessage(isLong: Boolean): String &#123; return if(isLong)&#123; &quot;Name is too long.&quot; &#125;else&#123; &quot;Please rename.&quot; &#125;&#125; withwith函数是run的变体，他们的功能行为是一样的，但with的调用方式不同，调用with时需要值参作为其第一个参数传入。 12var result3 = &quot;The people&#x27;s Republic of china.&quot;.run &#123; length &gt; 10 &#125;val result4 = with(&quot;The people&#x27;s Republic of china.&quot;) &#123; length &gt;= 10 &#125; also​ also和let类似，和let一样，also也是把接收者作为值参传给lambda,但是有点不同: also返回接收者对象，而let返回lambda结果。因此also适合针对同一原始对象，利用副作用做事，肌肉also返回的是接收者对象，就可以基于原始接收者对象执行额外的链式调用。 12345678var fileContents: List&lt;String&gt;File(FILE_DREAM) .also &#123; println(it.name) &#125;.also &#123; fileContents = it.readLines() &#125;println(fileContents) takeif 123456//如果 it.exists() &amp;&amp; it.canRead() 返回true,返回file对象，接着执行后面语句。// 如果为false，就返回null,就不会执行后面的语句。val readText = File(FILE_DREAM) .takeIf &#123; it.exists() &amp;&amp; it.canRead() &#125; ?.readText()println(readText) takeUnless和takeif是反的 takeUnless, 只有判断你给定的条件结果是 false 时，takeUnless才会返回原始接收者对象。 1234val result5 = File(FILE_DREAM) .takeUnless &#123; it.isHidden &#125; //不是 不可见的，所以是false ?.readText()println(result5) flatmap ArrayList 转成 ArrayList 123val flatMap = limitServiceList?.flatMap &#123; mutableListOf(CategoryEditService(false, services = it))&#125; 12&#123; mutableListOf(CategoryEditService(false, services &#x3D; it))&#125; 这个是一个方法，方法类型是transform: (T) -&gt; Iterable&lt;R&gt; 1234567891011121314151617181920212223/** * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection. * * @sample samples.collections.Collections.Transformations.flatMap */public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.flatMap(transform: (T) -&gt; Iterable&lt;R&gt;): List&lt;R&gt; &#123; return flatMapTo(ArrayList&lt;R&gt;(), transform)&#125;/** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. */public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.flatMapTo(destination: C, transform: (T) -&gt; Iterable&lt;R&gt;): C &#123; for (element in this) &#123;//这里this是limitServiceList. val list = transform(element) // 这里回调&#123;mutableListOf(CategoryEditService(false, services = it))&#125;方法 // 传入element值，返回list destination.addAll(list) //添加新的对象,达到转换的目的 &#125; return destination&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[]},{"title":"kmp","slug":"kmp","date":"2021-06-17T14:44:42.000Z","updated":"2023-01-02T03:31:39.209Z","comments":true,"path":"2021/06/17/kmp/","link":"","permalink":"https://noteforme.github.io/2021/06/17/kmp/","excerpt":"","text":"蛮力算法 i++ j++ 12345678910111213141516171819/****************************************************************************************** * Text : 0 1 2 . . . i-j . . . . i . . n-1 * ------------------------|-------------------|------------ * Pattern : 0 . . . . j . . * |-------------------| ******************************************************************************************/int match ( char* P, char* T ) &#123; //串匹配算法（Brute-force-1） size_t n = strlen ( T ), i = 0; //文本串长度、当前接受比对字符的位置 size_t m = strlen ( P ), j = 0; //模式串长度、当前接受比对字符的位置 while ( j &lt; m &amp;&amp; i &lt; n ) //自左向右逐个比对字符 /*DSA*/&#123;// /*DSA*/showProgress ( T, P, i - j, j ); getchar(); if ( T[i] == P[j] ) //若匹配 &#123; i ++; j++; &#125; //则转到下一对字符 else //否则 &#123; i -= (j - 1); j = 0; &#125; //文本串回退、模式串复位 // i j 都在往右走， i -= (j - 1) 相当于i在初始位置 又往右走了一步 /*DSA*/&#125; return i - j; //如何通过返回值，判断匹配结果？&#125; i , j++ 123456789101112131415161718/****************************************************************************************** * Text : 0 1 2 . . . i i+1 . . . i+j . . n-1 * ------------------------|-------------------|------------ * Pattern : 0 1 . . . j . . * |-------------------| ******************************************************************************************/int match ( char* P, char* T ) &#123; //串匹配算法（Brute-force-2） size_t n = strlen ( T ), i = 0; //文本串长度、与模式串首字符的对齐位置 size_t m = strlen ( P ), j; //模式串长度、当前接受比对字符的位置 for ( i = 0; i &lt; n - m + 1; i++ ) &#123; //文本串从第i个字符起，与 for ( j = 0; j &lt; m; j++ ) //模式串中对应的字符逐个比对 /*DSA*/&#123;showProgress ( T, P, i, j ); getchar(); if ( T[i + j] != P[j] ) break; //若失配，模式串整体右移一个字符，再做一轮比对 /*DSA*/&#125; if ( j &gt;= m ) break; //找到匹配子串 &#125; return i; //如何通过返回值，判断匹配结果？&#125; 数据结构下 第十三章 串 KMP算法算法主体 KMP排除了三个位置 1234567891011121314151617int match ( char* P, char* T ) &#123; //KMP算法 int* next = buildNext ( P ); //构造next表 int n = ( int ) strlen ( T ), i = 0; //文本串指针 int m = ( int ) strlen ( P ), j = 0; //模式串指针 while ( j &lt; m &amp;&amp; i &lt; n ) //自左向右逐个比对字符 /*DSA*/&#123; /*DSA*/showProgress ( T, P, i - j, j ); /*DSA*/printNext ( next, i - j, strlen ( P ) ); /*DSA*/getchar(); printf ( &quot;\\n&quot; ); if ( 0 &gt; j || T[i] == P[j] ) //若匹配，或P已移出最左侧（两个判断的次序不可交换） &#123; i ++; j ++; &#125; //则转到下一字符 else //否则 j = next[j]; //模式串右移（注意：文本串不用回退） /*DSA*/&#125; delete [] next; //释放next表 return i - j;&#125; 构建next表 1234567891011121314int* buildNext ( char* P ) &#123; //构造模式串P的next表 size_t m = strlen ( P ), j = 0; //“主”串指针 int* N = new int[m]; //next表 int t = N[0] = -1; //模式串指针 while ( j &lt; m - 1 ) if ( 0 &gt; t || P[j] == P[t] ) &#123; //匹配 j ++; t ++; N[j] = t; //此句可改进... &#125; else //失配 t = N[t]; /*DSA*/printString ( P ); printf ( &quot;\\n&quot; ); /*DSA*/printNext ( N, 0, m ); return N;&#125; https://www.bilibili.com/video/av3246487/ 前缀 : 包含首位字符 但不包含末位字符的子串。 后缀： 包含末位字符但不包含首位字符的子串。 还一种理解 Prefix 长度为k的前缀 :起始于首字符的前k个字符 suffix 长度为k的后缀 : 终止与末元素的最靠后的k个字符 前缀 字符串 : ababacb 前缀集合 ：不包括最后一个字符 a , ab , aba , abab , ababa, ababac 后缀集合 : 不包括第一个字符 , b, cb, acb,bacb,abacb,babacb 找到公共前后缀, 前缀移动到后缀的位置 kmp算法 了解了前后缀，再看这个视频，会很清晰 https://www.bilibili.com/video/BV1AY4y157yL KMP字符串匹配算法1 讲解分析不错 ,视频2运行碰到一些问题，也没听懂 https://www.bilibili.com/video/BV1Px411z7Yo 【宫水三叶】简单题学 KMP 算法LeetCode这个题解，分析能看懂，next数组构建也能看懂，但是不知道为什么是这样构建的, p[j] != p[i] ，为什么是 j = next[j-1]? https://leetcode.cn/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/ 代码随想录https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC 宫水三叶中的问题 ，但是不知道为什么是这样构建的, p[j] != p[i] ，为什么是 j = next[j-1]? 随想录下面有说到 为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。 关于随想录视频2，跟着他讲的代码流程走都清楚理解了，就是 next为什么回退, 原理没太明白. 有空听听他讲的 50分钟讲到回溯,比较清晰，不过用汉字比较看了感觉不太好 https://www.bilibili.com/video/BV1S64y1u74P 22分钟讲了回溯 https://www.bilibili.com/video/BV1CY4y14751 kmp优化偷懒技巧 中间加特殊符号# 连起来 没听懂 最终还是看随想录视频理解 i 后缀末位（从左到右） ， j前缀末位(也是最长公共前后缀的长度)","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[]},{"title":"Assembly","slug":"Assembly","date":"2021-05-21T03:13:41.000Z","updated":"2022-07-16T15:07:08.236Z","comments":true,"path":"2021/05/21/Assembly/","link":"","permalink":"https://noteforme.github.io/2021/05/21/Assembly/","excerpt":"","text":"8086 14个寄存器AX , BX , CX , DX , SI , DI , SP , BP, IP , CS , SS, DS ,ES ,PSW 实验环境搭建 https://github.com/froginwell/assembly https://www.bilibili.com/s/video/BV1254y1B75r CS:IP 他们指示了CPU当前要读取指令的地址。 CS为代码段地址 IP 指令指针寄存器 jmp ax ,含义上类似 ： mov IP , ax 第三章DS和addressdebug中，内存单元从左到右是地址从低到高顺序排列的。 8086CPU自动取ds中的数据为内存单元的段地址 move , add , sub [0] ， 0表示内存单元的偏移地址 SS:SP 指向栈顶元素，栈顶的段地址存放在栈顶，偏移地址存放在SP中。 Loop5.3 在Debug中跟踪用loop指令实现的循环程序 ​ 实验四 向内存0:200H0:23fH依次传送数据063（3FH） 内存0:200H~0:23fH空间与0020:0-0020:3f内存空间是一样的 (0:200 0020:0物理地址相同) 答案 https://www.cnblogs.com/Base-Of-Practice/category/1005745.html https://blackdragonf.github.io/2017/03/09/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C/ 视频 小甲鱼 剑指 Offer 58 - II. 左旋转字符串数组System.arraycopy深入分析用到了汇编指令,后面可以加强学习,其实底层的知识还是需要的，要不然没法深入下去了 https://blog.csdn.net/jackgo73/article/details/111866491","categories":[],"tags":[{"name":"Assembly","slug":"Assembly","permalink":"https://noteforme.github.io/tags/Assembly/"}]},{"title":"Data_LinkedList","slug":"Data-LinkedList","date":"2021-04-19T13:49:19.000Z","updated":"2022-05-06T11:24:51.238Z","comments":true,"path":"2021/04/19/Data-LinkedList/","link":"","permalink":"https://noteforme.github.io/2021/04/19/Data-LinkedList/","excerpt":"","text":"链表 首节点 第一个有效节点 尾节点 最后一个有效节点 头节点 头节点的数据类型和首节点类型一样 第一个有效节点之前的那个节点，只存放了 首节点 的地址 头节点并不存在有效数据 加头节点的目的主要是为了方便对链表的操作 头指针 ​ 指向头节点的指针变量 ​ 只占用4个byte,比头节点占用空间小. 尾指针 指向尾节点的指针变量 栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;printf.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef struct Node &#123; int data; struct Node *pNext;&#125; NODE, *PNODE;typedef struct Stack &#123; PNODE pTop; PNODE pBottom;&#125; STACK, *PSTACK; //PSTACK等价于 stuct STACK *void init(PSTACK);void push(STACK *pStack, int i);void traverse(STACK *pStack);bool pop(PSTACK pS, int *pVal);void clear(PSTACK ps);bool empty(PSTACK pStack);int main() &#123; STACK S; //等价于 struct Stack init(&amp;S); push(&amp;S, 1); push(&amp;S, 22); push(&amp;S, 88); traverse(&amp;S); int val;// if (pop(&amp;S, &amp;val)) &#123;// printf(&quot;出栈成功\\n&quot;);// printf(&quot;出栈的数据 %d \\n&quot;, val);// &#125; else &#123;// printf(&quot;出栈失败\\n&quot;);// &#125; clear(&amp;S); printf(&quot;清空数据\\n&quot;); traverse(&amp;S);&#125;void push(STACK *pStack, int val) &#123; PNODE pNew = (PNODE) malloc(sizeof(NODE)); pNew-&gt;data = val; pNew-&gt;pNext = pStack-&gt;pTop; //如果是空可以用pBottom，但是后面不为空 pStack-&gt;pTop = pNew;&#125;void init(PSTACK pS) &#123; pS-&gt;pTop = (PNODE) malloc(sizeof(NODE)); if (NULL == pS-&gt;pTop) &#123; printf(&quot;动态内存分配失败!\\n&quot;); exit(-1); &#125; else &#123; pS-&gt;pBottom = pS-&gt;pTop; pS-&gt;pTop-&gt;pNext = NULL; &#125;&#125;void traverse(PSTACK pS) &#123; PNODE p = pS-&gt;pTop; while (p != pS-&gt;pBottom) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;pNext; &#125;&#125;//把pS所指向的栈出栈一次，并把出栈的元素存入pVal形参所指向的变量中，如果出栈失败，返回false,否则返回true,bool pop(PSTACK pS, int *pVal) &#123; *pVal = pS-&gt;pTop-&gt;data; PNODE p = pS-&gt;pTop; if (pS-&gt;pTop != pS-&gt;pBottom) &#123; //或者写个方法 isEmpty() pS-&gt;pTop = pS-&gt;pTop-&gt;pNext; return true; &#125; free(p); return false;&#125;//清空void clear(PSTACK pS)&#123; if(empty(pS))&#123; return; &#125; else&#123; PNODE p = pS-&gt;pTop; PNODE q = NULL; while(p!=pS-&gt;pBottom)&#123; q = p-&gt;pNext; free(p); p = q; &#125; pS-&gt;pTop = pS-&gt;pBottom; &#125;&#125;bool empty(PSTACK pS) &#123; if(pS-&gt;pTop==pS-&gt;pBottom)&#123; return true; &#125; return false;&#125; 应用 函数调用 中断 表达式求值 内存分配 缓冲处理 迷宫 链表队列队列 ： 一种可以实现先进先出的存储结构 队列链式队列 – 用链表实现。 静态队列 – 用数组实现。 循环队列（数组）定义 队列初始化 front和rear的值都是0。 队列非空 front代表队列的第一个元素。 rear代表队列的最后一个有效 元素的下一个元素。 队列空 front和rear的值相等，但他们的值不一定时0。 操作入队: 将值存入r所代表的位置，接着r后移一位。 出队:f后移一位。 如何判断循环队列是否已满​ r==f时候，可能为空，页可能满的。 多增加一个标识参数，存放元素个数 少用一个元素 (r+1)%数组的长度 = f ![](Data-LinkedList/Screenshot from 2021-04-22 17-48-04_circleLinkedList.png) CircleQueue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;typedef struct Queue &#123; int *pBase; int front; int rear;&#125; QUEUE;void init(QUEUE *);bool en_queue(QUEUE *, int val); //入队void traverse_queue(QUEUE *);bool full_queue(QUEUE *pQueue);//队列是否已满bool out_queue(QUEUE *pQueue, int *pInt); //出队bool empty_queue(QUEUE *pQueue);int main() &#123; QUEUE Q; init(&amp;Q); en_queue(&amp;Q, 2); en_queue(&amp;Q, 7); en_queue(&amp;Q, 33); en_queue(&amp;Q, 4); en_queue(&amp;Q, 9); traverse_queue(&amp;Q); //执行这句 pQ-&gt;front会变，所以出队列失败// int pVal;// if(out_queue(&amp;Q,&amp;pVal))&#123;// printf(&quot;出队成功，出队元素是 %d \\n&quot;,pVal);// &#125; else&#123;// printf(&quot;出队失败\\n&quot;);// &#125;// traverse_queue(&amp;Q);&#125;void init(QUEUE *pQ) &#123; pQ-&gt;pBase = malloc(sizeof(int) * 6); pQ-&gt;front = 0; pQ-&gt;rear = 0;&#125;bool full_queue(QUEUE *pQ) &#123; if ((pQ-&gt;rear + 1) % 6 == pQ-&gt;front) &#123; return true; &#125; return false;&#125;bool en_queue(QUEUE *pQ, int val) &#123; if (full_queue(pQ)) &#123; return false; &#125; else &#123; pQ-&gt;pBase[pQ-&gt;rear] = val; pQ-&gt;rear = (pQ-&gt;rear + 1) % 6; return true; &#125;&#125;//void traverse_queue(QUEUE *pQ) &#123;// int q = pQ-&gt;front;// while ((q) % 6 != pQ-&gt;rear) &#123;// printf(&quot; %d &quot;, pQ-&gt;pBase[(pQ-&gt;front++) % 6]);// q++;// &#125;// return;//&#125;//或者下面方式void traverse_queue(QUEUE *pQ) &#123; int i = pQ-&gt;front; while (i!=pQ-&gt;rear)&#123; printf(&quot;%d &quot;,pQ-&gt;pBase[i]); i = (i+1)%6; &#125; printf(&quot;\\n&quot;); return;&#125;bool out_queue(QUEUE *pQ, int *pInt) &#123; if(empty_queue(pQ))&#123; return false; &#125; else&#123; *pInt = pQ-&gt;pBase[pQ-&gt;front]; pQ-&gt;front=(pQ-&gt;front+1)%6; return true; &#125;&#125;bool empty_queue(QUEUE *pQ) &#123; if(pQ-&gt;front==pQ-&gt;rear)&#123; return true; &#125; return false;&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[]},{"title":"Data_Tree","slug":"Data-Tree","date":"2021-03-24T13:46:39.000Z","updated":"2021-08-19T11:11:43.778Z","comments":true,"path":"2021/03/24/Data-Tree/","link":"","permalink":"https://noteforme.github.io/2021/03/24/Data-Tree/","excerpt":"","text":"树分类 满二叉树 : ​ 在不增加树的层数的前提下，无法再多添加一个节点的二叉树就是满二叉树。 完全二叉树 : ​ 如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树是完全二叉树。 树的存储二叉树表示法 ​ 先把一般树转化为二叉树，再存储二叉树。 ​ 一般树转化为二叉树的方法是:设法保证任意一个节点的 左指针域指向它的第一个孩子 右指针域指向它的下一个兄弟 只要能满足此条件，就可以把一个普通树转化为二叉树来存储。 BST树- Binary search tree删除 1234567891011121314151617181920212223template&lt;typename T&gt;static BinNodePosi&lt;T&gt; removeAt(BinNodePosi&lt;T&gt; &amp;x, BinNodePosi&lt;T&gt; &amp;hot) &#123; printf(&quot; x %d \\n&quot;,x-&gt;data); BinNodePosi&lt;T&gt; w = x; //实际被摘除的节点，初值同x BinNodePosi&lt;T&gt; succ = NULL; //实际被删除节点的接替者 if (!HasLChild (*x)) //若*x的左子树为空，则可 succ = x = x-&gt;rc; //直接将*x替换为其右子树 else if (!HasRChild (*x)) //若右子树为空，则可 succ = x = x-&gt;lc; //对称地处理——注意：此时succ != NULL else &#123; //若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要 w = w-&gt;succ(); //（在右子树中）找到*x的直接后继*w swap(x-&gt;data, w-&gt;data); //交换*x和*w的数据元素 BinNodePosi&lt;T&gt; u = w-&gt;parent; printf(&quot;u %d x %d \\n&quot;,u-&gt;data,x-&gt;data); ((u == x) ? u-&gt;rc : u-&gt;lc) = succ = w-&gt;rc; //隔离节点*w // (u == x)感觉没作用呀 ??? &#125; hot = w-&gt;parent; //记录实际被删除节点的父亲 if (succ) succ-&gt;parent = hot; //并将被删除节点的接替者与hot相联 release(w-&gt;data); release(w); return succ; //释放被摘除节点，返回接替者&#125; //rele ​ 树的遍历 ​ M N 作为根节点 先序遍历[先访问根节点] 先访问根节点 再先序访问左子树 再先序访问右子树 A B Q M N L C D H K E F 中序遍历[中间访问根节点] 中序遍历左子树 再访问根节点 再中遍历右子树 M Q N B L A H D K C E F 后序遍历[最后访问根节点] 先中序遍历左子树 再中序遍历右子树 再访问根节点 M N Q L B H K D F E C A 推导通过先序和中序或者 中序和后序可以还原出 原始的二叉树. 示例1 先序: ABCDEFGH 中序:BDCEAFHG 求后序: DECBHGFA 示例2 先序: ABDGHCEFI 中序:GDHBAECIF 求后序 : G H D B E I F C A 二叉树遍历示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;zconf.h&gt;#include &lt;malloc.h&gt;struct BTNode &#123; int data; struct BTNode *pLchild; struct BTNode *pRchild;&#125;;struct BTNode *createBTree();void preTraverseBTree(struct BTNode *pNode);int main() &#123; struct BTNode *pT = createBTree();// preTraverseBTree(pT);// inTraverseBTree(pT); postTraverseBTree(pT); return 0;&#125;void preTraverseBTree(struct BTNode *pNode) &#123; if (pNode-&gt;data != NULL) &#123; printf(&quot;%c\\n&quot;, pNode-&gt;data); if (pNode-&gt;pLchild != NULL) &#123; preTraverseBTree(pNode-&gt;pLchild); &#125; if (pNode-&gt;pRchild != NULL) &#123; preTraverseBTree(pNode-&gt;pRchild); &#125; &#125;&#125;void inTraverseBTree(struct BTNode *pNode) &#123; if (pNode-&gt;data != NULL) &#123; if (pNode-&gt;pLchild != NULL) &#123; inTraverseBTree(pNode-&gt;pLchild); &#125; printf(&quot;%c\\n&quot;, pNode-&gt;data); if (pNode-&gt;pRchild != NULL) &#123; inTraverseBTree(pNode-&gt;pRchild); &#125; &#125;&#125;void postTraverseBTree(struct BTNode *pNode) &#123; if (pNode-&gt;data != NULL) &#123; if (pNode-&gt;pLchild != NULL) &#123; postTraverseBTree(pNode-&gt;pLchild); &#125; if (pNode-&gt;pRchild != NULL) &#123; postTraverseBTree(pNode-&gt;pRchild); &#125; printf(&quot;%c\\n&quot;, pNode-&gt;data); &#125;&#125;struct BTNode *createBTree() &#123; struct BTNode *pA = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pB = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pC = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pD = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pE = (struct BTNode *) malloc(sizeof(struct BTNode)); pA-&gt;data = &#x27;A&#x27;; pB-&gt;data = &#x27;B&#x27;; pC-&gt;data = &#x27;C&#x27;; pD-&gt;data = &#x27;D&#x27;; pE-&gt;data = &#x27;E&#x27;; pA-&gt;pLchild = pB; pA-&gt;pRchild = pC; pB-&gt;pLchild = pB-&gt;pRchild = NULL; pC-&gt;pLchild = pD; pC-&gt;pRchild = NULL; pD-&gt;pLchild = NULL; pD-&gt;pRchild = pE; pE-&gt;pLchild = pE-&gt;pRchild = NULL; return pA;&#125; AVL树左右子树的高度差 不超过1 通过左旋或者右旋(左旋右旋后一定不会破坏二叉搜索树的查找规则 zig zagzig 顺时针 zag 逆时针 g : grandparent节点 p : parent节点 zigzig zigzag节点 类似工人组装魔方，确定好 G P V 所对应的 a b c ,何 0 1 2 3 所对应的 T0 T1 T2 T3,直接组装程图1的树 1234567891011121314151617181920template &lt;typename T&gt; BinNodePosi&lt;T&gt; BST&lt;T&gt;::rotateAt ( BinNodePosi&lt;T&gt; v ) &#123; //v为非空孙辈节点 /*DSA*/if ( !v ) &#123; printf ( &quot;\\a\\nFail to rotate a null node\\n&quot; ); exit ( -1 ); &#125; BinNodePosi&lt;T&gt; p = v-&gt;parent; BinNodePosi&lt;T&gt; g = p-&gt;parent; //视v、p和g相对位置分四种情况 if ( IsLChild ( *p ) ) /* zig */ if ( IsLChild ( *v ) ) &#123; /* zig-zig */ //*DSA*/printf(&quot;\\tzIg-zIg: &quot;); p-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( v, p, g, v-&gt;lc, v-&gt;rc, p-&gt;rc, g-&gt;rc ); &#125; else &#123; /* zig-zag */ //*DSA*/printf(&quot;\\tzIg-zAg: &quot;); v-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( p, v, g, p-&gt;lc, v-&gt;lc, v-&gt;rc, g-&gt;rc ); &#125; else /* zag */ if ( IsRChild ( *v ) ) &#123; /* zag-zag */ //*DSA*/printf(&quot;\\tzAg-zAg: &quot;); p-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( g, p, v, g-&gt;lc, p-&gt;lc, v-&gt;lc, v-&gt;rc ); &#125; else &#123; /* zag-zig */ //*DSA*/printf(&quot;\\tzAg-zIg: &quot;); v-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( g, v, p, g-&gt;lc, v-&gt;lc, v-&gt;rc, p-&gt;rc ); &#125;&#125; 伸缩树 B-TreeB树解决 一段一段从IO读取数据 地址 B树插入因为新节点的插入，导致所属节点的分支数超过B树阶次m的情况称作overflow ​ m=5时，每个节点的分支数不超过5，一般节点分支树不少于是3, (3,5) ​ m=6 对于6阶B树，分支树的上限是6，下限是3。 (3,6) B树上溢分裂 A[n/2]节点中点分裂 ​ 插入37，然后上溢分裂 下溢 先从兄弟树借节点，借不到的话就合并 2-3-4树特点 所有叶子节点都拥有相同的深度。 节点只能是 2-节点、3-节点、4-节点之一。 2-节点:包含 1 个元素的节点，有 2 个子节点; 3-节点:包含 2 个元素的节点，有 3 个子节点; 4-节点:包含 3 个元素的节点，有 4 个子节点; 所有节点必须至少包含1个元素 元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点; 而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。 2-3树的生长和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。 红黑二叉查找树2-3-4树与红黑树的等价关系 ​ ​ 裂变状态 9先从黑节点(从4节点)变成红节点，10、12先从红节点变成黑节点。 2-3-4 树新增操作，从叶子节点开始 红黑树 性质红黑树是一种结点带有颜色属性的二叉查找树，但它在二叉查找树之外，还有以下5大性质: 节点是红色或黑色。 根是黑色。 所有叶子都是黑色(叶子是NIL节点，这类节点不可以忽视，否则代码会看不懂)。 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点(黑色平衡)。// 2-3-4树层级相等. https://www.cs.usfca.edu/~galles/visualization/RedBlack.html 红黑树 新增都是红色节点 根据上面的等价关系，把2-3-4树转换成下面的红黑树。 https://www.bilibili.com/video/BV135411h7wJ?p=4 旋转 12345678910111213141516171819202122232425262728293031/** * 围绕p左旋 * pf pf * / / * p pr(r) * / \\ ==&gt; / \\ * pl pr(r) p rr * / \\ / \\ * rl rr pl rl * * @param p */ private void leftRotate(RBNode p) &#123; if (p != null) &#123; RBNode r = p.right; p.right = r.left; if (r.left != null) &#123; r.left.parent = p; &#125; r.parent = p.parent; if (p.parent == null) &#123; root = r; &#125; else if (p.parent.left == p) &#123; p.parent.left = r; &#125; else &#123; p.parent.right = r; &#125; r.left = p; p.parent = r; &#125; &#125; 12345678910111213141516171819202122232425262728293031/** * 右旋 * pf pf * \\ \\ * p (l)pl * / \\ =&gt; / \\ *(l)pl pr ll p * / \\ / \\ * ll lr lr pr * * @param p */ private void rightRotate(RBNode p) &#123; if (p != null) &#123; RBNode l = p.left; p.left = l.right; if (l.right != null) &#123; l.right.parent = p; &#125; l.parent = p.parent; if (p.parent == null) &#123; root = l; &#125; else if (p.parent.right == p) &#123; p.parent.right = l; &#125; else &#123; p.parent.left = l; &#125; l.right = p; p.parent = l; &#125; &#125; 新增红黑树新增，第一个节点 是红节点 新增的节点都是红节点 红黑树形成过程，忘了怎么形成，包括旋转 ， 节点颜色是怎么变化的。 删除https://www.cs.usfca.edu/~galles/visualization/RedBlack.html 图找到最优路径","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[]},{"title":"Data_Sort","slug":"Data-Sort","date":"2021-03-21T05:04:53.000Z","updated":"2021-08-19T11:11:43.770Z","comments":true,"path":"2021/03/21/Data-Sort/","link":"","permalink":"https://noteforme.github.io/2021/03/21/Data-Sort/","excerpt":"","text":"排序冒泡 1234567891011public static void bubbleSort(int[] arr) &#123; for (int i = arr.length - 1; i &gt; 0; i--) &#123; //剩余需要排序的长度 for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t; &#125; &#125; &#125;&#125; 思路1: 第一次遍历最大的元素放到最右边，第二遍放倒数第二个位置，… 一开始的想法是i 也递增，j&lt; arr.length - 1 - i 。但是这样可读性就不如 i 递减的方式，还要注意数组越界的问题，所以int i = arr.length - 1 思路2 还可以通过增加 swap，遍历后判断是否有序,当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出 1234567891011121314151617public static void bubbleSort2(int[] arr) &#123; boolean swap; for (int i = arr.length - 1; i &gt; 0; i--) &#123; //剩余需要排序的长度 swap = false; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t; swap = true; &#125; &#125; if (!swap) &#123; break; &#125; &#125; &#125; 选择排序通过比较找到当前的最大元素M,并通过交换使值就位 12345678910111213141516//选择排序 public static void selectionSort(int[] arr) &#123; int maxIndex; //知道下标就能得到值 int tmp; for (int i = arr.length - 1; i &gt; 0; i--) &#123; maxIndex = 0; for (int j = 1; j &lt;= i; j++) &#123; if (arr[j] &gt; arr[maxIndex]) &#123; maxIndex = j; &#125; &#125; tmp = arr[i]; arr[i] = arr[maxIndex]; arr[maxIndex] = tmp; &#125; &#125; 快速排序思想： 前一序列的元素 都小于等于后一序列的元素，递归后 只剩单个元素时，自身就是有序的，可以作为递归基。 快速排序1 初始情况U是整个序列， L G是空,然后 lo hi都向内侧移动，最终hi lo指向同一个位置m,也就是最终的轴点。 L &lt;= pivot &lt;= G; U = [lo,hi]中，[lo]和[hi]交替空闲 当_elem[hi]&gt;pivot时，hi向左移动，自序列G跟着拓展。 当_elem[hi]&lt;pivot时，把_elem[hi]移动到lo位置上。 向右移动lo,拓展子序列lo。 当elem[lo] &gt; pivot时，把elem[lo] 移动到hi位置上。 最终hi lo指向同一个位置m,也就是最终的轴点pivot。 123456789101112131415161718public static void quickSort(int[] arr, int lo, int hi) &#123; if (lo&gt;=hi) return; int mi = partition(arr, lo, hi); quickSort(arr, lo, mi-1); quickSort(arr, mi + 1, hi);&#125;private static int partition(int[] elem, int lo, int hi) &#123; int pivot = elem[lo]; while (lo &lt; hi) &#123; while (lo&lt;hi&amp;&amp;elem[hi] &gt;= pivot) hi--; elem[lo] = elem[hi]; while (lo&lt;hi&amp;&amp;elem[lo] &lt; pivot) lo++; elem[hi] = elem[lo]; &#125; elem[lo]= pivot; return lo;&#125; 快速排序2快速排序变种 插入排序 希尔排序 https://www.bilibili.com/video/BV1LT4y137cK?from=search&amp;seid=6852216660251002525 归并排序代码不太理解(学堂在线) 符号表的各种实现的优缺点 堆排序结合了数组与链表的特性 自下而上 2 1 6 3 9 7 4 8 5 最末尾的内部节点所对应的秩开始 floor(9/2)-1=3,也就是第三个位置，接下来是堆6 1 2进行下滤操作 一开始很不理解为什么是 floor(9/2)-1，因为前面有 parent(i) = (i-1)&gt;&gt;1 其实这个9就是 arr.length,这里的 i是下标,也就是 arr.length-1,这样就很好理解为什么-1可以移出来 建堆 按照树的层序遍历顺序，从左到右开始建堆。 接着根据floyd算法开始调整， 5/2 - 1 = 1,第一个位置对应的是3，3上移 接着是5,上移， 上面左下图是调整之后的，完全二叉堆 上面的数字太小，https://www.youtube.com/watch?v=WsNQuCa_-PU 这个视频有两次调整的情况 选取与调整 类似于选择排序 选取根节点5和末尾元素2交换,放到向量末尾，5放到 已排序序列，从完全二叉堆中移出。 对根节点2下滤 选取根节点4和末位置1交换，4放到已排序序列，下面依次操作 123456789101112131415161718192021222324252627282930313233343536public static void heapSort(int[] arr) &#123; buildHeap(arr, arr.length); //建堆 selectSorted(arr); // 交换 下滤&#125;private static void buildHeap(int[] arr, int length) &#123; for (int k = (length - 1) &gt;&gt; 1; k &gt;= 0; k--) &#123; //最后的内部节点 往前遍历 addJustHeap(arr, k, length); &#125;&#125;private static void addJustHeap(int[] arr, int k, int length) &#123; for (int i = 2 * k + 1; i &lt;= length; i = 2 * i + 1) &#123; // 上面节点调整后，可能比子节点还小，需要继续调整 if ((i + 1) &lt; length &amp;&amp; arr[i] &lt; arr[i + 1]) &#123; i++; // 左子树比右子树小，用右子树比较 &#125; if (i &lt; length &amp;&amp; arr[k] &lt; arr[i]) &#123; swap(arr, k, i); k = i; &#125; &#125;&#125;private static void selectSorted(int[] arr) &#123; for (int j = 0; j &lt; arr.length - 1; j++) &#123; swap(arr, 0, arr.length - 1 - j); //交换到已排序位置 addJustHeap(arr, 0, arr.length - 1 - j); //继续调整 &#125;&#125;private static void swap(int[] arr, int k, int i) &#123; int tmp = arr[i]; arr[i] = arr[k]; arr[k] = tmp;&#125; https://zhuanlan.zhihu.com/p/42586566","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[]},{"title":"Concurrency_SychronizedVolatile","slug":"Concurrency-SychronizedVolatile","date":"2021-03-08T07:37:45.000Z","updated":"2022-06-12T03:17:58.617Z","comments":true,"path":"2021/03/08/Concurrency-SychronizedVolatile/","link":"","permalink":"https://noteforme.github.io/2021/03/08/Concurrency-SychronizedVolatile/","excerpt":"","text":"MESI为什么需要MESI协议 : CPU的高度运算需要高速的数据,然而内存和硬盘的发展速度远远不及CPU 一个CPU的变量发生改变，其他拥有这个变量CPU需要同步. 查看如下链接的 多核缓存协同操作流程图 https://www.bilibili.com/video/BV1fK4y1E7NC视频讲解了这个状态图的各个情况. https://www.cnblogs.com/yanlong300/p/8986041.html https://www.codenong.com/cs106520859/ Memory Barriers 通过 Store Forwarding 解决了单个 CPU 执行顺序性和内存可见性问题，但是在全局多 CPU 的环境下，这种内存可见性恐怕就很难保证了。 1234567891011void foo(void)&#123; a = 1; b = 1;&#125;void bar(void)&#123; while (b == 0) continue; assert(a == 1);&#125; 假设上面的 foo 方法被 CPU 0 执行，bar 方法被 CPU 1 执行，也就是我们常说的多线程环境。试想，即便在多线程环境下，foo 和 bar 如若严格按照理想的顺序执行，是无论如何都不会出现 assert failed 的情况的。但往往事与愿违，这种看似很诡异的且有一定几率发生的 assert failed ，结合上面所说的 Store Buffer 就一点都不难理解了。 我们来还原 assert failed 的整个过程，假设 a,b 初始值为 0 ，a 被 CPU0 和 CPU1 共同持有，b 被 CPU0 独占； CPU0 处理 a=1 之前发送 Invalidate 消息给 CPU1 ，并将其放入 Store Buffer ，尚未及时刷入缓存； CPU 0 转而处理 b=1 ，此时 b=1 直接被刷入缓存； CPU 1 发出 Read 消息读取 b 的值，发现 b 为 1 ，跳出 while 语句； CPU 1 发出 Read 消息读取 a 的值，发现 a 却为旧值 0，assert failed。 在日常开发过程中也是完全有可能遇到上面的情况，由于 a 的变更对 CPU1 不可见，虽然执行指令的时序没有真正被打乱，但对于 CPU1 来说，这造成了 b=1 先于 a=1 执行的假象，这种看是乱序的问题，通常称为 “重排序”。当然上面所说的情况，只是指令重排序的一种可能。 Java内存模型 工作内存与主内存之间的原子操作lock( 锁定 )：作用于主内存的变量，把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，把一个处于锁定的变量释放出来，释放变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存种的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的值放入主内存的变量中。 深入理解java虚拟机(12.3.2 内存间交互操作) 总线上传递的消息首先不同CPU之间也是需要沟通的，这里的沟通是通过在消息总线上传递message实现的。 Read: sent if CPU needs to read from an address Read Response: response to a read message, carries the data at the requested address Invalidate: asks others to evict a cache line Invalidate Acknowledge: reply indicating that an Read Invalidate: like Read + Invalidate (also called “read with intend to modify”) ​ Writeback: info on what data has been sent to main memory ​ 该消息包含一个物理内存地址和数据内容，目的是把这块数据通过总线写回内存里。 Read：当CPU在自己的cache中没有发现需要的物理地址，就会发送一条“READ”消息，该消息包括缓存行需要读的物理地址。 Read Response: 顾名思义，”Read Response”消息是回复“Read”消息的。“Read Response”消息是由内存或者其他CPU缓存提供的。如果其他缓存请求一个处于“modified”状态的数据，则本地缓存必须提供“Read Response”消息。这个很容易理解，别的CPU在请求本地缓存中的数据，而这份数据还没有刷新到内存，所以必须告诉其他CPU该数据的最新值。接收到”Read Response”消息后，该数据的缓存状态就由”invalid”变成了”share”或者”exclusive”，这取决于”Read Response”的提供者是内存还是其他CPU缓存。 Invalidate：“ invalidate” 消息包含要使无效的缓存行的物理地址。其他的缓存必须从它们的缓存中移除相应的数据并且响应此消息。当CPU要对一个变量进行写操作，而此变量处于只读状态(share)，就需要发送“invalid”消息。由于一个变量被多个CPU缓存，所以单个CPU的改写会造成缓存不一致，所以在写之前必须告诉其他CPU你们缓存的值马上就要过时了。接受到”invalidate”消息的CPU就会把本地缓存中的对应数据无效掉。 Invalidate Acknowledge：一个接收到“invalidate”消息的 CPU必须在移除指定数据后响应一个“invalidate acknowledge”消息。这个消息就是告诉“invalidate”消息的提供者“我已经知道你要更改这个数据了，我放弃使用自己缓存中的拷贝！” Read Invalidate：”read invalidate”消息包含要缓存行读取的物理地址。同时指示其他缓存移除数据。因此，它包含一个”read”和一个”invalidate”。“read invalidate”也需要“read response”以及”invalidate acknowledge”消息集。 “Read Invalidate”消息的发送时机有两个：第一个是CPU对一个数据进行原子读写操作，但是该数据没有在本地CPU的缓存中，在其他CPU缓存中可能有该数据的拷贝。所以它需要发送一条“Read Invalidate”消息，它不仅需要读取该数据的最新值，还要无效掉其他的CPU缓存(它马上就要改写该数据)。 Writeback：“writeback”消息包含要回写到内存的地址和数据。这个消息允许缓存在必要时换出“modified”状态的数据以腾出空间。消息的发送时机是，CPU把本地缓存中的数据刷新到内存中，而该数据是share状态(只读)，它需要告诉其他CPU”我不再使用这些缓存数据了” http://intheworld.win/2015/07/16/%E5%A4%9A%E6%A0%B8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/ MESI为什么还需要volatile?volatile 和MESI 中间差了好几层抽象，中间会经历java编译器，java虚拟机和JIT，操作系统，CPU核心。 volatile 是Java 中标识变量可见性的关键字，说直接点：使用volatile 修饰的变量是有内存可见性的，这是Java 语法定的，Java 不关心你底层操作系统、硬件CPU 是如何实现内存可见的，我的语法规定就是volatile 修饰的变量必须是具有可见性的。 CPU 有X86（复杂指令集）、ARM（精简指令集）等体系架构，版本类型也有很多种，CPU 可能通过锁总线、MESI 协议实现多核心缓存的一致性。因为有硬件的差异以及编译器和处理器的指令重排优化的存在，所以Java 需要一种协议来规避硬件平台的差异，保障同一段代表在所有平台运行效果一致，这个协议叫做Java 内存模型（Java Memory Model）。 https://www.wwwbuild.net/java3y/5614.html 可见性问题存在的主要原因就是，Store Buffer ，尚未及时刷入缓存，然后其他CPU还是从内存里面取出旧值.为了提高CPU效率，MESI引入了缓存失效机制. https://www.cnblogs.com/xmzJava/p/11417943.html 这篇文章很好 而对于JAVA而言，他必须要屏蔽各个处理器的差异，所以才有了java内存模型(JMM),volatile只是内存模型的一小部分，实现了变量的可见性和禁止指令重排序优化的功能。整个内存模型必须要实现可见性，原子性，和有序性。而volatile实现了其中的可见性和有序性。 思考上面说的意思是volitle是上层实现，不管底层是什么，其实MESI volatile还是没搞懂，但是MESI是CPU具体存在的，而且MESI也和可见性差不多原理，如果不用volatile就没有MESI了？ https://www.scss.tcd.ie/jeremy.jones/VivioJS/caches/MESI.htm 各种文章人云亦云，要么直接回避上面问题，有的还说volatile保障MESI,自己相信吗? https://www.youtube.com/watch?v=q8r7b1KMUlE 看了这个视频感觉能说通了，volatile是在MESI基础上，禁止指令重排序(加了栅栏),来保障可见性。 有空看看其他几个视频链接，该删的删. CPU代码执行顺序1234567891011121314151617181920212223242526public class VisibilityThread &#123; private static volatile boolean initFlag = true; public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; System.out.println(&quot;waiting data...&quot;); while (!initFlag) &#123; &#125; System.out.println(&quot;=========success&quot;); &#125;).start(); Thread.sleep(2000); initFlag = false; new Thread(()-&gt;prepareData()).start(); &#125; private static void prepareData() &#123; System.out.println(&quot;prepareData&quot;); initFlag = true; System.out.println(&quot;prepare data end..&quot;); &#125;&#125; 流程图 https://www.bilibili.com/video/BV1XZ4y157Pj?p=4 Volatile禁止重排序单个线程中，只要重排序不会对结果产生影响，就不能保证其中的操作一定按照程序写定的顺序执行——即使重排序对于其他线程会产生影响。java并发编程实战3.1 这个视频讲了 Volatile重排序的实现，没讲可见性 https://www.bilibili.com/video/BV1UD4y127Kw?p=4 https://blog.csdn.net/reliveIT/article/details/50450136 第五章 Cache - 处理器的肚量(大话处理器-处理器基础知识读本) https://zhuanlan.zhihu.com/p/148772753 https://www.bilibili.com/video/BV1tE411o7oj?p=2 https://wudaijun.com/2019/04/cpu-cache-and-memory-model/#valine-comments Sychronized三种应用方式 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 作用于实例方法 123public synchronized void increase()&#123; i++;&#125; 示例 12345678910111213141516171819202122232425262728293031public class AccountingSync implements Runnable&#123; //共享资源(临界资源) static int i=0; /** * synchronized 修饰实例方法 */ public synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; AccountingSync instance=new AccountingSync(); Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125; /** * 输出结果: * 2000000 */ 当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁。 如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同 synchronized作用于静态方法 12345678910111213141516171819202122232425262728293031323334public class synchronized_01 implements Runnable &#123; static int i = 0; /** * 对于全局 */ public static synchronized void increase() &#123; i++; &#125; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1 = new Thread(new AccountingSyncBad()); t1.start(); for (int j = 0; j &lt; 1000000; j++) &#123; increase(); &#125; TimeUnit.SECONDS.sleep(2); System.out.println(i); &#125;&#125; /** * 输出结果: * 2000000 */ 其锁对象是当前类的class对象. 可以看到主线程和自线程发生互斥。 synchronized同步代码块 1234567891011121314151617181920212223public class synchronized_03 implements Runnable &#123; static synchronized_03 instance=new synchronized_03(); static int i=0; @Override public void run() &#123; //省略其他耗时操作.... //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized(instance)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1 = new Thread(new synchronized_03()); t1.start(); System.out.println(i); &#125;&#125; 将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象.当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁 //this,当前实例对象锁 123456789101112synchronized(this)&#123; for(int j&#x3D;0;j&lt;1000000;j++)&#123; i++; &#125;&#125;&#x2F;&#x2F;class对象锁synchronized(AccountingSync.class)&#123; for(int j&#x3D;0;j&lt;1000000;j++)&#123; i++; &#125;&#125; https://blog.csdn.net/javazejian/article/details/72828483 Sychronized volatile区别？ Sychronized 保证原子性和可见性 synchronized可见性，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性 volatile 只能保证可见性 CAS原理CAS操作流程 CPU1发现 待修改的变量值是100，期望值100，启动修改 Cpu2发现不是100了，修改失败 CAS缺点 ABA问题 从上一次看到这个值以来到现在，这个值是否发生过变化,从 A 变成了 B，再由 B 变回了 A,CAS 并不能检测出在此期间值是不是被修改过，它只能检查出现在的值和最初的值是不是一样。 通过添加版本号解决,A→B→A 变成了 1A→2B→3A,atomic 包中提供了 AtomicStampedReference 这个类，它是专门用来解决 ABA 问题的 自旋时间过长 CAS 往往是配合着循环来实现的，有的时候甚至是死循环，不停地进行重试，直到线程竞争不激烈的时候，才能修改成功 范围不能灵活控制 执行 CAS 的时候，是针对某一个，而不是多个共享变量的，这个变量可能是 Integer 类型，也有可能是 Long 类型、对象类型等等，但是我们不能针对多个共享变量同时进行 CAS 操作，因为这多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性. 解决方案:那就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用 atomic 包中的 AtomicReference 来把这个新对象整体进行 CAS 操作，这样就可以保证线程安全。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"https://noteforme.github.io/tags/concurrency/"}]},{"title":"Concurrency_thread","slug":"Concurrency-thread","date":"2021-02-26T13:57:48.000Z","updated":"2021-08-20T05:10:09.195Z","comments":true,"path":"2021/02/26/Concurrency-thread/","link":"","permalink":"https://noteforme.github.io/2021/02/26/Concurrency-thread/","excerpt":"","text":"用户态 : 应用程序运行 内核态 ：操作系统运行 线程的6中状态 New（新创建） Runnable（可运行） Blocked（被阻塞） Waiting（等待） Timed Waiting（计时等待） Terminated（被终止） 状态分析 New ​ 当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable 如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。 Blocked ​ 从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。 Waiting 等待 没有设置 Timeout 参数的 Object.wait() 方法。 没有设置 Timeout 参数的 Thread.join() 方法。 LockSupport.park() 方法。 Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。 Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。 Timed Waiting 限期等待在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。 以下情况会让线程进入 Timed Waiting 状态。 设置了时间参数的 Thread.sleep(long millis) 方法； 设置了时间参数的 Object.wait(long timeout) 方法； 设置了时间参数的 Thread.join(long millis) 方法； 设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。 想要从 Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁，而从 Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都不会主动恢复。 如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。 同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。 Terminated run() 方法执行完毕，线程正常退出。 出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。 多线程方法notify()只能叫醒别人 状态实例WAITINGwait()WAITING.java 123456789101112final Object lock = new Object(); threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; &#125;, &quot;Thread-A&quot;); threadA.start(); Thread.sleep(2000L); System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); joinWaitJOIN.java 12345678910111213141516171819202122232425262728final Object lock = new Object();threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); threadB.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;Thread-A&quot;);threadB = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadB.getState()); try &#123; Thread.sleep(1000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;Thread-B&quot;);threadA.start();threadB.start();Thread.sleep(2000);System.out.println(Thread.currentThread().getName() + &quot;运行 线程A的状态 &quot; + threadA.getState()); 运行结果 Thread-A RUNNABLEmain运行 线程A的状态 WAITING waitWaitState.java 123456789101112131415161718192021222324final Object lock = new Object(); threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); lock.wait(); Thread.sleep(5000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;BLOCKED-Thread-A&quot;); threadB = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadB.getState()); System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); try &#123; Thread.sleep(5000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;BLOCKED-Thread-B&quot;); 结果 BLOCKED-Thread-A RUNNABLEBLOCKED-Thread-B RUNNABLEBLOCKED-Thread-B 线程A的状态 WAITING 从结果可以得到两个结论: 线程A调用 lock.wait()后 A出于WAITING状态。 线程A调用 lock.wait()后，立马释放锁，线程B获得锁开始执行。 park12345678910111213141516171819202122char[] aI = &quot;1234567&quot;.toCharArray();char[] aC = &quot;ABCDEFG&quot;.toCharArray();t1 = new Thread(() -&gt; &#123; for(char c : aI) &#123; System.out.print(c); LockSupport.unpark(t2); //叫醒T2 LockSupport.park(); //T1阻塞 &#125;&#125;, &quot;t1&quot;);t2 = new Thread(() -&gt; &#123; for(char c : aC) &#123; LockSupport.park(); //t2阻塞 System.out.print(c); LockSupport.unpark(t1); //叫醒t1 &#125;&#125;, &quot;t2&quot;); 轮流打印数字和字母 TIMED_WAITINGwait(5000)WAITING_TIMEOUT.java 12345678910111213final Object lock = new Object();threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); try &#123; lock.wait(5000); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125;, &quot;Thread-A&quot;);threadA.start();Thread.sleep(2000L);System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); 运行结果: Thread-A RUNNABLEmain 线程A的状态 TIMED_WAITING sleep(5000)TIMED_WAITING.java 12345678910threadA = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125;&#125;, &quot;Thread-A&quot;);threadA.start();Thread.sleep(2000L);System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); 调用了 Thread.sleep(5000l); 运行结果: Thread-A RUNNABLEmain 线程A的状态 TIMED_WAITING BLOCKED123456789101112131415161718192021222324final Object lock = new Object(); threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); System.out.println(Thread.currentThread().getName() + &quot; 线程B的状态 &quot; + threadB.getState()); Thread.sleep(10000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;Thread-A&quot;); threadB = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); System.out.println(Thread.currentThread().getName() + &quot; 线程B的状态 &quot; + threadB.getState()); try &#123; Thread.sleep(10000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;Thread-B&quot;); 运行结果:线程A得到锁，线程B进入阻塞状态。 Thread-A 线程A的状态 RUNNABLEThread-A 线程B的状态 BLOCKEDThread-B 线程A的状态 TERMINATEDThread-B 线程B的状态 RUNNABLE 注意 线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。 线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。 Thread sleep() yield()结束后，回到就绪状态. https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/ https://fangjian0423.github.io/2016/06/04/java-thread-state/ 让步(yield) 如果已经完成了run()方法循环的一次迭代过程所需的工作，可以给线程调度机制一个暗示：你的工作已经做的差不多了，可以让别的线程使用CPU了，这个暗示將通过调用yield()来做做出(不过这只是一个暗示，没有任何机制保证它將被采纳)，也只是建议相同优先级的其他线程运行。 -ThinkInJava P661 加入一个线程 (join) 在Joiner线程里面调用Sleeper线程 的join() , Joiner任务必须等Sleeper任务结束活被打断或结束 才恢复 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Sleeper extends Thread &#123; private int duration; public Sleeper(String name, int sleepTime) &#123; super(name); duration = sleepTime; start(); &#125; @Override public void run() &#123; super.run(); try &#123; sleep(duration);// Print.print(getName()+&quot;执行了&quot;); &#125; catch (InterruptedException e) &#123; Print.print(getName() + &quot; 被打断&quot; + &quot;isInterrupted() &quot; + isInterrupted()); return; &#125; Print.print(getName() + &quot; has awakened&quot;); &#125;&#125;class Joiner extends Thread &#123; private Sleeper sleeper; public Joiner(String name, Sleeper sleeper) &#123; super(name); this.sleeper = sleeper; start(); &#125; @Override public void run() &#123; super.run(); try &#123; sleeper.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Print.print(getName() + &quot; join completed&quot;); &#125;&#125;public class Joining &#123; public static void main(String[] args) &#123; Sleeper sleepy = new Sleeper(&quot;Sleepy&quot;, 1500), grumpy = new Sleeper(&quot;Grumpy&quot;, 1500); Joiner dopey = new Joiner(&quot;Dopey&quot;, sleepy), doc = new Joiner(&quot;Doc&quot;, grumpy); grumpy.interrupt(); 其他对象上同步 有时候必须在另一个对象上同步，如果需要这样，必须确保所有相关的任务都是在同一个对象上同步。 123456789101112131415161718192021222324252627282930313233class DualSynch &#123; private Object syncObject = new Object(); public synchronized void f() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(&quot; f() &quot;); Thread.yield(); &#125; &#125; public void g() &#123; synchronized (syncObject) &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(&quot; g() &quot;); Thread.yield(); &#125; &#125; &#125;&#125;public class SyncObject &#123; public static void main(String[] args) &#123; DualSynch ds = new DualSynch(); new Thread() &#123; @Override public void run() &#123; super.run(); ds.f(); &#125; &#125;.start(); ds.g(); &#125;&#125; 这两个方式在同时运行，任何一个方法都没有对另一个方法同步而阻塞 线程间的协作 wait() : 在wait期间 对象锁是释放的,而Sleep期间是没有的 线程的停止方法原因通常情况下，我们不会手动停止一个线程，而是允许线程运行到结束， 贸然强制停止线程就可能会造成一些安全的问题，为了避免造成问题就需要给对方一定的时间来整理收尾工作。比如：线程正在写入一个文件，这时收到终止信号，它就需要根据自身业务判断，是选择立即停止，还是将整个文件写入成功后停止，而如果选择立即停止就可能造成数据不完整，不管是中断命令发起者，还是接收者都不希望数据出现问题。 正确的停止方式对于 Java 而言，最正确的停止线程的方式是使用 interrupt。但 interrupt 仅仅起到通知被停止线程的作用。而对于被停止的线程而言，它拥有完全的自主权，它既可以选择立即停止，也可以选择一段时间后停止，也可以选择压根不停止。首先通过 Thread.currentThread().isInterrupt() 判断线程是否被中断，随后检查是否还有工作要做。&amp;&amp; 逻辑表示只有当两个判断条件同时满足的情况下，才会去执行下面的工作。 123while (!Thread.currentThread().isInterrupted() &amp;&amp; cout&lt;1000) &#123; do more work&#125; 例子1 1234567891011121314151617public class StopThread implements Runnable &#123; @Override public void run() &#123; int count = 0; while (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; 1000) &#123; System.out.println(&quot;count = &quot; + count++); &#125; System.out.println(&quot;sleep isInterrupted &quot; + Thread.currentThread().isInterrupted()); &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(new StopThread()); thread.start(); Thread.sleep(5); thread.interrupt(); &#125;&#125; 运行结果 123456789count = 0count = 1count = 2..count = 304count = 305count = 306sleep isInterrupted true sleep 期间能否感受到中断 try catch在while外面 1234567891011121314151617181920public class StopDuringSleep &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; int num = 0; try &#123; while (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= 1000) &#123; System.out.println(num); num++; Thread.sleep(1000000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(5); thread.interrupt(); &#125;&#125; 在还没打印完1000个数的时候就会停下来，这种就属于通过 interrupt 正确停止线程的情况。 输出 0 try catch在while里面 外层设置标志中断 123456789101112131415161718192021222324public class StopDuringSleep_answer01 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; while (!Thread.currentThread().isInterrupted()) &#123; try &#123; subTas2(); &#125; catch (InterruptedException e) &#123;// Thread.currentThread().interrupt(); 注释2 &#125; &#125; System.out.println(&quot;thread isInterrupted &quot; + Thread.currentThread().isInterrupted()); &#125;; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(50); thread.interrupt(); &#125; private static void subTas2() throws InterruptedException &#123; System.out.println(&quot;subTas2 isInterrupted &quot; + Thread.currentThread().isInterrupted()); Thread.sleep(1000); &#125;&#125; 输出 subTas2 isInterrupted falsesubTas2 isInterrupted falsesubTas2 isInterrupted falsesubTas2 isInterrupted false 把注释打开输出 subTas2 isInterrupted falsethread isInterrupted true 结论 ：如果 sleep、wait 等可以让线程进入阻塞的方法使线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false。这样一来就不用担心长时间休眠中线程感受不到中断了，因为即便线程还在休眠，仍然能够响应中断通知，并抛出异常。 我们先来看下 try/catch 的处理逻辑。如上面的代码所示，catch 语句块里代码是空的，它并没有进行任何处理。假设线程执行到这个方法，并且正在 sleep，此时有线程发送 interrupt 通知试图中断线程，就会立即抛出异常，并清除中断信号。抛出的异常被 catch 语句块捕捉。 但是，捕捉到异常的 catch 没有进行任何处理逻辑，相当于把中断信号给隐藏了，这样做是非常不合理的，那么究竟应该怎么处理呢？首先，可以选择在方法签名中抛出异常。 另一种处理方式类似 123456789101112131415161718192021222324252627282930public class StopDuringSleep_answer01 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; while (!Thread.currentThread().isInterrupted()) &#123; subTas1(); &#125; System.out.println(&quot;thread isInterrupted &quot; + Thread.currentThread().isInterrupted()); &#125;; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(50); thread.interrupt(); &#125; private static void subTas2() throws InterruptedException &#123; System.out.println(&quot;subTas2 isInterrupted &quot; + Thread.currentThread().isInterrupted()); Thread.sleep(1000); &#125; private static void subTas1() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // 在这里不处理该异常是非常不好的 Thread.currentThread().interrupt(); &#125; &#125;&#125; 再次中断方式 设置标志,在方法中处理，上一种是抛出上一层,在上一层设置标志中断 volatile 修饰标记位不适用的场景生产者/消费者模式的案例来演示为什么说 volatile 标记位的停止方法是不完美的。生产者 1234567891011121314151617181920212223242526public class Producer implements Runnable &#123; public volatile boolean canceled = false; BlockingQueue storage; public Producer(BlockingQueue storage) &#123; this.storage = storage; &#125; @Override public void run() &#123; int num = 0; try &#123; while (num &lt;= 100000 &amp;&amp; !canceled) &#123; if (num % 50 == 0) &#123; storage.put(num); System.out.println(num + &quot;是50的倍数,被放到仓库中了。&quot;); &#125; num++; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;生产者结束运行&quot;); &#125; &#125;&#125; 消费者 1234567891011121314public class Consumer &#123; BlockingQueue storage; public Consumer(BlockingQueue storage) &#123; this.storage = storage; &#125; public boolean needMoreNums() &#123; if (Math.random() &gt; 0.97) &#123; return false; &#125; return true; &#125;&#125; 1234567891011121314151617181920212223242526272829ArrayBlockingQueue storage = new ArrayBlockingQueue(8);Producer producer = new Producer(storage);Thread producerThread = new Thread(producer);producerThread.start();try &#123; Thread.sleep(500);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;Consumer consumer = new Consumer(storage);while (consumer.needMoreNums()) &#123; try &#123; System.out.println(consumer.storage.take() + &quot;被消费了&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;System.out.println(&quot;消费者不需要更多数据了。&quot;);//一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来producer.canceled = true;System.out.println(producer.canceled); 当 producer.canceled = true时,生产者Producer跳出循环 while (num &lt;= 100000 &amp;&amp; !canceled) ,来到运行 1System.out.println(&quot;生产者结束运行&quot;); 然而结果却不是我们想象的那样，尽管已经把 canceled 设置成 true，但生产者仍然没有停止，这是因为在这种情况下，生产者在执行 storage.put(num) 时发生阻塞，在它被叫醒之前是没有办法进入下一次循环判断 canceled 的值的，所以在这种情况下用 volatile 是没有办法让生产者停下来的，相反如果用 interrupt 语句来中断，即使生产者处于阻塞状态，仍然能够感受到中断信号，并做响应处理。 修复版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class WrongWayVolatileFixed &#123; public static void main(String[] args) throws InterruptedException &#123; ArrayBlockingQueue storage = new ArrayBlockingQueue(10); WrongWayVolatileFixed body = new WrongWayVolatileFixed(); Producer producer = body.new Producer(storage); Thread producerThread = new Thread(producer); producerThread.start(); Thread.sleep(1000); Consumer consumer = body.new Consumer(storage); while (consumer.needMoreNums()) &#123; System.out.println(storage.take()+&quot;被消费&quot;); Thread.sleep(100); &#125; System.out.println(&quot;消费者不需要更多数据了&quot;); /** * 一旦消费不需要更多数据了，我们应该让生产者也停下来， * 但是实际情况,在 storage.put(num);处被阻塞了，无法进入新的一层while()循环中判断，!Canceled 的值也就无法判断 */ producerThread.interrupt(); &#125; class Producer implements Runnable&#123; BlockingQueue storage; public Producer(BlockingQueue storage) &#123; this.storage = storage; &#125; @Override public void run() &#123; int num = 0; try &#123; //canceled为true，则无法进入 while (num &lt;= 100000 &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; if (num % 100 == 0) &#123; storage.put(num); System.out.println(num + &quot;是100的倍数,被放到仓库中了。&quot;); &#125; num++; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;生产者结束运行&quot;); &#125; &#125; &#125; class Consumer &#123; BlockingQueue storage; public Consumer(BlockingQueue storage) &#123; this.storage = storage; &#125; public boolean needMoreNums() &#123; if (Math.random() &gt; 0.95) &#123; return false; &#125; return true; &#125; &#125;&#125; producerThread.interrupt();去打断 线程池关闭方式1234567891011121314151617181920212223242526272829303132public class ShutdownTest &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); exec.submit(new ShutDownThread()); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; exec.shutdownNow(); &#125; static class ShutDownThread implements Runnable &#123; static int taskId = 0; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted())&#123; try &#123; Thread.sleep(5000); System.out.println(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; System.out.println(&quot;taskId Terminated&quot; + taskId++); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125; 为什么 wait 必须在 synchronized 保护的同步代码中使用? 不在synchronized就不能保证原子性，执行wait之前的代码后，被其他线程抢占执行了notifiy(此时没起作用，wait方法还没调用)，回来继续执行wait，这样该线程就得不到唤醒. https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=242 https://github.com/Lvshujia/JUC","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"https://noteforme.github.io/tags/concurrency/"}]},{"title":"Exception","slug":"Exception","date":"2021-01-14T09:29:14.000Z","updated":"2022-06-12T03:17:58.619Z","comments":true,"path":"2021/01/14/Exception/","link":"","permalink":"https://noteforme.github.io/2021/01/14/Exception/","excerpt":"","text":"异常结构图 https://www.cnblogs.com/aspirant/p/10790803.html ![2022-06-06 -8.53](Exception/2022-06-06 -8.53.png)","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"JVM_GC","slug":"JVM-GC","date":"2021-01-05T03:49:01.000Z","updated":"2024-07-19T00:08:55.383Z","comments":true,"path":"2021/01/05/JVM-GC/","link":"","permalink":"https://noteforme.github.io/2021/01/05/JVM-GC/","excerpt":"","text":"垃圾回收可达性分析​ 从GC Roots向下追溯、搜索，会产生一个叫做Refrence Chain的链条。当一个对象不能和任何一个GC Root产生关系时，就会被回收。 ​ 如图所示，Obj5、Obj6、Obj7，由于不能和 GC Root 产生关联，发生 GC 时，就会被摧毁。 垃圾回收就是围绕着 GC Roots 去做的。同时，它也是很多内存泄露的根源，因为其他引用根本没有这样的权利。 那么，什么样的对象，才会是 GC Root 呢？这不在于它是什么样的对象，而在于它所处的位置。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=31#/detail/pc?id=1029 GC Roots 有哪些GC Roots 是一组必须活跃的引用。用通俗的话来说，就是程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象。 GC Roots 包括： Java 线程中，当前所有正在被调用的方法的引用类型参数、局部变量、临时值等。也就是与我们栈帧相关的各种引用。 所有当前被加载的 Java 类。 Java 类的引用类型静态变量。 运行时常量池里的引用类型常量（String 或 Class 类型）。 JVM 内部数据结构的一些引用，比如 sun.jvm.hotspot.memory.Universe 类。 用于同步的监控对象，比如调用了对象的 wait() 方法。 JNI handles，包括 global handles 和 local handles。 这些 GC Roots 大体可以分为三大类，下面这种说法更加好记一些： 活动线程相关的各种引用。 类的静态变量的引用。 JNI 引用。 ​ 注意 我们这里说的是活跃的引用，而不是对象，对象是不能作为 GC Roots 的。 GC 过程是找出所有活对象，并把其余空间认定为“无用”；而不是找出所有死掉的对象，并回收它们占用的空间。所以，哪怕 JVM 的堆非常的大，基于 tracing 的 GC 方式，回收速度也会非常快。 引用计数算法(忽略)当前主流的商用程序语言(Java、C#，上溯至前面提到的古老的Lisp)的内存管理子系统，都是 通过可达性分析(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。 12345678910111213141516/*** testGC()方法执行后，objA和objB会不会被GC呢? * @author zzm*/public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024 * 1024;/*** 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; // 假设在这行发生GC，objA和objB是否能被回收? System.gc(); &#125; &#125; 能够找到 Reference Chain 的对象，就一定会存活么？引用级别 将引用分为强引用(Strongly Re-ference)、软 引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。 ·强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 12345// 伪代码Object object = new Object();SoftReference&lt;Object&gt; softRef = new SoftReference(object); 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 12345// 伪代码Object object = new Object();WeakReference&lt;Object&gt; softRef = new WeakReference(object); 虚引用也称为“幽灵引用”或者“幻影引用”，这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"OS","slug":"OS","date":"2020-12-28T07:32:28.000Z","updated":"2025-02-26T13:19:59.903Z","comments":true,"path":"2020/12/28/OS/","link":"","permalink":"https://noteforme.github.io/2020/12/28/OS/","excerpt":"","text":"MIT6.S081GitHub - YukunJ&#x2F;xv6-operating-system: XV6 - MIT 6.s081 operating system Fall 2020 version https://zhuanlan.zhihu.com/p/449687883 https://zhuanlan.zhihu.com/p/442656932 MIT 6.S081: Operating System Engineering - CS自学指南 这几位教授还专门写了一本教程，详细讲解了 xv6 的设计思想和实现细节。 这门课的讲授也很有意思，老师会带着学生依照 xv6 的源代码去理解操作系统的众多机制和设计细节，而不是停留于理论知识。每周都会有一个 lab，让你在 xv6 上增加一些新的机制和特性，非常注重学生动手能力的培养。整个学期一共有 11 个 lab，让你全方位地深刻理解操作系统的每个部分，非常有成就感。而且所有的lab都有着非常完善的测试框架，有的测试代码甚至上千行，让人不得不佩服 MIT 的几位教授为了教好这门课所付出的心血。 这门课的后半程会讲授操作系统领域的多篇经典论文，涉及文件系统、系统安全、网络、虚拟化等等多个主题，让你有机会接触到学界最前沿的研究方向。 课程资源 课程网站：https://pdos.csail.mit.edu/6.828/2021/schedule.html 课程视频： - YouTube，每节课的链接详见课程网站 课程视频翻译文档：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/ 课程教材：https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf 课程作业：https://pdos.csail.mit.edu/6.828/2021/schedule.html，11个lab，具体要求详见课程网站 6.S081 Fall 2020 Lecture 1: Introduction and Examples - YouTube xv6 补充资源 xv6 操作系统的深入讲解 xv6 中文文档 xv6 关键源码逐行解读 + 整体架构分析 课程教材翻译 xv6-riscv-book-zh-cn 课程教材翻译源码 xv6-riscv-book-zh-cn 资源汇总@PKUFlyingPig 在学习这门课中用到的所有资源和作业实现都汇总在 PKUFlyingPig&#x2F;MIT6.S081-2020fall - GitHub 中。 @KuangjuX 编写了 MIT 6.S081 的 lab 的题解，里面有详细的解法和补充知识。另外，@KuangjuX 还使用 Rust 语言重新实现了 xv6-riscv 操作系统：xv6-rust，里面对于 xv6-riscv 有更为详细的思考和讨论，感兴趣的同学可以看一下哦。 一些可以参考的博客 doraemonzzz Xiao Fan (樊潇) Miigon’s blog Zhou Fang Yichun’s Blog 解析Ta PKUFlyingPig 星遥见 tzyt 的博客 实验 + 操作系统导论 https://github.com/woai3c/MIT6.828 https://pdos.csail.mit.edu/6.828/2018/index.html https://www.zhihu.com/question/40973610 RISC-V 微处理器 xv6 实验环境配置https://pdos.csail.mit.edu/6.828/2021/tools.html https://pdos.csail.mit.edu/6.S081/2021/xv6.html GitHub - chaiqingao&#x2F;xv6-labs-2021: MIT 6.S081: Operating System Engineering &#x2F; Fall 2021 课程实验 https://zhuanlan.zhihu.com/p/343655412 https://zhuanlan.zhihu.com/p/272199762 https://zhuanlan.zhihu.com/p/331492444 https://www.bilibili.com/video/BV11K4y127Qk?from=search&amp;seid=8628043749223720261 issue112345678m@m:~/TESTLAB/xv6-labs-2021$ make qemuriscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -DLAB_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -c -o user/sh.o user/sh.cuser/sh.c:55:1: error: empty declaration [-Werror] 55 | __attribute__((noreturn)); | ^~~~~~~~~~~~~user/sh.c: In function ‘runcmd’:user/sh.c:59:1: error: infinite recursion detected [-Werror=infinite-recursion] 59 | runcmd(struct cmd *cmd) 修改user&#x2F;sh.c :58处，添加 123456789101112diff --git a/user/sh.c b/user/sh.cindex 83dd513..c96dab0 100644--- a/user/sh.c+++ b/user/sh.c@@ -54,6 +54,7 @@ void panic(char*); struct cmd *parsecmd(char*); // Execute cmd. Never returns.__attribute__((noreturn)) // 添加 void runcmd(struct cmd *cmd) &#123; 记录MIT6.s081 编译QEMU中的错误_error: pkg-config binary ‘pkg-config’ not found-CSDN博客 错误1 1234ERROR: glib-2.48 gthread-2.0 is required to compile QEMU处理sudo apt-get install libglib2.0-dev 错误2 12345ERROR: pixman &gt;= 0.21.8 not present. Please install the pixman devel package.处理sudo apt-get install libpixman-1-dev 实验 在user目录下创建copy.c 在Makefile 152行添加配置 测试添加程序 启动xv6后，执行copy https://blog.csdn.net/u013577996/article/details/108680888 LABlab1 123456789101112131415161718192021222324252627#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[])&#123; if(argc &lt; 2)&#123; fprintf(2 ,&quot;Usage: need at least one arugment...\\n&quot;); exit(1); &#125; printf(&quot;Number of arguments: %d\\n&quot;, argc); // Print each argument for (int i = 0; i &lt; argc; i++) &#123; printf(&quot;Argument %d: %s\\n&quot;, i, argv[i]); &#125; int time = atoi(argv[1]); // should notice argv[1] is first arugment. int ret = sleep(time); printf(&quot;Sleep time %d: \\n&quot;, time); exit(ret); return 0;&#125; $ sleep 5Number of arguments: 2Argument 0: sleepArgument 1: 5Sleep time 5: 课程学习3.4内核执行任何内核指令3.4 之前提到，设置处理器中kernel mode的bit位的指令是一条特殊权限指令，那么一个用户程序怎么才能让内核执行任何内核指令？因为现在切换到kernel mode的指令都是一条特殊权限指令了，对于用户程序来说也没法修改那个bit位 用户程序会通过系统调用来切换到kernel mode。当用户程序执行系统调用，会通过ECALL触发一个软中断（software interrupt），软中断会查询操作系统预先设定的中断向量表，并执行中断向量表中包含的中断处理程序。中断处理程序在内核中，这样就完成了user mode到kernel mode的切换，并执行用户程序想要执行的特殊权限指令？ 针对这个回答，我的疑问是，怎么确保恶意程序不走这种系统调用呢 3.9 断点调试12345678一个窗口make CPUS=1 qemu-gdb新开窗口 gdb-multiarch kernel/kerneltarget remote localhost:26000 https://zhuanlan.zhihu.com/p/331492444 GDB简单使用 123ctrl x a 显示代码 b 断点 r运行 https://www.bilibili.com/video/BV1ei4y1V758?from=search&amp;seid=4972450432119771986 4.3页表 在最高级的page directory中的PPN，包含了下一级page directory的物理内存地址， 第二个9bit用来索引中间级的page directory，第三个9bit用来索引最低级的page directory。在最低级page directory，我们还是可以得到44bit的PPN，这里包含了我们实际上想要翻译的物理page地址，然后再加上虚拟内存地址的12bit offset，就得到了56bit物理内存地址。 第一个level1有了Level2页表的物理地址，Level2的 PPN就是页表的偏移量,指向Level3的物理地址. https://www.bilibili.com/video/BV1zt4y1U7rq?from=search&amp;seid=11572648099017443360 启动概览 ​ 简单来说 就是加电后，1。启动主板BIOS 》 2. BIOS初始化从磁盘中把加载程序bootloader 加载到内存中 》3.把磁盘镜像操作系统加载到内存中运行 为什么不在第二步直接加载操作系统呢? 1. 为了兼容不同的文件系统 2. bootloader只能存 512字节，系统远大于它。 https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_3_booting.html BIOS初始化 硬件自检POST,检测系统中（内存和显卡，软盘 ，影片 光盘 USB)等关键部件的存在和工作状态查找并执行显卡等接口卡BIOS,并进行设备初始化； 加载上述设备的第一个扇区（主引导扇区，Master Boot Record,or MBR）的512字节的内容读到内存固定地址0x7c00，这个内容就是bootloader,等待对Ucore操作系统的加载. bootloader做的事情 从实模式切换到保护模式(protection mdoe) ，为后续操作系统的执行做准备。 从硬盘上读取kernel in ELF格式的ucore kernel(就是系统代码，跟在MBR后面的扇区)并放到内存中固定位置。 跳转到ucore OS的入口点(entry point)执行，这时候控制器交给了 ucore. 第二部细节 加载程序![](OS\\2021-04-13at1.36.29 PM.png) ​ 计算机可能有不止一个分区，每个分区有不同的系统，主引导记录来确定去哪个文件系统读加载程序 BIOS启动过程 当计算机加电后，一般不直接执行操作系统，而是执行系统初始化软件完成基本IO初始化和引导加载功能(BIOS)。简单地说，系统初始化软件就是在操作系统内核运行之前运行的一段小软件。通过这段小软件，我们可以初始化硬件设备、建立系统的内存空间映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。最终引导加载程序把操作系统内核映像加载到RAM中，并将系统控制权传递给它。 对于绝大多数计算机系统而言，操作系统和应用软件是存放在磁盘（硬盘&#x2F;软盘）、光盘、EPROM、ROM、Flash等可在掉电后继续保存数据的存储介质上。计算机启动后，CPU一开始会到一个特定的地址开始执行指令，这个特定的地址存放了系统初始化软件，负责完成计算机基本的IO初始化，这是系统加电后运行的第一段软件代码。对于Intel 80386的体系结构而言，PC机中的系统初始化软件由BIOS (Basic Input Output System，即基本输入&#x2F;输出系统，其本质是一个固化在主板Flash&#x2F;CMOS上的软件)和位于软盘&#x2F;硬盘引导扇区中的OS Boot Loader（在ucore中的bootasm.S和bootmain.c）一起组成。BIOS实际上是被固化在计算机ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS就是PC计算机硬件与上层软件程序之间的一个”桥梁”，负责访问和控制硬件。 以Intel 80386为例，计算机加电后，CPU从物理地址0xFFFFFFF0（由初始化的CS：EIP确定，此时CS和IP的值分别是0xF000和0xFFF0)）开始执行。在0xFFFFFFF0这里只是存放了一条跳转指令，通过跳转指令跳到BIOS例行程序起始点。BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。 bootloader启动过程 BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。bootloader完成的工作包括： 切换到保护模式，启用分段机制 读磁盘中ELF执行文件格式的ucore操作系统到内存 显示字符串信息 把控制权交给ucore操作系统 对应其工作的实现文件在lab1中的boot目录下的三个文件asm.h、bootasm.S和bootmain.c。下面从原理上介绍完成上述工作的计算机系统硬件和软件背景知识。 操作系统启动过程 当bootloader通过读取硬盘扇区把ucore在系统加载到内存后，就转跳到ucore操作系统在内存中的入口位置（kern&#x2F;init.c中的kern_init函数的起始地址），这样ucore就接管了整个控制权。当前的ucore功能很简单，只完成基本的内存管理和外设中断管理。ucore主要完成的工作包括： 初始化终端； 显示字符串； 显示堆栈中的多层函数调用关系； 切换到保护模式，启用分段机制； 初始化中断控制器，设置中断描述符表，初始化时钟中断，使能整个系统的中断机制； 执行while（1）死循环。 以后的实验中会大量涉及各个函数直接的调用关系，以及由于中断处理导致的异步现象，可能对大家实现操作系统和改正其中的错误有很大影响。而理解好函数调用关系的建立机制和中断处理机制，对后续实验会有很大帮助。下面就练习5涉及的函数栈调用关系和练习6中的中断机制的建立进行阐述。 https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_3_booting.html 系统调用POSIXPortable Operating System Interface of Unix(IEEE制定的一个标准族) 操作系统给上层提供的接口，macos,Linux都遵循这个接口。 内核态 0 ， 用户态 3 GDT表存了DPL为0，用户访问CPL为3， 3 &gt; 0 没法访问。 0x80到内核中 中断、异常和系统调用 中断 硬件设对操作系统备的处理请求（缓存区里有数据，需要内核读走。或者缓冲区里数据用完了，需要内核补充新的数据） 异常 非法指令或者其他原因导致当前指令执行失败（程序出错后的处理请求） 系统调用 应用程序主动向操作系统发出的服务请求 物理内存管理： 连续内存分配最先匹配（First Fit Allocation）： 空闲分区列表按地址顺序排序 分配过程时，搜索第一个合适的分区，如果有剩下的空闲分区，继续把空闲分区切割出来，所以会产生碎片。 释放分区时，检查是否可与临近的空闲分区合并 最佳匹配（Best Fit Allocation） 空闲分区列表按照 小到大排序 分配时，查找比需要分区大的最小的分区，可避免大的空闲分区被拆分，减少碎片大小。 释放时，超找并且合并临近地址的空闲分区（如果找到） Screenshot from 最差匹配(WORST Fit Allocation) 空闲分区列表按大到小排序 分配时，选最大的分区，后续找大分区比较难。 释放时，检查是否可与临近的空闲分区合并，进行可能的合并并调整空闲分区列表顺序。 伙伴系统 非连续内存分配 虚拟地址和物理地址的转换 软件实现 硬件实现 非连续分配的硬件辅助记者 段式存储管理（segmentation）: 分的比较大 页式存储管理 （paging） 把物理地址空间划分为大小相同的基本分配单位，2的n次方，如512,4096 linux启动 http://c.biancheng.net/view/1013.html linux目录结构 目录 描述 &#x2F;bin 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里 &#x2F;etc 存放系统管理和配置文件 &#x2F;home 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是 &#x2F;home&#x2F;user &#x2F;usr 用于存放系统应用程序，比较重要的目录&#x2F;usr&#x2F;local 本地系统管理员软件安装目录 &#x2F;opt 额外安装的可选应用程序包所放置的位置 &#x2F;proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 &#x2F;root 超级用户(系统管理员)的主目录 &#x2F;sbin 存放二进制可执行文件，只有root才能访问 &#x2F;dev 用于存放设备文件 &#x2F;mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系 统。 &#x2F;boot 存放用于系统引导时使用的各种文件 &#x2F;lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 &#x2F;var 用于存放运行时需要改变数据的文件 进程进程调度 : FIFO , Priority 进程切换进程当前的状态存放到PCB(Process Control Block)中，获取下一个需要执行进程的PCB信息，切换进程。 线程 线程 指令的切换，映射表不用切换 2个线程用一个栈的情况 12345678910//第一个Yieldvoid Yield()&#123; 找到300； jmp 300;&#125;//第二个Yieldvoid Yield()&#123; 找到 ? ; 204 jmp ? ;&#125; 按照 (1) -&gt; (2) -&gt; (3)的顺序执行，执行玩D()中的Yield()回到B()中，到了 右括号ret 出栈，出去的是404,正确的情况时时出204 两个线程 两个栈 jmp 204去掉：否则会执行两次 用户程序 内核程序调用 多核处理 多核情况共用一个MMU,减少切换资源调用。 进程线程区别 进程 : 有很大的独立性 线程 : 所有线程都有完全一样的地址空间,意味着它们也共享同样的全局变量。由于线程可以访问进程地址空间的每一个内存地址，所以一个线程可以读、写甚至清除另一个线程的堆栈。 每个进程中的内容 : 地址空间 全局变量 打开文件 子进程 即将发生的定时器 信号与信号处理程序 每个线程中的内容：程序计数器、寄存器、堆栈、状态. 同步原子性 原子性是指一系列操作不可被中断的特性,这一系列操作要么全部执行完成，要么全部没有执行,不存在部分执行部分未执行的情况 互斥量​ 互斥量是最简单的线程同步的方法,处于两态之一的变量:解锁和加锁,两个状态可以保证资源访问的串行 自旋锁与自适应自旋 自旋锁 ​ 自旋锁的线程会反复检查锁变量是否可用,自旋锁不会让出CPU，是一种忙等待状态, ​ 自旋锁避免了进程或线程上下文切换的开销 ​ 自旋锁不适合在单核CPU使用 ​ 自旋锁的线程会反复检查锁变量是否可用 自适应自旋 提到了互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢 复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同 时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了 这段时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多路(核)处理器系 统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们 就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很 快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环(自旋)，这项技术就是所谓的自 旋锁。 自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开 启，在JDK 6中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自 旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很 短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理 器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限 度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数 的默认值是十次，用户也可以使用参数-XX:PreBlockSp in来自行更改。 不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在 JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由 前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚 刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成 功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自 旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资 源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况 预测就会越来越精准，虚拟机就会变得越来越“聪明”了。 读写锁​ 读写锁是一种特殊的自旋锁, ​ 允许多个读者同时访问资源以提高读性能 ​ 对于写操作则是互斥的 条件变量​ 条件变量是一种相对复杂的线程同步方法 ​ 条件变量允许线程睡眠，直到满足某种条件 ​ 当满足条件时，可以向该线程信号，通知唤醒 mooc-os-lab[现代操作系统] 示例 p55 先学习(现代操作系统) 陈渝 向勇 https://www.bilibili.com/video/BV1js411b7vg?from=search&amp;seid=2361361014547524697 配套书： 操作系统概念(第七版) ， 操作系统-精髓与设计原理（第七版）william stallings 实验环境配置https://www.bilibili.com/video/BV1Zz4y1d7BK?from=search&amp;seid=14777231705696776183 http://os.cs.tsinghua.edu.cn/oscourse/OS2020spring ucore实验基准源代码 https://www.bilibili.com/s/video/BV1Zz4y1d7BK ubuntu窗口调整 device -&gt; Insert Guest addtions CD Image https://blog.csdn.net/u012631731/article/details/79548621 修改Ubuntu硬盘大小 https://my.oschina.net/u/4388335/blog/3321852 windows ubuntu文件夹共享 https://www.jianshu.com/p/4e73fd1c0c74?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation 并发 : 多个事件在分段被单个CPU分段执行。 并行： 多个CPU同时处理多个任务。 汇编操作系统https://fishc.com.cn/forum-39-1.html https://www.bilibili.com/video/av22872043/?p=2&amp;spm_id_from=pageDriver GCC内联汇编C语言中加入 汇编代码 2020 南京大学 “操作系统：设计与实现” (蒋炎岩) https://www.bilibili.com/video/BV1N741177F5?p=1&amp;vd_source=d4c5260002405798a57476b318eccac9 https://github.com/NJU-ProjectN/am-kernels GitHub - NJU-ProjectN&#x2F;abstract-machine: A minimal, modularized, and machine-independent hardware abstraction layer 实验不开源,可以了解 实验指导书 · Issue #1 · mansicer&#x2F;NJU-OSlab-2019 · GitHub Introduction · GitBook","categories":[{"name":"OS","slug":"OS","permalink":"https://noteforme.github.io/categories/OS/"}],"tags":[]},{"title":"ComputerOrganization","slug":"ComputerOrganization","date":"2020-12-10T14:42:44.000Z","updated":"2021-08-19T11:11:43.751Z","comments":true,"path":"2020/12/10/ComputerOrganization/","link":"","permalink":"https://noteforme.github.io/2020/12/10/ComputerOrganization/","excerpt":"","text":"组成原理 CPU 运算器 控制器 高速缓存 主存储器= 内存 控制器 程序计数器: 用于提供其他控制单元，当前要执行的指令地址 时序发生器: 用于发送时序脉冲， 依据不同的时序脉冲有节奏的进行工作 寄存器 指令寄存器 :从主存或高速缓存取计算机指令 主存地址寄存器：保存当前CPU正要访问的内存单元的地址 主存地址寄存器： 保存当前CPU正要读或写的主存数据 通用寄存器: 用于暂存或传送数据或指令 可保存ALU的运算中间结果 容量比一般专用寄存器要大 ​ 运算器 数据缓冲器​ 分为输入缓冲和输出缓冲 ​ 输入缓冲暂时存放外设送过来的数据 ​ 输出缓冲暂时存放送往外设的数据 ALU​ ALU:算术逻辑单元，是运算器的主要组成 ​ 常见的位运算(左右移、与或非等) ​ 算术运算(加减乘除等) 通用寄存器​ 用于暂时存放或传送数据或指令 ​ 可保存ALU的运算中间结果 ​ 容量比一般专用寄存器要大 状态字寄存器​ 存放运算状态(条件码、进位、溢出、结果正负等) ​ 存放运算控制信息(调试跟踪标记位、允许中断位等) 高速缓存指令执行过程 高速缓存命中率 ![](ComputerOrganization/Screen Shot 2021-03-03 at 10.10.02 PM.png) 不在缓存的数据需要去主存拿 4GB是寻址空间为什么是4G ,byte而不是 bit现在的内存可以看作一个很长的，每项宽度8位（即1Bit）的很长的数列,既然是数列，那么每一项便对应一个序号，这个序号便是地址，就如同你家在一条大街的第几号一样 https://www.zhihu.com/question/61974351","categories":[{"name":"Organization","slug":"Organization","permalink":"https://noteforme.github.io/categories/Organization/"}],"tags":[]},{"title":"TouchEvent3","slug":"TouchEvent3","date":"2020-11-25T06:12:50.000Z","updated":"2022-05-06T11:24:51.266Z","comments":true,"path":"2020/11/25/TouchEvent3/","link":"","permalink":"https://noteforme.github.io/2020/11/25/TouchEvent3/","excerpt":"","text":"Button TextViewbutton clickable=true,所以 默认消费事件,TextView不会 value.xml 123456789&lt;style name=&quot;Base.Widget.AppCompat.Button&quot; parent=&quot;android:Widget&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@drawable/abc_btn_default_mtrl_shape&lt;/item&gt; &lt;item name=&quot;android:textAppearance&quot;&gt;?android:attr/textAppearanceButton&lt;/item&gt; &lt;item name=&quot;android:minHeight&quot;&gt;48dip&lt;/item&gt; &lt;item name=&quot;android:minWidth&quot;&gt;88dip&lt;/item&gt; &lt;item name=&quot;android:focusable&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:clickable&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:gravity&quot;&gt;center_vertical|center_horizontal&lt;/item&gt;&lt;/style&gt; 处理开篇问题 处理方法外部拦截法:​ 需要在父ViewGroup，重写onInterceptTouchEvent( [ˌɪntərˈsept])方法，根据业务需要，判断哪些事件是父Viewgroup需要的，需要的话就对该事件进行拦截，然后交由onTouchEvent方法处理，若不需要，则不拦截，然后传递给子view或子viewGroup。 内部拦截法主要由子view控制事件，配合requestDisallowInterceptTouchEvent(),父View不拦截任何down事件 ,思路是这样的，在ViewGroupA的Action_Down动作中设置requestDisallowInterceptTouchEvent(true),这样RootView不会走拦截方法，保证Action_Move,能进入ViewGroupA,然后在ViewGroupA的move事件中，根据需要控制RootView发送过来的后续Action_Move事件. 代码 ViewGroupA 12345678910111213141516171819202122232425@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Logger.d(ev.getAction(), TAG, Static.dispatchTouchEvent + &quot;老板要做淘宝,下周上线?&quot;); int x &#x3D; (int) ev.getX(); int y &#x3D; (int) ev.getY(); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX &#x3D; x - mLastX; int deltaY &#x3D; y - mLastY; if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; getParent().requestDisallowInterceptTouchEvent(false); &#125; else &#123; getParent().requestDisallowInterceptTouchEvent(true); &#125; break; &#125; mLastX &#x3D; x; mLastY &#x3D; y; return super.dispatchTouchEvent(ev); &#125; RootView 123456789@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Logger.d(ev.getAction(), TAG, Static.onInterceptTouchEvent + &quot;(老板可能疯了,但又不是我做.)&quot;); if (ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN) &#123; return false; &#125;else &#123; return true; &#125;&#125; 内部拦截ViewGroupA消费事件 运行结果 D/MainActivity [老板] ACTION_DOWN: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.D/RootView [经理] ACTION_DOWN: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.D/RootView [经理] ACTION_DOWN: onInterceptTouchEvent (老板可能疯了,但又不是我做.)D/ViewGroupA [组长] ACTION_DOWN: dispatchTouchEvent 老板要做淘宝,下周上线?D/ViewGroupA [组长] ACTION_DOWN: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)D/ViewGroupA [组长] ACTION_DOWN: onTouchEvent 小王说做不了 D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 代码流程 Action_down都会被ViewGroupA消费,所以主要分析Action_Move事件流程,由于Action_down requestDisallowInterceptTouchEvent(true)那么 disallowIntercept =true, 第1次 Action_Move 分发 RootView : dispatchTouchEvent() 29 =&gt; 32=&gt;36 intercepted = false =&gt; 58 =&gt; ViewGroupA: dispatchTouchEvent() 29=&gt; 设置 getParent().requestDisallowInterceptTouchEvent(true) =&gt;view =&gt; dispatchTouchEvent被消费 第2次Action_Move 分发 RootView : dispatchTouchEvent() 29 =&gt; 32=&gt;36 intercepted = false =&gt; 58 =&gt; ViewGroupA: dispatchTouchEvent() 29=&gt; 设置y&gt;x getParent().requestDisallowInterceptTouchEvent(true) =&gt;view =&gt; dispatchTouchEvent被消费 运行结果 225 24328-24328/ D/MainActivity [老板] ACTION_DOWN: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.226 24328-24328/ D/RootView [经理] ACTION_DOWN: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.226 24328-24328/ D/RootView [经理] ACTION_DOWN: onInterceptTouchEvent (老板可能疯了,但又不是我做.)227 24328-24328/ D/ViewGroupA [组长] ACTION_DOWN: dispatchTouchEvent 老板要做淘宝,下周上线?227 24328-24328/ D/ViewGroupA [组长] ACTION_DOWN: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)228 24328-24328/ D/ViewGroupA [组长] ACTION_DOWN: onTouchEvent 小王说做不了 237 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.237 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.237 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?237 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent dx:0 dy:0238 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent Math.abs(deltaX) &gt; Math.abs(deltaY) false238 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 287 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.287 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.287 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?288 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent dx:2 dy:0288 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent Math.abs(deltaX) &gt; Math.abs(deltaY) true288 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 304 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.305 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.305 24328-24328/ D/RootView [经理] ACTION_MOVE: onInterceptTouchEvent (老板可能疯了,但又不是我做.) 320 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.321 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.321 24328-24328/ D/RootView [经理] ACTION_MOVE: onTouchEvent 报告老板, 技术部说做不了 338 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.338 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.338 24328-24328/ D/RootView [经理] ACTION_MOVE: onTouchEvent 报告老板, 技术部说做不了 代码流程 百思不得其姐， RootView dispatchTouchEvent 后面的onInterceptTouchEvent() 方法日志为什么没打印，其他都能通 1MotionEvent.ACTION_DOWN requestDisallowInterceptTouchEvent(true),必须设置,否则后续的Action_Move无法进入 ViewGroupA https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650237941&amp;idx=1&amp;sn=40bca69abe10015cc469132f8c76a910&amp;chksm=88639a9abf14138cae7409adec85c5496486a044d7f4ef102e513d9c052aaa30017fb37e3439&amp;scene=38#wechat_redirect","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[{"name":"TouchEvent","slug":"TouchEvent","permalink":"https://noteforme.github.io/tags/TouchEvent/"}]},{"title":"base64","slug":"base64","date":"2020-10-22T06:49:37.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/10/22/base64/","link":"","permalink":"https://noteforme.github.io/2020/10/22/base64/","excerpt":"","text":"https://www.jianshu.com/p/313b73ee7d6f","categories":[{"name":"flutter","slug":"flutter","permalink":"https://noteforme.github.io/categories/flutter/"}],"tags":[]},{"title":"flutter_paint","slug":"flutter-paint","date":"2020-10-14T05:53:46.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/10/14/flutter-paint/","link":"","permalink":"https://noteforme.github.io/2020/10/14/flutter-paint/","excerpt":"","text":"1Offset(size.width*0.5, size.height) //坐标 https://codewithandrea.com/videos/2020-01-27-flutter-custom-painting-do-not-fear-canvas/ https://flutter.dev/docs/development/ui/widgets/painting","categories":[{"name":"flutter","slug":"flutter","permalink":"https://noteforme.github.io/categories/flutter/"}],"tags":[]},{"title":"flutter_layout","slug":"flutter-layout","date":"2020-09-24T07:43:26.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/09/24/flutter-layout/","link":"","permalink":"https://noteforme.github.io/2020/09/24/flutter-layout/","excerpt":"","text":"https://jspang.com/detailed?id=43 https://book.flutterchina.club/chapter4/row_and_column.html 主轴和纵轴对于线性布局，有主轴和纵轴之分，如果布局是沿水平方向(Row),那么主轴就是指水平方向，而纵轴即垂直方向. 如果布局沿垂直方向(Colomn)，那么主轴就是指垂直方向，而纵轴就是水平方向 MainAxisAlignment 表示子组件在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义 crossAxisAlignment 表示子组件在纵轴方向的对齐方式，Row的高度等于子组件中最高的子元素高度 TextDirection : 字体方向 CrossAxisAlignment : 表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下. Row和Column都只会在主轴方向占用尽可能大的空间，而纵轴的长度则取决于他们最大子元素的长度 特殊情况 : 如果Row里面嵌套Row，或者Column里面再嵌套Column，那么只有最外面的Row或Column会占用尽可能大的空间，里面Row或Column所占用的空间为实际大小，下面以Column为例说明","categories":[{"name":"flutter","slug":"flutter","permalink":"https://noteforme.github.io/categories/flutter/"}],"tags":[]},{"title":"flutterdev","slug":"flutterdev","date":"2020-08-26T03:56:46.000Z","updated":"2021-08-19T11:11:44.299Z","comments":true,"path":"2020/08/26/flutterdev/","link":"","permalink":"https://noteforme.github.io/2020/08/26/flutterdev/","excerpt":"","text":"​ https://flutter.dev/docs/development/ui/layout Aligning widgetsMainAxisAlignmenthttps://blog.csdn.net/BINGXIHEART/article/details/95077098 可以接着完善 row 12345678Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ Image.asset(&#x27;images/pic1.jpg&#x27;), Image.asset(&#x27;images/pic2.jpg&#x27;), Image.asset(&#x27;images/pic3.jpg&#x27;), ],); Column 12345678Widget buildRow() =&gt; Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Image.asset(&#x27;images/pic1.jpg&#x27;), Image.asset(&#x27;images/pic2.jpg&#x27;), Image.asset(&#x27;images/pic3.jpg&#x27;), ], ); constraintsConstrainedBox The ConstrainedBox imposes additional constraints from its constraints parameter onto its child . UnconstrainedBoxThe screen forces the UnconstrainedBox to be exactly the same size as the screen. However, the UnconstrainedBox lets its child Container be any size it wants https://resocoder.com/2019/08/15/flutter-custom-icons-automatic-manual-way-icon-font-or-svg/ https://www.fluttericon.com/ json and serializtion1234567891011dependencies: json_annotation: ^2.2.0dev_dependencies: flutter_test: sdk: flutter build_runner: ^1.0.0 json_serializable: ^2.0.0 json_model: flutter packages pub run json_model 123456789101112131415161718192021import &#x27;dart:convert&#x27;;import &#x27;dart:io&#x27;;import &#x27;package:flutteruse/models/user.dart&#x27;;void main() &#123; final jsonString = File(&#x27;jsons/user.json&#x27;).readAsStringSync(); print(jsonString); // var jsonString = &#x27;&#123;&quot;name&quot;: &quot;John Smith&quot;,&quot;email&quot;: &quot;john@example.com&quot;&#125;&#x27;; // Map&lt;String, dynamic&gt; user = jsonDecode(jsonString) as Map&lt;String, dynamic&gt;; // print(&#x27;Howdy, $&#123;user[&#x27;name&#x27;]&#125;!&#x27;); // print(&#x27;We sent the verification link to $&#123;user[&#x27;email&#x27;]&#125;.&#x27;); Map userMap = jsonDecode(jsonString); var user = User.fromJson(userMap); print(&#x27;Howdy, $&#123;user.name&#125;!&#x27;); print(&#x27;We sent the verification link to $&#123;user.email&#125;.&#x27;); print(user.toJson());&#125; 项目中采用第三种方法 使用json_model自动生成 1.在项目根目录新建jsons文件夹并将json数据新建成为文件，在lib目录下新建包名为models 注意：这两个文件夹的名字都必须为jsons和models 2、加入依懒 注意：这里添加完json_serializable相关依赖之后还添加了json_model的依赖，这就是快捷生成的关键，还有如果json中引用了其他model可以使用如下方式 { “name”:”wendux”, “father”:”$user”,//可以通过”$”符号引用其它model类 “friends”:”$[]user”,//可以通过”$[]”来引用数组 “keywords”:”$[]String”,//同上 “age”:20 } 3.完成上面的操作之后 在当前项目的根目录执行如下命令：flutter packages pub run json_model 控制台打印如下日志就成功了 注意：如果json文件中加了注释可能会报错，需要删除注释，错误信息如下 其实，我们也可以不使用命令行的方式自动生成， 用run([‘src=jsons’])的方法也可以，run方法为json_model暴露的方法 https://www.jianshu.com/p/f37d8546ab8f 修改包名后 pubspec.yaml target file “lib/main_dev.dart” not found 12345plugin: platforms: android: package: com.casanube.flutter_ble //记得修改这个包名 要不然爆出上面的错误 pluginClass: FlutterBlePlugin flutter自定义控件 https://mp.weixin.qq.com/s/aVvos5iWYVmiVZRv4hMQMQ https://juejin.im/post/6874061694491721736","categories":[{"name":"flutter","slug":"flutter","permalink":"https://noteforme.github.io/categories/flutter/"}],"tags":[]},{"title":"OS_PROCESS","slug":"OS-PROCESS","date":"2020-08-17T02:55:14.000Z","updated":"2025-02-26T13:18:40.146Z","comments":true,"path":"2020/08/17/OS-PROCESS/","link":"","permalink":"https://noteforme.github.io/2020/08/17/OS-PROCESS/","excerpt":"","text":"进程进程有很大的独立性 为了实现进程模型，操作系统维护着一张表格，进程表。每个进程占用一个进程表项。 进程通信进程通信方式文件 AIDL （基于 Binder） Android 进阶：进程通信之 AIDL 的使用 Android 进阶：进程通信之 AIDL 解析 Binder Android 进阶：进程通信之 Binder 机制浅析 Messenger （基于 Binder） Android 进阶：进程通信之 Messenger 使用与解析 ContentProvider （基于 Binder） Android 进阶：进程通信之 ContentProvider 内容提供者 Socket Android 进阶：进程通信之 Socket （顺便回顾 TCP UDP） 原文链接：https://blog.csdn.net/u011240877/article/details/72863432 管道通信 无名管道， 有名管道:文件系统中有这样一个文件名 信号通信： 进程通信的思想 共享内存 共享存储允许不相关的进程访问同一片物理内存 共享内存是两个进程之间共享和传递数据最快的方式 共享内存未提供同步机制，需要借助其他机制管理访问 共享存储是两个进程之间共享和传递数据最快的一种方式 共享内存未提供同步机制，需要借助其他机制管理访问 Unix域套接字 域套接字是一种高级的进程间通信的方法 Unix域套接字可以用于同一机器进程间通信 https://www.bilibili.com/video/BV1tJ41117ty?from=search&amp;seid=13006387505737298314","categories":[{"name":"OS","slug":"OS","permalink":"https://noteforme.github.io/categories/OS/"}],"tags":[]},{"title":"AutoDispose","slug":"AutoDispose","date":"2020-08-14T02:18:28.000Z","updated":"2021-08-19T11:11:43.695Z","comments":true,"path":"2020/08/14/AutoDispose/","link":"","permalink":"https://noteforme.github.io/2020/08/14/AutoDispose/","excerpt":"","text":"https://uber.github.io/AutoDispose/","categories":[],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://noteforme.github.io/tags/RxJava/"}]},{"title":"ViewGroup","slug":"ViewGroup","date":"2020-08-12T23:36:27.000Z","updated":"2021-12-05T11:51:53.119Z","comments":true,"path":"2020/08/13/ViewGroup/","link":"","permalink":"https://noteforme.github.io/2020/08/13/ViewGroup/","excerpt":"","text":"生命周期 每次onMeasure，onLayout用到的值都不能在构造方法里面初始化。 座标系 getLeft()直接调用是0 ? 需要自己设置 chidView.layout(left, top,right,bottom), 没调用chidView.layout 就获取不到 getLeft()的值。 left这些参数的座标系 是基于ViewGroup. getMeasuredWidth getWidthgetMeasuredWidth 在measure()过程结束后就可以获取到对应的值。 通过setMeasuredDimension()方法来进行设置。 getWidth 在view.layout()过程结束后才能获取到； 通过视图右边的坐标-左边的左边计算出来的 123456789101112131415final int childHeightMeasureSpec;if (lp.height == LayoutParams.MATCH_PARENT) &#123; final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY);&#125; else &#123; childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height);&#125;child.measure(childWidthMeasureSpec, childHeightMeasureSpec); Frame layout 子节点重新绘制，为什么 Framelayout边界怎么算的 1234567891011121314switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin;&#125; LayoutParams MeasureSpec的关系 ViewGroup测量 先度量child View,再度量自己的大小。 先度量 child View,child view度量完成，如果是 wrap_content，就是all childview的size. ​ // parent size child want size ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;// padding是parent view的 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding);// parent size int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; MeasureSpec创建规则 子View为精确宽高，无论父容器的MeasureSpec，子View的MeasureSpec都为精确值且遵循LayoutParams中的值。 子View为match_parent时，如果父容器是精确模式，则子View也为精确模式且为父容器的剩余空间大小；如果父容器是最大模式，则子View也是最大模式且不会超过父容器的剩余空间。 子View为wrap_content时，无论父View是精确还是最大模式，子View的模式总是最大模式，且不会超过父容器的剩余空间。 艺术探索 https://www.jianshu.com/p/cb529ed03597 https://juejin.cn/post/6844904094205739016 MeasureSpec表示 MeasureSpec用int表示,总共32位，高2位代表SpecMode，低30位代表SpecSize,SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配.打包makeMeasureSpec。 高2位 00 , 01, 10, 分别对应UNSPECIFIED, EXACTLY,AT_MOST。 UNSPECIFIED 父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态. 开发者用不了. EXACTLY 父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。 AT_MOST 父容器指定了一个可用大小即SpecSize,View的大小不能大于这个值 ​ Inflate解析过程 https://www.bilibili.com/video/BV1Ka4y1j7HA?p=4&amp;spm_id_from=pageDriver https://www.youtube.com/watch?v=aOb4Hvqbeu4 https://www.bilibili.com/video/BV1M54y1y79P?from=search&amp;seid=18028227823566625572&amp;spm_id_from=333.337.0.0 自定义View Marginhttps://blog.csdn.net/qiantanlong/article/details/82347850","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[]},{"title":"WMS","slug":"WMS","date":"2020-08-09T15:05:02.000Z","updated":"2021-08-19T11:11:44.282Z","comments":true,"path":"2020/08/09/WMS/","link":"","permalink":"https://noteforme.github.io/2020/08/09/WMS/","excerpt":"","text":"AMS启动activity Activity启动流程 window作用单一职责:解藕activity view View是生命周期哪个方法绘制 window负责管理UI,因为window是在 onCreate()之后产生的，所以view绘制一定在onCreate()之后。 onResume() decorview和Activity进行绑定，所以也是 onCreate()能在子线程刷新UI的原因 , 接着在 onResume()调用 performMeasure() performLayout(), performDraw() 1234textView = findViewById(R.id.tv_thread);new Handler().post(() -&gt; &#123; Log.i(&quot;GlideActivity&quot;, &quot;onResume: &quot; + textView.getWidth());&#125;); 运行结果 I/GlideActivity: onResume: 0 OnResume()也是一个消息，虽然post消息放在后面，但是是因为建立了消息屏障。所以还是先执行，然后获取宽度为0; https://www.bilibili.com/video/BV1FK4y1R7Nw?from=search&amp;seid=12068296586023469576","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"PMS","slug":"PMS","date":"2020-08-07T14:05:02.000Z","updated":"2021-08-19T11:11:44.196Z","comments":true,"path":"2020/08/07/PMS/","link":"","permalink":"https://noteforme.github.io/2020/08/07/PMS/","excerpt":"","text":"PMS PMS服务是干什么的 管理 加载 缓存APK文件，把APK文件加载成package对象，缓存到mPackages中 当AMS需要加载Activity时，PMS提供对应的信息(javabean) PMS是谁启动的SystemServer PMS扫描是为了什么以空间换时间 PMS启动应用，会发生什么 通过包名，找到对应的apk文件 解压apk文件 经过dom解析，找到Launcher对应的activity 再反射加载 app启动成功。","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"AMS","slug":"AMS","date":"2020-08-07T14:04:13.000Z","updated":"2021-08-19T11:11:43.480Z","comments":true,"path":"2020/08/07/AMS/","link":"","permalink":"https://noteforme.github.io/2020/08/07/AMS/","excerpt":"","text":"系统启动![](AMS/2021-07-31 at 7.53_start1.png) ​ AMSAMS属于SystemServer进程,主要是为了加载Activity 管理Activity生命周期 . Launcher请求AMS创建根Activity所在进程（如果之前没有该进程），AMS请求Zygote进程fork应用进程。 android启动流程 https://www.bilibili.com/video/BV1DQ4y197oX?from=search&amp;seid=14802265503756746151 https://www.bilibili.com/video/BV1Pi4y1A7Sr?from=search&amp;seid=17031756056912732811 一般 https://www.bilibili.com/video/BV1K541177GU?p=3 应用启动流程Launcher请求AMS阶段","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"RxJava","slug":"RxJava","date":"2020-08-04T03:16:40.000Z","updated":"2022-07-16T15:07:08.241Z","comments":true,"path":"2020/08/04/RxJava/","link":"","permalink":"https://noteforme.github.io/2020/08/04/RxJava/","excerpt":"","text":"观察者模式观察者模式使用 最主要的是Observable里面持有observer引用，就可以给observer发消息，其他的都是拓展。 Rxjava2会有Flower等背压类继承ObservableSource，所以 Observable 从ObservableSource分离出来，让ObservableCreate实现subscribeAcutal(Observer) 本来可以在ObservableCreate中直接发消息，因为emmit也可能变，现在把调用流程放到了ObservableOnSubscribe,并且传了emmit,最终ObservableOnSubscribe打包给了了ObservableCreate 观察者模式应用12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 具体的被观察者 */public class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; @Override protected void subscribeActual(Observer observer) &#123; observer.onSubscribe(); //订阅成功，回调给观察者 //创建发射器 CreateEmitter createEmitter = new CreateEmitter(observer); //发射器和观察者建立关联 source.subscribe(createEmitter); //发射器与被观察者建立关联 &#125; static final class CreateEmitter&lt;T&gt; implements Emitter&lt;T&gt; &#123; final Observer&lt;T&gt; observer; public CreateEmitter(Observer&lt;T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; observer.onNext(t); &#125; @Override public void onError(Throwable e) &#123; observer.onError(e); &#125; @Override public void onComplete() &#123; observer.onComplete(); &#125; &#125;&#125; 装饰器模式装饰器模式使用RxJava观察者模式最主要是这个方法 subscribeActual(Observer observer) ，通过发射器与 观察者、被观察者建立关联，接着通过发射器发送事件给观察者。 !(RxJava/2021-07-12-RXJAVA.png) 红色方框中用到了 装饰器模式。 应用实例WriteRxJavaActivity.java 1234567891011121314151617181920212223242526272829Observable.create(new ObservableOnSubscribe&lt;Object&gt;() &#123; @Override public void subscribe(Emitter&lt;Object&gt; emitter) &#123; Log.i(TAG, &quot;subscribe: &quot;); emitter.onNext(&quot;aaaa&quot;); emitter.onNext(&quot;bbb&quot;); emitter.onNext(&quot;12312&quot;); emitter.onComplete(); &#125;&#125;) .map(new Function&lt;Object, Object&gt;() &#123; @Override public Object apply(Object o) &#123; return (&quot;apply 后 1 &quot; + o); &#125; &#125;) .map(new Function&lt;Object, Object&gt;() &#123; @Override public Object apply(Object o) &#123; return (&quot;apply 后 2 &quot; + o); &#125; &#125;) .subscribe(new Observer() &#123; @Override public void onNext(Object o) &#123; Log.i(TAG, &quot;onNext: &quot; + o); &#125; &#125;); 调用结构图上面代码的调用结构可以用下图表示 上面三条流，可以看到每一条流的结束会启动另一条流的开端。 N0持有source引用，自己又创建Observable,订阅了O4。 链式构建流 订阅流 观察者回调流（事件回调流） ObservableMap其中关键代码在ObservableMap.java ,subscribeActual方法。 Observalbe.java 123public &lt;R&gt; ObservableMap&lt;T, R&gt; map(Function&lt;T,R&gt; function)&#123; return new ObservableMap(this,function); //上层Observable传入 ObservableMap&#125; ObservableMap.java 123protected void subscribeActual(Observer observer) &#123; // source上层Observable, source.subscribe(new MapObserver(observer, function)); //传入的observer是下游的observer,可以从最后往前看&#125; 调用流程 第一遍 把 Observable传入下一层的Observable中。 可以理解为 调用结构图 -&gt;向右建立关联 直至调用到最后的观察者subscribe(new Observer())，开始把下一级的Observer传入Observable(被观察者)，可以理解为向左建立关联。 1，2完成后可以理解为建立双向链表，上游一直持有下游的Observer,开始发送emitter.onNext(“aaaa”);事件。 ​ 除了最后手动建立观察者，中间也建立了观察者，不停的向下发送事件。 ​ observable observer都在套娃。 ObservableFlatMap接收事件后，创建新的事件发送。 问题RxJava的subscribeOn只有第一次生效?​ subscribeOn对subscribe订阅进行处理，针对是订阅流，从后向前流动，所以最前面的一次生效。 RxJava的observeOn多次调用哪个有效?​ observeOn在事件发送的 onNext(T t)进行处理，针对的是观察者流，从前向后流动，所以最后一次生效。 匿名内部类和lambda区别[https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/2-Lambda%20and%20Anonymous%20Classes(II).md](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/2-Lambda and Anonymous Classes(II).md) 匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名。因此如果有如下形式的代码，编译之后将会产生两个class文件 Lambda表达式通过*invokedynamic*指令实现，书写Lambda表达式不会产生新的类 推论，this引用的意义 既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。因此下列代码将输出两遍Hello Hoolee，而不是两个引用地址。 Java 函数式接口 java接口 只有一个方法 传统方法123456789101112private static void log(int level, String msg) &#123; if (level &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F;如果不是1 msg已经拼接 所以造成浪费 System.out.println(msg); &#125;&#125;public static void main(String[] args) &#123; String msgA &#x3D; &quot;Hello&quot;; String msgB &#x3D; &quot;World&quot;; String msgC &#x3D; &quot;Java&quot;; log(1, msgA + msgB + msgC);&#125; lambda1234567891011121314151617181920212223242526272829303132333435@FunctionalInterfaceinterface MessageBuilder &#123; String builderMessage();&#125;private static void showLog(int level, MessageBuilder msg) &#123; if (level &#x3D;&#x3D; 1) &#123; System.out.println(msg.builderMessage()); &#125;&#125;public static void main(String[] args) &#123; String msgA &#x3D; &quot;Hello&quot;; String msgB &#x3D; &quot;World&quot;; String msgC &#x3D; &quot;Java&quot;; showLog(1, () -&gt; msgA + msgB + msgC); &#x2F;&#x2F;使用lambda表达式只是作为参数传递，仅仅吧参数传到showLog()中 &#x2F;&#x2F;只有日志等级是1时 才会调用builderMessage 拼接字符串 showLog(1, () -&gt; &#123; System.out.println(&quot;1 是否执行&quot;); return msgA + msgB + msgC; &#125; ); showLog(2, () -&gt; &#123; System.out.println(&quot;2 是否执行&quot;); return msgA + msgB + msgC; &#125; );&#125; 这样看来 lambda: (左边是参数) -&gt; {右边是方法体} 方法体是 接口中唯一方法的实现 https://www.bilibili.com/video/BV1U4411V7Sv?p=5 RxJava操作符Consumer123456789101112131415@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; accept123public static void method(String name,Consumer&lt;String&gt; con)&#123; con.accept(name);&#125; 123method(&quot;john&quot;,(String name)-&gt;&#123; System.out.println(name);&#125;); andThen示例1 123public static void method3(String s, Consumer1 con1, Consumer1 con2) &#123; con1.andThen3(con2).accept(s);&#125; 等价于 示例2 1234public static void method(String s, Consumer&lt;String&gt; con1, Consumer&lt;Double&gt; con2) &#123; con1.accept(s); con2.accept(Double.parseDouble(s));&#125; 12345method3(&quot;3.14&quot;, (t) -&gt; &#123; System.out.println(t + &quot;15926&quot;);&#125;, (t) -&gt; &#123; System.out.println(t + &quot;jj&quot;);&#125;); 一开始 纳闷 con1.andThen3(con2).accept(s); 为啥还调用一个accept(s) 自定义的Consumer1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@FunctionalInterfacepublic interface Consumer1 &#123; &#x2F;** * Performs this operation on the given argument. * * @param t the input argument *&#x2F; void accept(String t); default Consumer1 andThen(Consumer1 after) &#123; Objects.requireNonNull(after); return (String t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125; default Consumer1 andThen1(Consumer1 after) &#123; Objects.requireNonNull(after); return (String t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125; default Consumer1 andThen2(Consumer1 after) &#123; Objects.requireNonNull(after); return (String t) -&gt; &#123; accept(t); accept(t); after.accept(t); after.accept(t); &#125;; &#125; default Consumer1 andThen3(Consumer1 after) &#123; Consumer1 m &#x3D; (String t) -&gt; &#123; System.out.println(&quot;接收参数 t : &quot;+t); after.accept(t); accept(t); &#125;; return m; &#125;&#125; 我的理解 ： 可以看 lambda 延迟调用的示例，当调用accept(s)方法 才开始调用方法体 &#123; accept(t); after.accept(t); &#125;的方法， 返回lambda,可以当作匿名内部类的语法糖, accept(s)当作匿名内部类的方法， s作为参数 传入到 (T t) -&gt; &#123; accept(t); after.accept(t); &#125; t中 通过下面这个示例可以验证 1234@FunctionalInterfaceinterface MessageBuilder1 &#123; String builderMessage(int param);&#125; 123456private static void showLog1(int level, MessageBuilder1 msg) &#123; if (level == 1) &#123; System.out.println(msg.builderMessage(5)); &#125;&#125; 1234showLog1(1, (t) -&gt; &#123; System.out.println(t); return msgA + msgB + msgC;&#125;); 输出 5HelloWorldJava Function1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package java.util.function;/** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #apply(Object)&#125;. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the &#123;@code before&#125; * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of input to the &#123;@code before&#125; function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the &#123;@code before&#125; * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; /** * Returns a composed function that first applies this function to * its input, and then applies the &#123;@code after&#125; function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of output of the &#123;@code after&#125; function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the &#123;@code after&#125; function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; /** * Returns a function that always returns its input argument. * * @param &lt;T&gt; the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 1234public int compute(int a, Function&lt;Integer,Integer&gt; function)&#123; int reuslt = function.apply(a); // 相当于 2 * value 操作 return reuslt;&#125; 1234567FunctionTest functionTest = new FunctionTest();functionTest.compute(1,value-&gt;&#123;return 2 * value ;&#125;);Function&lt;Integer,Integer&gt; function = value -&gt; value *2;functionTest.compute(1,function);function.compose(function); RxJava 思考 https://gank.io/post/560e15be2dca930e00da1083#toc-31 https://juejin.im/post/6844903670203547656 https://juejin.im/post/6844903711416778765 https://www.jianshu.com/p/7fce2955f2db https://juejin.im/post/6844903838978146317","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://noteforme.github.io/tags/RxJava/"}]},{"title":"DesignPattern_Chain","slug":"DesignPattern-Chain","date":"2020-07-22T14:43:57.000Z","updated":"2024-10-01T11:29:48.525Z","comments":true,"path":"2020/07/22/DesignPattern-Chain/","link":"","permalink":"https://noteforme.github.io/2020/07/22/DesignPattern-Chain/","excerpt":"","text":"传统方案OA系统审批问题 职责链模式介绍 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连城一条链，并沿着这条传递该请求。直到有一个对象处理它为止。 ![2021-09-12_7.11.21_ class](DesignPattern-Chain&#x2F;2021-09-12_7.11.21_ class.png) 大话示例chain of Responsibility Pattern 12345public class Request &#123; public String requestType; public String requestContent; public int number;&#125; 12345678910111213141516public abstract class Manager &#123; protected String name; protected Manager superior;//管理者上级 public Manager(String name) &#123; this.name = name; &#125; // 设置管理者上级 public void setSuperior(Manager superior) &#123; this.superior = superior; &#125; //申请请求 abstract void requestApplications(Request request);&#125; 123456789101112131415public class CommonManager extends Manager &#123; public CommonManager(String name) &#123; super(name); &#125; @Override void requestApplications(Request request) &#123; if (&quot;请假&quot;.equals(request.requestType)&amp;&amp;request.number&lt;2)&#123; System.out.println(name+&quot; &quot;+ request.requestContent+ &quot; 数量 &quot;+ request.number+&quot; 被批准&quot;); &#125;else &#123; if (superior!=null) superior.requestApplications(request); &#125; &#125;&#125; 123456789101112131415public class MajorDomo extends Manager &#123; public MajorDomo(String name) &#123; super(name); &#125; @Override void requestApplications(Request request) &#123; if (&quot;请假&quot;.equals(request.requestType)&amp;&amp;request.number&lt;5)&#123; System.out.println(name+&quot; &quot;+ request.requestContent+ &quot; 数量 &quot;+ request.number+&quot; 被批准&quot;); &#125;else &#123; if (superior!=null) superior.requestApplications(request); &#125; &#125;&#125; 12345678910111213141516public class GeneralManager extends Manager &#123; public GeneralManager(String name) &#123; super(name); &#125; @Override void requestApplications(Request request) &#123; if (&quot;请假&quot;.equals(request.requestType) &amp;&amp; request.number &lt; 5) &#123; System.out.println(name + &quot; &quot; + request.requestContent + &quot; 数量 &quot; + request.number + &quot; 被批准&quot;); &#125; else if (&quot;加薪&quot;.equals(request.requestType) &amp;&amp; request.number &lt; 500) &#123; System.out.println(name + &quot; &quot; + request.requestContent + &quot; 数量 &quot; + request.number + &quot; 被批准&quot;); &#125;else if (&quot;加薪&quot;.equals(request.requestType) &amp;&amp; request.number &gt; 500) &#123; System.out.println(name + &quot; &quot; + request.requestContent + &quot; 数量 &quot; + request.number + &quot; 再说吧&quot;); &#125; &#125;&#125; 12345678910111213141516171819CommonManager commonManager = new CommonManager(&quot;经理&quot;);MajorDomo majorDomo = new MajorDomo(&quot;总监&quot;);GeneralManager generalManager = new GeneralManager(&quot;总经理&quot;);commonManager.setSuperior(majorDomo);//设置上级majorDomo.setSuperior(generalManager);Request request = new Request();request.requestType = &quot;请假&quot;;request.number = 4;request.requestContent = &quot;去找小姐姐&quot;;commonManager.requestApplications(request);Request request1 = new Request();request1.requestType = &quot;加薪&quot;;request1.number = 888;request1.requestContent = &quot;给哥加薪&quot;;commonManager.requestApplications(request1); 责任链模式作用 https://www.bilibili.com/video/BV1G4411c7N4?p=149&amp;spm_id_from=pageDriver https://blog.csdn.net/weixin_45203607/article/details/120238491","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[]},{"title":"Regular","slug":"Regular","date":"2020-07-20T09:07:08.000Z","updated":"2024-03-31T23:23:52.279Z","comments":true,"path":"2020/07/20/Regular/","link":"","permalink":"https://noteforme.github.io/2020/07/20/Regular/","excerpt":"","text":"Tool Websitehttps://regex101.com/ https://ihateregex.io/expr/passwordhttps://deerchao.cn/tools/wegester/ ASCII 读ASCII表 先读 “横”座标,后读 “纵” 座标.例如：A , 二进制是 0100 0001 十进制是 2^6 + 1 = 65 十六进制 41 F : 二进制是 0100 0110 十进制是 2^6 + 2^2+2=70 十六进制 46 String中的数字转int1234val digits = &quot;23&quot;val c = digits[0] - &#x27;0&#x27; // 50 - 48println(digits[0].code) // ASCII是 50 ,16进制是0x32,可以在表中查出是2println(&#x27;0&#x27;.code) //ASCII是 48 正则意义对照表格https://www.jb51.net/shouce/jquery1.82/regexp.html https://baixin.ink/2016/03/21/regular-expression/ https://www.bilibili.com/video/BV1Eq4y1E79W?p=4 https://deerchao.cn/tutorials/regex/regex.htm https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285 语法字符普通字符字母、数字、汉字、下划线、以及没有特殊定义的标点符号都是普通字符。直接匹配与之相同的字符 -简单的转义字符 \\n 换行符 \\t 制表符 \\ \\本身 其他都是类似 ^ $ ( 这样匹配这些字符本身的（还有 ) { } ? + * | [ ] ） 标准字符集合 能够与多种字符匹配的表达式 注意区分大小写 大写是相反的意思 \\d 任意一个数字，0-9中任意一个 \\D 表示所有非数字 \\w 任意一个字母或下划线，也就是A-Z、a-z、0-9、_ 、中的任意一个 \\s 包括空格、制表符、换行符等空白字符中的任意一个 . 小数点可以匹配任意一个字符（除了换行符）。如果要匹配包括“\\n”在内的所有字符，一般用 [\\s\\S] \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 (注意是空白字符，不是空格) 自定义字符集合[]方括号匹配方式 ，能够匹配方括号中任意一个字符。^符号在方括号里表示 取反 方括号外表示零宽标记，见后面 [ab5@] 匹配 “a”或“b”或“5”或“@” [^abc] 匹配“a”、“b”、”c“之外的任意一个字符 [f-k] 匹配“f”-“k”之间的任意一个字母 [^A-F0-3] 匹配“A”-“F”，“0”-“3”之外的任意一个字符 正则表达式的特殊符号，被包含到中括号中则失去其特殊意义（就表示自身这个字符），除了^,-之外。 标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。 比如： [\\d.-+]将匹配：数字、小数点、+、- 本身意义，除非加转义字符\\ 上面两句一个意思呀 量词Quantifier修饰匹配次数的特殊符号 {n} 表达式重复n次 如：\\d{6} 匹配6位数字 \\d\\d{6} 匹配7位数字 {\\d\\d}{6} 匹配12位数字 {m,n} 表达式至少重复m次，最多重复n次 {m,} 至少重复m次 ？ 匹配表达式0次或1次 ，相当于{0，1} 如：a\\d{0,1}b a\\d?b 是等价的 + 表达式至少出现1次,相当于{1，} 如：a\\d+b * 表达式不出现或出现任意次 相当于{0，} 选其中之一的条件 ｜匹配x或y。例如，“z 匹配次数中的贪婪模式 （匹配字符数越多越好，默认的）如\\d{3,6} 会优先匹配 6位数字 匹配次数中的非贪婪模式 （匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个“？”号） 对于 2[0-4]\\d|25[0-5]|[01]?\\d\\d? 的ip地址解析可以这样理解 2[0-4]\\d : 200- 249 25[0-5] : 250 - 255 [01]?\\d\\d? : 0- 199 这样就覆盖了所有能填的ip地址。 {n} o{2}” 不能匹配“Bob”中的“o”，因为只有1个o, 但是能匹配“food”中的两个o . {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 字符边界(零宽，不占长度)-（本组标记匹配的不是字符而是位置，符合某种条件的位置） ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^。 $ 与字符结束的地方匹配 \\b 匹配一个单词边界 ^ []部分也有描述. https://www.runoob.com/regexp/regexp-syntax.html REG : John\\b John 匹配 可以看到 John_ 下划线_就是\\b的位置，他的左侧n 匹配，但是右侧空格不匹配 \\w,所以就是不全是\\w,所以匹配。 -\\b匹配这样一个位置：前面的字符和后面的字符不全是\\w （全是的就不匹配） 如：^i 匹配 i开头的位置 i$ 匹配i结束的位置 hello\\b 匹配前后不全是\\w表示的hello 匹配模式IGNORECASE 忽略大小写 默认情况下正则表达式区分大小写(Case Insensitive) SINGLELINE 单行模式 整个文本看作一个字符串，只有一个开头，一个结尾。使得小数点“.”可以匹配包含换行符（\\n）在内的任意字符 MULTILINE 多行模式 每行都是一个字符串，都有开头和结尾。在指定了此模式后，如果需要仅匹配字符串开始和结束位置，可以使用\\A和\\Z 如：\\Ai匹配 第一行第一个i ^i 匹配每一行第一个的i i$匹配每一行的最后一个i i\\Z 匹配整个文档最后一个i 选择符和分组 表达式 作用 | 分支结构 左右两边表达式之间 “或” 关系，匹配左边或者右边 表示“或” 如 h () 捕获组 (1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 (2)取匹配结果的时候，括号中的表达式匹配到的内容可以被单独地编号 (3)每一对括号会被分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为零的第一 个捕获是由整个正则表达式模式匹配的内容 (?:Expression) 非捕获组 一些表达式中，不得不使用（），但又不需要保存（）中的子表达式匹配的内容，这时可以用非捕获组来抵消使用（）带来的副作用。节省内存。 反向引用（\\nnn）\\nnn表示可以匹配多位数字-每一对（）会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。 -通过反向引用，可以对分组已捕获的字符串进行引用。 如 ([a-z]{2})\\1 中的\\1 代表第一个组里的内容,匹配到gogo，toto，dodo这样的字符串。 （）（）（） 捕获的内容分别用\\1 \\2 \\3 编号以左括号为准。 后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例： \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 上面 \\1 就代表 go了， \\2的表达式还没搞出来 https://deerchao.cn/tutorials/regex/regex.htm ?当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 预搜索（零宽断言）（也叫环视） 只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度,应该可以理解为只匹配，不消耗字符。 这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符。是对位置的匹配。 正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。 表达式 作用 (?=exp) 断言自身出现的位置的后面能匹配表达式exp (?&lt;=exp) 断言自身出现的位置的前面能匹配表达式exp (?!exp) 断言此位置的后面不能匹配表达式exp (?&lt;!exp) 断言此位置的前面不能匹配表达式exp (?:pattern)匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。 例如“industr(?:y|ies|he)”就是一个比“industry|industries|industrhe”更简略的表达式。 (?:foo){1,2}如果表达式是 /foo{1,2}/，{1,2} 将只应用于 ‘foo’ 的最后一个字符 ‘o’，可以看上面的{n}。如果使用非捕获括号，则 {1,2} 会应用于整个 ‘foo’ 单词可以看到， foo最多匹配两个，超过的就分组了。 (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc x(?=y) 需匹配文案x在前面匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern)正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern)反向肯定预查，** 与正向肯定预查类拟，只是方向相反 **。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;=y)x需匹配文案x在后面 (?&lt;!pattern)反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 https://deerchao.cn/tutorials/regex/regex.htm (?&lt;=\\d)[a-z]+ 22john 如：[a-z]+(?=ing) 匹配ing结尾的字符串，但不匹配ing本身 [a-z]+(?=\\d+) 匹配数字结尾的字符串 常用的一些正则表达式电话号码验证（包含固话和手机号，不能确认号码一定存在，只能匹配格式） （1）电话号码由数字和“-”构成 （2）电话号码为7-8位 （3）如果电话号码中包含有区号，那么区号为3位或4位，首位是0 （4）区号用“-”和其他部分隔开 （5）移动电话号码为11位 （6）11位移动电话号码的第一位和第二位为“13”“15”“18” 固话 0\\d{2,3}-\\d{7,9} 手机号 1[35789]\\d{9} 电子邮箱地址验证1.用户名：字母、数字、中划线、下划线组成 2.@ 3.网址：字母、数字组成 4.小数点。 5.组织域名：2-4位字母组成 不区分大小写 [\\w-]+@[a-z0-9A-Z]+(.[A-Za-z]{2,4}){1,2} 如：&#x73;&#115;&#x61;&#x68;&#x64;&#97;&#104;&#x64;&#x40;&#x73;&#x69;&#110;&#97;&#x2e;&#x63;&#x6f;&#109;&#x2e;&#99;&#110; 常用正则表达式列表 表达式 功能 [\\u4e00-\\u9fa5] 匹配中文字符 \\n\\s*\\r 匹配空白行 `&lt;(\\S*?)[^&gt;]&gt;.?&lt;/\\1&gt; &lt;.*? /&gt;` ^\\s*\\s*$ 匹配首尾空白字符 \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 匹配Email地址 [a-zA-z]+://[^\\s]* 匹配网址URL \\d&#123;3&#125;-\\d&#123;8&#125;\\d&#123;4&#125;-\\d&#123;7&#125; 匹配国内电话号码 [1-9][0-9]&#123;4,&#125; 匹配腾讯QQ号 [1-9]\\d&#123;5&#125;(?!\\d) 匹配中国邮政编码 \\d&#123;15&#125;\\d&#123;18&#125; 匹配身份证 \\d+\\.\\d+\\.\\d+\\.\\d+ 匹配ip地址 括号 https://www.bilibili.com/video/BV1ef4y1U7V4/?spm_id_from=333.788.recommend_more_video.-1 工作学习中各种环境的使用JAVA程序中使用正则表达式相关类位于：java.util.regex包下面： 类 Pattern： 正则表达式的编译表示形式。 Pattern p = Pattern.compile(r,int); //建立正则表达式，并启用相应模式 类 Matcher： 通过解释 Pattern 对 character sequence 执行匹配操作的引擎。 Matcher m = p.matcher(str); //匹配str字符串 java代码应用正则的查找、分组、替换、分割： 查找1234567891011121314151617181920212223242526272829303132package com.bjsxt.regex.test;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 测试正则表达式对象的基本用法 */public class RegularTest &#123; public static void main(String[] args) &#123; //在这个字符串：abcd1234，是否符合指定的正则表达式：\\w+ //表达式对象 Pattern p = Pattern.compile(&quot;\\\\w+&quot;); //创建Matcher对象 Matcher m = p.matcher(&quot;abcd￥￥1234&quot;); //boolean result= m.matches(); //尝试将整个字符序列与该模式匹配 //System.out.println(result); //boolean result= m.find(); //该方法扫描输入的序列，查找与该模式匹配的下一个子序列 //System.out.println(m.find()); //System.out.println(m.group()); //System.out.println(m.find()); //System.out.println(m.group()); while(m.find())&#123; System.out.println(m.group()); //group(),group(0)匹配整个表达式的子字符串 System.out.println(m.group(0)); &#125; &#125;&#125; 分组123456789101112131415161718192021222324package com.bjsxt.regex.test;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 测试正则表达式对象中分组的处理 */public class Test2 &#123; public static void main(String[] args) &#123; //在这个字符串：abcd1234，是否符合指定的正则表达式：\\w+ //表达式对象 Pattern p = Pattern.compile(&quot;([a-z]+)([0-9]+)&quot;); //创建Matcher对象 Matcher m = p.matcher(&quot;abc123%%abcd234%abcde4567&quot;); while(m.find())&#123; System.out.println(m.group()); //group(),group(0)匹配整个表达式的子字符串 System.out.println(m.group(1)); System.out.println(m.group(2)); &#125; &#125;&#125; find用法 https://www.bilibili.com/video/BV1Eq4y1E79W?p=4 替换12345678910111213141516171819package com.bjsxt.regex.test;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 测试正则表达式对象的替换操作 */public class Test3 &#123; public static void main(String[] args) &#123; //表达式对象 Pattern p = Pattern.compile(&quot;[0-9]&quot;); //创建Matcher对象 Matcher m = p.matcher(&quot;abc123%%abcd234%abcde4567&quot;); //替换 String result= m.replaceAll(&quot;#&quot;); System.out.println(result); &#125;&#125; 分割123456789101112131415package com.bjsxt.regex.test;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 测试正则表达式对象的分割字符串的操作 */public class Test4 &#123; public static void main(String[] args) &#123; String str = &quot;ab23jk123ji8890123asd&quot;; String[] arrs = str.split(&quot;\\\\d+&quot;); System.out.println(Arrays.toString(arrs)); &#125;&#125; 手写网络爬虫（基本原理&amp;乱码处理）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.bjsxt.regex.test;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.MalformedURLException;import java.net.URL;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 网络爬虫取链接 */public class WebSpiderTest &#123; /** * 获得urlStr对应的网页的源码内容 * @param urlStr * @return */ public static String getURLContent(String urlStr,String charset)&#123; StringBuilder sb = new StringBuilder(); try &#123; URL url = new URL(urlStr); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(),Charset.forName(charset))); String temp = &quot;&quot;; while((temp=reader.readLine())!=null)&#123; sb.append(temp); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; public static List&lt;String&gt; getMatherSubstrs(String destStr,String regexStr)&#123; Pattern p = Pattern.compile(regexStr); //取到的超链接的地址 Matcher m = p.matcher(destStr); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while(m.find())&#123; result.add(m.group(1)); &#125; return result; &#125; public static void main(String[] args) &#123; String destStr = getURLContent(&quot;http://www.163.com&quot;,&quot;gbk&quot;); //Pattern p = Pattern.compile(&quot;&lt;a[\\\\s\\\\S]+?&lt;/a&gt;&quot;);//取到的超链接的整个内容 List&lt;String&gt; result = getMatherSubstrs(destStr, &quot;href=\\&quot;([\\\\w\\\\s./:]+?)\\&quot;&quot;); for (String temp : result) &#123; System.out.println(temp); &#125; &#125;&#125; https://blog.csdn.net/qq_39636602/article/details/101236461 https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md https://regexr.com/ Ascii表https://www.ascii-code.com/ https://www.regular-expressions.info/tutorial.html 密码判断断言必须包含一个字母或其他的字符 https://www.cnblogs.com/haoyul/p/12059737.html https://www.bilibili.com/video/BV1nY4y1q7Qr?spm_id_from=333.337.search-card.all.click https://www.bilibili.com/video/BV1oz4y1C7Uf?p=4 (?=.*[A-Za-z]+)[A-Za-z@\\/`’’‘,\\.\\(\\)\\-]{4,100}$ 从这个图可以看到，需要中间至少需要一个字母 123456^(?=.*?[A-Z])(?=.*?[^A-Za-z0-9]).&#123;6,12&#125;$(?=.*?[A-Z])(?=xxx)是零宽断言，表示后面的字符串必须符合xxx这个正则表达式，但是不消耗字符串，实际匹配字符串的正则是.&#123;6,12&#125;即6到12位字符 (?=.*?[A-Z])表示后面必须符号.*?[A-Z]这个 ，即必须有大写字母整个正则表达式表示6到12位字符，必须有大写字母和不是字母数字的字符 https://zhidao.baidu.com/question/1609169242401476667.html 正则优先级下图 从上到下，从左到右的优先级 https://www.runoob.com/regexp/regexp-operator.html https://zhidao.baidu.com/question/1609169242401476667.html http://www.rexegg.com/regex-lookarounds.html kotlin regular12345fun validation(pattern: String, str: String?): Boolean &#123; return if (str.isNullOrEmpty()) &#123; false &#125; else Pattern.compile(pattern).matcher(str).matches()&#125; escape character方括号（中括号）内的特殊字符不需要转义 即使加了转义字符，也不会起作用 [\\\\.] 还是表示点 1[\\^\\[\\-\\]\\\\] 会改变字符组含义的才需要转义 1、反斜线必须转义 2、方括号必须转义 3、「^」在首和「-」在中必须转义 所以以下常见的字符是不需要转义的 123[aeiou][$.*+?&#123;&#125;()|][abc^123-] https://www.zhihu.com/question/62542695 https://juejin.cn/s/%E6%AD%A3%E5%88%99%E4%B8%AD%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E9%9C%80%E8%A6%81%E8%BD%AC%E4%B9%89%E5%90%97 Regex named groups supporthttps://stackoverflow.com/questions/50048622/get-match-result-by-name-is-not-possible-when-using-java-10replace with find group(name) https://stackoverflow.com/questions/37088679/kotlin-regex-named-groups-support 1&quot;&quot;&quot;(\\w+?)(?&lt;num&gt;\\d+)&quot;&quot;&quot;.toRegex().matchEntire(&quot;area51&quot;)!!.groups[&quot;num&quot;]!!.value mather.group(“name”)","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"DesignPattern_Decorator","slug":"DesignPattern-Decorator","date":"2020-07-12T04:37:59.000Z","updated":"2024-10-01T11:31:04.043Z","comments":true,"path":"2020/07/12/DesignPattern-Decorator/","link":"","permalink":"https://noteforme.github.io/2020/07/12/DesignPattern-Decorator/","excerpt":"","text":"装饰器模式 应用场景: 拓展一个类的功能或给一个类添加附加职责. 优点: 不改变原有对象的情况下给一个对象拓展功能 使用不同的组合实现不同的效果 符合开闭原则 1234567891011121314151617181920212223242526272829interface Component&#123; void operation();&#125;// 具体类class ConcreteComponent implements Component&#123; @Override public void operation() &#123; System.out.println(&quot;拍照&quot;); &#125;&#125;//对具体类的拓展class ConcreteComponent1 implements Component &#123; private Component component; public ConcreteComponent1(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; System.out.println(&quot;美颜&quot;); component.operation(); &#125;&#125;//测试new ConcreteComponent1(new ConcreteComponent()).operation(); 也可以把装饰器抽象出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Component&#123; void operation();&#125;// 具体类class ConcreateComponent implements Component&#123; @Override public void operation() &#123; System.out.println(&quot;拍照&quot;); &#125;&#125;abstract class Decorator implements Component&#123; Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125;//对具体类的拓展class ConcreateComponent1 extends Decorator&#123; public ConcreateComponent1(Component component) &#123; super(component); &#125; @Override public void operation() &#123; System.out.println(&quot;美颜&quot;); super.operation(); &#125;&#125;class ConcreateComponent2 extends Decorator&#123; public ConcreateComponent2(Component component) &#123; super(component); &#125; @Override public void operation() &#123; System.out.println(&quot;呵呵&quot;); super.operation(); &#125;&#125;//测试 ConcreateComponent2 concreateComponent1 = new ConcreateComponent2(new ConcreateComponent1(new ConcreateComponent())); concreateComponent1.operation(); https://www.bilibili.com/video/BV1hp4y1D7MP?from=search&amp;seid=6785978722248254154 https://www.bilibili.com/video/BV1Hv411r7uN?p=2","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[]},{"title":"LiveData","slug":"LiveData","date":"2020-06-15T03:20:42.000Z","updated":"2023-01-02T03:31:39.094Z","comments":true,"path":"2020/06/15/LiveData/","link":"","permalink":"https://noteforme.github.io/2020/06/15/LiveData/","excerpt":"","text":"https://www.bilibili.com/video/BV19B4y1N7iV 优势 确保界面符合数据状态 不会发生内存泄漏 不会因Activity停止而导致崩溃 不再需要手动处理生命周期 数据始终保持最新状态 适当的配置更改 共享资源 stiky eventhttps://juejin.cn/post/7019734258793054238 savedStateHandle 使用 模拟app killed https://developer.android.com/codelabs/android-lifecycles#6 12adb shell ps -A |grep lifecycleadb shell am kill 1. 为什么有粘性事件Google官方文档中描述，设备横竖屏切换的时候，界面销毁重建，但是Activity生命周期并未结束，旋转后新建的空页面上数据需要重新填充，曾经的后台Activity返回到前台后立即接受最新的数据，所以LiveData在被再次观察时会立即推送数据更新。 粘性实例https://juejin.cn/post/6856688280231444487 旋转屏幕，为什么能保持数据 12345678910111213141516static class ObserverWithState &#123; State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = event.getTargetState(); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); // onstart状态 能继续发送，不知道什么方法触发的。 mState = newState; &#125;&#125; livedata和viewmodel关系viewmodel中的数据发生变化时通知页面 livedata active状态e LiveData objects only consider subscriptions as active when their respective lifecycle owner is either STARTED or RESUMED. STARTED ， 1234@Overrideboolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);&#125; 12345678910class EnumTest &#123; @Test fun compareTest()&#123; println(&quot;DESTROYED &quot;+ State.DESTROYED.isAtLeast(State.STARTED)) println(&quot;INITIALIZED &quot;+ State.INITIALIZED.isAtLeast(State.STARTED)) println(&quot;CREATED &quot;+ State.CREATED.isAtLeast(State.STARTED)) println(&quot;STARTED &quot;+ State.STARTED.isAtLeast(State.STARTED)) println(&quot;RESUMED &quot;+ State.RESUMED.isAtLeast(State.STARTED)) &#125;&#125; DESTROYED falseINITIALIZED falseCREATED falseSTARTED trueRESUMED true https://blog.csdn.net/qq_44076155/article/details/121471697 https://juejin.cn/post/6955309901363036191 https://juejin.cn/post/7148049769057746952 从上面例子可以知道LiveData的核心主要在于这两步，liveData.observe()以及liveData.postValue()，一个是注册观察者，一个是发送通知。那么下面的解析就将这两个函数作为切入点。 mLastVersion : 观察者 mVersion : 被观察者 1.LiveData.observe()从liveData.observe()跟踪进去: LiveData.java 123456789101112131415161718192021222324252627 private SafeIterableMap&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt; mObservers = new SafeIterableMap&lt;&gt;(); ...... @MainThread public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observe&quot;); //✅ 第一部分 if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; //✅ 第二部分 LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; //✅ 第三部分 owner.getLifecycle().addObserver(wrapper); &#125;复制代码 observe方法传有两个参数LifecycleOwner和Observer，LifecycleOwner是一个具有Android生命周期的类，一般传入的是Activity和Fragment，Observer是一个接口，内部存在void onChanged(T t)方法。 ✅ 第一部分： observe内部一开始就存在一个生命周期的判断， 1if (owner.getLifecycle().getCurrentState() &#x3D;&#x3D; DESTROYED) &#123;return;&#125; 当组件生命周期已经Destroy了，也就没有必要再继续走下去，则直接return。在这里，LiveData对生命周期的感知也就慢慢显现出来了。 ✅ 第二部分： 首先以LifecycleOwner和Observer作为参数创建了一个LifecycleBoundObserver对象，接着以Observer为key，新创建的LifecycleBoundObserver为value，存储到mObservers这个map中。在后面LiveData postValue中会遍历出该map的value值ObserverWrapper，获取组件生命周期的状态，已此状态来决定分不分发通知（这部分详情见“第二小节postValue()”） 那LifecycleBoundObserver是什么？ 123456789101112class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123; super(observer); mOwner = owner; &#125; ....... &#125;复制代码 从源码可以看到，LifecycleBoundObserver继承ObserverWrapper并且实现了LifecycleEventObserver的接口，LifecycleEventObserver是监听组件生命周期更改并将其分派给接收方的一个接口，而在LifecycleBoundObserver的构造函数中将observer传给了父类ObserverWrapper。LifecycleBoundObserver其实只是包裹着LifecycleOwner和Observer得一个类，其中的实现有点代理模式的味道。 ✅ 第三部分： owner.getLifecycle().addObserver(wrapper)将新创建的LifecycleBoundObserver添加到Lifecycle中，也就是说这个时候观察者注册成功，当LifecycleOwner也就是组件的状态发生改变时，也会通知到所匹配的observer。 到这里，UI层viewModel.liveData.observe(this, object:Observer&lt;String&gt; &#123; override fun onChanged(value: String) &#123;&#125; &#125;)注册观察者的内部解析也就大致清楚了。 2.postValue()liveData.postValue()是作为一个发射方来通知数据改变，其内部又做了哪些工作？接下来就一探究竟。直接从postValue中最核心的部分在于将参数value赋值给了一个全局变量源码开始： 123456789101112 protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125;复制代码 postValue中首先将参数value赋值给了一个全局变量mPendingData，它的初始值为一个空对象，而mPendingData只是作为一个中间媒介来存储value的值，在后续的操作中会用到，我们就暂时先记住它。 在最后就是一个将线程切换到主线程的操作，主要看mPostValueRunnable的实现： 12345678910111213 private final Runnable mPostValueRunnable = new Runnable() &#123; @SuppressWarnings(&quot;unchecked&quot;) @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; setValue((T) newValue); &#125; &#125;;复制代码 在Runnable中,mPendingData赋值给了临时变量newValue，最后调用了setValue（）方法。我们都知道LiveData发送通知可以使用PostValue或者SetValue，而他两的区别就在于，PostValue可以在任意线程中调用，而SetValue只能在主线程中，因为PostValue多了一步上面切换主线程的操作。 OK，接下来就是PostValue/SetValue最核心的部分。 123456789101112131415161718192021222324252627282930313233343536 @MainThread protected void setValue(T value) &#123; assertMainThread(&quot;setValue&quot;); mVersion++; mData = value; dispatchingValue(null); &#125; ....... void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; //✅ 第二部分 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false; &#125;复制代码 在setValue中，参数value将值赋给了一个全局变量mData，而这个mData最后将通过mObserver.onChanged((T) mData);将需要修改的value值分发给了UI。最后调用传入一个null调用dispatchingValue方法。 由于dispatchingValue里的参数为null，也就顺理成章的走到了✅ 第二部分。else一进入就是迭代器在遍历mObservers，而mObservers在第一小节“1.LiveData.observe()”中说得很清楚，它作为一个map，存储了Observer和ObserverWrapper。通过遍历，将每个观察者所匹配的ObserverWrapper作为参数传给了considerNotify（）方法。 1234567891011121314151617181920private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we&#x27;ve not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData); &#125;复制代码 而在considerNotify()中，先通过observer来获取组件生命周期的状态，如果处于非活动状态，则拒绝发起通知。在该方法的最后， observer.mObserver.onChanged((T) mData)，是不是很熟悉，这就是UI层一开始就实现的接口，而就在这找到了最后的发送方。 https://juejin.cn/post/6955309901363036191 粘性事件原理数据粘性实例 https://juejin.cn/post/7148049769057746952 或者切换屏幕 turn the android phone on the horizontal 经过了解和使用 view model,databiding后，我觉得这个不是官方留的坑，在特定的场景可能还需要这样做，我获取手环睡眠数据此时有其他fragment还没创建，我就需要创建后才就监听到数据。 方法1我们能不能再创建新的ObserverWrapper的时候，直接把mVersion的值赋给mLastVersion，这样就符合(observer.mLastVersion &gt;= mVersion)这一条件了，就不会再继续执行onChanged方法了 https://blog.csdn.net/geyuecang/article/details/89028283 singleLiveEvent多个观察者，这个就不好用了。 其实这个方法解决的并不是粘性事件的问题，而是“数据倒灌”的问题。“数据倒灌”一词出自KunMinX的Blog重学安卓：LiveData 数据倒灌 背景缘由全貌 独家解析,即在setValue后,observe对此次set的value值会进行多次消费。比如进行第二次observe的时候获取到的数据是第一次的旧数据。这样会带来不可预期的后果。 https://github.com/android/architecture-samples/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java m.compareAndSet(a,b),如果m==a ,返回true，同时将m置为b； 如果m==b，返回false。 方法3UnPeekLiveData 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ProtectedUnPeekLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; protected boolean isAllowNullValue; private final HashMap&lt;Integer, Boolean&gt; observers = new HashMap&lt;&gt;(); public void observeInActivity(@NonNull AppCompatActivity activity, @NonNull Observer&lt;? super T&gt; observer) &#123; LifecycleOwner owner = activity; Integer storeId = System.identityHashCode(observer);//源码这里是activity.getViewModelStore()，是为了保证同一个ViewModel环境下&quot;唯一可信源&quot; observe(storeId, owner, observer); &#125; private void observe(@NonNull Integer storeId, @NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; if (observers.get(storeId) == null) &#123; observers.put(storeId, true); &#125; super.observe(owner, t -&gt; &#123; if (!observers.get(storeId)) &#123; observers.put(storeId, true); if (t != null || isAllowNullValue) &#123; observer.onChanged(t); &#125; &#125; &#125;); &#125; @Override protected void setValue(T value) &#123; if (value != null || isAllowNullValue) &#123; for (Map.Entry&lt;Integer, Boolean&gt; entry : observers.entrySet()) &#123; entry.setValue(false); &#125; super.setValue(value); &#125; &#125; protected void clear() &#123; super.setValue(null); &#125;&#125; ，为每个传入的observer对象携带一个布尔类型的值，作为其是否能进入observe方法的开关。每当有一个新的observer存进来的时候，开关默认关闭。 每次setValue后，打开所有Observer的开关，允许所有observe执行。 这个确实清晰，简单 https://www.jianshu.com/p/d0244c4c7cc9 https://juejin.cn/post/6844903623252508685 方法412345678910111213141516171819202122232425/** * Used as a wrapper for data that is exposed via a LiveData that represents an event. */open class Event&lt;out T&gt;(private val content: T) &#123; var hasBeenHandled = false private set // Allow external read but not write /** * Returns the content and prevents its use again. */ fun getContentIfNotHandled(): T? &#123; return if (hasBeenHandled) &#123; null &#125; else &#123; hasBeenHandled = true content &#125; &#125; /** * Returns the content, even if it&#x27;s already been handled. */ fun peekContent(): T = content&#125; UnPeekLiveData 或者 ELiveData https://juejin.im/post/5b2b1b2cf265da5952314b63 https://www.jianshu.com/p/79d909b6f8bd https://juejin.im/post/6892704779781275662 https://www.jianshu.com/p/d0244c4c7cc9 LifeCycle通过lifecycle旋转屏幕后，重新发送事件来分析，粘性事件。https://developer.android.com/codelabs/android-lifecycles#2","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://noteforme.github.io/categories/Jetpack/"}],"tags":[]},{"title":"THINKING","slug":"THINKING","date":"2020-05-19T01:55:11.000Z","updated":"2022-06-12T03:17:58.728Z","comments":true,"path":"2020/05/19/THINKING/","link":"","permalink":"https://noteforme.github.io/2020/05/19/THINKING/","excerpt":"","text":"the way learning 一年后用不到，就不用学。 https://www.bilibili.com/video/BV1bY4y1Y7WR/?spm_id_from=333.788 how to use(video blog) 学习产生价值，带着目标学习. https://juejin.im/post/5eb168e9f265da7bb65fb27a https://www.mifengtd.cn/articles/runningcheese-gtd-system.html https://github.com/JsonChao/Awesome-Android-Notebook I don’t know what to do if I prevent me think code or tech in my life. I think i love tech ,but it could’t support my career now.I l’m look forword is that what I can do . CodeReview","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[{"name":"THINK","slug":"THINK","permalink":"https://noteforme.github.io/tags/THINK/"}]},{"title":"ActivityLayout","slug":"ActivityLayout","date":"2020-05-08T01:54:32.000Z","updated":"2023-09-02T07:27:16.876Z","comments":true,"path":"2020/05/08/ActivityLayout/","link":"","permalink":"https://noteforme.github.io/2020/05/08/ActivityLayout/","excerpt":"","text":"Activity绘制流程 https://blog.csdn.net/yanbober/article/details/45970721?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160657696619724827674302%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160657696619724827674302&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-10-45970721.pc_first_rank_v2_rank_v28&amp;utm_term=setContentView&amp;spm=1018.2118.3001.4449 https://mp.weixin.qq.com/s/ii07I8Cy80MqjsqKkns_WQ https://www.jianshu.com/p/b5b1b8e1747f 带你探究 LayoutInflater 布局解析原理https://juejin.cn/post/6886052422260228103","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"https://noteforme.github.io/tags/XML/"}]},{"title":"DataStructure","slug":"DataStructure","date":"2020-05-06T01:46:22.000Z","updated":"2023-10-28T12:18:05.085Z","comments":true,"path":"2020/05/06/DataStructure/","link":"","permalink":"https://noteforme.github.io/2020/05/06/DataStructure/","excerpt":"","text":"无论什么难题，降低复杂度的方法就是这三个步骤。只要你能深入理解这里的核心思想，就能把问题迎刃而解。 第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。 第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。 第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。 既然说这是这门专栏的总纲，那么很显然后续的学习都是在这个总纲体系的框架中。第一步的暴力解法没有太多的套路，只要围绕你面临的问题出发，大胆发挥想象去尝试解决即可。第二步的无效操作处理中，你需要学会并掌握递归、二分法、排序算法、动态规划等常用的算法思维。第三步的时空转换，你需要对数据的操作进行细分，全面掌握常见数据结构的基础知识。再围绕问题，有针对性的设计数据结构、采用合理的算法思维，去不断完成时空转移，降低时间复杂度。 https://github.com/labuladong/fucking-algorithm 复杂度 消耗计算时间和计算空间 时间复杂度 对数阶1234int count =1;while(count &lt; n)&#123; count = count * 2;&#125; 代码看到 2 * 2 * 2 … 最终离n很近，最终退出循环，2^x =n ,得到 x = log2^n,所以这个循环时间复杂度为O(logn) 空间复杂度空间方面主要体现在计算过程中,对于存储资源的消耗情况 链表​ p,q指向的都是整体 1234567891011121314typedef struct node&#123; int data; // 存储数据本身 struct node *pNext; //pNext存储 它指向的下一个节点的指针&#125; NODE, *PNODE;// NODE等价于struct node//PNODE等价于struct node*//将动态分配的新节点的地址赋给pPNODE p = (PNODE)malloc(sizeof(NODE));free(p) //删除p指向节点所占的内存，不是删除p本身所占的内存p-&gt;pNext; //p所指向结构体变量中pNext成员本身 插入q节点 12345方法1:r = p-&gt; pNext ; p-&gt;pNext =q ; q-&gt;pNext = r;方法2:q-&gt;pNext = p-&gt;pNext;p-&gt;pNext = q; 删除p后面的节点 123r = p-&gt;pNext;p-&gt;pNext= r-&gt;pNext;free(r); 双向链表插入 123456ListNodePosi &lt;T&gt; insertAsPred(T const&amp;e)&#123;//紧靠当前节点之前插入新节点 ListNodePosi&lt;T&gt; x = new ListNode(e,pred,this); //创建新节点 pred-&gt;succ = x; this-&gt;pred= x;//设置正向链接,这里是当前节点的前置节点的意思，容易和节点pred混淆 return x; //返回新节点的位置&#125; 递归 递归必须得有一个明确的中止条件。 该函数所处理的数据规模必须在递减。 递归复杂度递归跟踪(recursion trace)分析1234sum(int A[],int n)&#123; return (n&lt;1)? 0:sum(A,n-1)+A[n-1]&#125; 检查每个递归实例，累计所需的时间(调用语句本身，计入对应的子实例) 其总和即算法执行时间 本例中，单个递归实例自身只需o(1)时间 T(n) = o(1) * (n+1) = o(n) 递归方程求解sum(A,n) : 递归求解规模为n-1的问题sum(A,n-1) 加上 A[n-1] 。 ​ T(n) = T(n-1) + o(1) // 为了求解T(n)所需要的时间,花了T(n-1)的时间求解n-1的问题,然后再花了o(1)的时间 ​ T(0) = o(1) T(n) = T(n-1) + o(1) //两边同时 -n T(n) -n = T(n-1) -(n-1) ​ = … ​ =T(2) - 2 ​ = T(1) -1 ​ =T(0) T(n) = o(1) +n = o(n) 递归实例阶乘 、求和123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;long f(int n);long sum(int n);int main(void) &#123; printf(&quot;n=1 输出 %ld \\n &quot;, f(1)); printf(&quot;n=2 输出 %ld \\n &quot;, f(2)); printf(&quot;n=3 输出 %ld \\n &quot;, f(3)); printf(&quot;n=4 输出 %ld \\n &quot;, f(4)); printf(&quot;n=5 输出 %ld \\n &quot;, f(5)); printf(&quot;n=100 相加 %ld \\n &quot;, sum(100)); int val,mult = 1; printf(&quot;请输入一个数: val=&quot;); scanf(&quot;%d&quot;,&amp;val); for (int i = 1; i &lt;= val; ++i) &#123; mult = mult * i; &#125; printf(&quot;%d的阶乘是: %d\\n&quot;,val,mult);&#125;//假定n的值是1或大于1的值long f(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * f(n - 1); &#125;&#125;// 1+2+...+100long sum(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return (n + sum(n-1)); &#125;&#125; 汉诺塔123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;void hannuota(int n, char a, char b, char c) &#123; /** * 一个盘子 : * 直接将a柱子上的盘子从a移动到b * 否则 : * 先将a柱子上的n-1个盘子借助c移到b * 直接将a柱子上的盘中从a移到c * 最后将b柱子上的n-1个盘子借助a移到c */ if (1 == n) &#123; printf(&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\\n&quot;, n, a, c); &#125; else &#123; hannuota(n - 1, a, c, b); printf(&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\\n&quot;, n, a, c); hannuota(n - 1, b, a, c); &#125;&#125;int main(void) &#123; char ch1 = &#x27;A&#x27;; char ch2 = &#x27;B&#x27;; char ch3 = &#x27;C&#x27;; printf(&quot;请输入要移动盘子的个数:&quot;); int n; scanf(&quot;%d&quot;,&amp;n); hannuota(n,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;); return 0;&#125; Fibonacci.c12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int f(int n)&#123; if(n==0)&#123; return 0; &#125; else if(n==1)&#123; return 1; &#125; else&#123; return f(n-1)+f(n-2); &#125;&#125;int main()&#123; int n; printf(&quot;输入n的值为 &quot;); while (true)&#123; scanf(&quot;%d&quot;,&amp;n); printf(&quot;f(n) %d \\n&quot;,f(n)); &#125;&#125; 上面这种求和方式，随着n增加，时间复杂度会指数型增加，到了40已经算不动了，里面会有大量重复的计算 123456789int f(int n) &#123; int f = 0; int g = 1; while (n--)&#123; g = g+f; f = g-f; &#125; return g;&#125; 这种时间复杂度O(n),不要太快,交替滚动向前推进。 Hash(散列)[Hash(key) + 1^2] % M 以平方数为距离，确定下一试探桶单元 M为三列表的容量","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"}],"tags":[]},{"title":"DeliverValue","slug":"DeliverValue","date":"2020-04-28T02:20:55.000Z","updated":"2021-08-19T11:11:43.800Z","comments":true,"path":"2020/04/28/DeliverValue/","link":"","permalink":"https://noteforme.github.io/2020/04/28/DeliverValue/","excerpt":"","text":"Value Copyhttps://blog.csdn.net/huaiyiheyuan/article/details/55102057 https://mp.weixin.qq.com/s/lP-xB5yzpvqVEiA439euVQ https://juejin.im/post/5e91cc6c51882573a343db03 基本数据类型 declare in stack Object declare in Heap Java value deliver https://juejin.im/post/5af3a44bf265da0b74522bf3 1234String name = &quot;hollischuang&quot;;String name = new String(&quot;hollischuang&quot;);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"Bluetooth04","slug":"Bluetooth04","date":"2020-04-26T02:46:23.000Z","updated":"2024-10-02T01:36:40.951Z","comments":true,"path":"2020/04/26/Bluetooth04/","link":"","permalink":"https://noteforme.github.io/2020/04/26/Bluetooth04/","excerpt":"","text":"蓝牙问题汇总https://race604.com/android-ble-in-action/ 连接断开之后可以根据实际情况进行重连，但如果是连接失败的情况，建议不要立即重连，而是调用void closeBluetoothGatt()清空一下状态，并延迟一段时间等待复位，否则会把gatt阻塞，导致手机不重启蓝牙就再也无法连接任何设备的严重情况。 https://github.com/Jasonchenlijian/FastBle/blob/master/README_1.2.x.md 每当设备断开连接时，请确保在BluetoothGatt对象上调用close()并将其设置为null, 解决方法:始终在断开连接时关闭gatt实例，并在每次连接时创建一个新的gatt实例。 在onLeScan(..)中启动一个新线程，然后进行连接 https://stackoom.com/question/1Cyqr/Android-%E8%93%9D%E7%89%99%E4%BD%8E%E5%8A%9F%E8%80%97%E4%B8%8D%E7%A8%B3%E5%AE%9A BluetoothLeScanner: could not find callback wrapper 连接失败处理 分两个平台来说，iOS端也有连接失败的委托，但是好像几乎不会发生这种情况，至少我从来没遇见过，而对于同款设备，android常常会出现连接失败的情况，status != BluetoothGatt.GATT_SUCCESS ，android端开发请不要把连接失败和断开连接放在一块处理，因为断开连接可以直接尝试重新连接，而连接失败后尝试重新连接，需要加一些延时，并且需要gatt.close，清空一下状态，否则会把gatt阻塞导致手机不重启蓝牙就再也无法连接任何设备的情况。 http://liuyanwei.jumppo.com/2017/01/23/zhihu-live-a-hour-for-bluetooth-0.html 扫描广播包 所有外设，只有在发出广播包的情况下，才能被central发现，绝大多数情况下，外设被连接后就不会发出广播（也有例外），很多人遇到无法找到设备的问题，大多属于这种情况。 重复扫描问题—————— http://liuyanwei.jumppo.com/2017/01/23/zhihu-live-a-hour-for-bluetooth-0.html Android 7+ will stop scanning if it continues without stopping at all for 30 minutes or more. This was added as a feature to prevent battery drain in case developers had inadvertently or abusively left scanning on forever. https://github.com/AltBeacon/android-beacon-library/issues/528 https://blog.csdn.net/m0_37796683/article/details/83657204 status 133 https://blog.csdn.net/baidu_26352053/article/details/54571688 unregisterApp() - mClientIf&#x3D;5 filter https://juejin.im/post/5d37d4d6f265da1bc414958a 防止Android7中的BLE扫描滥用，从而做了一些限制，即不要在30s内对蓝牙扫描重复开启-关闭超过5次。 https://blog.classycode.com/undocumented-android-7-ble-behavior-changes-d1a9bd87d983 蓝牙添加扫描间隔 ​ https://github.com/haodynasty/AndroidBleManager ​ https://github.com/AltBeacon/android-beacon-library 应用如何做自动重连其实自动重连比想象的要简单许多，无论是android还是ios端，只需要在设备断开连接的委托方法中，重新调用gatt.connet或者是centralManager.connet方法就可以了，无论当时设备是否有点，是否在周围，当设备再次开会或者连接到可连接范围内，都会自动被连上，就是这么简单。 http://liuyanwei.jumppo.com/2017/01/23/zhihu-live-a-hour-for-bluetooth-0.html Intent mIntent &#x3D; new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);startActivityForResult(mIntent, 1); 12mBluetoothAdapter.enable();mBluetoothAdapter.disable(); https://blog.csdn.net/u014418171/article/details/81219297 扫描 过滤 Scanning by device name Looking for a device by it’s name has 2 main use cases: to look for 1 specific device or to look for 1 specific device model. For example, my Polar H7 chest strap advertises itself as “Polar H7 391BB014”. The latter part (‘391BB014’) is a unique number (or serial number) and the first part is generic for all Polar H7 devices. This is very common practice. Unfortunately the device name scan filter can only be used to find specific devices as it does full string matching. If you want to find all Polar H7 devices you will need to do a ‘substring’ compare on ‘Polar H7’, but you can’t do that with a filter. You just need to pass null as the filter and do the substring comparison yourself in onScanResult. So here is an example of how to scan for devices by exact name 123456789101112String[] names = new String[]&#123;&quot;Polar H7 391BB014&quot;&#125;;List&lt;ScanFilter&gt; filters = null;if(names != null) &#123; filters = new ArrayList&lt;&gt;(); for (String name : names) &#123; ScanFilter filter = new ScanFilter.Builder() .setDeviceName(name) .build(); filters.add(filter); &#125;&#125;scanner.startScan(filters, scanSettings, scanCallback); https://medium.com/@martijn.van.welie/making-android-ble-work-part-1-a736dcd53b02 android蓝牙自动连接 http://www.cocoachina.com/articles/83844 Ble libraryAndroid-BLE-Library 123LoggableBleManager public void log(final int priority, @NonNull final String message)是日志打印出口是 BleManager public void log(final int priority, @NonNull final String message)的实现 nRF-Logger-API是手机日志查看工具 12345678910111213141516171819202122232425262728293031public abstract class LoggableBleManager&lt;T extends BleManagerCallbacks&gt; extends BleManager&lt;T&gt; &#123; private ILogSession logSession; /** * The manager constructor. * &lt;p&gt; * After constructing the manager, the callbacks object must be set with * &#123;@link #setManagerCallbacks(BleManagerCallbacks)&#125;. * * @param context the context. */ public LoggableBleManager(@NonNull final Context context) &#123; super(context); &#125; /** * Sets the log session to log into. * * @param session nRF Logger log session to log inti, or null, if nRF Logger is not installed. */ public void setLogger(@Nullable final ILogSession session) &#123; logSession = session; &#125; @Override public void log(final int priority, @NonNull final String message) &#123; Logger.log(logSession, LogContract.Log.Level.fromPriority(priority), message); Log.println(priority, &quot;BleManager&quot;, message);// Timber.i(&quot;BleManager &quot;+ message); &#125;&#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"JVM","slug":"JVM","date":"2020-04-18T14:19:42.000Z","updated":"2022-07-16T15:07:08.240Z","comments":true,"path":"2020/04/18/JVM/","link":"","permalink":"https://noteforme.github.io/2020/04/18/JVM/","excerpt":"","text":"JVM方法区-第六章 https://www.iteye.com/blog/rednaxelafx-656951 https://www.bilibili.com/video/av75247289?p=2 这种情况全局变量 b: B是否会造成内存泄漏 123456789101112class A &#123; val b = B.getInstance()&#125;class B &#123; companion object &#123; val b = B() fun getInstance(): B &#123; return b &#125; &#125;&#125; 我觉得不会,B 并不指向A https://www.bilibili.com/video/BV1GA4y197VR?spm_id_from=333.337.search-card.all.click&amp;vd_source=d4c5260002405798a57476b318eccac9 mOpenEnv 加","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"tool_mac","slug":"tool-mac","date":"2020-04-11T08:35:50.000Z","updated":"2025-01-07T11:35:17.347Z","comments":true,"path":"2020/04/11/tool-mac/","link":"","permalink":"https://noteforme.github.io/2020/04/11/tool-mac/","excerpt":"","text":"JDK环境变量adb 环境变量123456789sudo touch ~/.zshrcsudo vi ~/.zshrc复制export ANDROID_HOME=/Users/m/Library/Android/sdkexport PATH=$ANDROID_HOME/platform-tools:$PATHexport PATH=$ANDROID_HOME/tools:$PATHexport PATH=$ANDROID_HOME/tools/bin:$PATH https://dev.to/ravics09/solution-of-command-not-found-adb-error-29e7 Installation of the JDK and the JRE on macOS Mac系统的环境变量，加载顺序为：&#x2F;etc&#x2F;profile &#x2F;etc&#x2F;paths ~&#x2F;.bash_profile ~&#x2F;.bash_login ~&#x2F;.profile ~&#x2F;.bashrc IntelliJ idea clionclion激活: CLion-2019.2.5.dmg 下载完成后,先使用再打开,jetbrains-agent-20200227.zip直接拖入就好了。 some tool for mac 查看当前环境变量 : env Packet Sendertcp ip tool HomeBrew安装 下载 https://raw.githubusercontent.com/Homebrew/install/master/install.sh 更换源 123BREW_REPO=&quot;https://github.com/Homebrew/brew&quot; 换成 BREW_REPO=&quot;git://mirrors.ustc.edu.cn/brew.git&quot; 权限 12chmod 755 install.sh ./install.sh https://blog.csdn.net/weixin_43635647/article/details/104249968 set environment variable mac Flutter 1234vi ~/.bash_profileexport PATH=&quot;$PATH:/Users/john/development/flutter/bin&quot;which flutter mac terminal download and install iterm2 Download iterm2-finder-tools-1.0.0 open Open iTerm.workflow install file top 右键 customize toolbar then move opem iTerm into toolbar Ignore Command + Shift + . Environment set AppledeMacBook-Pro:~ apple$ cat ~&#x2F;.bash_profile export PATH&#x3D;”$PATH:&#x2F;Users&#x2F;john&#x2F;development&#x2F;flutter&#x2F;bin” export PUB_HOSTED_URL&#x3D;https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL&#x3D;https://storage.flutter-io.cn gradle 阿里云镜像&#x2F;Users&#x2F;john&#x2F;.gradle 目录添加 init.gradle 鼠须管默认简繁体control 加上 ~ 快捷键 屏幕录制https://blog.csdn.net/qq_43428139/article/details/109038098 https://www.cnblogs.com/hi3254014978/p/15084851.html#:~:text=%E8%A7%A3%E5%86%B3Mac%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E8%87%AA%E5%B8%A6%E5%BD%95%E5%B1%8F%E8%BD%AF%E4%B https://www.youtube.com/watch?v=KjL_sJS9Rko&amp;t=430s https://www.youtube.com/watch?v=LSmM5FXzVBg&amp;t=320s","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"Corouties","slug":"Corouties","date":"2020-04-05T02:37:04.000Z","updated":"2024-04-28T13:56:27.518Z","comments":true,"path":"2020/04/05/Corouties/","link":"","permalink":"https://noteforme.github.io/2020/04/05/Corouties/","excerpt":"","text":"https://juejin.cn/post/6953441828100112392 https://www.cnblogs.com/joy99/p/15805916.html 协程启动模式 DEFAULT https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#1 DispatchersBy default, Kotlin coroutines provides three Dispatchers: Main, IO, and Default. The IO dispatcher is optimized for IO work like reading from the network or disk, while the Default dispatcher is optimized for CPU intensive tasks. runBlocking vs CoroutineScoperunBlocking is also a coroutine builder that bridges the non-coroutine world of a regular fun main() and the code with coroutines inside of runBlocking { … } curly braces. This is highlighted in an IDE by this: CoroutineScope hint right after the runBlocking opening curly brace. https://kotlinlang.org/docs/coroutines-basics.html#your-first-coroutine https://juejin.cn/post/6883652600462327821 runBlocking 只会等待相同作用域的协程完成才会退出 1234567fun main&#123; runBlocking&#123; // 不会阻塞正常的调用，阻塞主线程，让内部的程序执行完 GlobalScope.launch&#123; println(&quot;hello world&quot;) &#125; &#125; &#125; https://www.bilibili.com/video/BV1uo4y1y7ZF/?p=101 https://www.bilibili.com/video/BV1Yu411X73j?p=5 https://www.bilibili.com/video/BV164411C7FK?from=search&amp;seid=2446477518780731765 https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"}]},{"title":"databinding","slug":"databinding","date":"2020-03-31T21:52:42.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/04/01/databinding/","link":"","permalink":"https://noteforme.github.io/2020/04/01/databinding/","excerpt":"","text":"layout expression of the language https://codelabs.developers.google.com/codelabs/android-databinding/#0 https://developer.android.com/topic/libraries/data-binding Create first layout expression when you want to use it in your own projects the first step is to enable the library in the modules that will use it: 123456android &#123;... dataBinding &#123; enabled true &#125;&#125; Convert to data binding layout 打开布局文件，选中根布局的 ViewGroup，按住 option + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;name&quot; //不能用下划线 &quot;_&quot; type=&quot;String&quot;/&gt; &lt;variable name=&quot;lastName&quot; type=&quot;String&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/plain_name&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginEnd=&quot;128dp&quot; android:text=&quot;@&#123;name&#125;&quot; android:textAppearance=&quot;@style/TextAppearance.AppCompat.Large&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/name_label&quot;/&gt; &lt;TextView android:id=&quot;@+id/plain_lastname&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginEnd=&quot;128dp&quot; android:text=&quot;@&#123;lastName&#125;&quot; android:textAppearance=&quot;@style/TextAppearance.AppCompat.Large&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/lastname_label&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; Bind TextView 12345678910111213141516171819class PlainOldActivitySolution2 : AppCompatActivity() &#123; // Obtain ViewModel from ViewModelProviders private val viewModel by lazy &#123; ViewModelProviders.of(this).get(SimpleViewModel::class.java) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val binding: PlainActivitySolution2Binding = DataBindingUtil.setContentView(this, R.layout.plain_activity_solution_2) binding.name = &quot;John&quot; binding.lastName = &quot;lice&quot; // TODO: Explicitly setting initial values is a bad pattern. We&#x27;ll fix that later on. updateLikes() &#125;&#125;&#125; Dealing with user events Observering data12345&lt;data&gt; &lt;variable name=&quot;viewmodel&quot; type=&quot;com.example.android.databinding.basicsample.data.SimpleViewModel&quot;/&gt; &lt;/data&gt; 12345android:onClick=&quot;@&#123;() -&gt; viewmodel.onLike()&#125;&quot; binding.viewmodel = viewModel 1234private val _likes = MutableLiveData(0) fun onLike() &#123; _likes.value = (_likes.value ?: 0) + 1 &#125; 123&lt;TextView android:id=&quot;@+id/likes&quot; android:text=&quot;@&#123;Integer.toString(viewmodel.likes)&#125;&quot; Using Binding Adapters One parameter 123456@BindingAdapter(&quot;android:text&quot;) public static void setText(TextView view, CharSequence text) &#123; // Some checks removed for clarity view.setText(text); &#125; 1234@BindingAdapter(&quot;app:hideIfZero&quot;) fun hideIfZero(view: View, number: Int) &#123; view.visibility = if (number == 0) View.GONE else View.VISIBLE &#125; 123&lt;ProgressBar android:id=&quot;@+id/progressBar&quot; app:hideIfZero=&quot;@&#123;viewmodel.likes&#125;&quot; Create a Binding Adapter with multiple parameters 12345&lt;ProgressBar android:id=&quot;@+id/progressBar&quot; app:hideIfZero=&quot;@&#123;viewmodel.likes&#125;&quot; app:progressScaled=&quot;@&#123;viewmodel.likes&#125;&quot; android:max=&quot;@&#123;100&#125;&quot; oberver class fieldhttps://developer.android.com/topic/libraries/data-binding/observability#observable_fields https://developer.android.com/topic/libraries/data-binding/observability#observable_objects Using Binding Adapters to create custom attributes1234@BindingAdapter(value=[&quot;app:setSleepData&quot;])fun setSleepData(viewBodySleep: ViewBodySleep, sleepData: String) &#123; viewBodySleep.setSleepData(sleepData)&#125; 12345678&lt;com.android.util.view.ViewBodySleep android:id=&quot;@+id/view_body_sleep&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;55dp&quot; android:paddingRight=&quot;48dp&quot; app:setSleepData=&quot;@&#123;vmBodyFragment.spData&#125;&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; https://developer.android.com/topic/libraries/data-binding/expressions#expression_language Work with observable data objects isNull 1android:text=&#x27;@&#123;viewModel.patientInfo.remoteCheckReceiveName??&quot;&quot;&#125;&#x27; visible 1234@BindingAdapter(&quot;app:goneUnless&quot;)fun goneUnless(view: View, visible: Boolean) &#123; view.visibility = if (visible) View.VISIBLE else View.GONE&#125; android-databinding https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046992&amp;idx=1&amp;sn=b8b4c47537be1227eecd01c1eaee2550&amp;chksm=808ca6d5b7fb2fc32d9ec361c91a2958e51a2db1c6b20370e7ef6493bb5cb20314cda6ab059c&amp;scene=38#wechat_redirect https://juejin.im/post/5d2be05ff265da1bd605d49a https://mp.weixin.qq.com/s/4UP-pDs0FK66g1QUQvRN6A 定义xml背景 https://juejin.im/post/5b95c6a0e51d450e664b0aa0 https://www.jianshu.com/p/741103ba2ff1 https://www.cs.usfca.edu/~galles/visualization/RedBlack.html","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://noteforme.github.io/categories/Jetpack/"}],"tags":[]},{"title":"Android_itnerview2","slug":"Java-Queue","date":"2020-03-23T09:47:11.000Z","updated":"2023-09-03T07:04:03.894Z","comments":true,"path":"2020/03/23/Java-Queue/","link":"","permalink":"https://noteforme.github.io/2020/03/23/Java-Queue/","excerpt":"","text":"https://blog.csdn.net/bn493235694/article/details/79600634 队列是一个先进先出的的数据结构 DequeI need to have a thread-safe LIFO structure Use LinkedBlockingDeque if at a time you want only single thread can operate your data. Use ConcurrentLinkedDeque if you want that each thread can access the shared data https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentLinkedDeque.html ConcurrentLinkedDeque https://blog.csdn.net/hello_worldee/article/details/77880532 Deque : https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html https://www.liaoxuefeng.com/wiki/1252599548343744/1265122668445536 https://www.geeksforgeeks.org/deque-interface-java-example/ LinkedList 线程安全处理 https://blog.csdn.net/d380025303/article/details/81010980","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"ActivityRender01","slug":"ActivityRender01","date":"2020-03-22T14:45:17.000Z","updated":"2021-08-19T11:11:43.525Z","comments":true,"path":"2020/03/22/ActivityRender01/","link":"","permalink":"https://noteforme.github.io/2020/03/22/ActivityRender01/","excerpt":"","text":"https://juejin.im/post/5baf275f5188255c9a7740ba https://github.com/SusionSuc/AdvancedAndroid/blob/master/AndroidFramework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E8%A7%86%E5%9B%BE%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/README.md https://blog.csdn.net/luoshengyang/article/details/8170307 https://juejin.im/post/6844904146227691527 https://mp.weixin.qq.com/s/sKJCG1AjhIRRQL9tQTrLZg","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://noteforme.github.io/tags/Activity/"}]},{"title":"ActivityStart01","slug":"ActivityStart01","date":"2020-01-18T13:53:41.000Z","updated":"2021-08-19T11:11:43.526Z","comments":true,"path":"2020/01/18/ActivityStart01/","link":"","permalink":"https://noteforme.github.io/2020/01/18/ActivityStart01/","excerpt":"","text":"Activity创建 ​ 生命周期方法调用 本篇文章将根据源码解剖Android的Activity的启动流程，需注意的是下列的分析均基于Android7.0, 7.0版本相较于之前几个版本做了许多改动和重构，但是整体的流程是变化不大。根据启动Activity时机的不同，可分为根Activity的启动流程和普通Activity启动流程，根Activity启动流程又可以称为应用程序启动流程，即在桌面上点击一个应用图标到进入到应用第一个Activity的流程。而普通Activity的启动流程就是在一个应用里开启另外一个Activity的流程。由于两种启动流程是有重叠的，而根Activity的启动流程更加复杂，所以接下来我们重点分析根Activity的启动流程，而普通Activity的启动流程在涉及的地方会稍微提一下。由于考虑到篇幅较长，这里将分为两篇来介绍。 这篇将分析启动流程中的应用进程的创建： Launcher进程请求AMS AMS发送创建应用进程请求 Zygote进程接受请求并孵化应用进程 应用进程启动ActivityThread MainActivity组件是由Launcher 组件来启动的，而Launcher组件又是通过Activity管理服务ActivityManagerServ ice来启动Main Activity组件的’。MainActivity组件、Launcher组件和 ActivityManagerService是分别运行在不同的进程中的，因此，MainActivity组件的启动过程就涉及到了三个进程。这三个进程是通过Binder进程间通信机制来完成MainActivity组件的启动过程的。 Launcher组件启动MainActivity组件的过程如下所示。 (1)Launcher组件向ActivityManagerService发送一个启动MainActivity组件的进程间通信请求。 ( 2 ) ActivityManagerService首先将要启动的MainActivity组件的信息保存下来，然后再向Launcher 组件发送一个进入中止状态的进程间通信请求。 ( 3 ) Launcher组件进入到中止状态之后，就会向ActivityManagerService发送一个已进人中止状态 的进程间通信请求，以便ActivityManagerServ ice可以继续执行启动MainActivity组件的操作。 (4) ActivityManagerService发现用来运行MairiActivity组件的应用程序进程不存在，因此，它就会 先启动一个新的应用程序进程。 (5）新的应用程序进程启动完成之后，就会向ActivityManagerServi(e发送一个启动完成的进程间 通信请求，以便ActivityManagerService可以继续执行启动MainActivity组件的操作。 (6) ActivityManagerService将第2步保存下来的MainActivity组件的信息发送给第4步创建的应用程序进程，以便它可以将MainActivity组件启动起来。 一、Launcher进程请求AMS上面我们提到根Activity的启动流程其实就是桌面上点击一个应用图标进入到应用的第一个Activity的流程，其实桌面也可以看成一个程序，即Launcher。当系统开机后，Launcher也随之被启动，然后将已经安装的应用程序图标显示到桌面上，所以当我们点击一个应用图标其实就是相当于点击Activity中的一个button,其相应事件就是Launcher进程请求AMS来启动该应用程序。 1. 时序图 2. 详细过程请求的入口就是Launcher的startActivitySafe方法，如下： packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 12345678910111213141516171819202122232425public boolean startActivitySafely(View v, Intent intent, ItemInfo item) &#123; ... // 根Activity会在新的任务栈中启动 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; ... if (isShortcut) &#123; // Shortcuts need some special checks due to legacy reasons. startShortcutIntentSafely(intent, optsBundle, item); &#125; else if (user == null || user.equals(Process.myUserHandle())) &#123; // 调用startActivity startActivity(intent, optsBundle); &#125; else &#123; LauncherAppsCompat.getInstance(this).startActivityForProfile( intent.getComponent(), user, intent.getSourceBounds(), optsBundle); &#125; ... return true; &#125; catch (ActivityNotFoundException|SecurityException e) &#123; ... &#125; return false;&#125; 可以发现该方法为根Activity设置了flag，即根Activity会在新的任务栈中启动。然后会调用我们熟悉的startActivity方法,而在Launcher并没有这个方法，所以我们自然想到了应该是父类的方法，然后让我们来看看Launcher继承了哪些类？ 1234567891011public class Launcher extends BaseDraggingActivity implements LauncherExterns, LauncherModel.Callbacks, LauncherProviderChangeListener, UserEventDelegate&#123; &#125;public abstract class BaseDraggingActivity extends BaseActivity implements WallpaperColorInfo.OnChangeListener &#123; &#125;public abstract class BaseActivity extends Activity implements UserEventDelegate&#123;&#125; 其实一直追踪下去，你就会发现其实Launcher调用的startActivity其实就是Activity中的startActivity。从这里也可以证明Launcher其实也是个Activity。所以在Launcher启动一个app，和我们平时在startActivity基本是一样的（基本一样，不代表完全一样，通过后文分析你就会明白！），于是我们来看看我们熟悉的Activity中的startActivity的源码是如何的： 源码：frameworks/base/core/java/android/app/Activity.java 123456789101112131415161718192021222324252627282930@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; //第二个参数为-1表示Launcher不需要知道根Activity的启动结果 if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null);&#125;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; //mParent表示当前Activity的父类，当根活动还没创建则mParent==null if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ... &#125; ...&#125; 从上面代码可以发现startActivity的最终实现是startActivityForResult，startActivity()第二个参数为-1表示Launcher不需要知道根Activity的启动结果,然后在startActivityForResult中由于此时根Activity还没有创建，故mParent=null,所以我们只需要关注mParent=null的情况。在这种情况中会调用Instrumentation的execStartActivity。这时候也许你就会问这个Instrumentation是什么？为什么要交给它处理？其实Instrumentation这个类很重要，重要体现在对Activity生命周期的调用。每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。看看Instrumentation的execStartActivity这个方法。 frameworks/base/core/java/android/app/Instrumentation.java 12345678910111213141516171819public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ... try &#123; ... //获取AMS的代理对象 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125; 在这个方法会调用ActivityManager的getService方法来得到AMS的代理对象，然后调用这个代理对象的 startActivity方法，那么这个代理对象是谁呢？让我们一探究竟 123456789101112131415161718@UnsupportedAppUsagepublic static IActivityManager getService() &#123; return IActivityManagerSingleton.get();&#125;@UnsupportedAppUsageprivate static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; //得到activity的service引用，即IBinder类型的AMS引用 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); //转换成IActivityManager对象 final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 可以发现在Singleton中的create方法中由于b是AMS引用作为服务端处于SystemServer进程中，与当前Launcher进程作为客户端与服务端不在同一个进程，所以am返回的是IActivityManager.Stub的代理对象，此时如果要实现客户端与服务端进程间的通信，只需要在AMS继承了IActivityManager.Stub类并实现了相应的方法，而通过下面的代码可以发现AMS刚好是继承了IActivityManager.Stub类的，这样Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了，就这样Launcher的工作就交给AMS实现了。 12345public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123; &#125;复制代码 二、AMS发送创建应用进程请求通过上面的分析，我们已经知道现在任务已经交给了AMS，入口是AMS的startActivity。 1. 时序图 2. 详细过程2.1 AMS将请求任务转移给Process首先来看看在AMS中的startActivity方法： 源码：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; //判断调用者的进程是否隔离 enforceNotIsolatedCaller(&quot;startActivity&quot;); //检查调用者权限 userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;); // TODO: Switch to user app stacks here. return mActivityStartController.obtainStarter(intent, &quot;startActivityAsUser&quot;) .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute();&#125; startActivity方法经过多个方法调用会去执行startActivityAsUser方法，在startActivityAsUser方法最后会返回mActivityStartController的一长串链式调用方法，如果AlertDialog的话，应该不难看出这链式方法肯定都是返回一个类型的对象的，我们只需要看看obtainStarter的返回类型就可以知道这个对象是什么类型了。 frameworks/base/services/core/java/com/android/server/am/ActivityStartController.java 1234ActivityStarter obtainStarter(Intent intent, String reason) &#123; return mFactory.obtain().setIntent(intent).setReason(reason);&#125; 可以发现这个obtainStarter返回的是ActivityStarter类型的，所以链式方法就是对ActivityStarter对象设置了要启动的活动的相关信息，最后再调用ActivityStarter对象execute方法。所以我们下一步所需要看的就是这个execute方法。 frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 12345678910111213141516171819202122232425262728293031int execute() &#123; try &#123; // TODO(b/64750076): Look into passing request directly to these methods to allow // for transactional diffs and preprocessing. if (mRequest.mayWait) &#123; return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent); &#125; else &#123; return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent); &#125; &#125; finally &#123; onExecutionComplete(); &#125;&#125; 因为在startActivityAsUser的链式方法中我们调用了setMayWait这个方法，所以这里的mRequest.mayWait为true，故会继续调用startActivityMayWait方法。 ActivityStarter#startActivityMayWait 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 private int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup, PendingIntentRecord originatingPendingIntent) &#123; ..... //根据intent在系统中找到合适的应用的activity，如果有多个activity可选择，//则会弹出ResolverActivity让用户选择合适的应用。 ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent); .... &#125; private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup) &#123; ... mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, inTask, allowPendingRemoteAnimationRegistryLookup); ... return getExternalResult(mLastStartActivityResult); &#125; private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) &#123; ... return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity); &#125; private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; ... result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); ... postStartActivityProcessing(r, result, mTargetStack); return result; &#125; startActivityMayWait方法经过调用多次的startActivity方法后会调用到startActivityUnchecked这个方法，那这个方法是干啥的呢？这个方法会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。比如我们在一开始将活动设置了FLAG_ACTIVITY_NEW_TASK后将创建一个任务栈，其它的就自行看代码。 12345678910111213141516171819202122232425262728293031323334353637383940 private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123;... if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; //创建新的TaskRecord result = setTaskFromReuseOrCreateNewTask( taskToAffiliate, preferredLaunchStackId, topStack); &#125; else if (mSourceRecord != null) &#123; result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; result = setTaskFromInTask(); &#125; else &#123; setTaskToCurrentTopOrCreateNewTask(); &#125; ... if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; ... &#125; else &#123; if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;); &#125; mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; &#125; else &#123; mTargetStack.addRecentActivityLocked(mStartActivity); &#125; ...&#125; 然后无论以何种模式启动最终都会调用ActivityStackSupervisor.resumeFocusedStackTopActivityLocked方法。 frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 123456789boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; .... if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; ....&#125; 于是又调用了ActivityStack的resumeTopActivityUncheckedLocked frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 1234567891011121314151617181920 @GuardedBy(&quot;mService&quot;) boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ... try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); &#125; ... &#125;private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; emmmm…..，看到这估计都懵逼了，几个类跳来跳去也不知道干了些什么，不慌，让我们坚持看下ActivityStackSupervisor.startSpecificActivityLocked,因为这个方法很重要。这个方法将是普通Activity和根Activity启动流程的分岔路口。 ActivityStackSupervisor#startSpecificActivityLocked 1234567891011121314151617181920212223242526272829303132 void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; //获取即将要启动的Activity的所在的应用程序进程 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); //如果应用进程已经存在 if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) &#123; // Don&#x27;t add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn&#x27;t make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125;//应用进程还未创建，则通过AMS调用startProcessLocked向Zygote进程发送请求 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); &#125; 阅读上面的代码我们可以知道在方法中首先获取到了即将要启动的Activity所在的应用进程，假如是普通的Activity的启动流程的活，这个进程肯定是存在的，所以将执行realStartActivityLocked的方法。但是我们现在讨论的是根Activity的启动流程，由于应用都还未启动，意味着根Activity所在的应用进程还未创建，而mService其实就是AMS，所以这里将调用AMS的startProcessLocked。于是我们又回到了最初的起点AMS。 ActivityManagerService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123; return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */);&#125;final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123; ... final boolean success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride); ...&#125;@GuardedBy(&quot;this&quot;)private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride) &#123; return startProcessLocked(app, hostingType, hostingNameStr, false /* disableHiddenApiChecks */, abiOverride);&#125;private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) &#123; ... int uid = app.uid; //创建应用进程的用户ID int[] gids = null; int mountExternal = Zygote.MOUNT_EXTERNAL_NONE; if (!app.isolated) &#123; int[] permGids = null; try &#123; checkTime(startTime, &quot;startProcess: getting gids from package manager&quot;); final IPackageManager pm = AppGlobals.getPackageManager(); permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId); StorageManagerInternal storageManagerInternal = LocalServices.getService( StorageManagerInternal.class); mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; /* * 对用户组进行创建和赋值 */ if (ArrayUtils.isEmpty(permGids)) &#123; gids = new int[3]; &#125; else &#123; gids = new int[permGids.length + 3]; System.arraycopy(permGids, 0, gids, 3, permGids.length); &#125; gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid)); gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid)); gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid)); // Replace any invalid GIDs if (gids[0] == UserHandle.ERR_GID) gids[0] = gids[2]; if (gids[1] == UserHandle.ERR_GID) gids[1] = gids[2]; &#125; ... //这个参数后文会提到 final String entryPoint = &quot;android.app.ActivityThread&quot;; return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); &#125;private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; .... //重点关注 final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint, app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo, requiredAbi, instructionSet, invokeWith, app.startTime); ...&#125;private ProcessStartResult startProcess(String hostingType, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; .... if (hostingType.equals(&quot;webview_service&quot;)) &#123; startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; else &#123; //通过Process.start方法来为应用创建进程 startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); return startResult; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125; 通过调用多个startProcessLocked方法后最终将调用startProcess方法，不过需要重点看一下上面的第四个startProcessLocked，在该方法中有个entryPoint参数为 “android.app.ActivityThread”，这个参数将在后文讲到创建应用进程后启动ActivityThread会用到。然后在startProcess方法里将调用Process.start来发送应用创建进程的请求。这样AMS就将发送请求的事交给了Process 2.2 Process向Zygote进程发送创建应用进程请求 frameworks/base/core/java/android/os/Process.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) &#123; return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, /*useBlastulaPool=*/ true, zygoteArgs);&#125;public final Process.ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean useBlastulaPool, String[] zygoteArgs) &#123; try &#123; //重点关注 return startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/false, useBlastulaPool, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); &#125;&#125; 从上面可以发现，Process中的start方法的实现是startViaZygote方法，所以我们重点观察下这个方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean startChildZygote, boolean useBlastulaPool, String[] extraArgs) throws ZygoteStartFailedEx &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, //创建字符串列表argsForZygote，并将启动应用进程的启动参数保存在这个列表中 argsForZygote.add(&quot;--runtime-args&quot;); argsForZygote.add(&quot;--setuid=&quot; + uid); argsForZygote.add(&quot;--setgid=&quot; + gid); argsForZygote.add(&quot;--runtime-flags=&quot; + runtimeFlags); if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(&quot;--mount-external-default&quot;); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123; argsForZygote.add(&quot;--mount-external-read&quot;); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123; argsForZygote.add(&quot;--mount-external-write&quot;); &#125; argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion); ... synchronized(mLock) &#123; //重点关注 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), useBlastulaPool, argsForZygote); &#125;&#125; 在startViaZygote中会创建字符串列表argsForZygote来保存将要创建的应用进程的启动参数，然后最后会调用zygoteSendArgsAndGetResult方法，而在这个方法中第一个参数会调用openZygoteSocketIfNeeded方法，第三个参数就是启动参数列表。所以我们先看看openZygoteSocketIfNeeded这个方法的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);//64位进程中的 if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; //调用ZygoteState的connect函数与mZygoteSocketAddress建立连接， //这里mZygoteSocketAddress的值为“zygote” primaryZygoteState = ZygoteState.connect(mZygoteSocketAddress, mBlastulaPoolSocketAddress); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe); &#125; maybeSetApiBlacklistExemptions(primaryZygoteState, false); maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState); &#125; if (primaryZygoteState.matches(abi)) &#123; //Socket进行连接成功并匹配abi后会返回ZygoteState类型对象 return primaryZygoteState; &#125; // 32位Zygote进程中 if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(mZygoteSecondarySocketAddress, mBlastulaPoolSecondarySocketAddress); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe); &#125; maybeSetApiBlacklistExemptions(secondaryZygoteState, false); maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState); &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi); &#125; openZygoteSocketIfNeeded这个方法从方法名就可以推测出这个方法的作用，大概就是与Zygote建立Socket连接。而从代码中也证实了这一点，在代码中会根据Zygote进程的位数来建立相应的Socket连接，然后返回ZygoteState类型的对象。既然与Zygote建立好Socket连接后，接下来当然是发送请求！我们来看看zygoteSendArgsAndGetResult这个方法中是如何发送请求的！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//将传入的应用进程的启动参数argsForZygote写入到ZygoteState @GuardedBy(&quot;mLock&quot;) private static Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, boolean useBlastulaPool, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; String msgStr = Integer.toString(args.size()) + &quot;\\n&quot; + String.join(&quot;\\n&quot;, args) + &quot;\\n&quot;; // Should there be a timeout on this? Process.ProcessStartResult result = new Process.ProcessStartResult(); // TODO (chriswailes): Move branch body into separate function. if (useBlastulaPool &amp;&amp; Zygote.BLASTULA_POOL_ENABLED &amp;&amp; isValidBlastulaCommand(args)) &#123; LocalSocket blastulaSessionSocket = null; try &#123; blastulaSessionSocket = zygoteState.getBlastulaSessionSocket(); final BufferedWriter blastulaWriter = new BufferedWriter( new OutputStreamWriter(blastulaSessionSocket.getOutputStream()), Zygote.SOCKET_BUFFER_SIZE); final DataInputStream blastulaReader = new DataInputStream(blastulaSessionSocket.getInputStream()); blastulaWriter.write(msgStr); blastulaWriter.flush(); result.pid = blastulaReader.readInt(); // Blastulas can&#x27;t be used to spawn processes that need wrappers. result.usingWrapper = false; if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(&quot;Blastula specialization failed&quot;); &#125; return result; &#125; catch (IOException ex) &#123; // If there was an IOException using the blastula pool we will log the error and // attempt to start the process through the Zygote. Log.e(LOG_TAG, &quot;IO Exception while communicating with blastula pool - &quot; + ex.toString()); &#125; finally &#123; try &#123; blastulaSessionSocket.close(); &#125; catch (IOException ex) &#123; Log.e(LOG_TAG, &quot;Failed to close blastula session socket: &quot; + ex.getMessage()); &#125; &#125; &#125; try &#123; final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter; final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream; zygoteWriter.write(msgStr); zygoteWriter.flush(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = zygoteInputStream.readInt(); result.usingWrapper = zygoteInputStream.readBoolean(); &#125; catch (IOException ex) &#123; zygoteState.close(); Log.e(LOG_TAG, &quot;IO Exception while communicating with Zygote - &quot; + ex.toString()); throw new ZygoteStartFailedEx(ex); &#125; if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); &#125; return result; &#125; 因为在openZygoteSocketIfNeeded中我们已经与Zygote进程建立了Socket连接，所以在这个方法中将传入的应用进程的启动参数argsForZygote写入到ZygoteState。这样AMS就完成了向Zygote进程发送创建应用进程的请求的任务。 三、Zygote进程接受请求并孵化应用进程从上面我们知道，AMS已经与Zygote进程建立Socket连接并发送了创建应用进程的请求，那么Zygote进程是在哪里收到请求，收到请求后又是怎么处理的呢？通过阅读后我们知道Zygote进程是在ZygoteInit的main方法中接受请求的。所以现在的入口就是ZygoteInit的main方法。 1. 时序图 2. 详细过程从时序图与上面的分析我们知道现在Zygote进程接受请求是在main方法，就让我们来看看这个main方法 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 12345678910111213141516171819202122232425262728293031323334353637383940 @UnsupportedAppUsage public static void main(String argv[]) &#123; ZygoteServer zygoteServer = new ZygoteServer(); Runnable caller; try &#123; ... //创建名为zygote的Socket zygoteServer.createZygoteSocket(socketName); .... //由于在init.rc中设置了start-system-server参数,因此 //这里将启动SystemServer,可见SystemServer由Zygote创建的第一个进程 if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, socketName, zygoteServer); if (r != null) &#123; r.run(); return; &#125; &#125; caller = Zygote.initBlastulaPool(); if (caller == null) &#123; Log.i(TAG, &quot;Accepting command socket connections&quot;); //等待AMS的请求 runSelectLoop(abiList); &#125; &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with exception&quot;, ex); throw ex; &#125; finally &#123; zygoteServer.closeServerSocket(); &#125; // We&#x27;re in the child process and have exited the select loop. Proceed to execute the // command. if (caller != null) &#123; caller.run(); &#125; &#125;复制代码 通过main方法，我们可以知道在这个main方法首先要创建一个Server端的Socket，这个name为”zygote”的Socket用来等待ActivityManagerService来请求Zygote来创建新的应用程序进程,在上面AMS请求的分析中我们也知道客户端将根据这个name来与Zygote的Socket建立连接。接下去会启动SystemServer进程，这个进程会启动各种系统服务，比如与Activity启动息息相关的AMS。最后会调用ZygoteServer.runSelectLoop(abiList)来使创建的Socket进入无限循环，等待AMS请求。让我们来看看这个runSelectLoop frameworks/base/core/java/com/android/internal/os/ZygoteServer.java 12345678910111213141516171819202122232425262728 Runnable runSelectLoop(String abiList) &#123; ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); peers.add(null); while (true) &#123; while (--pollIndex &gt;= 0) &#123; if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (pollIndex == 0) &#123; //监听Socket连接，充当服务端Socket ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); socketFDs.add(newPeer.getFileDescriptor()); &#125; else if (pollIndex &lt; blastulaPoolEventFDIndex) &#123; try &#123; //不断处理客户端的AMS的请求，然后交给processOneCommand ZygoteConnection connection = peers.get(pollIndex); final Runnable command = connection.processOneCommand(this); &#125; .... &#125; &#125; &#125; &#125;复制代码 可以发现这个方法是死循环表示不停的监听着Socket连接。acceptCommandPeer方法就是监听是否收到了请求，如果收到了请求就交给processOneCommand来实现 frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 Runnable processOneCommand(ZygoteServer zygoteServer) &#123; String args[]; ZygoteArguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; //获取应用程序进程的启动参数 args = Zygote.readArgumentList(mSocketReader); // TODO (chriswailes): Remove this and add an assert. descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; throw new IllegalStateException(&quot;IOException on command socket&quot;, ex); &#125; .... parsedArgs = new ZygoteArguments(args); .... //fork当前进程创建一个子进程 pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote, parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion); try &#123; //pid为0则代表这个进程为子进程，即新创建的应用程序进程 if (pid == 0) &#123; zygoteServer.setForkChild(); zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; return handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.mStartChildZygote); &#125; else &#123; // In the parent. A pid &lt; 0 indicates a failure and will be handled in // handleParentProc. IoUtils.closeQuietly(childPipeFd); childPipeFd = null; handleParentProc(pid, descriptors, serverPipeFd); return null; &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125; &#125;复制代码 在这个方法中将对请求进行处理，首先获取到将要启动的应用进程的启动参数，然后调用forkAndSpecialize来创建应用进程。 frameworks/base/core/java/com/android/internal/os/Zygote.java 12345678910111213141516171819202122 public static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir, int targetSdkVersion) &#123; ZygoteHooks.preFork(); // Resets nice priority for zygote process. resetNicePriority(); int pid = nativeForkAndSpecialize( uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose, fdsToIgnore, startChildZygote, instructionSet, appDataDir); // Enable tracing as soon as possible for the child process. if (pid == 0) &#123; Zygote.disableExecuteOnly(targetSdkVersion); Trace.setTracingEnabled(true, runtimeFlags); // Note that this event ends at the end of handleChildProc, Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;); &#125; ZygoteHooks.postForkCommon(); return pid; &#125;复制代码 在forkAndSpecialize中，最终将创建应用进程的任务交给nativeForkAndSpecialize，而这个方法可以看出来应该是本地方法，所以具体如何创建的我们就不深究了，在这里我们这需要知道nativeForkAndSpecialize最终是通过fork当前线程来创建一个子线程，而fork后会有返回值给pid: 父进程中，fork返回新创建的子进程pid; 子进程中，fork返回0； 出现错误时，fork返回负数。 于是到这里子线程也就是应用进程就被孵化出来了。你以为这样就结束了？其实还早呢！别忘了我们的最终使命是根Activity的启动，而现在只是有了根Activity所需要的应用进程，革命尚未成功，仍需要努力！ 四、应用进程启动ActivityThread1. 时序图 2. 详细过程从上面我们知道应用进程已经被创建，那创建后呢？这就需要我们回头看上面的processOneCommand方法，细心的你肯定会发现再孵化出应用进程后，还是有返回值的。 frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 1234567891011121314151617181920212223 Runnable processOneCommand(ZygoteServer zygoteServer) &#123; ....//fork当前进程创建一个子进程 pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote, parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion); try &#123; //pid为0则代表这个进程为子进程，即新创建的应用程序进程 if (pid == 0) &#123; .... return handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.mStartChildZygote); &#125; else &#123; ... &#125; &#125; .... &#125; 在上面我们分析了当pid=0的时候，则代表了当前进程已经是子进程了，即应用进程。所以下一步将执行handleChildProc方法。 1234567891011private Runnable handleChildProc(ZygoteArguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, boolean isZygote) &#123; ..... if (!isZygote) &#123; return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mRemainingArgs, null /* classLoader */); &#125; else &#123; .... &#125;&#125; 而handleChildProc最终又会调用ZygoteInit.zygoteInit方法。如下 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 12345678910111213141516 public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123; if (RuntimeInit.DEBUG) &#123; Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;); &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;); RuntimeInit.redirectLogStreams();//为当前的VM设置未捕获异常器 RuntimeInit.commonInit();//Binder驱动初始化，该方法完成后，可通过Binder进行进程通信 ZygoteInit.nativeZygoteInit();//主要调用SystemServer的main方法 return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); &#125; 在这个方法里会创建当前进程的Binder线程池，便于后续与其它进程通信，然后调用了RuntimeInit的applicationInit方法，如下： frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 12345678protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123; ... final Arguments args = new Arguments(argv); // Remaining arguments are passed to the start class&#x27;s static main return findStaticMain(args.startClass, args.startArgs, classLoader); &#125; 这个方法最终会调用findStaticMain方法，不过需注意的是方法的第一个参数args.startClass其实就是我们上文AMS将请求任务转移给Process中在最后强调的那个参数：android.app.ActivityThread。然后我们看看findStaticMain的实现 12345678910111213141516171819protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader);//1 &#125; catch (ClassNotFoundException ex) &#123; .... &#125; Method m; try &#123; m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);//2 &#125; catch (NoSuchMethodException ex) &#123; ... &#125; catch (SecurityException ex) &#123; ... &#125; return new MethodAndArgsCaller(m, argv);&#125; 在这个方法中首先在注释1通过反射获取到android.app.ActivityThread类，然后在注释2获取到ActivityThread的main方法，最后通过main方法来构造MethodAndArgsCaller。而这个MethodAndArgsCaller是什么呢？如下： frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 1234567891011121314151617181920212223242526272829static class MethodAndArgsCaller implements Runnable &#123; /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125; &#125; 追踪下去，MethodAndArgsCaller其实是RuntimeInit的一个内部类并且继承了Runnable,然后在run方法中会通过反射调用了mMethod方法，此时mMethod是ActivityThread的main方法，即run方法中将会执行ActivityThread的main方法，在这里你可能会有疑问了，那这个run方法什么时候执行呢？让我们来看看最开始的ZygoteInit的main方法。 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 1234567891011121314151617181920212223@UnsupportedAppUsagepublic static void main(String argv[]) &#123; Runnable caller; try &#123; .... caller = Zygote.initBlastulaPool(); if (caller == null) &#123; Log.i(TAG, &quot;Accepting command socket connections&quot;); //等待AMS的请求 caller = zygoteServer.runSelectLoop(abiList); &#125; &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with exception&quot;, ex); throw ex; &#125; finally &#123; zygoteServer.closeServerSocket(); &#125; if (caller != null) &#123; caller.run(); &#125;&#125; 从分析Zygote进程接受请求并孵化应用进程的一开始，我们就是分析runSelectLoop(abiList)这个方法，而分析到最后findStaticMain方法将返回MethodAndArgsCaller对象（继承Runnable）,所以这时候在ZygoteInit的main方法caller会等于这个MethodAndArgsCaller对象，显然caller不等于null，故最后会执行caller.run方法，即执行ActivityThread的main方法。于是应用进程成功启动ActivityThread。 https://juejin.im/post/5d9d948de51d45782c23fabc https://juejin.im/post/5a936c5a6fb9a0633229ca74 http://codemx.cn/2018/01/26/AndroidOS008-Activity/ Android系统启动流程（二）解析Zygote进程启动过程 https://juejin.im/post/6867744083809419277 https://juejin.im/post/6887431834041483271 启动流程目的 https://juejin.cn/post/6897892195483779080","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"ActivityStart02","slug":"ActivityStart02","date":"2020-01-13T02:49:39.000Z","updated":"2021-08-19T11:11:43.527Z","comments":true,"path":"2020/01/13/ActivityStart02/","link":"","permalink":"https://noteforme.github.io/2020/01/13/ActivityStart02/","excerpt":"","text":"Application OnCreate() 12345678910111213141516171819public static void main(String[] args) &#123; Looper.prepareMainLooper(); //创建消息循环 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); //使当前进程进入消息循环&#125; 在这里我们就不再详细分析prepareMainLooper和loop方法，其主要功能就是准备好主线程的Looper以及消息队列，最后再开启主线程的消息循环。 1234567891011121314151617181920212223242526272829303132private void attach(boolean system) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); //获得ApplicationThreadNative //代理类ActivityManagerProxy try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; mgr.releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; &#125;);&#125; 可以看到由于在ActivityThread的attach中我们传入的是false，故在attach方法中将执行!system里的代码，通过调用AMS的attachApplication来将ActivityThread中的内部类ApplicationThread对象绑定至AMS，这样AMS就可以通过这个代理对象 来控制应用进程。接着为这个进程添加垃圾回收观察者，每当系统触发垃圾回收的时候就在run方法中计算应用使用了多大的内存，如果超过总量的3/4就尝试释放内存。 1234567891011public void attachApplication(IApplicationThread app) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 12345678910111213141516@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case ATTACH_APPLICATION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IApplicationThread app = ApplicationThreadNative.asInterface( data.readStrongBinder()); //得到代理类ApplicationThreadProxy if (app != null) &#123; attachApplication(app); &#125; reply.writeNoException(); return true; &#125; &#125;&#125; 123456789@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; ​ 将应用进程的ApplicationThread对象绑定到AMS，即AMS获得ApplicationThread的代理对象 123456789101112131415161718private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; //创建Application thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); //创建Activity if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; create Application 12345678910111213141516171819@Overridepublic final void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArgs, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException &#123; data.writeInt(restrictedBackupMode ? 1 : 0); data.writeInt(persistent ? 1 : 0); config.writeToParcel(data, 0); compatInfo.writeToParcel(data, 0); data.writeMap(services); data.writeBundle(coreSettings); mRemote.transact(BIND_APPLICATION_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 123456789101112131415161718192021 @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case BIND_APPLICATION_TRANSACTION: boolean trackAllocation = data.readInt() != 0; boolean restrictedBackupMode = (data.readInt() != 0); boolean persistent = (data.readInt() != 0); Configuration config = Configuration.CREATOR.createFromParcel(data); CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); HashMap&lt;String, IBinder&gt; services = data.readHashMap(null); Bundle coreSettings = data.readBundle(); bindApplication(packageName, info, providers, testName, profilerInfo, testArgs, testWatcher, uiAutomationConnection, testMode, enableBinderTracking, trackAllocation, restrictedBackupMode, persistent, config, compatInfo, services, coreSettings); return true; &#125;&#125; 1234567891011121314151617public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; sendMessage(H.BIND_APPLICATION, data);&#125; 12345case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); 1234567891011private void handleBindApplication(AppBindData data) &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; mInstrumentation.callApplicationOnCreate(app); //调用Application的create方法 &#125; 1234567891011121314151617181920212223242526public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = &quot;android.app.Application&quot;; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;initializeJavaContextClassLoader&quot;); initializeJavaContextClassLoader(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app);&#125; LaunchActivity1234567891011121314151617181920212223242526272829303132333435// we use token to identify this activity without having to send the // activity itself back to the activity manager. (matters more with ipc) @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 12345678910111213public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; //通过Activity所在的应用程序信息及该Activity对应的CompatibilityInfo信息从PMS服务中查询当前Activity的包信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //获取当前Activity的组件信息 ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; //packageName为启动Activity的包名，targetActivity为Activity的类名 if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //通过类反射方式加载即将启动的Activity Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; ...... try &#123; //通过单例模式为应用程序进程创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) &#123; //为当前Activity创建上下文对象ContextImpl Context appContext = createBaseContextForActivity(r, activity); ...... //将当前启动的Activity和上下文ContextImpl、Application绑定 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... //将Activity保存到ActivityClientRecord中，ActivityClientRecord为Activity在应用程序进程中的描述符 r.activity = activity; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... //生命周期onStart、onresume if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; //ActivityThread的成员变量mActivities保存了当前应用程序进程中的所有Activity的描述符 mActivities.put(r.token, r); ...... return activity;&#125; 在上述方法中将调用performLaunchActivity来启动Activity，如下 应用程序进程通过performLaunchActivity函数将即将要启动的Activity加载到当前进程空间来，同时为启动Activity做准备。 [ActivityThread.java #performLaunchActivity()] 123456789101112private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //用类加载器来创建该Activity的实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);&#125; public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance(); &#125; 解决问题Application Activity创建流程 Launch app启动问题 https://juejin.im/post/5baf275f5188255c9a7740ba","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"JVM_HEAP","slug":"JVM-HEAP","date":"2020-01-06T09:37:17.000Z","updated":"2022-05-06T11:24:51.250Z","comments":true,"path":"2020/01/06/JVM-HEAP/","link":"","permalink":"https://noteforme.github.io/2020/01/06/JVM-HEAP/","excerpt":"","text":"堆内存细分现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为： Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Old generation space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区，又被划分为Eden区和Survivor区 Old generation space 养老区 Meta Space 元空间 Meta 约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代 堆空间内部结构，JDK1.8之前从永久代 替换成 元空间 堆是分配对象的唯一选择么？在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述： 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。 此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 逃逸分析 如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域： 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。 逃逸分析举例 1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC） 123456public void my_method() &#123; V v = new V(); // use v // .... v = null;&#125; 2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配 123456public static StringBuffer createStringBuffer(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb;&#125; 3、如果想要StringBuffer sb不发生逃逸，可以这样写 123456public static String createStringBuffer(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString();&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * 逃逸分析 * * 如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。 */public class EscapeAnalysis &#123; public EscapeAnalysis obj; /* 方法返回EscapeAnalysis对象，发生逃逸 */ public EscapeAnalysis getInstance()&#123; return obj == null? new EscapeAnalysis() : obj; &#125; /* 为成员属性赋值，发生逃逸 */ public void setObj()&#123; this.obj = new EscapeAnalysis(); &#125; //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。 /* 对象的作用域仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis()&#123; EscapeAnalysis e = new EscapeAnalysis(); &#125; /* 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis1()&#123; EscapeAnalysis e = getInstance(); //getInstance().xxx()同样会发生逃逸 &#125;&#125; 逃逸分析参数设置 在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析 如果使用的是较早的版本，开发人员则可以通过： 选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析 通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果 总结 开发中能使用局部变量的，就不要使用在方法外定义。 代码优化使用逃逸分析，编译器可以对代码做如下优化： 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"List","slug":"List","date":"2020-01-05T13:50:30.000Z","updated":"2023-01-02T03:31:39.093Z","comments":true,"path":"2020/01/05/List/","link":"","permalink":"https://noteforme.github.io/2020/01/05/List/","excerpt":"","text":"Colletion容器继承图 https://www.jianshu.com/p/31ed50ab01e3 Java ListList &lt;– ArrayList LinkedList ArrayList ```ArrayList arrayList = new ArrayList&lt;&gt;(); 12345 得到一个object数组 &#96;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;&#96;source public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 12342. &#96;&#96;&#96; arrayList.add(1); arrayList.add(2); source 1234567891011public boolean add(E e) &#123; ensureCapacityInternal(size + 1); &#x2F;&#x2F; Increments modCount!! elementData[size++] &#x3D; e; return true;&#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; 先看看calculateCapacity 123456789private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;private static final int DEFAULT_CAPACITY &#x3D; 10;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) minCapacity==10 ensureExplicitCapacity() 1234567891011121314151617181920private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; &#x2F;&#x2F; overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; &#x2F;&#x2F; overflow-conscious code int oldCapacity &#x3D; elementData.length; int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity &#x3D; minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity &#x3D; hugeCapacity(minCapacity); &#x2F;&#x2F; minCapacity is usually close to size, so this is a win: elementData &#x3D; Arrays.copyOf(elementData, newCapacity);&#125; 添加arrayList.add(1);时，size 为10的数组， elementData[size++] = e; 注意size初始化值==0，程序先 执行elementData[0]=1,然后是size++; 当添加的数是11时， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);开始执行 10 + 1010&gt;&gt;1 = 10+5,申请了5个空间 然后get()可以获取element 源码简写 123456789int size &#x3D;0;Object[] elementData&#x3D; &#123;&#125;;Object[] elementArr &#x3D; Arrays.copyOf(elementData, 10);elementArr[size++] &#x3D; 5;elementArr[size++] &#x3D; 7;for ( Object el :elementArr)&#123; System.out.print(el+&quot; &quot;);&#125;System.out.println(elementArr[0]); LinkedList 源码功能如图所示 1234567891011121314151617181920212223void linkLast(E e) &#123; final Node&lt;E&gt; l &#x3D; last; final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null); last &#x3D; newNode; if (l &#x3D;&#x3D; null) first &#x3D; newNode; else l.next &#x3D; newNode; size++; modCount++;&#125;private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item &#x3D; element; this.next &#x3D; next; this.prev &#x3D; prev; &#125; &#125; List iterator List crunchifyList = new ArrayList(); ​ // add 4 different values to list ​ crunchifyList.add(“Facebook”); ​ crunchifyList.add(“Paypal”); ​ crunchifyList.add(“Google”); ​ crunchifyList.add(“Yahoo”); ​ // Other way to define list is - we will not use this list :) ​ List crunchifyListNew = Arrays.asList(“Facebook”, “Paypal”, “Google”, “Yahoo”); ​ Iterator - Returns an iterator over the elements in this list in proper sequence. 1234567Iterator&lt;String&gt; crunchifyIterator &#x3D; crunchifyList.iterator(); while(crunchifyIterator.hasNext()) &#123; System.out.println(crunchifyIterator.next()); &#125; // ListIterator - traverse a list of elements in either forward or backward order ​ // An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, ​ // and obtain the iterator’s current position in the list. 1234ListIterator&lt;String&gt; crunchifyListIterator &#x3D; crunchifyList.listIterator(); while (crunchifyListIterator.hasNext()) &#123; System.out.println(crunchifyListIterator.next()); &#125; Iterable.forEach() util: Returns a sequential Stream with this collection as its source 12345crunchifyList.forEach((temp) -&gt; &#123; System.out.println(temp); &#125;); collection Stream.forEach() util: Returns a sequential Stream with this collection as its source 1crunchifyList.stream().forEach((crunchifyTemp) -&gt; System.out.println(crunchifyTemp)); kotlin List1var mPatientList &#x3D; patientList.filter &#123; it.patientCode &#x3D;&#x3D; patientCode &#125; 123return mQnList?.let &#123; it -&gt; it.filter &#123; it.type &#x3D;&#x3D; type &#125;.map &#123; it.value &#125;&#125; sequencehttps://zhuanlan.zhihu.com/p/38258597 https://juejin.cn/post/7022429745874731045 https://winterbe.com/posts/2018/07/23/kotlin-sequence-tutorial/ https://zhuanlan.zhihu.com/p/38258597","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"JVM_METHOD","slug":"JVM-METHOD","date":"2020-01-04T14:27:53.000Z","updated":"2021-08-19T11:11:43.988Z","comments":true,"path":"2020/01/04/JVM-METHOD/","link":"","permalink":"https://noteforme.github.io/2020/01/04/JVM-METHOD/","excerpt":"","text":"对象的访问定位 Person类的.class信息存放在 方法区中 person变量存放在Java栈的局部变量表中 Person对象存放在Java堆中 在Person堆中，有个指针指向方法区的person类型数据,表示person对象是方法区中的Person类New出来的. 内存布局总结 123456789101112131415161718public class Customer&#123; int id = 1001; String name; Account acct; &#123; name = &quot;匿名客户&quot;; &#125; public Customer()&#123; acct = new Account(); &#125; public static void main(String[] args) &#123; Customer cust = new Customer(); &#125;&#125;class Account&#123;&#125; 图解内存布局 原子性(Atomicity)​ 由 J a v a 内 存 模 型 来 直 接 保 证 的 原 子 性 变 量 操 作 包 括 r e a d 、 l o a d 、 a s s i gn 、 u s e 、 s t o r e 和 w r i t e 这 六 个 ， 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的(例外就是long和double的非原子性 协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况)。 如果应用场景需要一个更大范围的原子性保证(经常会遇到)，Java内存模型还提供了lock和 unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更 高 层 次 的 字 节 码 指 令 m o n i t o r e n t e r 和 m o n i t o r e xi t 来 隐 式 地 使 用 这 两 个 操 作 。 这 两 个 字 节 码 指 令 反 映 到 J a v a 代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 long 和 double 的原子性在前面，我们讲述了 long 和 double 和其他的基本类型不太一样，好像不具备原子性，这是什么原因造成的呢？ ​ long 和 double 的值需要占用 64 位的内存空间，而对于 64 位值的写入，可以分为两个 32 位的操作来进行。 这样一来，本来是一个整体的赋值操作，就可能被拆分为低 32 位和高 32 位的两个操作。如果在这两个操作之间发生了其他线程对这个值的读操作，就可能会读到一个错误、不完整的值。 可 见 性 ( Vi s i b i l i t y )可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。上文在讲解 volat ile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内 存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是 普通变量还是volat ile变量都是如此。普通变量与volat ile变量的区别是，volat ile的特殊规则保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volat ile保证了多线程操作 时变量的可见性，而普通变量则不能保证这一点。 能立即同步到主内存 ？？ 感觉也有问题 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 描述： 演示可见性带来的问题 */public class VisibilityProblem &#123; int a = 10; int b = 20; private void change() &#123; a = 30; b = a; &#125; private void print() &#123; System.out.println(&quot;b=&quot; + b + &quot;;a=&quot; + a); &#125; public static void main(String[] args) &#123; while (true) &#123; VisibilityProblem problem = new VisibilityProblem(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; problem.change(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; problem.print(); &#125; &#125;).start(); &#125; &#125;&#125; 会出现 b = 30;a = 30 b = 20;a = 10 b = 20;a = 30 还会有一种情况 b = 30;a = 10, 这种情况就会有可见性问题,a 的值已经被第 1 个线程修改了，但是其他线程却看不到，由于 a 的最新值却没能及时同步过来，所以才会打印出 a 的旧值。 主内存和工作内存的关系CPU 有多级缓存，导致读的数据过期,由于 CPU 的处理速度很快，相比之下，内存的速度就显得很慢，所以为了提高 CPU 的整体运行效率，减少空闲时间，在 CPU 和内存之间会有 cache 层，也就是缓存层的存在。虽然缓存的容量比内存小，但是缓存的速度却比内存的速度要快得多，其中 L1 缓存的速度仅次于寄存器的速度 越靠近核心，其容量就越小，但是速度也越快. 线程可见性问题的实质线程间对于共享变量的可见性问题，并不是直接由多核引起的，而是由我们刚才讲到的这些 L3 缓存、L2 缓存、L1 缓存，也就是多级缓存引起的：每个核心在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 L1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。 假设 core 1 修改了变量 a 的值，并写入到了 core 1 的 L1 缓存里，但是还没来得及继续往下同步，由于 core 1 有它自己的的 L1 缓存，core 4 是无法直接读取 core 1 的 L1 缓存的值的，那么此时对于 core 4 而言，变量 a 的值就不是 core 1 修改后的最新的值，core 4 读取到的值可能是一个过期的值，从而引起多线程时可见性问题的发生。 什么是主内存和工作内存Java 作为高级语言，屏蔽了 L1 缓存、L2 缓存、L3 缓存(可以看作 工作内存)，也就是多层缓存的这些底层细节，用 JMM 定义了一套读写数据的规范。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。 每个线程只能够直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 JMM 控制的。 JMM 有以下规定： （1）所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝； （2）线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改； （3） 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=298 指令重排序假设我们写了一个 Java 程序，包含一系列的语句，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序。 重排序的好处 左侧 3 行 Java 代码，右侧是这 3 行代码可能被转化成的指令。可以看出 a = 100 对应的是 Load a、Set to 100、Store a，意味着从主存中读取 a 的值，然后把值设置为 100，并存储回去，同理， b = 5 对应的是下面三行 Load b、Set to 5、Store b，最后的 a = a + 10，对应的是 Load a、Set to 110、Store a。如果你仔细观察，会发现这里有两次“Load a”和两次“Store a”，说明存在一定的重排序的优化空间。 重排序后， a 的两次操作被放到一起，指令执行情况变为 Load a、Set to 100、Set to 110、 Store a。下面和 b 相关的指令不变，仍对应 Load b、 Set to 5、Store b。 可以看出，重排序后 a 的相关指令发生了变化，节省了一次 Load a 和一次 Store a。重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。 重排序的 3 种情况下面我们来看一下重排序的 3 种情况。 （1）编译器优化 编译器（包括 JVM、JIT 编译器等）出于优化的目的，例如当前有了数据 a，把对 a 的操作放到一起效率会更高，避免读取 b 后又返回来重新读取 a 的时间开销，此时在编译的过程中会进行一定程度的重排。不过重排序并不意味着可以任意排序，它需要需要保证重排序后，不改变单线程内的语义，否则如果能任意排序的话，程序早就逻辑混乱了。 （2）CPU 重排序 CPU 同样会有优化行为，这里的优化和编译器优化类似，都是通过乱序执行的技术来提高整体的执行效率。所以即使之前编译器不发生重排，CPU 也可能进行重排，我们在开发中，一定要考虑到重排序带来的后果。 （3） 内存的“重排序” 内存系统内不存在真正的重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=295","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"flutter_begin","slug":"flutter-begin","date":"2020-01-04T05:46:38.000Z","updated":"2025-02-18T00:16:27.924Z","comments":true,"path":"2020/01/04/flutter-begin/","link":"","permalink":"https://noteforme.github.io/2020/01/04/flutter-begin/","excerpt":"","text":"环境变量 bash_profile ~&#x2F;.bash_profile 123456export PATH=/Users/m/development/flutter/bin:$PATHexport ANDROID_HOME=&quot;/Users/m/Library/Android/sdk&quot;export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-toolsexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn ~/.zshrc ，在其中添加：source ~&#x2F;.bash_profile Project struct -&gt; Modules -&gt; no sdk 选择 https://mp.weixin.qq.com/s/YfzcvebruRk4LJRTQFVDXA https://github.com/toly1994328/FlutterUnit build apk出错解决: rm &#x2F;Users&#x2F;john&#x2F;development&#x2F;flutter&#x2F;bin&#x2F;cache A problem occurred evaluating root project ‘agora_rtm’. Could not get unknown property ‘kotlin_version’ for object of type org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler. 版本配置 &#x2F;Users&#x2F;***&#x2F;flutter&#x2F;.pub-cache&#x2F;hosted&#x2F;pub.flutter-io.cn&#x2F;cipher2-xxxx&#x2F;android&#x2F;build.gradle’ , ext.kotlin_version &#x3D; 1.3.10 Users&#x2F;john&#x2F;.pub-cache&#x2F;hosted&#x2F;pub.flutter-io.cn&#x2F;agora_rtm-0.9.9&#x2F;android&#x2F;build.gradle’ https://blog.csdn.net/weixin_44416513/article/details/90298303 WidgetText1234567891011121314151617181920212223class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;Text widget&#x27;, home: Scaffold( body: Center( child: Text( &#x27;Hello JSPang ,非常喜欢前端，并且愿意为此奋斗一生。我希望可以出1000集免费教程。&#x27;, textAlign: TextAlign.left, overflow: TextOverflow.ellipsis, maxLines: 1, style: TextStyle( fontSize: 25.0, color: Color.fromARGB(255, 255, 150, 150), decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid, ), )), ), ); &#125;&#125; Image1234567891011121314151617181920212223class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build // TODO: implement createState return MaterialApp( title: &quot;Text WIDGET&quot;, home: Scaffold( body: Center( child: Container( child: new Image.network( &#x27;http://blogimages.jspang.com/blogtouxiang1.jpg&#x27;, repeat: ImageRepeat.repeatY, ), width: 300, height: 200, color: Colors.lightBlue, ), ), ), ); &#125;&#125; ListView 横向 123456789101112131415161718192021222324252627282930313233343536373839class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;JSPang Flutter Demo&#x27;, home: Scaffold( appBar: AppBar(title: Text(&#x27;ListView Widget&#x27;)), body: Center( child: Container( height: 200, child: MyListView(), ), ), )); &#125;&#125;class MyListView extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return ListView( scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ Container( width: 180, color: Colors.amber, ), Container( width: 180, color: Colors.lightBlue, ), Container( width: 180, color: Colors.deepPurpleAccent, ), ], ); &#125;&#125; 动态数据 123456789101112131415161718192021class MyApp extends StatelessWidget &#123; final List&lt;String&gt; items; MyApp(&#123;@required this.items&#125;) : super(); @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;JSPang Flutter Demo&#x27;, home: Scaffold( appBar: AppBar(title: Text(&#x27;ListView Widget&#x27;)), body: ListView.builder( itemCount: items.length, itemBuilder: (context,index)&#123; return ListTile( title: Text(&#x27;$&#123;items[index]&#125;&#x27;), ); &#125;, ))); &#125;&#125; gridview 1234567891011121314151617181920212223class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;JSPang Flutter Demo&#x27;, home: Scaffold( appBar: AppBar(title: Text(&#x27;ListView Widget&#x27;)), body: GridView.count( padding: EdgeInsets.all(20), crossAxisSpacing: 10, crossAxisCount: 4, children: &lt;Widget&gt;[ Text(&#x27;I am JOHN&#x27;), Text(&#x27;I am LI&#x27;), Text(&#x27;I am JON&#x27;), Text(&#x27;I am HEHE&#x27;), Text(&#x27;I am LILI&#x27;), Text(&#x27;I am SIYUE&#x27;), Text(&#x27;I am QIQI&#x27;), ], ))); &#125;&#125; row 固定 123456789101112131415161718192021222324252627282930313233class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: &#x27;Row Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body: Row( children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123;&#125;, color: Colors.amber, child: Text(&#x27;red Button&#x27;), ), RaisedButton( onPressed: () &#123;&#125;, color: Colors.lightBlue, child: Text(&#x27;lightBlue Button&#x27;), ), RaisedButton( onPressed: () &#123;&#125;, color: Colors.redAccent, child: Text(&#x27;redAccent Button&#x27;), ), ] ), ), ); &#125;&#125; 不固定 12345678910111213141516171819202122232425262728293031323334353637class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: &#x27;Row Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body: Row(children: &lt;Widget&gt;[ Expanded( child: RaisedButton( onPressed: () &#123;&#125;, color: Colors.lightBlue, child: Text(&#x27;lightBlue Button&#x27;), ), ), Expanded( child: RaisedButton( onPressed: () &#123;&#125;, color: Colors.redAccent, child: Text(&#x27;redAccent Button&#x27;), ), ), Expanded( child: RaisedButton( onPressed: () &#123;&#125;, color: Colors.deepPurpleAccent, child: Text(&#x27;deepPurpleAccent Button&#x27;), ), ), ]), ), ); &#125;&#125; coloumn12345678910111213141516171819202122232425262728class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: &#x27;Column Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body: Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text(&#x27;I am JOHN&#x27;), Text(&#x27;I am LI&#x27;), Text(&#x27;I am JON I am JON I am JON&#x27;), Text(&#x27;I am HEHE&#x27;), Text(&#x27;I am LILI&#x27;), Text(&#x27;I am SIYUE&#x27;), Text(&#x27;I am QIQI&#x27;), ], ), ), ); &#125;&#125; CrossAxisAlignment 相对于最长的布局 StackWidget1234567891011121314151617181920212223242526272829class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var stack = Stack( alignment: FractionalOffset(0.5,0.8), children: &lt;Widget&gt;[ CircleAvatar( backgroundImage: NetworkImage(&#x27;http://blogimages.jspang.com/blogtouxiang1.jpg&#x27;), radius: 100, ), Container( decoration: BoxDecoration(color: Colors.blue), padding: EdgeInsets.all(5), child: Text(&quot;I am JON&quot;), ) ], ); return MaterialApp( title: &#x27;Column Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body:Center(child: stack), ), ); &#125;&#125; FractionalOffset 0-1 相对于当前容器的 X Y轴 Position Widget12345678910111213141516171819202122232425262728293031323334353637383940class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var stack = Stack( alignment: FractionalOffset(0.1, 0.5), children: &lt;Widget&gt;[ CircleAvatar( backgroundImage: NetworkImage(&#x27;http://blogimages.jspang.com/blogtouxiang1.jpg&#x27;), radius: 100, ), Positioned( top: 10, left: 60, child: Text(&quot;I am JON&quot;), ), Positioned( bottom: 10, right: 10, child: Text( &quot;I am JON&quot;, style: TextStyle(fontSize: 25, color: Colors.lightBlue), ), ), ], ); return MaterialApp( title: &#x27;Column Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text( &quot;水平方向布局&quot;, style: TextStyle(fontSize: 25, color: Colors.redAccent), ), ), body: Center(child: stack), ), ); &#125;&#125; Positioned 相对于当前容器 padding? card123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var card = new Card( child: Column( children: &lt;Widget&gt;[ ListTile( title: Text( &quot;上海市 高兴区&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: Text(&quot;john 182929739933&quot;), leading: Icon( Icons.account_box, color: Colors.lightBlue, ), ), Divider(), ListTile( title: Text( &quot;北京市 高兴区&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: Text(&quot;elon 182929739933&quot;), leading: Icon( Icons.account_box, color: Colors.lightBlue, ), ), Divider(), ListTile( title: Text( &quot;江西省 高兴区&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: Text(&quot;lari 182929739933&quot;), leading: Icon( Icons.account_box, color: Colors.lightBlue, ), ), ], ), ); return MaterialApp( title: &quot;Row Widget Demo&quot;, home: Scaffold( appBar: AppBar( title: Text(&#x27;Card布局&#x27;), ), body: Center( child: card, ), )); &#125;&#125; 页面跳转1234567891011121314151617181920212223242526272829303132333435363738class FirstScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar(title: Text(&#x27;导航页面&#x27;)), body: Center( child: RaisedButton( child: Text(&#x27;查看商品详情页&#x27;), onPressed: () &#123; Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; new SecondScreen())); &#125;, ), ), ); &#125;&#125;class SecondScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( title: Text(&#x27;导航商品详情页&#x27;), ), body: Center( child: RaisedButton( child: Text(&#x27;返回&#x27;), onPressed: ()&#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 列表传参1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void main() =&gt; runApp(MaterialApp( title: &quot;列表数据传递&quot;, home: ProductList( products: List.generate(20, (i) =&gt; Product(&#x27; 商品 $i&#x27;, &#x27;这是一个商品详情， 编号: $i&#x27;)))));class ProductList extends StatelessWidget &#123; final List&lt;Product&gt; products; ProductList(&#123;this.products&#125;) : super(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&#x27;商品列表&#x27;), ), body: ListView.builder( itemCount: products.length, itemBuilder: (context, index) &#123; return ListTile( title: Text(products[index].title), onTap: () &#123; Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; ProductDetail(product: products[index]))); &#125;, ); &#125;), ); &#125;&#125;class Product &#123; final String title; final String description; Product(this.title, this.description);&#125;class ProductDetail extends StatelessWidget &#123; final Product product; ProductDetail(&#123;this.product&#125;) : super(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&#x27;$&#123;product.title&#125;&#x27;), ), body: Center( child: Text(&#x27;$&#123;product.description&#125;&#x27;), ), ); &#125;&#125; 跳转返回1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&#x27;小姐姐要电话&#x27;), ), body: Center( child: RouteButton(), ), ); &#125;&#125;class RouteButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return RaisedButton( onPressed: () &#123; _navigateToXiaoJIe(context); &#125;, child: Text(&#x27;找小姐姐&#x27;), ); &#125;&#125;_navigateToXiaoJIe(BuildContext context) async &#123; final result = await Navigator.push( context, MaterialPageRoute(builder: (context) =&gt; XiaoJieJie())); Scaffold.of(context).showSnackBar(SnackBar( content: Text(&#x27;$result&#x27;), ));&#125;class XiaoJieJie extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( title: Text(&#x27;我是小姐姐&#x27;), ), body: Center( child: Column( children: &lt;Widget&gt;[ RaisedButton( child: Text(&#x27;可爱小姐姐&#x27;), onPressed: () &#123; Navigator.pop(context, &#x27;可爱小姐姐 1550008883&#x27;); &#125;, ), RaisedButton( child: Text(&#x27;漂亮小姐姐&#x27;), onPressed: () &#123; Navigator.pop(context, &#x27;漂亮小姐姐 1550009983&#x27;); &#125;, ), ], ), ), ); &#125;&#125;","categories":[{"name":"flutter","slug":"flutter","permalink":"https://noteforme.github.io/categories/flutter/"}],"tags":[]},{"title":"JVM_STACK","slug":"JVM-STACK","date":"2020-01-04T03:28:39.000Z","updated":"2022-06-12T03:17:58.660Z","comments":true,"path":"2020/01/04/JVM-STACK/","link":"","permalink":"https://noteforme.github.io/2020/01/04/JVM-STACK/","excerpt":"","text":"字节码指令运行 https://www.bilibili.com/video/BV1PJ411n7xZ?p=49 虚拟机栈虚拟机栈的出现背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 内存中的栈与堆 首先栈是运行时的单位，而堆是存储的单位。 即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里 虚拟机栈基本内容 Java虚拟机栈是什么？ Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，栈是线程私有的 12345678910111213141516171819public class StackTest &#123; public static void main(String[] args) &#123; StackTest test = new StackTest(); test.methodA(); &#125; public void methodA() &#123; int i = 10; int j = 20; methodB(); &#125; public void methodB()&#123; int k = 30; int m = 40; &#125;&#125; 虚拟机栈的生命周期 生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了 虚拟机栈的作用 主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。 局部变量，它是相比于成员变量来说的（或属性） 基本数据类型变量 VS 引用类型变量（类、数组、接口） ​ 虚拟机栈的特点 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。 JVM直接对Java栈的操作只有两个： 每个方法执行，伴随着进栈（入栈、压栈） 执行结束后的出栈工作 对于栈来说不存在垃圾回收问题 栈不需要GC，但是可能存在OOM 虚拟机栈的异常面试题：栈中可能出现的异常？ Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutofMemoryError 异常。 设置栈内存大小我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 Sets the thread stack size (in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, and g or G to indicate GB. The default value depends on the platform: Linux/x64 (64-bit): 1024 KB macOS (64-bit): 1024 KB Oracle Solaris/x64 (64-bit): 1024 KB Windows: The default value depends on virtual memory The following examples set the thread stack size to 1024 KB in different units: 123-Xss1m-Xss1024k-Xss1048576 12345678public class StackErrorTest &#123; private static int count = 1; public static void main(String[] args) &#123; System.out.println(count); count++; main(args); &#125;&#125; 没设置参数前 部分输出结果： 12345114041140511406Exception in thread &quot;main&quot; java.lang.StackOverflowError at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691) 说明栈在11406这个深度溢出了 12345247424752476Exception in thread &quot;main&quot; java.lang.StackOverflowError at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77) 栈的存储单位栈中存储什么？ 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。 栈运行原理 JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出（后进先出）原则 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class） 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。 Java方法有两种返回函数的方式。 一种是正常的函数返回，使用return指令。 另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。 但不管使用哪种方式，都会导致栈帧被弹出。 栈帧的内部结构每个栈帧中存储着： 局部变量表（Local Variables） 操作数栈（Operand Stack）（或表达式栈） 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息 并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的 局部变量表 局部变量表也被称之为局部变量数组或本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。 对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。 进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。 在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。 当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LocalVariablesTest &#123; private int count = 0; public static void main(String[] args) &#123; LocalVariablesTest test = new LocalVariablesTest(); int num = 10; test.test1(); &#125; //练习： public static void testStatic()&#123; LocalVariablesTest test = new LocalVariablesTest(); Date date = new Date(); int count = 10; System.out.println(count); //因为this变量不存在于当前方法的局部变量表中！！// System.out.println(this.count); &#125; //关于Slot的使用的理解 public LocalVariablesTest()&#123; this.count = 1; &#125; public void test1() &#123; Date date = new Date(); String name1 = &quot;atguigu.com&quot;; test2(date, name1); System.out.println(date + name1); &#125; public String test2(Date dateP, String name2) &#123; dateP = null; name2 = &quot;songhongkang&quot;; double weight = 130.5;//占据两个slot char gender = &#x27;男&#x27;; return dateP + name2; &#125; public void test3() &#123; this.count++; &#125; public void test4() &#123; int a = 0; &#123; int b = 0; b = a + 1; &#125; //变量c使用之前已经销毁的变量b占据的slot的位置 int c = a + 1; &#125;&#125; 看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。 部分详解为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了 1、0-15 也就是有16行字节码 2、方法异常信息表 3、Misc 4、行号表 ​ Java代码的行号和字节码指令行号的对应关系 5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数 1、图中圈的东西表示该局部变量的作用域 2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效 3、Length== 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。 4、Ljava/lang/String 前面的L表示引用类型 关于Slot的理解 参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。 局部变量表，最基本的存储单元是Slot（变量槽），局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。 在局部变量表里， 32位以内的类型只占用一个slot （包括returnAddress类型）， 64位的类型占用两个slot （1ong和double）。 byte、short、char在储存前辈转换为int，boolean也被转换为int，0表示false，非0表示true long和double则占据两个slot JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量） 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。（this也相当于一个变量） Slot代码示例this 存放在 index = 0 的位置： 123public void test3() &#123; this.count++;&#125; 局部变量表：this 存放在 index = 0 的位置 64位的类型（1ong和double）占用两个slot 1234567 public String test2(Date dateP, String name2) &#123; dateP = null; name2 = &quot;songhongkang&quot;; double weight = 130.5;//占据两个slot char gender = &#x27;男&#x27;; return dateP + name2;&#125; weight 为 double 类型，index 直接从 3 蹦到了 5 static 无法调用 this this 不存在与 static 方法的局部变量表中，所以无法调用 12345678 public static void testStatic()&#123; LocalVariablesTest test = new LocalVariablesTest(); Date date = new Date(); int count = 10; System.out.println(count); //因为this变量不存在于当前方法的局部变量表中！！// System.out.println(this.count); &#125; Slot的重复利用栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 123456789public void test4() &#123; int a = 0; &#123; int b = 0; b = a + 1; &#125; //变量c使用之前已经销毁的变量b占据的slot的位置 int c = a + 1;&#125; 静态变量与局部变量的对比12345678变量的分类：1、按照数据类型分：① 基本数据类型 ② 引用数据类型2、按照在类中声明的位置分： 2-1、成员变量：在使用前，都经历过默认初始化赋值 2-1-1、类变量: linking的prepare阶段：给类变量默认赋值 ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值 2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值 2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。 我们知道成员变量有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。 补充说明 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 操作数栈操作数栈的特点 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack） 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop） 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈， 比如：执行复制、交换、求和等操作 操作数栈的作用 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。 栈中的任何一个元素都是可以任意的Java数据类型 32bit的类型占用一个栈单位深度 64bit的类型占用两个栈单位深度 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。只不过操作数栈是用数组这个结构来实现的而已 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。 局部变量表就相当于食材 操作数栈就相当于做法步骤 操作数栈代码追踪123456789public void testAddOperation() &#123; //byte、short、char、boolean：都以int型来保存 byte i = 15; int j = 8; int k = i + j; // int m = 800;&#125; 对应字节码指令 123456789 0 bipush 15 2 istore_1 3 bipush 8 5 istore_2 6 iload_1 7 iload_2 8 iadd 9 istore_310 return 一步一步看流程1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈. 2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了. 解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this 3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中 4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作 iload_1：取出局部变量表中索引为1的数据入操作数栈 5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置 5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置 关于类型转换的说明 m改成800之后，byte存储不了，就成了short型，sipush 800 如果被调用的方法带有返回值，返回值入操作数栈 123456789101112public int getSum()&#123; int m = 10; int n = 20; int k = m + n; return k; &#125; public void testGetSum()&#123; //获取上一个栈桢返回的结果，并保存在操作数栈中 int i = getSum(); int j = 10; &#125; getSum() 方法字节码指令：最后带着个 ireturn testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值() ? testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值() 栈顶缓存技术栈顶缓存技术：Top Of Stack Cashing 前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。 寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多 动态链接（或指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invokedynamic指令 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 1234567891011121314151617public class DynamicLinkingTest &#123; int num = 10; public void methodA()&#123; System.out.println(&quot;methodA()....&quot;); &#125; public void methodB()&#123; System.out.println(&quot;methodB()....&quot;); methodA(); num++; &#125;&#125; 对应字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class Last modified 2020-11-10; size 712 bytes MD5 checksum e56913c945f897c7ee6c0a608629bca8 Compiled from &quot;DynamicLinkingTest.java&quot;public class com.atguigu.java1.DynamicLinkingTest minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #9.#23 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #8.#24 // com/atguigu/java1/DynamicLinkingTest.num:I #3 = Fieldref #25.#26 // java/lang/System.out:Ljava/io/PrintStream; #4 = String #27 // methodA().... #5 = Methodref #28.#29 // java/io/PrintStream.println:(Ljava/lang/String;)V #6 = String #30 // methodB().... #7 = Methodref #8.#31 // com/atguigu/java1/DynamicLinkingTest.methodA:()V #8 = Class #32 // com/atguigu/java1/DynamicLinkingTest #9 = Class #33 // java/lang/Object #10 = Utf8 num #11 = Utf8 I #12 = Utf8 &lt;init&gt; #13 = Utf8 ()V #14 = Utf8 Code #15 = Utf8 LineNumberTable #16 = Utf8 LocalVariableTable #17 = Utf8 this #18 = Utf8 Lcom/atguigu/java1/DynamicLinkingTest; #19 = Utf8 methodA #20 = Utf8 methodB #21 = Utf8 SourceFile #22 = Utf8 DynamicLinkingTest.java #23 = NameAndType #12:#13 // &quot;&lt;init&gt;&quot;:()V #24 = NameAndType #10:#11 // num:I #25 = Class #34 // java/lang/System #26 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #27 = Utf8 methodA().... #28 = Class #37 // java/io/PrintStream #29 = NameAndType #38:#39 // println:(Ljava/lang/String;)V #30 = Utf8 methodB().... #31 = NameAndType #19:#13 // methodA:()V #32 = Utf8 com/atguigu/java1/DynamicLinkingTest #33 = Utf8 java/lang/Object #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 println #39 = Utf8 (Ljava/lang/String;)V&#123; int num; descriptor: I flags: public com.atguigu.java1.DynamicLinkingTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: bipush 10 7: putfield #2 // Field num:I 10: return LineNumberTable: line 7: 0 line 9: 4 LocalVariableTable: Start Length Slot Name Signature 0 11 0 this Lcom/atguigu/java1/DynamicLinkingTest; public void methodA(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String methodA().... 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this Lcom/atguigu/java1/DynamicLinkingTest; public void methodB(); descriptor: ()V flags: ACC_PUBLIC Code: stack=3, locals=1, args_size=1 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #6 // String methodB().... 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: aload_0 9: invokevirtual #7 // Method methodA:()V 12: aload_0 13: dup 14: getfield #2 // Field num:I 17: iconst_1 18: iadd 19: putfield #2 // Field num:I 22: return LineNumberTable: line 16: 0 line 18: 8 line 20: 12 line 21: 22 LocalVariableTable: Start Length Slot Name Signature 0 23 0 this Lcom/atguigu/java1/DynamicLinkingTest;&#125;SourceFile: &quot;DynamicLinkingTest.java&quot; 1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？ 2、往上面翻，找到常量池的定义：#7 = Methodref #8.#31 先找 #8 ： #8 = Class #32 ：去找 #32 #32 = Utf8 com/atguigu/java1/DynamicLinkingTest 结论：通过 #8 我们找到了 DynamicLinkingTest 这个类 再来找 #31： #31 = NameAndType #19:#13 ：去找 #19 和 #13 #19 = Utf8 methodA ：方法名为 methodA #13 = Utf8 ()V ：方法没有形参，返回值为 void 3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用 4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等 为什么要用常量池呢？ 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。 常量池的作用：就是为了提供一些符号和常量，便于指令的识别 方法的调用静态链接与动态链接在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 静态链接： 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接 动态链接： 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。 早期绑定与晚期绑定 静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。 静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Animal &#123; public void eat() &#123; System.out.println(&quot;动物进食&quot;); &#125;&#125;interface Huntable &#123; void hunt();&#125;class Dog extends Animal implements Huntable &#123; @Override public void eat() &#123; System.out.println(&quot;狗吃骨头&quot;); &#125; @Override public void hunt() &#123; System.out.println(&quot;捕食耗子，多管闲事&quot;); &#125;&#125;class Cat extends Animal implements Huntable &#123; public Cat() &#123; super();//表现为：早期绑定 &#125; public Cat(String name) &#123; this();//表现为：早期绑定 &#125; @Override public void eat() &#123; super.eat();//表现为：早期绑定 System.out.println(&quot;猫吃鱼&quot;); &#125; @Override public void hunt() &#123; System.out.println(&quot;捕食耗子，天经地义&quot;); &#125;&#125;public class AnimalTest &#123; public void showAnimal(Animal animal) &#123; animal.eat();//表现为：晚期绑定 &#125; public void showHunt(Huntable h) &#123; h.hunt();//表现为：晚期绑定 &#125;&#125; 部分字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; public com.atguigu.java2.AnimalTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 54: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/atguigu/java2/AnimalTest; public void showAnimal(com.atguigu.java2.Animal); descriptor: (Lcom/atguigu/java2/Animal;)V flags: ACC_PUBLIC Code: stack=1, locals=2, args_size=2 0: aload_1 1: invokevirtual #2 // Method com/atguigu/java2/Animal.eat:()V 4: return LineNumberTable: line 56: 0 line 57: 4 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/atguigu/java2/AnimalTest; 0 5 1 animal Lcom/atguigu/java2/Animal; public void showHunt(com.atguigu.java2.Huntable); descriptor: (Lcom/atguigu/java2/Huntable;)V flags: ACC_PUBLIC Code: stack=1, locals=2, args_size=2 0: aload_1 1: invokeinterface #3, 1 // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V 6: return LineNumberTable: line 60: 0 line 61: 6 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/atguigu/java2/AnimalTest; 0 7 1 h Lcom/atguigu/java2/Huntable;&#125;SourceFile: &quot;AnimalTest.java&quot; invokevirtual 体现为晚期绑定 invokeinterface 也体现为晚期绑定 invokespecial 体现为早期绑定 多态与绑定 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。 Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 虚方法与非虚方法虚方法与非虚方法的区别 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。 其他方法称为虚方法。 子类对象的多态的使用前提： 类的继承关系 方法的重写 虚拟机中调用方法的指令 普通指令： invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令 invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Father &#123; public Father() &#123; System.out.println(&quot;father的构造器&quot;); &#125; public static void showStatic(String str) &#123; System.out.println(&quot;father &quot; + str); &#125; public final void showFinal() &#123; System.out.println(&quot;father show final&quot;); &#125; public void showCommon() &#123; System.out.println(&quot;father 普通方法&quot;); &#125;&#125;public class Son extends Father &#123; public Son() &#123; //invokespecial super(); &#125; public Son(int age) &#123; //invokespecial this(); &#125; //不是重写的父类的静态方法，因为静态方法不能被重写！ public static void showStatic(String str) &#123; System.out.println(&quot;son &quot; + str); &#125; private void showPrivate(String str) &#123; System.out.println(&quot;son private&quot; + str); &#125; public void show() &#123; //invokestatic showStatic(&quot;atguigu.com&quot;); //invokestatic super.showStatic(&quot;good!&quot;); //invokespecial showPrivate(&quot;hello!&quot;); //invokespecial super.showCommon(); //invokevirtual showFinal();//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。 //虚方法如下： /* invokevirtual 你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也 会认为)，所以编译期间确定不下来，就是虚方法。 */ showCommon(); info(); MethodInterface in = null; //invokeinterface in.methodA(); &#125; public void info() &#123; &#125; public void display(Father f) &#123; f.showCommon(); &#125; public static void main(String[] args) &#123; Son so = new Son(); so.show(); &#125;&#125;interface MethodInterface &#123; void methodA();&#125; Son 类中 show() 方法的字节码指令如下 关于 invokedynamic 指令 JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。 Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。 123456789101112131415161718192021222324@FunctionalInterfaceinterface Func &#123; public boolean func(String str);&#125;public class Lambda &#123; public void lambda(Func func) &#123; return; &#125; public static void main(String[] args) &#123; Lambda lambda = new Lambda(); Func func = s -&gt; &#123; return true; &#125;; lambda.lambda(func); lambda.lambda(s -&gt; &#123; return true; &#125;); &#125;&#125; 动态语言和静态语言 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。 说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。 Java：String info = “mogu blog”; (Java是静态类型语言的，会先编译就进行类型检查) JS：var name = “shkstart”; var name = 10; （运行时才进行检查） 1Python: info = 130.5 (运行时才检查) Java语言中方法重写的本质 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。 如果通过则返回这个方法的直接引用，查找过程结束 如果不通过，则返回java.lang.IllegalAccessError 异常 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 上面这个过程称为动态分派 IllegalAccessError介绍 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲 虚方法表 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。 例子1 如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找 1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。 2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。 方法返回地址 在一些帖子里，方法返回地址、动态链接、一些附加信息 也叫做帧数据区 存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式： 正常执行完成 出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 方法退出的两种方式 当一个方法开始执行后，只有两种方式可以退出这个方法， 正常退出： 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口； 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。 在字节码指令中，返回指令包含： ireturn：当返回值是boolean，byte，char，short和int类型时使用 lreturn：Long类型 freturn：Float类型 dreturn：Double类型 areturn：引用类型 return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法 异常退出： 在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。 方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 一些附加信息栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。 栈相关面试题举例栈溢出的情况？SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM 调整栈大小，就能保证不出现溢出么？不能保证不溢出，只能保证SOF出现的几率小 分配的栈内存越大越好么？不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的 垃圾回收是否涉及到虚拟机栈？方法中定义的局部变量是否线程安全？具体问题具体分析 如果只有一个线程才可以操作此数据，则必是线程安全的。 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 具体问题具体分析： ? 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 面试题： * 方法中定义的局部变量是否线程安全？具体情况具体分析 * * 何为线程安全？ * 如果只有一个线程才可以操作此数据，则必是线程安全的。 * 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 */public class StringBuilderTest &#123; int num = 10; //s1的声明方式是线程安全的（只在方法内部用了） public static void method1()&#123; //StringBuilder:线程不安全 StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;); s1.append(&quot;b&quot;); //... &#125; //sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作） public static void method2(StringBuilder sBuilder)&#123; sBuilder.append(&quot;a&quot;); sBuilder.append(&quot;b&quot;); //... &#125; //s1的操作：是线程不安全的（有返回值，可能被其它线程操作） public static StringBuilder method3()&#123; StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;); s1.append(&quot;b&quot;); return s1; &#125; //s1的操作：是线程安全的（s1自己消亡了，最后返回的智商s1.toString的一个新对象） public static String method4()&#123; StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;); s1.append(&quot;b&quot;); return s1.toString(); &#125; public static void main(String[] args) &#123; StringBuilder s = new StringBuilder(); new Thread(() -&gt; &#123; s.append(&quot;a&quot;); s.append(&quot;b&quot;); &#125;).start(); method2(s); &#125;&#125; 引用传递 值传递https://segmentfault.com/a/1190000016773324","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"JVM_RUNTIME","slug":"JVM-RUNTIME","date":"2020-01-03T13:45:04.000Z","updated":"2021-08-19T11:11:44.009Z","comments":true,"path":"2020/01/03/JVM-RUNTIME/","link":"","permalink":"https://noteforme.github.io/2020/01/03/JVM-RUNTIME/","excerpt":"","text":"[运行时数据区概述及线程]前言本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段 当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区 运行时数据区结构运行时数据区与内存 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁 线程的内存空间 Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 灰色的为单独线程私有的，红色的为多个线程共享的。即： 线程独有：独立包括程序计数器、栈、本地方法栈 线程间共享：堆、堆外内存（永久代或元空间、代码缓存） Runtime类每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。 JVM 线程 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收 操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法 关于线程，并发可以看笔者的Java并发系列 JVM 系统线程 如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。 这些主要的后台系统线程在Hotspot JVM里主要是以下几个： 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持 编译线程：这种线程在运行时会将字节码编译成到本地代码 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理 程序计数器(PC寄存器)PC寄存器介绍官方文档网址：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。 PC寄存器的作用PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。 12345678910111213public class PCRegisterTest &#123; public static void main(String[] args) &#123; int i = 10; int j = 20; int k = i + j; String s = &quot;abc&quot;; System.out.println(i); System.out.println(k); &#125;&#125; 看字节码的方法：https://blog.csdn.net/21aspnet/article/details/88351875 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.class Last modified 2020-11-2; size 675 bytes MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3 Compiled from &quot;PCRegisterTest.java&quot;public class com.atguigu.java.PCRegisterTest minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = String #27 // abc #3 = Fieldref #28.#29 // java/lang/System.out:Ljava/io/PrintStream; #4 = Methodref #30.#31 // java/io/PrintStream.println:(I)V #5 = Class #32 // com/atguigu/java/PCRegisterTest #6 = Class #33 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/atguigu/java/PCRegisterTest; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 i #19 = Utf8 I #20 = Utf8 j #21 = Utf8 k #22 = Utf8 s #23 = Utf8 Ljava/lang/String; #24 = Utf8 SourceFile #25 = Utf8 PCRegisterTest.java #26 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #27 = Utf8 abc #28 = Class #34 // java/lang/System #29 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #30 = Class #37 // java/io/PrintStream #31 = NameAndType #38:#39 // println:(I)V #32 = Utf8 com/atguigu/java/PCRegisterTest #33 = Utf8 java/lang/Object #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 println #39 = Utf8 (I)V&#123; public com.atguigu.java.PCRegisterTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 7: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/atguigu/java/PCRegisterTest; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=5, args_size=1 0: bipush 10 2: istore_1 3: bipush 20 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: ldc #2 // String abc 12: astore 4 14: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 17: iload_1 18: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 21: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 24: iload_3 25: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 28: return LineNumberTable: line 10: 0 line 11: 3 line 12: 6 line 14: 10 line 15: 14 line 16: 21 line 18: 28 LocalVariableTable: Start Length Slot Name Signature 0 29 0 args [Ljava/lang/String; 3 26 1 i I 6 23 2 j I 10 19 3 k I 14 15 4 s Ljava/lang/String;&#125;SourceFile: &quot;PCRegisterTest.java&quot; 左边的数字代表指令地址（指令偏移），即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令 两个面试题使用PC寄存器存储字节码指令地址有什么用呢？或者问为什么使用 PC 寄存器来记录当前线程的执行地址呢？ 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设定为私有的？ 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 注意并行和并发的区别，笔者的并发系列有讲 CPU 时间片 CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"JVM_Overview","slug":"JVM-Overview","date":"2020-01-03T02:48:45.000Z","updated":"2022-06-12T03:17:58.630Z","comments":true,"path":"2020/01/03/JVM-Overview/","link":"","permalink":"https://noteforme.github.io/2020/01/03/JVM-Overview/","excerpt":"","text":"Mark word 虚拟机是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 JVM分类 https://www.zhihu.com/question/29265430/answer/43818804 元空间寸哪些数据? https://www.cnblogs.com/duanxz/p/3520829.html JVM整体结构 Java代码执行流程 ​ 详细图 JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别： 基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统； 避开了寄存器的分配难题：使用零地址指令方式分配。 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。 不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 花费更少的指令去完成一项操作。 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋 总结 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？ 栈 跨平台性 指令集小 指令多 执行性能比寄存器差 类加载过程1234567public class HelloLoader &#123; public static void main(String[] args) &#123; System.out.println(&quot;谢谢ClassLoader加载我....&quot;); System.out.println(&quot;你的大恩大德，我下辈子再报！&quot;); &#125;&#125; 它的加载过程是怎么样的呢? 执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader 加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main 加载失败则抛出异常 完整的流程图如下所示： 加载阶段加载： 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载class文件的方式： 从本地系统中直接加载 通过网络获取，典型场景：Web Applet 从zip压缩包中读取，成为日后jar、war格式的基础 运行时计算生成，使用最多的是：动态代理技术 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 链接阶段链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 举例 使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。 准备(Prepare) 为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中 代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1 12345678public class HelloApp &#123; private static int a = 1;//prepare：a = 0 ---&gt; initial : a = 1 public static void main(String[] args) &#123; System.out.println(a); &#125;&#125; 解析(Resolve) 将常量池内的符号引用转换为直接引用的过程 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等 符号引用 反编译 class 文件后可以查看符号引用 初始化阶段类的初始化时机 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName(“com.atguigu.Test”)） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法） clinit() 初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法 &lt;clinit&gt;()方法中的指令按语句在源文件中出现的顺序执行 &lt;clinit&gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()） 若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕 虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁 IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度 5说明若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕 如上代码，加载流程如下： 首先，执行 main() 方法需要加载 ClinitTest1 类 获取 Son.B 静态变量，需要加载 Son 类 Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载 6说明虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁 1234567891011121314151617181920212223242526public class DeadThreadTest &#123; public static void main(String[] args) &#123; Runnable r = () -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;开始&quot;); DeadThread dead = new DeadThread(); System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); &#125;; Thread t1 = new Thread(r,&quot;线程1&quot;); Thread t2 = new Thread(r,&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125;class DeadThread&#123; static&#123; if(true)&#123; System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;); while(true)&#123; &#125; &#125; &#125;&#125; 12345线程2开始线程1开始线程2初始化当前类&#x2F;然后程序卡死了 程序卡死，分析原因： 两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环 先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放 所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次） 类加载器的分类概述 JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader） 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示 1234567891011121314151617181920212223242526public class ClassLoaderTest &#123; public static void main(String[] args) &#123; //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //获取其上层：扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d //获取其上层：获取不到引导类加载器 ClassLoader bootstrapClassLoader = extClassLoader.getParent(); System.out.println(bootstrapClassLoader);//null //对于用户自定义类来说：默认使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。 ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(classLoader1);//null &#125;&#125; 我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，因为引导类加载器右 C/C++ 语言，我们获取不到 两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明系统类加载器是全局唯一的 双亲委派机制双亲委派机制原理ava虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常 双亲委派机制代码演示举例11、我们自己建立一个 java.lang.String 类，写上 static 代码块 123456public class String &#123; // static&#123; System.out.println(&quot;我是自定义的String类的静态代码块&quot;); &#125;&#125; 2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类 12345678910public class StringTest &#123; public static void main(String[] args) &#123; java.lang.String str = new java.lang.String(); System.out.println(&quot;hello,atguigu.com&quot;); StringTest test = new StringTest(); System.out.println(test.getClass().getClassLoader()); &#125;&#125; 12hello,atguigu.comsun.misc.Launcher$AppClassLoader@18b4aac2 程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。 把刚刚的类改一下 1234567891011package java.lang;public class String &#123; // static&#123; System.out.println(&quot;我是自定义的String类的静态代码块&quot;); &#125; //错误: 在类 java.lang.String 中找不到 main 方法 public static void main(String[] args) &#123; System.out.println(&quot;hello,String&quot;); &#125;&#125; 由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。 123456789package java.lang;public class ShkStart &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 1234567891011121314151617java.lang.SecurityException: Prohibited package name: java.lang at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662) at java.lang.ClassLoader.defineClass(ClassLoader.java:761) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) at java.net.URLClassLoader.access$100(URLClassLoader.java:73) at java.net.URLClassLoader$1.run(URLClassLoader.java:368) at java.net.URLClassLoader$1.run(URLClassLoader.java:362) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:361) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)Error: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; Process finished with exit code 1 即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制 举例3当我们加载jdbc.jar 用于实现数据库连接的时候 我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api 然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了 具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】 第三方的jar包中的类属于系统类加载器来加载 从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载 双亲委派机制优势通过上面的例子，我们可以知道，双亲机制可以 避免类的重复加载 保护程序安全，防止核心API被随意篡改 自定义类：自定义java.lang.String 没有被加载。 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类） 沙箱安全机制 自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。 这样可以保证对java核心源代码的保护，这就是沙箱安全机制。 其他如何判断两个class对象是否相同？在JVM中表示两个class对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的 对类加载器的引用 JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲） https://youthlql.gitee.io/javayouth/#/?id=java","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"}]},{"title":"AnimPropertyView","slug":"AnimPropertyView","date":"2019-12-29T14:23:37.000Z","updated":"2021-08-19T11:11:43.546Z","comments":true,"path":"2019/12/29/AnimPropertyView/","link":"","permalink":"https://noteforme.github.io/2019/12/29/AnimPropertyView/","excerpt":"","text":"估值器（TypeEvaluator）设置动画 如何从初始值 过渡到 结束值 的逻辑 插值器（Interpolator）决定 值 的变化模式（匀速、加速） 估值器（TypeEvaluator）决定 值 的具体变化数值 ValueAnimator实现原理 : 通过不断控制 值的变化， 再不断赋值给对象的属性，从而实现动画的效果。 从上面原理可以看出：ValueAnimator类中有3个重要方法： ValueAnimator.ofInt（int values） ValueAnimator.ofFloat（float values） ValueAnimator.ofObject（int values） ValueAnimator.ofInt（int values）将初始值 以整型数值的形式 过渡到结束值 即估值器是整型估值器 - IntEvaluator 模板代码实际开发中，建议使用Java代码实现属性动画：因为很多时候属性的起始值是无法提前确定的（无法使用XML设置），这就需要在Java代码里动态获取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 步骤1：设置动画属性的初始值 &amp; 结束值ValueAnimator anim = ValueAnimator.ofInt(0, 3); // ofInt（）作用有两个 // 1. 创建动画实例 // 2. 将传入的多个Int参数进行平滑过渡:此处传入0和1,表示将值从0平滑过渡到1 // 如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推 // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置，即默认设置了如何从初始值 过渡到 结束值 // 关于自定义插值器我将在下节进行讲解 // 下面看看ofInt()的源码分析 -&gt;&gt;关注1 // 步骤2：设置动画的播放各种属性 anim.setDuration(500); // 设置动画运行的时长 anim.setStartDelay(500); // 设置动画延迟播放时间 anim.setRepeatCount(0); // 设置动画重复播放次数 = 重放次数+1 // 动画播放次数 = infinite时,动画无限重复 anim.setRepeatMode(ValueAnimator.RESTART); // 设置重复播放动画模式 // ValueAnimator.RESTART(默认):正序重放 // ValueAnimator.REVERSE:倒序回放 // 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器 // 设置 值的更新监听器 // 即：值每次改变、变化一次,该方法就会被调用一次 anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int currentValue = (Integer) animation.getAnimatedValue(); // 获得改变后的值 System.out.println(currentValue); // 输出改变后的值 // 步骤4：将改变后的值赋给对象的属性值，下面会详细说明 View.setproperty（currentValue）； // 步骤5：刷新视图，即重新绘制，从而实现动画效果 View.requestLayout(); &#125; &#125;); anim.start(); // 启动动画 &#125;// 关注1：ofInt（）源码分析 public static ValueAnimator ofInt(int... values) &#123; // 允许传入一个或多个Int参数 // 1. 输入一个的情况（如a）：从0过渡到a； // 2. 输入多个的情况（如a，b，c）：先从a平滑过渡到b，再从b平滑过渡到C ValueAnimator anim = new ValueAnimator(); // 创建动画对象 anim.setIntValues(values); // 将传入的值赋值给动画对象 return anim; &#125; XML设置123456789101112131415// ValueAnimator采用&lt;animator&gt; 标签&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:valueFrom=&quot;0&quot; // 初始值 android:valueTo=&quot;100&quot; // 结束值 android:valueType=&quot;intType&quot; // 变化值类型 ：floatType &amp; intType android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲/&gt; 12345678Animator animator = AnimatorInflater.loadAnimator(context, R.animator.set_animation); // 载入XML动画animator.setTarget(view); // 设置动画对象animator.start(); // 启动动画 实战按钮的宽度从 200px 放大到 500px 123456&lt;Button android:id=&quot;@+id/bt_value_anim&quot; android:layout_width=&quot;200px&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;动画&quot; /&gt; ？代码设置初始值 12345678910111213141516171819202122232425// 步骤1：设置属性数值的初始值(此处在xml中200) &amp; 结束值(600)val valueAnimator = ValueAnimator.ofInt(bt_value_anim.layoutParams.width, 600) // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置 // 即默认设置了如何从初始值200 过渡到 结束值500// 步骤2：设置动画的播放各种属性valueAnimator.duration = 2000// 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器 // 设置 值的更新监听器 // 即：值每次改变、变化一次,该方法就会被调用一次valueAnimator.addUpdateListener &#123; val currentValue = it.animatedValue // 获得每次变化后的属性值 Timber.d(&quot;currentValue $currentValue&quot;) // 每次值变化时，将值手动赋值给对象的属性 bt_value_anim.layoutParams.width = currentValue as Int // 即将每次变化后的值 赋 给按钮的宽度，这样就实现了按钮宽度属性的动态变化 // 步骤4：刷新视图，即重新绘制，从而实现动画效果 bt_value_anim.requestLayout()&#125;valueAnimator.start() 浮点型：ValueAnimator.oFloat（）将初始值 以浮点型数值的形式 过渡到结束值 ValueAnimator.oFloat（）采用默认的浮点型估值器 (FloatEvaluator) ValueAnimator.ofInt（）采用默认的整型估值器（IntEvaluator） 在使用上完全没有区别 ValueAnimator.ofObject（）将初始值 以对象的形式 过渡到结束值 即通过操作 对象 实现动画效果 实战可以看到 ValueAnimator.ofObject（）的本质还是操作 值,将多个值封装到一个对象里的方式，同时对多个值一起操作 PointEvaluator 12345678910111213141516class PointEvaluator : TypeEvaluator&lt;Point&gt; &#123; override fun evaluate(fraction: Float, startValue: Point?, endValue: Point?): Point &#123; // 将动画初始值startValue 和 动画结束值endValue 强制类型转换成Point对象 val startPoint = startValue val endPoint = endValue // 根据fraction来计算当前动画的x和y的值 val x = startPoint!!.x + fraction * (endPoint!!.x - startPoint!!.x) val y = startPoint!!.y + fraction * (endPoint!!.y - startPoint!!.y) // 将计算后的坐标封装到一个新的Point对象中并返回 val point = Point(x,y) return point &#125;&#125; Point 1class Point(val x: Float, val y: Float) MyView 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class MyView : View &#123; constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) // 设置需要用到的变量 val RADIUS = 70f // 圆的半径 = 70 private var currentPoint // 当前点坐标 : Point? = null val mPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply &#123; color = Color.BLUE &#125; init &#123; &#125; override fun onDraw(canvas: Canvas?) &#123; // 如果当前点坐标为空(即第一次执行) if (currentPoint == null) &#123; currentPoint = Point(RADIUS, RADIUS) val x = currentPoint?.x val y = currentPoint?.y if (x != null &amp;&amp; y != null) &#123; canvas?.drawCircle(x, y, RADIUS, mPaint) &#125; // (重点关注)将属性动画作用到View中 // 步骤1:创建初始动画时的对象点 &amp; 结束动画时的对象点 // (重点关注)将属性动画作用到View中 // 步骤1:创建初始动画时的对象点 &amp; 结束动画时的对象点 val startPoint = Point(RADIUS, RADIUS) // 初始点为圆心(70,70) val endPoint = Point(700f, 1000f) // 结束点为(700,1000) // 步骤2:创建动画对象 &amp; 设置初始值 和 结束值 val anim = ValueAnimator.ofObject(PointEvaluator(), startPoint, endPoint) // 参数说明 // 参数1：TypeEvaluator 类型参数 - 使用自定义的PointEvaluator(实现了TypeEvaluator接口) // 参数2：初始动画的对象点 // 参数3：结束动画的对象点 // 步骤3：设置动画参数 anim.duration = 5000 // 设置 值的更新监听器 // 即每当坐标值（Point对象）更新一次,该方法就会被调用一次 anim.addUpdateListener &#123; currentPoint = it.animatedValue as Point? // 将每次变化后的坐标值（估值器PointEvaluator中evaluate（）返回的Piont对象值）到当前坐标值对象（currentPoint） // 从而更新当前坐标值（currentPoint） Timber.d(&quot;currentPoint==null $&#123;currentPoint?.x&#125; $&#123;currentPoint?.y&#125;&quot;) // 步骤4：每次赋值后就重新绘制，从而实现动画效果 invalidate() &#125; anim.start() &#125; else &#123; //除了第一次，后面每次都根据addUpdateListener回调，在这画圆 // 所以坐标值每改变一次,就会调用onDraw()一次,就会画一次圆,从而实现动画效果 // 在该点画一个圆:圆心 = (30,30),半径 = 30 val x = currentPoint!!.x val y = currentPoint!!.y canvas?.drawCircle(x, y, RADIUS, mPaint) Timber.d(&quot;currentPoint currentPoint!=null $&#123;currentPoint?.x&#125; $&#123;currentPoint?.y&#125;&quot;) &#125; &#125;&#125; 插值器xml设置当在XML文件设置插值器时，只需传入对应的插值器资源ID即可 主要是设置插值器属性android:interpolator 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/overshoot_interpolator&quot; // 通过资源ID设置插值器 android:duration=&quot;3000&quot; android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;2&quot; android:toYScale=&quot;2&quot; /&gt;&gt; 代码设置当在Java代码设置插值器时，只需创建对应的插值器对象即可 123456789101112131415Button mButton = (Button) findViewById(R.id.Button);// 步骤1:创建 需要设置动画的 视图ViewAnimation alphaAnimation = new AlphaAnimation(1,0);// 步骤2：创建透明度动画的对象 &amp; 设置动画效果alphaAnimation.setDuration(3000);Interpolator overshootInterpolator = new OvershootInterpolator();// 步骤3：创建对应的插值器类对象alphaAnimation.setInterpolator(overshootInterpolator);// 步骤4：给动画设置插值器mButton.startAnimation(alphaAnimation);// 步骤5：播放动画 系统内置插值器![](AnimPropertyView/Screen Shot 2021-02-01 at 10.57.34 AM.png) 自定义插值器​ 根据动画的进度（0%-100%）计算出当前属性值改变的百分比 ​ 自定义插值器需要实现 Interpolator / TimeInterpolator接口 &amp; 复写getInterpolation（） 补间动画 实现 Interpolator接口；属性动画实现TimeInterpolator接口 TimeInterpolator接口是属性动画中新增的，用于兼容Interpolator接口，这使得所有过去的Interpolator实现类都可以直接在属性动画使用 12345678910111213141516171819202122// Interpolator接口 tween动画public interface Interpolator &#123; // 内部只有一个方法 float getInterpolation(float input) &#123; // 参数说明 // input值值变化范围是0-1，且随着动画进度（0% - 100% ）均匀变化 // 即动画开始时，input值 = 0；动画结束时input = 1 // 而中间的值则是随着动画的进度（0% - 100%）在0到1之间均匀增加 ...// 插值器的计算逻辑 return xxx； // 返回的值就是用于估值器继续计算的fraction值，下面会详细说明 &#125; // TimeInterpolator接口 属性动画// 同上public interface TimeInterpolator &#123; float getInterpolation(float input); &#125; 匀速插值器 12345678910111213141516171819202122232425262728// 匀速差值器：LinearInterpolator@HasNativeInterpolator public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return input; // 没有对input值进行任何逻辑处理，直接返回 // 即input值 = fraction值 // 因为input值是匀速增加的，因此fraction值也是匀速增加的，所以动画的运动情况也是匀速的，所以是匀速插值器 &#125; // 先加速再减速 差值器：AccelerateDecelerateInterpolator@HasNativeInterpolator public class AccelerateDecelerateInterpolator implements Interpolator, NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; // input的运算逻辑如下： // 使用了余弦函数，因input的取值范围是0到1，那么cos函数中的取值范围就是π到2π。 // 而cos(π)的结果是-1，cos(2π)的结果是1 // 所以该值除以2加上0.5后，getInterpolation()方法最终返回的结果值还是在0到1之间。只不过经过了余弦运算之后，最终的结果不再是匀速增加的了，而是经历了一个先加速后减速的过程 // 所以最终，fraction值 = 运算后的值 = 先加速后减速 // 所以该差值器是先加速再减速的 &#125; &#125; 先加速再减速 插值器：AccelerateDecelerateInterpolator 123456789101112131415// 先加速再减速 差值器：AccelerateDecelerateInterpolator@HasNativeInterpolator public class AccelerateDecelerateInterpolator implements Interpolator, NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; // input的运算逻辑如下： // 使用了余弦函数，因input的取值范围是0到1，那么cos函数中的取值范围就是π到2π。 // 而cos(π)的结果是-1，cos(2π)的结果是1 // 所以该值除以2加上0.5后，getInterpolation()方法最终返回的结果值还是在0到1之间。只不过经过了余弦运算之后，最终的结果不再是匀速增加的了，而是经历了一个先加速后减速的过程 // 所以最终，fraction值 = 运算后的值 = 先加速后减速 // 所以该差值器是先加速再减速的 &#125; &#125; 对input值 根据动画的进度（0%-100%）通过逻辑计算 计算出当前属性值改变的百分比 实战 DecelerateAccelerateInterpolator 12345678910111213141516class DecelerateAccelerateInterpolator : TimeInterpolator &#123; override fun getInterpolation(input: Float): Float &#123; var result: Float = 0.0f if (input &lt;= 0.5) &#123; result = Math.sin(Math.PI * input).toFloat() / 2 // 使用正弦函数来实现先减速后加速的功能，逻辑如下： // 因为正弦函数初始弧度变化值非常大，刚好和余弦函数是相反的 // 随着弧度的增加，正弦函数的变化值也会逐渐变小，这样也就实现了减速的效果。 // 当弧度大于π/2之后，整个过程相反了过来，现在正弦函数的弧度变化值非常小，渐渐随着弧度继续增加，变化值越来越大，弧度到π时结束，这样从0过度到π，也就实现了先减速后加速的效果 &#125; else &#123; result= (2 - Math.sin(Math.PI * input)).toFloat() / 2 &#125; return result // 返回的result值 = 随着动画进度呈先减速后加速的变化趋势 &#125;&#125; InterpolatorActivity 123456val curTranslationX = bt_anim_interpolator.translationXval animator = ObjectAnimator.ofFloat(bt_anim_interpolator, &quot;translationX&quot;, curTranslationX, 300f, curTranslationX)animator.duration = 5000animator.interpolator = DecelerateAccelerateInterpolator()animator.start() ObjectAnimator与 ValueAnimator类的区别 ValueAnimator 类是先改变值，然后 手动赋值 给对象的属性从而实现动画；是 间接 对对象属性进行操作； ObjectAnimator 类是先改变值，然后 自动赋值 给对象的属性从而实现动画；是 直接 对对象属性进行操作 估值器（TypeEvaluator) 和插值器 插值器（Interpolator）决定 值 的变化模式（匀速、加速） 估值器（TypeEvaluator）决定 值 的具体变化数值,设置动画从初始值过渡到结束值的逻辑。 https://blog.csdn.net/carson_ho/article/details/99619871 作者：Carson_Ho链接：https://www.jianshu.com/p/7c95342f4bc2 ​ https://www.jianshu.com/p/2f19fe1e3ca1 来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"anim","slug":"anim","permalink":"https://noteforme.github.io/categories/anim/"}],"tags":[]},{"title":"AnimationView","slug":"AnimationView","date":"2019-12-26T10:23:55.000Z","updated":"2021-08-19T11:11:43.675Z","comments":true,"path":"2019/12/26/AnimationView/","link":"","permalink":"https://noteforme.github.io/2019/12/26/AnimationView/","excerpt":"","text":"View Animation第一种就pass了，看下View Animation: You can use the view animation system to perform tweened animation on Views. Tween animation calculates the animation with information such as the start point, end point, size, rotation, and other common aspects of an animation. 这种动画可以在一个视图容器执行 位置、大小、旋转、透明度的变化，使用XML定义更具可读性 -set|-android:interpolator -&gt; 插值器，影响动画的速度 |-默认值 -&gt; @android:anim/accelerate_decelerate_interpolator|-android:shareInterpolator -&gt; 集合所有动画是否使用同一插值器|-android:fillAfter -&gt; 动画结束后View是否停留在结束的位置|-android:startOffset -&gt; 动画多少秒之后执行|-android:repeatMode -&gt; 重复的模式,默认为restart,即重头开始重新运行,reverse即从结束开始向前重新运行-TranslateAnimation -&gt; 移动View|- |-android:fillAfter -&gt; |-android:duration -&gt; 表示动画持续的时间 |-android:fromXDelta -&gt; 表示 x 的起始值 |-android:toXDelta -&gt; 表示 x 的结束值 |-android:fromYDelta -&gt; 表示 y 的起始值 |-android:toYDelta -&gt; 表示 y 的结束值-scaleAnimation -&gt; 放大或者缩小View|- |-android:duration -&gt; 表示动画持续的时间 |-android:fromXScale -&gt; 表示水平方向缩放的起始值 |-android:fromYScale -&gt; 表示竖直方向缩放的起始值 |-android:pivotX -&gt; 表示缩放中心点的 X 坐标 |-android:pivotY -&gt; 表示缩放中心点的 Y 坐标 |-android:toXScale -&gt; 表示水平方向缩放的结束值 |-android:toYScale -&gt; 表示竖直方向缩放的结束值-RotateAnimation -&gt; 旋转View|- |-android:duration -&gt; 表示动画持续的时间 |-android:fromDegrees -&gt; 旋转开始的角度 |-android:toDegrees -&gt; 旋转结束的角度 |-android:pivotX -&gt; 旋转中心点的 X 坐标 |-android:pivotY -&gt; 旋转中心点的 Y 坐标-AlphaAnimation -&gt; 改变View的透明度|- |-android:duration -&gt; 表示动画持续的时间 |-android:fromAlpha -&gt; 透明度的起始值 |-android:toAlpha -&gt; 透明度的结束值-自定义View动画 -&gt; (不会,待实践中学习) 1234private fun anim(resAnim:Int)&#123; val translateAnimation = AnimationUtils.loadAnimation(this,resAnim) textView5.startAnimation(translateAnimation)&#125; view_anim_translate.xml 12345678910111213141516// 以下参数是4种动画效果的公共属性,即都有的属性 android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲 // 以下参数是平移动画特有的属性 android:fromXDelta=&quot;0&quot; // 视图在水平方向x 移动的起始值 android:toXDelta=&quot;500&quot; // 视图在水平方向x 移动的结束值 android:fromYDelta=&quot;0&quot; // 视图在竖直方向y 移动的起始值 android:toYDelta=&quot;500&quot; // 视图在竖直方向y 移动的结束值 View_anim_translate.xml 12345678910111213141516171819202122232425262728293031&lt;!-- // 以下参数是4种动画效果的公共属性,即都有的属性 android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲 // 以下参数是缩放动画特有的属性 android:fromXScale=&quot;0.0&quot; // 动画在水平方向X的起始缩放倍数 // 0.0表示收缩到没有；1.0表示正常无伸缩 // 值小于1.0表示收缩；值大于1.0表示放大 android:toXScale=&quot;2&quot; //动画在水平方向X的结束缩放倍数 android:fromYScale=&quot;0.0&quot; //动画开始前在竖直方向Y的起始缩放倍数 android:toYScale=&quot;2&quot; //动画在竖直方向Y的结束缩放倍数 android:pivotX=&quot;50%&quot; // 缩放轴点的x坐标 android:pivotY=&quot;50%&quot; // 缩放轴点的y坐标 // 轴点 = 视图缩放的中心点 // pivotX pivotY,可取值为数字，百分比，或者百分比p // 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。 // 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。 // 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT // 两个50%表示动画从自身中间开始，具体如下图 android:pivotX=”50%” // 缩放轴点的x坐标 android:pivotY=”50%” // 缩放轴点的y坐标 这个拿掉看看效果 添加 pivotX pivotY Rotate 12345678910111213// 以下参数是旋转动画特有的属性 android:duration=&quot;1000&quot; android:fromDegrees=&quot;0&quot; // 动画开始时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针) android:toDegrees=&quot;270&quot; // 动画结束时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针) android:pivotX=&quot;50%&quot; // 旋转轴点的x坐标 android:pivotY=&quot;0&quot; // 旋转轴点的y坐标 // 轴点 = 视图缩放的中心点 // pivotX pivotY,可取值为数字，百分比，或者百分比p // 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。 // 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。 // 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT // 两个50%表示动画从自身中间开始，具体如下图 alpha 12345678910111213// 以下参数是4种动画效果的公共属性,即都有的属性android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms）android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为trueandroid:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为falseandroid:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为trueandroid:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲// 以下参数是透明度动画特有的属性android:fromAlpha=&quot;1.0&quot; // 动画开始时视图的透明度(取值范围: -1 ~ 1)android:toAlpha=&quot;0.0&quot;// 动画结束时视图的透明度(取值范围: -1 ~ 1) 组合动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;// 采用&lt; Set/&gt;标签&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;// 组合动画同样具备公共属性 android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲 // 组合动画独特的属性 android:shareinterpolator = “true” // 表示组合动画中的动画是否和集合共享同一个差值器 // 如果集合不指定插值器，那么子动画需要单独设置// 组合动画播放时是全部动画同时开始// 如果想不同动画不同时间开始就要使用android:startOffset属性来延迟单个动画播放时间// 设置旋转动画，语法同单个动画 &lt;rotate android:duration=&quot;1000&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt;// 设置平移动画，语法同单个动画 &lt;translate android:duration=&quot;10000&quot; android:startOffset = “1000”// 延迟该动画播放时间 android:fromXDelta=&quot;-50%p&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;50%p&quot; android:toYDelta=&quot;0&quot; /&gt;// 设置透明度动画，语法同单个动画 &lt;alpha android:startOffset=&quot;7000&quot; android:duration=&quot;3000&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot; /&gt;// 设置缩放动画，语法同单个动画 &lt;scale android:startOffset=&quot;4000&quot; android:duration=&quot;1000&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;0.5&quot; android:toYScale=&quot;0.5&quot; /&gt;// 特别注意：// 1. 在组合动画里scale缩放动画设置的repeatCount（重复播放）和fillBefore（播放完后，视图是否会停留在动画开始的状态）是无效的。// 2. 所以如果需要重复播放或者回到原位的话需要在set标签里设置// 3. 但是由于此处rotate旋转动画里已设置repeatCount为infinite，所以动画不会结束，也就看不到重播和回复原位&lt;/set&gt; 它是一个接一个播放，可以通过设置repeatCount 达到同时播放的目的 监听动画 Animation.addListener anim.addListener(new AnimatorListenerAdapter() 应用 Activity入场 activity_anim_enter.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration= &quot;3000&quot; android:fromXDelta=&quot;100%p&quot; android:toXDelta=&quot;0%p&quot;/&gt;&lt;/set&gt; activity_anim_exit.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration= &quot;3000&quot; android:fromXDelta=&quot;0%p&quot; android:toXDelta=&quot;-100%p&quot;/&gt;&lt;/set&gt; 视图组（ViewGroup）动画插值器https://www.jianshu.com/p/2f19fe1e3ca1 https://blog.csdn.net/carson_ho/article/details/72827747","categories":[{"name":"anim","slug":"anim","permalink":"https://noteforme.github.io/categories/anim/"}],"tags":[]},{"title":"AnimBitmaps","slug":"AnimBitmaps","date":"2019-12-25T07:38:00.000Z","updated":"2021-08-19T11:11:43.546Z","comments":true,"path":"2019/12/25/AnimBitmaps/","link":"","permalink":"https://noteforme.github.io/2019/12/25/AnimBitmaps/","excerpt":"","text":"Overviewhttps://developer.android.com/training/animation Animate drawable graphicsThe first option is to use an Animation Drawable. This allows you to specify several static drawable files that will be displayed one at a time to create an animation. The second option is to use an Animated Vector Drawable, which lets you animate the properties of a vector drawable. The XML file consists of &lt;animation=list&gt; 123456&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true&quot;&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust2&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust3&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; in which the animation is added to an ImageView and then animated when the screen is touched 12345678910111213private lateinit var rocketAnimation: AnimationDrawableoverride fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.main) val rocketImage = findViewById&lt;ImageView&gt;(R.id.rocket_image).apply &#123; setBackgroundResource(R.drawable.rocket_thrust) rocketAnimation = background as AnimationDrawable &#125; rocketImage.setOnClickListener(&#123; rocketAnimation.start() &#125;)&#125; It’s important to note that the start() method called on the AnimationDrawable cannot be called during the onCreate() method of your Activity, because the AnimationDrawable is not yet fully attached to the window. If you want to play the animation immediately, without requiring interaction, then you might want to call it from the onStart() method in your Activity, which will get called when Android makes the view visible on screen. AnimatedVectorDrawable","categories":[{"name":"anim","slug":"anim","permalink":"https://noteforme.github.io/categories/anim/"}],"tags":[]},{"title":"JCenterPublish","slug":"JCenterPublish","date":"2019-12-12T22:30:57.000Z","updated":"2021-08-19T11:11:43.981Z","comments":true,"path":"2019/12/13/JCenterPublish/","link":"","permalink":"https://noteforme.github.io/2019/12/13/JCenterPublish/","excerpt":"","text":"nexus sonatype 主要步骤按照这个操作 https://www.gcssloop.com/gebug/maven-private 注意： 密码不再是 admin admin 123了按照这个步骤 https://www.jianshu.com/p/fcb128e34c87 部署好一个平台后，sonatype-work复制过去，其他配置就不用再弄了，注意nexus-3.20.0-04-unix.tar.gz解压后也会有sonatype-work文件，可能会把之前的覆盖 运行 在命令行工具中输入启动命令： software/nexus-3.20.0-04-mac/nexus-3.20.0-04/bin 1./nexus start 如果一切顺利，在等待几十秒到一两分钟之后就可以查看我们的仓库了，如果出错了，可以使用 run 命令来查看具体的出错原因： 12# run 命令相当于 debug 模式，会输出所有的日志信息./nexus run 当然，Nexus 还有很多其他命令(例如:停止、重启、查看状态等)： 1./nexus &#123;start|stop|run|run-redirect|status|restart|force-reload&#125; 注意:windows启动是这样的 .\\nexus.exe /run 打包 在配置完善后同步一下项目，就可以打开 gradle 命令菜单看到多出来了3个命令，双击即可执行对应的命令： pack：打包项目 uploadToLocal：上传到本机仓库 uploadToPublic：上传到公网仓库 查看 http://localhost:8081 即可查看，如果修改了端口号，后面写对应的端口号即可。如果是运行在服务器上，则在其他电脑上输入http://&#123;服务器ip&#125;:&#123;port&#125; IP 和对应的端口号。如果运行成功，则会看到类似如下界面： Prepare Setting the JDK path 123Open ~/.bash_profile export JAVA_HOME=$(/usr/libexec/java_home)source ~/.bash_profile https://android.jlelse.eu/publishing-your-android-kotlin-or-java-library-to-jcenter-from-android-studio-1b24977fe450 maven center按照这个教程参考**TestMavenUp* 就差不多了 https://www.jianshu.com/p/6c1d2688ed2d/ https://www.jianshu.com/p/0629548ab5a4 可以把项目和jar放到同一个目录","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"TEST_UNIT","slug":"TEST-UNIT","date":"2019-11-17T12:49:14.000Z","updated":"2023-01-02T03:31:39.095Z","comments":true,"path":"2019/11/17/TEST-UNIT/","link":"","permalink":"https://noteforme.github.io/2019/11/17/TEST-UNIT/","excerpt":"","text":"Test Driven Development MainPrinciple:Write the test case before the implementation of the function (only for unit tests) Write the function signature Write the test cases for the function Write the function logic so the tests pass You should only have one assertion per test case. 123456789101112131415161718192021222324252627282930object RegistrationUtil &#123; private val exitingUsers = listOf(&quot;Peter&quot;,&quot;Carl&quot;) /** * the input is not valid if... * ...the username /password is empty * ...the username is already taken * ...the confirmed password is not the same as the real password * ...the pasword contains less than 2 digits */ fun validateRegistrationInput( userName: String, password: String, confirmedPassword: String ):Boolean&#123; if (userName.isEmpty()||password.isEmpty())&#123; return false &#125; if (userName in exitingUsers)&#123; return false &#125; if (password!=confirmedPassword)&#123; return false &#125; if (password.count&#123;it.isDigit()&#125;&lt;2)&#123; return false &#125; return true &#125;&#125; RegistrationUtilTest.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import com.google.common.truth.Truth.assertThatimport org.junit.Testclass RegistrationUtilTest&#123; @Test fun `empty username returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;&quot;, &quot;123&quot;, &quot;123&quot; ) assertThat(result).isFalse() &#125; @Test fun `valid username and correctly repeated password returns true`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;123&quot;, &quot;123&quot; ) assertThat(result).isTrue() &#125; @Test fun `username already exists returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Carl&quot;, &quot;123&quot;, &quot;123&quot; ) assertThat(result).isFalse() &#125; @Test fun `incorrectly confirmed password returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;123456&quot;, &quot;abcdefg&quot; ) assertThat(result).isFalse() &#125; @Test fun `empty password returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;&quot;, &quot;&quot; ) assertThat(result).isFalse() &#125; @Test fun `less than 2 digit password returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;abcdefg5&quot;, &quot;abcdefg5&quot; ) assertThat(result).isFalse() &#125;&#125; https://www.youtube.com/watch?v=W0ag98EDhGc&amp;list=PLQkwcJG4YTCSYJ13G4kVIJ10X5zisB2Lq&amp;index=3 https://developer.android.com/kotlin/coroutines/coroutines-best-practices","categories":[{"name":"TEST","slug":"TEST","permalink":"https://noteforme.github.io/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://noteforme.github.io/tags/Test/"}]},{"title":"SharedPreferences","slug":"SharedPreferences","date":"2019-11-06T06:50:12.000Z","updated":"2024-10-01T14:26:25.173Z","comments":true,"path":"2019/11/06/SharedPreferences/","link":"","permalink":"https://noteforme.github.io/2019/11/06/SharedPreferences/","excerpt":"","text":"Question问题1sp初始化 是读取所有的文件，还是指定文件的数据。 问题2sp读取文件后会把数据保存到map中，如果后续我pusString() 数据了，还需要重新读取文件吗. 启动变慢sp可能导致启动变慢 : 12345678910private void startLoadFromDisk() &#123; synchronized (mLock) &#123; mLoaded = false; &#125; new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123; public void run() &#123; loadFromDisk(); &#125; &#125;.start();&#125; mLock是异步操作 如果启动的时候，主线程读取，会导致启动变慢 12345678@Overridepublic boolean getBoolean(String key, boolean defValue) &#123; synchronized (mLock) &#123; awaitLoadedLocked(); Boolean v = (Boolean)mMap.get(key); return v != null ? v : defValue; &#125;&#125; 123456789101112131415161718@GuardedBy(&quot;mLock&quot;)private void awaitLoadedLocked() &#123; if (!mLoaded) &#123; // Raise an explicit StrictMode onReadFromDisk for this // thread, since the real read will be in a different // thread and otherwise ignored by StrictMode. BlockGuard.getThreadPolicy().onReadFromDisk(); &#125; while (!mLoaded) &#123; try &#123; mLock.wait(); &#125; catch (InterruptedException unused) &#123; &#125; &#125; if (mThrowable != null) &#123; throw new IllegalStateException(mThrowable); &#125;&#125; 所有 getXXX() 方法都是同步的，在主线程调用 get 方法，必须等待 SP 加载完毕，会导致主线程阻塞，下面的代码，我相信小伙伴们并不陌生。 commit vs applycommit ： 是同步 Apply : 异步 https://yjy239.github.io/2020/05/04/android-chong-xue-xi-lie-sharedpreferences-yuan-ma-jie-xi/ https://www.51cto.com/article/685850.html 解决SharedPreferences缺陷，微信MMKV原理分析 https://www.bilibili.com/video/BV1HF411b7H1?p=6&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1ih411a7KG?p=1 DataStoreSharedPreferences迁移 https://www.hi-dhl.com/2020/10/19/jetpack/11-DataStore/","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"SurfaceView","slug":"SurfaceView","date":"2019-11-05T04:42:57.000Z","updated":"2021-08-19T11:11:44.238Z","comments":true,"path":"2019/11/05/SurfaceView/","link":"","permalink":"https://noteforme.github.io/2019/11/05/SurfaceView/","excerpt":"","text":"我们知道View是通过刷新来重绘视图，系统通过发出VSSYNC信号来进行屏幕的重绘，刷新的时间间隔是16ms,如果我们可以在16ms以内将绘制工作完成，则没有任何问题，如果我们绘制过程逻辑很复杂，并且我们的界面更新还非常频繁，这时候就会造成界面的卡顿，影响用户体验，为此Android提供了SurfaceView来解决这一问题。 如果View需要频繁的刷新，或者刷新的数据量比较大，就需要使用SurfaceView 优势 View中刷新频繁，Ondraw()会频繁调用,onDraw方法执行的时间过程会掉帧，出现页面卡顿。SurfaceView使用双缓冲技术，提高了绘制速度，可以缓解这一现象。 SurfaceView可以在子线程更新UI,不会阻塞主线程，提高了响应速度. https://www.jianshu.com/p/b037249e6d31 啥是双缓冲技术?https://blog.csdn.net/guanguanboy/article/details/99715643 Android群英传 6.8 SurfaceView使用模板大部分绘图都按照模板来 SurfaceViewTemplate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable &#123; private SurfaceHolder mSurfaceHolder; //绘图的Canvas private Canvas mCanvas; //子线程标志位 private boolean mIsDrawing; public SurfaceViewTemplate(Context context) &#123; this(context, null); &#125; public SurfaceViewTemplate(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SurfaceViewTemplate(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; //开启子线程 new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public void run() &#123; while (mIsDrawing)&#123; draw(); &#125; &#125; //绘图逻辑 private void draw() &#123; try &#123; //获得当前Canva绘图对象，获取的还是继续上次的Canvas对象，而不是一个新的对象,因此之前的绘图都将被保留，如果需要擦除，则绘制前，通过drawColor()方法进行清屏操作. mCanvas = mSurfaceHolder.lockCanvas(); //绘制背景 mCanvas.drawColor(Color.WHITE); //绘图 &#125;catch (Exception e)&#123; &#125;finally &#123; if (mCanvas != null)&#123; //释放canvas对象并提交画布 mSurfaceHolder.unlockCanvasAndPost(mCanvas); &#125; &#125; &#125; /** * 初始化View */ private void initView()&#123; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); setFocusable(true); setKeepScreenOn(true); setFocusableInTouchMode(true); &#125;&#125; 正旋曲线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * https://www.jianshu.com/p/b037249e6d31 */public class SurfaceViewSinFun extends SurfaceView implements SurfaceHolder.Callback, Runnable &#123; private SurfaceHolder mSurfaceHolder; //绘图的Canvas private Canvas mCanvas; //子线程标志位 private boolean mIsDrawing; private int x = 0, y = 0; private Paint mPaint; private Path mPath; public SurfaceViewSinFun(Context context) &#123; this(context, null); &#125; public SurfaceViewSinFun(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SurfaceViewSinFun(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(5); mPath = new Path(); //路径起始点(0, 100) mPath.moveTo(0, 100); initView(); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public void run() &#123; long start = System.currentTimeMillis(); while (mIsDrawing)&#123; drawSomething(); x += 1; y = (int)(100 * Math.sin(2 * x * Math.PI / 180) + 400); //加入新的坐标点 mPath.lineTo(x, y); &#125; //控制绘制频率 long end = System.currentTimeMillis(); //50 - 100 if (end - start&lt;100)&#123; try &#123; Thread.sleep(100-(end-start)); //相当于绘制一次总的时间 100ms &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void drawSomething() &#123; try &#123; //获得canvas对象 mCanvas = mSurfaceHolder.lockCanvas(); //绘制背景 mCanvas.drawColor(Color.WHITE); //绘制路径 mCanvas.drawPath(mPath, mPaint); &#125;catch (Exception e)&#123; &#125;finally &#123; if (mCanvas != null)&#123; //释放canvas对象并提交画布 mSurfaceHolder.unlockCanvasAndPost(mCanvas); &#125; &#125; &#125; /** * 初始化View */ private void initView()&#123; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); setFocusable(true); setKeepScreenOn(true); setFocusableInTouchMode(true); &#125;&#125; 通过draw()方法所使用的逻辑时长来确定sleep的时长，这是一个非常通用的解决方案，每次绘制时间控制在100ms 画板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 画板 */class DrawingBoardView : SurfaceView, SurfaceHolder.Callback, Runnable &#123; private var mCanvas: Canvas? = null private var mSurfaceHolder: SurfaceHolder? = holder //子线程标志位 private var mIsDrawing = false private val x = 0 private var y: Int = 0 private var mPaint: Paint? = Paint().apply &#123; color = Color.BLACK style = Paint.Style.STROKE isAntiAlias = true strokeWidth = 5f &#125; private var mPath: Path? = null constructor(context: Context) : this(context, null) constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0) constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) &#123; &#125; init &#123; mSurfaceHolder?.addCallback(this) isFocusable = true keepScreenOn = true isFocusableInTouchMode = true mPath = Path() &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; mIsDrawing = true //开启子线程 Thread(this).start() &#125; override fun run() &#123; while (mIsDrawing) &#123; draw() &#125; &#125; private fun draw() &#123; try &#123; mCanvas = mSurfaceHolder?.lockCanvas() //SurfaceView背景 mCanvas?.drawColor(Color.WHITE) mPaint?.let &#123; mPath?.let &#123; it1 -&gt; mCanvas?.drawPath(it1, it) &#125; &#125; &#125; catch (e: Exception) &#123; &#125; finally &#123; mCanvas?.let &#123; mSurfaceHolder?.unlockCanvasAndPost(it) &#125; &#125; &#125; override fun onTouchEvent(event: MotionEvent?): Boolean &#123; val x = event?.x val y = event?.y when (event?.action) &#123; MotionEvent.ACTION_DOWN -&gt; x?.let &#123; if (y != null) &#123; mPath?.moveTo(it, y) &#125; &#125; MotionEvent.ACTION_MOVE -&gt; x?.let &#123; if (y != null) &#123; mPath?.lineTo(it, y) &#125; &#125; &#125; return true &#125;&#125;","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[]},{"title":"kotlin_begin","slug":"kotlin-begin","date":"2019-11-02T08:08:22.000Z","updated":"2023-01-02T03:31:39.211Z","comments":true,"path":"2019/11/02/kotlin-begin/","link":"","permalink":"https://noteforme.github.io/2019/11/02/kotlin-begin/","excerpt":"","text":"Kotlin in Action函数类型1val d: (String, Int) -&gt; Unit &#x2F;&#x2F; 函数类型 (String,Int) 接收参数 ， Unit 返回类型 kotlin lambda 1234567891011121314151617181920212223242526272829303132333435363738 val list &#x3D; listOf(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;, &quot;watermelon&quot;)&#x2F;&#x2F; val result &#x3D; list.maxBy &#123; it.length &#125; val lambda &#x3D; &#123; fruit: String -&gt; fruit.length &#125; &#x2F;&#x2F;推导1&#x2F;&#x2F; val result &#x3D; list.maxBy(lambda) &#x2F;&#x2F;推导2&#x2F;&#x2F; val result &#x3D; list.maxBy(&#123;fruit:String-&gt;&#x2F;&#x2F; fruit.length&#x2F;&#x2F; &#125;) &#x2F;&#x2F;推导3&#x2F;&#x2F; val result &#x3D; list.maxBy(&#123; fruit: String -&gt;&#x2F;&#x2F; fruit.length&#x2F;&#x2F; &#125;) &#x2F;&#x2F;如果一个函数， 他接收的最后一个参数是lambda表达式，那么这最后一个参数可以移到括号外面 &#x2F;&#x2F;推导4&#x2F;&#x2F; val result &#x3D; list.maxBy&#123; fruit: String -&gt;&#x2F;&#x2F; fruit.length &#x2F;&#x2F;如果一个函数 ,括号可以省略&#x2F;&#x2F; &#125; &#x2F;&#x2F;推导4&#x2F;&#x2F; val result &#x3D; list.maxBy&#123; fruit -&gt;&#x2F;&#x2F; fruit.length &#x2F;&#x2F;kotlin类型推导机制，参数类型可以省略&#x2F;&#x2F; &#125; &#x2F;&#x2F;推导5 val result &#x3D; list.maxBy&#123; it.length &#x2F;&#x2F; lmbda表达式只有一个参数，参数可以省略 改用it替代 &#125; println(result) 1234567891011121314fun &lt;T,R:Comparable&lt;R&gt;&gt; List&lt;T&gt;.findMax(block: (T) -&gt; R):T?&#123; if (isEmpty()) return null var maxElement &#x3D;get(0) &#x2F;&#x2F;获取List上下文的 第一个元素 var maxValue &#x3D; block(maxElement) &#x2F;&#x2F;block() 走到了 lambda方法中 for(element in this)&#123; var value &#x3D; block(element) if (value&gt; maxValue)&#123; maxElement &#x3D; element maxValue &#x3D; value &#125; &#125; return maxElement&#125; 1234&#x2F;&#x2F; val result &#x3D; list.findMax(lambda) val result &#x3D; list.findMax&#123;it.length&#125; println(result) https://www.bilibili.com/s/video/BV1Ut4y127xM 1.Java定义的接口 2.单抽象方法 Defining and calling functions 3.2.3 Getting rid of static utility classes: top-level functions and properties 12345public class JoinJava &#123; public static void johnToString()&#123; System.out.println(&quot;johnToString java&quot;); &#125;&#125; 123456package com.kotlin3fun johnToString()&#123; println(&quot;johnToString kotlin&quot;)&#125; 1234fun main(args: Array&lt;String&gt;) &#123; johnToString() JoinJava.johnToString()&#125; 3.3.3 extension functions 123456789101112131415161718fun String.lastChar() &#x3D; this.get(this.length-1)fun String.addName() &#x3D; this + &quot; john&quot; &#x2F;&#x2F;this 获取到String类的上下文val String.lastLetter: Char get()&#x3D; get(length-1) &#x2F;&#x2F;拓展属性fun String.hellowrod()&#123; println(&quot;hello world&quot;)&#125;fun String.cpaitalEnd():String&#123; if (this.isEmpty()) return &quot;&quot;; val charArray &#x3D; this.toCharArray() charArray[length-1] &#x3D; charArray[length-1].toUpperCase() return String(charArray)&#125; 1234567891011121314import com.kotlin3.t3_3_2.addNameimport com.kotlin3.t3_3_2.lastCharimport com.kotlin3.t3_3_2.lastLetterfun main(args: Array&lt;String&gt;) &#123; println(&quot;kotlin&quot;.lastChar()) println(&quot;kotlin&quot;.addName()) print(&quot;kotlin&quot;.lastLetter) &quot;&quot;.hellowrod() &#x2F;&#x2F;输出 hello world println(&quot;code&quot;.cpaitalEnd()) &#x2F;&#x2F; codE&#125; Conventions used 7.3 如果用 10..20构建一个普通的 区间(闭区间)，该区间则包括10到20的所有数字， 包括20。开区间10 until 20 包括从 10 到凹的数字，但不包括 20。矩形类通常定义成这样，它的底部和右 侧坐标不是矩形的一部分，因此在这里使用开区 间是合适的 。 Delegated - classs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;&#x2F;原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;xlh1191860939&#x2F;article&#x2F;details&#x2F;99641573interface ServiceApi &#123; fun login(userName: String, password: String)&#125;class Retrofit : ServiceApi &#123; override fun login(userName: String, password: String) &#123; println(&quot;login successfully.&quot;) &#125;&#125;&#x2F;** * 不用委托 *&#x2F;&#x2F;&#x2F;class RemoteRepository : ServiceApi, NewsApi &#123;&#x2F;&#x2F;&#x2F;&#x2F; private val serverApi: ServiceApi &#x3D; Retrofit()&#x2F;&#x2F; private val retrofitApi: NewsApi &#x3D; NewsApiImpl()&#x2F;&#x2F;&#x2F;&#x2F; override fun login(username: String, password: String) &#123;&#x2F;&#x2F; serverApi.login(username, password)&#x2F;&#x2F; &#125;&#x2F;&#x2F;&#x2F;&#x2F; override fun getNewsList() &#123;&#x2F;&#x2F; retrofitApi.getNewsList()&#x2F;&#x2F; &#125;&#x2F;&#x2F;&#125;&#x2F;* * 使用kotlin 委托用下面简化 *&#x2F;class RemoteRepository(): ServiceApi by Retrofit() , NewsApi by NewsApiImpl()interface NewsApi &#123; fun getNewsList()&#125;class NewsApiImpl : NewsApi &#123; override fun getNewsList() &#123; println(&quot;NewsApiImpl: getNewsList()&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val repository &#x3D; RemoteRepository() repository.login(&quot;David&quot;, &quot;123456&quot;) &#x2F;&#x2F;输出 login successfully. repository.getNewsList()&#125; 7.5.2 使用委托属性:惰性初始化和 “by lazy()” 123456789101112131415161718192021222324252627282930&#x2F;&#x2F;class Person(val name: String) &#123;&#x2F;&#x2F; private var _emails: List&lt;Email&gt;? &#x3D; null&#x2F;&#x2F; val emails: List&lt;Email&gt;&#x2F;&#x2F; get() &#123;&#x2F;&#x2F; if (_emails &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; _emails &#x3D; loadEmails(this)&#x2F;&#x2F; &#125;&#x2F;&#x2F; return _emails!!&#x2F;&#x2F; &#125;&#x2F;&#x2F;&#125;&#x2F;&#x2F;你有一个属性， emails，用来存储这个值， 而另一个 emails，用来提供对属性的读取访 问 。你需要使用两个属性 ，因为属性 具有不同的类型: emails 可以为空，而 emails 为非空。这种技术经常会使用到， 值得熟练掌握。class Person(val name:String)&#123; val emails by lazy&#123; loadEmails(this) &#125;&#125;fun loadEmails(person: Person): List&lt;Email&gt;? &#123; println (&quot;load emails for $&#123;person.name &#125;&quot; ) return listOf()&#125;fun main(args: Array&lt;String&gt;) &#123; val p &#x3D; Person(&quot;Alice&quot;) p.emails p.emails&#125; https://juejin.im/post/5e1288d86fb9a048217a19d9 https://zhuanlan.zhihu.com/p/65914552 委托Shareprefernce实战 简易版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class DelegateSharedPreferencesUtils &#123; object User : Delegates() &#123; override fun getSharedPreferencesName(): String &#x3D; this.javaClass.simpleName var name by string() var phone by long() &#125; abstract class Delegates &#123; private val preferences: SharedPreferences by lazy &#123; AppUtil.getApp().applicationContext.getSharedPreferences( getSharedPreferencesName(), Context.MODE_PRIVATE ) &#125; abstract fun getSharedPreferencesName(): String fun int(defaultValue: Int &#x3D; 0) &#x3D; object : ReadWriteProperty&lt;Any, Int&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Int &#123; return preferences.getInt(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Int) &#123; preferences.edit().putInt(property.name, value).apply() &#125; &#125; fun string(defaultValue: String? &#x3D; null) &#x3D; object : ReadWriteProperty&lt;Any, String?&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): String? &#123; return preferences.getString(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: String?) &#123; preferences.edit().putString(property.name, value).apply() &#125; &#125; fun long(defaultValue: Long &#x3D; 0L) &#x3D; object : ReadWriteProperty&lt;Any, Long&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Long &#123; return preferences.getLong(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Long) &#123; preferences.edit().putLong(property.name, value).apply() &#125; &#125; fun boolean(defaultValue: Boolean &#x3D; false) &#x3D; object : ReadWriteProperty&lt;Any, Boolean&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Boolean &#123; return preferences.getBoolean(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Boolean) &#123; preferences.edit().putBoolean(property.name, value).apply() &#125; &#125; fun float(defaultValue: Float &#x3D; 0.0f) &#x3D; object : ReadWriteProperty&lt;Any, Float&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Float &#123; return preferences.getFloat(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Float) &#123; preferences.edit().putFloat(property.name, value).apply() &#125; &#125; fun setString(defaultValue: Set&lt;String&gt;? &#x3D; null) &#x3D; object : ReadWriteProperty&lt;DelegateSharedPreferencesUtils, Set&lt;String&gt;?&gt; &#123; override fun getValue( thisRef: DelegateSharedPreferencesUtils, property: KProperty&lt;*&gt; ): Set&lt;String&gt;? &#123; return preferences.getStringSet(property.name, defaultValue) &#125; override fun setValue( thisRef: DelegateSharedPreferencesUtils, property: KProperty&lt;*&gt;, value: Set&lt;String&gt;? ) &#123; preferences.edit().putStringSet(property.name, value).apply() &#125; &#125; fun clearAll() &#123; preferences.edit().clear().apply() &#125; &#125;&#125; 12345DelegateSharedPreferencesUtils.User.name &#x3D; &quot;john&quot; &#x2F;&#x2F;存bt_get.setOnClickListener &#123; Timber.i(&quot;bt_get &quot;+DelegateSharedPreferencesUtils.User.name) &#x2F;&#x2F;取&#125; https://wazing.github.io/2019/05/23/kotlin-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0SharedPreferences/ Pro version 12345678910111213141516171819202122232425262728293031object SpUtil &#123; val SP by lazy &#123; AppUtil.getApp().getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) &#125; &#x2F;&#x2F;读 SP 存储项 fun &lt;T&gt; getValue(name: String, default: T): T &#x3D; with(SP) &#123; val res: Any &#x3D; when (default) &#123; is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) ?: &quot;&quot; is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw java.lang.IllegalArgumentException() &#125; res as T &#125; &#x2F;&#x2F;写 SP 存储项 fun &lt;T&gt; putValue(name: String, value: T) &#x3D; with(SP.edit()) &#123; when (value) &#123; is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;This type can&#39;t be saved into Preferences&quot;) &#125;.apply() &#125;&#125; 123456789101112131415161718192021222324252627&#x2F;** * @author xiaofei_dev * @desc 定义的 SP 存储项 *&#x2F;object SpBase&#123; &#x2F;&#x2F;SP 存储项的键 private const val CONTENT_SOMETHING &#x3D; &quot;CONTENT_SOMETHING&quot; &#x2F;&#x2F; 这就定义了一个 SP 存储项 &#x2F;&#x2F; 把 SP 的读写操作委托给 SPDelegates 类的一个实例（使用 by 关键字，by 是 Kotlin 语言层面的一个原语）， &#x2F;&#x2F; 此时访问 SpBase 的 contentSomething (你可以简单把其看成 Java 里的一个静态变量)属性即是在读取 SP 的存储项， &#x2F;&#x2F; 给 contentSomething 属性赋值即是写 SP 的操作，就这么简单 &#x2F;&#x2F; 这里用到的 SPDelegates 对象的 getValue 方法的 thisRef（见上文） 参数的类型正是外层的 SpBase var contentSomething: String by SPDelegates(CONTENT_SOMETHING, &quot;我是一个 SP 存储项，点击编辑我&quot;)&#125;class SPDelegates&lt;T&gt;(private val key: String, private val default: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return SpUtil.getValue(key, default) &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; SpUtil.putValue(key, value) &#125;&#125; 123456SpBase.contentSomething &#x3D; &quot;显示&quot; bt_get.setOnClickListener &#123; Timber.i(&quot;bt_get &quot;+SpBase.contentSomething)&#125; https://juejin.im/post/5e1bbf396fb9a02ffe702610 Operator FindViewById ​ Kotlin不用findViewById 注意在Fragmet中 需要在onViewCreated后使用 ​ https://blog.csdn.net/hust_twj/article/details/80290362 The reason why we ignore findviewbyId https://antonioleiva.com/kotlin-android-extensions/ ? 123456789&#x2F;&#x2F;kotlin:a?.foo()&#x2F;&#x2F;相当于java:if(a!&#x3D;null)&#123; a.foo();&#125;else&#123; null &#125; !! 123456789&#x2F;&#x2F;kotlin:a!!.foo()&#x2F;&#x2F;相当于java: if(a!&#x3D;null)&#123; a.foo();&#125;else&#123; throw new KotlinNullPointException();&#125; null or empty 1234data &#x3D; &quot; &quot; &#x2F;&#x2F; this is a text with blank space println(data.isNullOrBlank()?.toString()) &#x2F;&#x2F;trueprintln(data.isNullOrEmpty()?.toString()) &#x2F;&#x2F;false Elvis 1234val ss:String?&#x3D;nullprintln(ss ?: &quot;1&quot;)&gt;&gt; 1 https://developer.android.com/samples/?language=kotlin https://developer.android.com/kotlin/get-started https://www.jianshu.com/p/9fb9a1ab6c31 https://juejin.im/post/5aa64556f265da238c3a51d3 高级用法https://www.cnblogs.com/Jetictors/p/9225557.html byhttps://blog.csdn.net/wzgiceman/article/details/82689135 oprator https://zhuanlan.zhihu.com/p/26546977 kotlin细节https://juejin.im/post/5eeffd73f265da02ec0bc42e apply 123456val mDialPaint &#x3D; Paint(Paint.ANTI_ALIAS_FLAG)mDialPaint.apply &#123; color &#x3D; Color.parseColor(&quot;#3333333&quot;) strokeWidth &#x3D; arcWidth*8 textSize &#x3D; 65f &#125; coroutineshttps://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html https://juejin.im/post/5eea757a51882565ae5cb287 https://blog.csdn.net/xlh1191860939/article/details/99641573 Android kotlin计划ktx不是重心，重心在kotlin库如协程,paging3.0和compose https://www.bilibili.com/video/BV1fV411r7Lw string to list. list. to stringhttps://www.bezkoder.com/kotlin-convert-string-list/ constval 加不加const的区别 Const ‘val’ are only allowed on top level, in named objects, or in companion objects const只能在下面3种情况加 12345678910111213val name = &quot;jon&quot;const val age = &quot;joo&quot;object ConstantObject &#123; val name = &quot;jon&quot; const val age = &quot;joo&quot;&#125;class ConstantClass &#123; companion object &#123; val name = &quot;jon&quot; const val age = &quot;joo&quot; &#125;&#125; 上面三种 反编译后，都是下面这种形式 123456789@NotNullprivate static final String name = &quot;jon&quot;;@NotNullpublic static final String age = &quot;joo&quot;;@NotNullpublic static final String getName() &#123; return name;&#125; 不加const , private修饰，通过get获取， 会有一点点效率影响 https://www.cnblogs.com/liuliqianxiao/p/7253116.html const使用 二维数组two dimensional array 1val twoD = Array(4,&#123;intArray(3)&#125;) 4行3列,像下面的这样 这一题有2个注意点 退出条件是根据数组字母个数来的，也就树的高度。index条件 在遍历过程中是不用设置startIndex的，因为每次都是从0开始的新的3个字母. 这里可以理解输入字母个数树树的高度，里面for循环是控制宽度 随想录解法 https://www.bilibili.com/video/BV1yV4y1V7Ug/ 123456789101112131415161718192021222324252627282930313233 val result = ArrayList&lt;String&gt;() val pathStr = StringBuilder() fun letterCombinations(digits: String): List&lt;String&gt; &#123; val arrayList = arrayListOf( null, null, (&quot;abc&quot;), (&quot;def&quot;), (&quot;ghi&quot;), (&quot;jkl&quot;), (&quot;mno&quot;), (&quot;pqrs&quot;), (&quot;tuv&quot;), (&quot;wxyz&quot;) ) backTrack(arrayList, digits, 0) return result &#125; private fun backTrack(arrayList: ArrayList&lt;String?&gt;, digits: String, index: Int) &#123; if (index == digits.length) &#123; // index==输入个数，才能退出，因为字母还要处理 if (pathStr.isNotEmpty()) result.add(String(pathStr)) return &#125; val digit = digits[index] - &#x27;0&#x27; val item = arrayList[digit] ?: return for (i in item.indices) &#123; pathStr.append(item[i]) backTrack(arrayList, digits, index + 1) pathStr.deleteCharAt(pathStr.length - 1) &#125; &#125;&#125; index + 1会不会有问题，这里是没有的，如果输入”23”, 这里到了下一层==2进入方法后就要退出.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"}],"tags":[]},{"title":"room","slug":"room","date":"2019-09-20T02:22:52.000Z","updated":"2021-08-19T11:11:44.316Z","comments":true,"path":"2019/09/20/room/","link":"","permalink":"https://noteforme.github.io/2019/09/20/room/","excerpt":"","text":"https://developer.android.com/training/data-storage/room Room https://codelabs.developers.google.com/codelabs/android-room-with-a-view/#0 https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin/#0 kotlin need familiar [basic coroutines]( 数据库基本操作 主键 每个实体必须定义至少1个字段作为主键。即使只有1个字段，仍然需要用@PrimaryKey注解字段。此外，如果您想Room自动分配IDs给实体，则可以设置@PrimaryKey的autoGenerate属性。如果实体具有复合主键，则可以使用@Entity注解的primaryKeys属性 Entity 12345678@Entitypublic class BleData &#123; @PrimaryKey public int id; public long createDttm; public String bleParam;&#125; Dao https://developer.android.com/topic/libraries/architecture/room https://github.com/googlecodelabs/android-room-with-a-view https://codelabs.developers.google.com/codelabs/android-room-with-a-view/#0 https://github.com/googlecodelabs/android-room-with-a-view/tree/kotlin https://blog.skymxc.com/2018/04/15/Room/ https://www.jianshu.com/p/0ed8b17a199e 索引为什么加快访问速度 数据库迁移https://www.jianshu.com/p/72eeaded8913 https://blog.csdn.net/a254837127/article/details/84564545 https://developer.android.com/training/data-storage/room#java https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0)","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://noteforme.github.io/tags/DB/"}]},{"title":"RxJava02","slug":"RxJava02","date":"2019-09-19T03:50:24.000Z","updated":"2021-08-19T11:11:44.237Z","comments":true,"path":"2019/09/19/RxJava02/","link":"","permalink":"https://noteforme.github.io/2019/09/19/RxJava02/","excerpt":"","text":"操作符 retryWhen retryWhen是收到onError后触发是否要重订阅的询问，而repeatWhen是通过onComplete触发。 https://blog.csdn.net/qq_35599978/article/details/80290252 https://www.jianshu.com/p/d135f19e045c zip专用于合并事件，该合并不是连接（连接操作符后面会说），而是两两配对，也就意味着，最终配对出的 Observable 发射事件数目只和少的那个相同。 concat单一的把两个发射器连接成一个发射器 FlatMap它可以把一个发射器 Observable 通过某种方法转换为多个 Observables,flatMap 并不能保证事件的顺序 如果需要保证，需要用到我们下面要讲的 ConcatMap ConcatMapdoOnNext让订阅者在接收到数据之前可以做其他事情,获取到数据之前想先保存一下它 skip skip(2) 跳过count个数开始接收 take最多接收count个数据 just1Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) 简单的发射器依次调用 onNext() 方法 SingleSingle 只会接收一个参数，而 SingleObserver 只会调用 onError() 或者 onSuccess() distinct去重操作符，简单的作用就是去重 debouncedefer每次订阅都会创建一个新的 Observable，并且如果没有被订阅，就不会产生新的 last操作符仅取出可观察到的最后一个值 mergewindow按照实际划分窗口，将数据发送给不同的 Observable empty() &amp; never() &amp; error() empty() ： 直接发送 onComplete() 事件 never()：不发送任何事件 error()：发送 onError() 事件 https://www.jianshu.com/p/c08bfc58f4b6","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://noteforme.github.io/tags/RxJava/"}]},{"title":"ThreadStop","slug":"ThreadStop","date":"2019-08-30T02:00:40.000Z","updated":"2021-08-19T11:11:44.252Z","comments":true,"path":"2019/08/30/ThreadStop/","link":"","permalink":"https://noteforme.github.io/2019/08/30/ThreadStop/","excerpt":"","text":"https://segmentfault.com/a/1190000007961347 https://www.cnblogs.com/xingele0917/p/3994468.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"GreenDao","slug":"GreenDao","date":"2019-08-12T09:42:58.000Z","updated":"2021-08-19T11:11:43.904Z","comments":true,"path":"2019/08/12/GreenDao/","link":"","permalink":"https://noteforme.github.io/2019/08/12/GreenDao/","excerpt":"","text":"基本使用数据库定义 Bean schema：告知GreenDao当前实体属于哪个schema active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法 nameInDb：在数据库中使用的别名，默认使用的是实体的类名 indexes：定义索引，可以跨越多个列 createInDb：标记创建数据库表 基础属性注解 @Id：主键 Long 型，可以通过@Id(autoincrement = true)设置自增长@Property：设置一个非默认关系映射所对应的列名，默认是使用字段名，例如：@Property(nameInDb = “name”)@NotNull：设置数据库表当前列不能为空@Transient：添加此标记后不会生成数据库表的列 索引注解 @Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束@Unique：向数据库添加了一个唯一的约束 关系注解 @ToOne：定义与另一个实体（一个实体对象）的关系@ToMany：定义与多个实体对象的关系 https://blog.csdn.net/speedystone/article/details/72769793 @Convert 自定义类型123456public @interface Convert &#123; Class&lt;? extends PropertyConverter&gt; converter(); Class columnType(); //可以在DB中保留的列的类。这仅限于greenDAO原生支持的所有java类。&#125;@Convert(converter = NoteTypeConverter.class, columnType = String.class) //类型转换类，自定义的类型在数据库中存储的类型private NoteType type; //在保存到数据库时会将自定义的类型 NoteType 通过 NoteTypeConverter 转换为数据库支持的 String 类型。反之亦然 Basic123456789101112131415161718192021@Entitypublic class Student &#123; @Id(autoincrement = true) // id 递增 Long id; @Unique public int studentNo; public int age; //年龄 @Property(nameInDb = &quot;usePhone&quot;) //数据库中映射的字段就是 usePhone public String telPhone;//手机号 @Transient //数据库中不会创建对应的字段 String sex; //性别 String name;//姓名 String address;//家庭住址 String schoolName;//学校名字 String grade;//几年级 private boolean statue; insert insertData 12345678910111213141516171819for (int i = 0; i &lt; 4; i++) &#123; Student student = new Student(); student.setStudentNo(i); student.age = new Random().nextInt() + 10; student.telPhone = RandomValue.getTel(); student.setName(RandomValue.getChineseName()); if (i % 2 == 0) &#123; student.setSex(&quot;男&quot;); &#125; else &#123; student.setSex(&quot;女&quot;); &#125; if (i == 0) &#123; student.setStatue(true); &#125; student.setAddress(RandomValue.getRoad()); student.setSchoolName(RandomValue.getSchoolName()); long dsoi = studaoImpl.insert(student); Timber.i(&quot;insertData &quot; + dsoi);&#125; insertOrReplace 1234Student student = new Student();student.setStudentNo(1);student.setName(&quot;我改名了&quot;);long df = studaoImpl.insertOrReplace(student); updateData 1234Student student = new Student();student.setStudentNo(1);student.setName(&quot;我改名了&quot;);studaoImpl.update(student); delete 123Student student = new Student();student.setId(1l);studaoImpl.delete(student); deleteAll ​ studaoImpl.deleteAll(); query QueryAll 12List&lt;Student&gt; dd = studaoImpl.loadAll();studaoImpl.loadAll().forEach(current-&gt;Timber.i(current.toString())); // print student QueryLastState 123456List&lt;Student&gt; sList = studaoImpl.queryBuilder().limit(1).where(StudentDao.Properties.Statue.eq(false)).list();Timber.i(sList.toString());Student student = sList.get(0);student.setStatue(true);studaoImpl.update(student);sList = studaoImpl.queryBuilder().limit(1).where(StudentDao.Properties.Statue.eq(false)).list(); oneToOne1234567@Entitypublic class Person &#123; @Id(autoincrement = true) private long pid; private String name; private int age;&#125; 123456789@Entitypublic class CreditCard &#123; @Id(autoincrement = true) private long cid; private long pid; //idcard和person是一对一关系，外键为personId @ToOne(joinProperty = &quot;pid&quot;) private Person person; &#125; insert12345678Long pid = 6L;//personIdPerson p = new Person(pid, &quot;xiaoMing&quot;, 18);mPersonDao.insert(p);Long cid = 2L;//idcardid;CreditCard c = new CreditCard(cid, 100); //这个写了100（无论写什么）,实际还是6,关联了personIdc.setPerson(p);mCreditCardDao.insert(c); query12345678910111213141516171819202122List&lt;CreditCard&gt; list = mCreditCardDao.loadAll();CreditCard card = list.get(0);if (card != null) &#123; Timber.i(&quot;CardInfo cardid----------&gt;&quot; + card.getCid() + &quot; personid----------&gt;&quot; + card.getPid());&#125;switch (position) &#123; case 0: selectPersonInfoByCard(card);//根据idcard获取person break;&#125; private void selectPersonInfoByCard(CreditCard card) &#123; Person person = null; if (card != null) &#123; person = card.getPerson(); &#125; if (person != null) &#123; Timber.i(&quot;PersonByCard personId + ----------&gt; &quot; + person.getPid() + &quot; name----------&gt; &quot; + person.getName() + &quot; age----------&gt;&quot; + person.getAge()); &#125; else &#123; Timber.i(&quot;----获取person信息失败------&quot;); &#125; &#125; https://juejin.im/post/5a30f79c6fb9a045031014fd https://blog.csdn.net/qq_34358104/article/details/69833909 OneToMany123456789101112131415161718@Entitypublic class MStudent &#123; @Id(autoincrement = true) private Long sid; private String name; private Long tid;&#125;@Entitypublic class MTecher &#123; @Id(autoincrement = true) private Long tid; private String name; //一对多关系，tid为Student表的外键 @ToMany(referencedJoinProperty = &quot;tid&quot;) private List&lt;MStudent&gt; students; &#125; insert123456789101112131415161718192021222324252627282930313233/** * 添加Student信息 */ private void insertStudent() &#123; try &#123; Long sid = 1L; for (int i = 0; i &lt; 5; i++) &#123; MStudent s = new MStudent(sid, &quot;xiaoMing--&gt;&quot; + i, tid); mStudentDao.insert(s); sid++; &#125; Log.i(&quot;tag&quot;, &quot;学生信息添加成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.i(&quot;tag&quot;, &quot;学生信息添加失败&quot;); &#125; &#125; /** * 添加Teacher信息 */ private void insertTeacher() &#123; try &#123; String name = &quot;Miss zhang&quot;; MTecher mTecher = new MTecher(tid, name); mTecherDao.insert(mTecher); Log.i(&quot;tag&quot;,&quot;教师信息添加成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.i(&quot;tag&quot;,&quot;教师信息添加失败&quot;); &#125; &#125; query1234567891011121314151617181920212223242526272829303132private void selectTeacher() &#123; MTecher t = null; try &#123; t = mTecherDao.loadByRowId(tid); if (t != null)&#123; Log.i(&quot;tag&quot;,&quot;查询教师信息----&gt;成功&quot;); Log.i(&quot;tag&quot;,&quot;tid---&gt;&quot;+t.getTid()); Log.i(&quot;tag&quot;,&quot;teacher&#x27;s name-----&gt;&quot;+t.getName()); selectStudentByTeacher(t); &#125;else&#123; Log.i(&quot;tag&quot;,&quot;查询表中没有该教师信息&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Log.i(&quot;tag&quot;,&quot;查询教师信息----&gt;失败&quot;); &#125;&#125; /** * 根据获取得到的Teacher获取其名下的学生信息 * @param t */ private void selectStudentByTeacher(MTecher t) &#123; List&lt;MStudent&gt; list = t.getStudents(); if (list != null &amp;&amp; list.size() &gt; 0)&#123; for (MStudent mStudent : list) &#123; Log.i(&quot;tag&quot;,&quot;sid---------&gt; &quot;+mStudent.getSid() +&quot; tid---------&gt;&quot;+mStudent.getTid()+&quot; name--------&gt;&quot;+mStudent.getName()); &#125; &#125;else&#123; Log.i(&quot;tag&quot;,&quot;--------获取学生信息失败--------&quot;); &#125; &#125; ManyToMany12345678910@Entitypublic class NTeacher &#123; @Id(autoincrement = true) private Long tid; private String name; @ToMany @JoinEntity(entity = TandSRelative.class, sourceProperty = &quot;tid&quot;, targetProperty = &quot;sid&quot;) private List&lt;TandSRelative&gt; list; &#125; 1234567891011@Entitypublic class NStudent &#123; @Id(autoincrement = true) private Long sid; private String name; @ToMany @JoinEntity(entity = TandSRelative.class,sourceProperty = &quot;sid&quot;,targetProperty = &quot;tid&quot;) List&lt;NTeacher&gt; teacherList;&#125; 12345678@Entitypublic class TandSRelative &#123; @Id(autoincrement = true) private Long tsid; private Long tid;//teacher的id private Long sid;//student的id&#125; insert12345678910111213141516171819202122232425262728293031323334353637 //2个教师和3个学生的关系//教师1，带学生1、2//教师2，带学生1、3//学生1，选修教师1和教师2的课 private void addTeacherStu() &#123; List&lt;NTeacher&gt; teacherList = new ArrayList&lt;&gt;(); for (long i = 1; i &lt; 3; i++) &#123; NTeacher teacherBean = new NTeacher(); teacherBean.setTid(i); teacherList.add(teacherBean); &#125; daoSession.getNTeacherDao().insertInTx(teacherList); List&lt;NStudent&gt; studentList = new ArrayList&lt;&gt;(); for (long j = 1; j &lt; 4; j++) &#123; NStudent studentBean = new NStudent(); studentBean.setSid(j); studentList.add(studentBean); &#125; //教师1带学生1、2 List&lt;TandSRelative&gt; teacherTeachStuList = new ArrayList&lt;&gt;(); TandSRelative tandSRelative1 = new TandSRelative(null, 1L, 1L); teacherTeachStuList.add(tandSRelative1); TandSRelative tandSRelative2 = new TandSRelative(null, 1L, 2L); teacherTeachStuList.add(tandSRelative2); TandSRelative tandSRelative3 = new TandSRelative(null, 2L, 1L); teacherTeachStuList.add(tandSRelative3); TandSRelative tandSRelative4 = new TandSRelative(null, 2L, 3L); teacherTeachStuList.add(tandSRelative4); daoSession.getTandSRelativeDao().insertInTx(teacherTeachStuList); &#125; https://www.cnblogs.com/Free-Thinker/p/10654474.html https://juejin.im/post/5a30f79c6fb9a045031014fd https://blog.csdn.net/RobotHost/article/details/70098744 migration12345678910111213141516171819202122public class MySQLiteOpenHelper extends DaoMaster.OpenHelper &#123; public MySQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123;// super.onUpgrade(db, oldVersion, newVersion); MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123; @Override public void onCreateAllTables(Database db, boolean ifNotExists) &#123; DaoMaster.createAllTables(db, ifNotExists); &#125; @Override public void onDropAllTables(Database db, boolean ifExists) &#123; DaoMaster.dropAllTables(db, ifExists); &#125; &#125;, StudentDao.class); //可以添加多个 &#125;&#125; 123456// DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;dblearn.db&quot;); MigrationHelper.DEBUG = true; MySQLiteOpenHelper helper = new MySQLiteOpenHelper(this,&quot;dblearn.db&quot;,null); SQLiteDatabase db = helper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(db); daoSession = daoMaster.newSession(); 1234567891011121314151617181920212223242526272829@Entitypublic class Student &#123; @Id(autoincrement = true) // id 递增 Long id; @Unique public int studentNo; public int age; //年龄 @Property(nameInDb = &quot;usePhone&quot;) //数据库中映射的字段就是 usePhone public String telPhone;//手机号 @Transient //数据库中不会创建对应的字段 String sex; //性别 String name;//姓名 String address;//家庭住址 String schoolName;//学校名字 String grade;//几年级 private boolean statue; @ToOne(joinProperty = &quot;name&quot;) IdCard student; private String migrate; //新添加的字段 迁移 &#125; https://github.com/yuweiguocn/GreenDaoUpgradeHelper/blob/master/README_CH.md https://stackoverflow.com/questions/13373170/greendao-schema-update-and-data-migration/30334668#30334668 查看数据库database navigator![check_Screen Shot 2020-04-13 at 5.59.22 PM](GreenDao/check_Screen Shot 2020-04-13 at 5.59.22 PM.png) ![Screen Shot 2020-04-13 at 6.04.11 PM](GreenDao/Screen Shot 2020-04-13 at 6.04.11 PM.png) C:\\Users\\john\\Desktop\\dbsqlite Device file explorer里面查看 data/data/{$packname}/mine https://blog.csdn.net/yu75567218/article/details/78904909 数据缓存 RxJava实现数据网络数据缓存 https://blog.csdn.net/qq_35064774/article/details/53449795 用户测量数据有网上传 https://wenku.baidu.com/view/65f16f61998fcc22bdd10d5b.html https://my.oschina.net/banxi/blog/57984 https://www.infoq.cn/article/q-EjPtHOVFaE46XKjhlf","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://noteforme.github.io/tags/DB/"}]},{"title":"Binder","slug":"Binder","date":"2019-08-11T07:26:25.000Z","updated":"2021-08-19T11:11:43.695Z","comments":true,"path":"2019/08/11/Binder/","link":"","permalink":"https://noteforme.github.io/2019/08/11/Binder/","excerpt":"","text":"IPC方式信号量 共享内存 : 容易导致同步问题。因为用户端没法解决。 Socket Binder: 服务端映射后， 官方解决了同步问题。 多进程作用 Binder流程![](Binder/2021-08-11 _8.31_binder_over.png) Binder机制mmap作用让一块虚拟内存 指向一块已知的物理内存。 这个物理内存是binder提供的。 传统进程通信 Binder进程通信 查看进程分配的内存大小123AppledeMacBook-Pro:MineUtils apple$ adb shellgeneric_x86:/ $ getprop dalvik.vm.heapsize512m https://www.bilibili.com/video/BV1Hr4y1P7QC?from=search&amp;seid=18026610356055236655 https://www.bilibili.com/video/BV1Hr4y1P7QC?p=4 https://www.bilibili.com/video/BV1Hr4y1P7QC?p=5&amp;spm_id_from=pageDriver https://github.com/weidongshan/APP_0005_Binder_JAVA_App https://www.bilibili.com/video/BV1tW411i7aB?p=22","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"Gradient","slug":"Gradient","date":"2019-07-22T09:41:27.000Z","updated":"2021-08-19T11:11:43.903Z","comments":true,"path":"2019/07/22/Gradient/","link":"","permalink":"https://noteforme.github.io/2019/07/22/Gradient/","excerpt":"","text":"LinearGradient1234567891011121314151617181920212223/** * LinearGradient * Create a shader that draws a linear gradient along a line. * * @param x0 The x-coordinate for the start of the gradient line * @param y0 The y-coordinate for the start of the gradient line * @param x1 The x-coordinate for the end of the gradient line * @param y1 The y-coordinate for the end of the gradient line * @param colors The colors to be distributed along the gradient line * @param positions May be null. The relative positions [0..1] of * each corresponding color in the colors array. If this is null, * the the colors are distributed evenly along the gradient line. 所占比例，渲染颜色所占比例,如果传null，则均匀渲染 * @param tile The Shader tiling mode */val colors = intArrayOf( Color.RED, Color.GREEN, Color.BLUE)val positions = floatArrayOf(0.5f, 1f, 0.5f)val linearGradient = LinearGradient(0f, 300f, 300f, 300f, colors, positions, Shader.TileMode.CLAMP)val mPaint = Paint()mPaint.setShader(linearGradient)canvas?.drawRect(0f, 0f, 300f, 300f, mPaint) LinearGradient（0f, 0f, 300f, 300f）,说明从 (0,0) 到(300,300)对角线方向渲染 https://www.jianshu.com/p/5fb82b189094 渐变模式 -CLAMP边缘拉伸-REPEAT在水平和垂直两个方向上重复，相邻图像没有间隙-MIRROR 以镜像的方式在水平和垂直两个方向上重复，相邻图像有间隙","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[]},{"title":"TEST_Robolectric","slug":"TEST_Robolectric","date":"2019-06-13T01:42:52.000Z","updated":"2021-09-17T06:15:04.635Z","comments":true,"path":"2019/06/13/TEST_Robolectric/","link":"","permalink":"https://noteforme.github.io/2019/06/13/TEST_Robolectric/","excerpt":"","text":"robolectric https://github.com/robolectric/robolectric google官方 Fragment测试方法 https://developer.android.google.cn/training/basics/fragments/testing 谷歌官方推荐的开源测试框架 Robolectric就是这么一个工具，简单来说它实现了一套可以在JVM上运行的Android代码。 谷歌官方推荐的开源测试框架 Robolectric就是这么一个工具，它实现了一套可以在JVM上运行的Android代码。 https://juejin.cn/post/6844904054192111623 robolectric Dependencyhttps://www.youtube.com/watch?v=AiTh0rGMdjs","categories":[{"name":"TEST","slug":"TEST","permalink":"https://noteforme.github.io/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://noteforme.github.io/tags/Test/"}]},{"title":"PrincipleComputer","slug":"PrincipleComputer","date":"2019-04-08T07:52:07.000Z","updated":"2021-08-19T11:11:44.204Z","comments":true,"path":"2019/04/08/PrincipleComputer/","link":"","permalink":"https://noteforme.github.io/2019/04/08/PrincipleComputer/","excerpt":"","text":"进制运算的基本知识整数二进制2进制转10进制： 重复除2取余数 小数二进制 :𝑁= 0.11001 =1∗2−1+1∗2−2+1∗2−5=0.78125=25 / 32 (小数)十进制转换二进制:重复相乘法 二进制数据的表示方法原码 原码表示法 使用0表示正数、1表示负数 规定符号位位于数值第一位 表达简单明了，是人类最容易理解的表示法 0有两种表示方法:00 , 10 缺陷 但是原码表示法有缺陷 希望找到不同符号操作数更加简单的运算方法 希望找到使用正数代替负数的方法 使用加法操作代替减法操作，从而消除减法 阶码 尾数 补码补码表示法 例子2: x=-13，计算x的二进制原码和补码 原码:x=1,1101 补码:2^(𝑛+1) + 𝑥 = 2^(4+1) − 13 = 100000 − 1101 = 1,0011 ​ 1是符号位 补码:x=1,0011 例子3: x=-7，计算x的二进制原码和补码 原码:x=1,0111 补码:2^(𝑛+1) + 𝑥 = 2^(4+1) − 7 = 100000 − 0111 = 11001 ​ 补码:x=1,1001 缺陷 还是同样的问题, 希望找到使用正数代替负数的方法$$ 使用加法操作代替减法操作，从而消除减法 在计算补码的过程中，还是使用了减法!! 反码 引进补码的目的 减法运算复杂，希望找到使用正数替代负数的方法 使用加法代替减法操作，从而消除减法 例子1: x=-13，计算x的二进制原码和,反码,补码 原码: x=1,1101 反码: 2^(𝑛+1)−1 + 𝑥 = (2^(4+1)−1) − 13 = 011111 − 1101 = 10010 ​ 反码:x=1,0010 补码: 2^(𝑛+1) + 𝑥 = 2^(4+1) − 13 = 100000 − 1101 = 10011 例子2:x=-7，计算x的二进制原码和反码 原码:x=1,0111 反码:2^(𝑛+1) + 𝑥 = 2^(4+1) − 7 = 011111 − 0111 = 11000 ​ 反码:x=1,1000 反码表示法 负数的反码等于原码除符号位外按位取反 负数的补码= (反码+1) 例子3:x=-7，计算x的二进制原码和反码和补码 原码:x=1,0111 反码:x=1,1000. 补码:x=1,1001 例子4:x=-9，计算x的二进制原码和反码和补码 原码:x=1,1001 反码:x=1,0110 补码:x=1,0111 ​ 小数的补码小数的补码 反码规则和整数一样，原码的方式按照 小数二进制 先算出来 例子1: x= 9/16 ，计算x的二进制原码和反码和补码 原码:x=0,0.1001 反码:x= 0,0.1001 补码:x= 0,0.1001 例子2:x=- ，计算x的二进制原码和反码和补码 原码:x=1,0.01011 反码:x=1,1.10100 补码:x=1,1.10101 二进制数据的运算定点数的加法运算整数加法: A 补 + B 补 = 𝐴 + 𝐵 补 (𝑚𝑜𝑑2𝑛+1) 小数加法: A补 +B补 = 𝐴+𝐵 补(𝑚𝑜𝑑2) 数值位与符号位一同运算，并将符号位产生的进位自然丢掉 例子1: A=-110010， B=001101，求A+B A[补] = 1,001110 =&gt; A[原] = 1,110010 =&gt; A[反]= 1,001101 B 补 = B[原] = 0,001101 A 补 +B 补 =(A+B) 补 =1,011011 A + B = −100101 例子2:A=-0.1010010， B=0.0110100，求A+B A[补] = 1,1.0101110 B 补 = B[原] = 0,0.0110100 A 补 +B 补 =(A+B) 补 =1,1.1100010 A + B =-0.0011110 例子4 ： A=-10010000， B=-11010000，求A+B A补 =1,01110000 B补 =1,00110000 A 补 +B 补 =(A+B) 补 =0,10100000 A + B = 10100000 A + B = 160 A = −144 B = −208 发生了溢出 : A 判断溢出 双符号位判断法 **单符号位表示变成双符号位:**0=&gt;00,1=&gt;11 双符号位产生的进位丢弃 结果的双符号位不同则表示溢出 例子4:A=-10010000， B=-11010000，求A+B A补 =1,01110000 B补 =1,00110000 A 补 +B 补 =(A+B) 补 =10,10100000 双符号位不同，表示溢出 符号位进位舍去 例子3:A=-10010000， B=-01010000，求A+B A补 =1,01110000 B补 =1,10110000 A 补 +B 补 =(A+B) 补 =11,00100000 双符号位相同，没有溢出 (A+B)[原] = 11,11100000 = −11100000 定点数的减法运算整数减法: A补 −B补 =𝐴+(−𝐵)补(𝑚𝑜𝑑2𝑛+1) 小数减法: A 补 −B 补 =𝐴+(−𝐵) 补 (𝑚𝑜𝑑2) -B[补]等于B[补]连同符号位按位取反，末位加一 B 补 = 1,0010101 (−B) 补 = 0,1101011 例子5:A=11001000， B=-00110100，求A-B A 补 = A[原] = 0,11001000 B 补 = 1,11001100 (−B) 补 = 0,00110100 A补 −B补 =A+(−B)补 A+(−B)补 =0,11111100 A − B = 111111100 浮点数的加减法运算対阶 尾数求和 尾数规格化 舍入 溢出判断 浮点数乘除法也是上面4个步骤 做蓝牙开发时byte数组出现 -122，来看看这个负数是怎么出现的 byte转int类型 b1 &amp; 0xff http://ju.outofmemory.cn/entry/215778 https://blog.csdn.net/RuobaiMEN/article/details/79890823 https://blog.csdn.net/LVXIANGAN/article/details/72726152 问题: 计算机负数加法 8 + （-1） ​ b1 &amp; 0xff 不理解 https://www.imooc.com/article/21360 https://blog.csdn.net/zdy10326621/article/details/50236529 字节一个字节byte 两位16进制数1个字节是8位，二进制8位：xxxxxxxx 范围从00000000－11111111，表示0到255。 1位16进制数最大是15（用二进制表示是xxxx ）（即对应16进制的0xF 1111 4位），要表示到255,就还需要4位。 位运算符基本操作 https://blog.csdn.net/qiantudou/article/details/49928423 https://www.orchome.com/1190 取一个字节 某几位123456789101112131415161718192021222324252627282930313233343536/** * 取一个字节高几位 * * @param b * @param length * @return */public static int getLeftNum(byte b, int length) &#123; return b &gt;&gt; (8 - length);&#125;/** * 取一个字节低几位bit * * @param b * @param length * @return */public static int getRightNum(byte b, int length) &#123; byte mv = (byte) (0xff &gt;&gt; (8 - length)); return b &amp; mv;&#125;/** * https://blog.csdn.net/bluestarjava/article/details/83446129 * * @param b * @param startIndex 高位从0开始 * @param endIndex * @return */public static int getMidNum(byte b, int startIndex, int endIndex) &#123; byte i = (byte) getLeftNum(b, endIndex + 1);//先取高几位 return getRightNum(i, endIndex - startIndex + 1);//再取低几位&#125; https://bbs.csdn.net/topics/310178646","categories":[{"name":"Organization","slug":"Organization","permalink":"https://noteforme.github.io/categories/Organization/"}],"tags":[]},{"title":"Popupwindow","slug":"Popupwindow","date":"2019-03-26T13:17:52.000Z","updated":"2021-08-19T11:11:44.204Z","comments":true,"path":"2019/03/26/Popupwindow/","link":"","permalink":"https://noteforme.github.io/2019/03/26/Popupwindow/","excerpt":"","text":"使用showAtLocation1234public void showAtLocation(View parent, int gravity, int x, int y) &#123; mParentRootView = new WeakReference&lt;&gt;(parent.getRootView()); showAtLocation(parent.getWindowToken(), gravity, x, y); &#125; gravity 9种情况 从 parent.getRootView()可以看到 parentview就是整个屏幕 Gravity.NO_GRAVITY ：显示效果同 Gravity.LEFT | Gravity.TOPGravity.LEFT：以屏幕左边中间位置为圆点Gravity.TOP：以屏幕顶部中间位置为参照物Gravity.RIGHT：以屏幕右侧中间位置为参照物Griavity.BOTTOM：以屏幕底部中间为参照物Gravity.LEFT | Gravity.TOP：以屏幕左上角为参照物Gravity.RIGHT | Gravity.TOP ：以屏幕右上角为参照物Gravity.LEFT | Gravity.BOTTOM ：以屏幕左下角为参照物Gravity.RIGHT | Gravity.BOTTOM ：以屏幕右下角为参照物x ：x &lt; 0时，向左偏移， x &gt;0 时，向右偏移 y ：显示效果受gravity参数影响。当参数不带Gravity.BOTTOM时，y &lt; 0，向上偏移， y &gt; 0 ，向下偏移；当参数带有Gravity.BOTTOM时, y &lt; 0,向下偏移，y &gt; 0，向下偏移 原文：https://blog.csdn.net/Justwen26/article/details/61621076 showAsDropDown123public void showAsDropDown(View anchor, int xoff, int yoff) &#123; showAsDropDown(anchor, xoff, yoff, DEFAULT_ANCHORED_GRAVITY);&#125; 弹窗会显示在anchor控件的正下方。","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"View_Practice","slug":"View_Practice","date":"2019-01-01T14:44:09.000Z","updated":"2023-12-17T12:50:32.998Z","comments":true,"path":"2019/01/01/View_Practice/","link":"","permalink":"https://noteforme.github.io/2019/01/01/View_Practice/","excerpt":"","text":"绘制心电图 https://github.com/SeekerFighter/LuckyEcgDemo https://www.jianshu.com/p/16301de41a18 表单输入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * EditText文字固定在右边 */public class EditTextRight extends AppCompatEditText &#123; private String txtRight; private Paint mPaint; public EditTextRight(Context context) &#123; super(context); &#125; public EditTextRight(Context context, AttributeSet attrs) &#123; super(context, attrs); initAttrs(context, attrs); &#125; private void initAttrs(Context context, AttributeSet attrs) &#123; TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.EditTextRight); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); txtRight = ta.getString(R.styleable.EditTextRight_textright);// Timber.d(&quot;text&quot; + txtRight); ta.recycle(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float txtSize = getTextSize(); if (!TextUtils.isEmpty(txtRight)) &#123; float yrig = getWidth() - txtSize * txtRight.length() - 10; //getWidth() 控件宽度 Timber.d(&quot;txt &quot; + txtRight + &quot; getRight &quot; + yrig); canvas.drawText(txtRight, yrig, getBaseline(), getPaint()); &#125; &#125;&#125; &lt;com.jonzhou.mineutils.ui.customview.EditTextRight android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; mineutils:textright=&quot;幢&quot; /&gt; 自定义属性画正方形 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); Timber.i(&quot; MyView(Context context, AttributeSet attrs)&quot;); &#125; public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Timber.i(&quot;onMeasure(int widthMeasureSpec, int heightMeasureSpec)&quot;); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; Timber.i(&quot;width &quot; + width + &quot; height &quot; + height); setMeasuredDimension(width,height); &#125; private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: //如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST://如果测量模式是最大取值为size //我们将大小取最大值,你也可以取其他值 mySize = size; break; case MeasureSpec.EXACTLY: mySize = size; break; &#125; return mySize; &#125;&#125; 设置 match_parent不是正方形? 关于自定义属性不提示 declare-styleable name要和自定义类名相同，然后重启Ide就好了 那么获取到的mode和size又代表了什么呢？mode代表了我们当前控件的父控件告诉我们控件，你应该按怎样的方式来布局。mode有三个可选值：EXACTLY, AT_MOST, UNSPECIFIED。它们的含义是： EXACTLY：父控件告诉我们子控件了一个确定的大小，你就按这个大小来布局。比如我们指定了确定的dp值和macth_parent的情况。AT_MOST：当前控件不能超过一个固定的最大值，一般是wrap_content的情况。 UNSPECIFIED:当前控件没有限制，要多大就有多大，这种情况很少出现。 下面是一个重写onMeasure的固定伪代码写法： 123456789if mode is EXACTLY&#123; 父布局已经告诉了我们当前布局应该是多大的宽高, 所以我们直接返回从measureSpec中获取到的size &#125;else&#123; 计算出希望的desiredSize if mode is AT_MOST 返回desireSize和specSize当中的最小值 else: 返回计算出的desireSize &#125; 原文：https://blog.csdn.net/yissan/article/details/51136088 自定义属性不提示 按照如图两名称一致，重启AndroidStudio https://blog.csdn.net/skysmile_/article/details/78833438 https://developer.android.com/guide/topics/ui/custom-components https://developer.android.com/training/custom-views/custom-drawing 绘图http://blog.csdn.net/huaiyiheyuan/article/details/52205969 画圆http://www.jianshu.com/p/d891fe636898 Scroll 滑动https://juejin.im/post/5c7f4f0351882562ed516ab6#heading-17 https://blog.csdn.net/guolin_blog/article/details/48719871 Kotlin12345678910111213class TermRoundView @JvmOverloads constructor( context: Context?, attrs: AttributeSet?, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; init&#123; val a = context?.theme?.obtainStyledAttributes(attrs, R.styleable.TermRoundView, 0, 0) try &#123; isRulerInput = a!!.getBoolean(R.styleable.TermRoundView_isRulerInput, false) &#125; finally &#123; a?.recycle() &#125; &#125;&#125; https://juejin.im/post/6844903909320835080","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/tags/VIEW/"}]},{"title":"view_custom_practice","slug":"view_custom_practice","date":"2019-01-01T14:44:09.000Z","updated":"2023-12-17T13:05:48.146Z","comments":true,"path":"2019/01/01/view_custom_practice/","link":"","permalink":"https://noteforme.github.io/2019/01/01/view_custom_practice/","excerpt":"","text":"绘制心电图 https://github.com/SeekerFighter/LuckyEcgDemo https://www.jianshu.com/p/16301de41a18 表单输入 1234567891011121314151617181920212223242526272829303132333435363738/** * EditText文字固定在右边 */public class EditTextRight extends AppCompatEditText &#123; private String txtRight; private Paint mPaint; public EditTextRight(Context context) &#123; super(context); &#125; public EditTextRight(Context context, AttributeSet attrs) &#123; super(context, attrs); initAttrs(context, attrs); &#125; private void initAttrs(Context context, AttributeSet attrs) &#123; TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.EditTextRight); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); txtRight = ta.getString(R.styleable.EditTextRight_textright);// Timber.d(&quot;text&quot; + txtRight); ta.recycle(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float txtSize = getTextSize(); if (!TextUtils.isEmpty(txtRight)) &#123; float yrig = getWidth() - txtSize * txtRight.length() - 10; //getWidth() 控件宽度 Timber.d(&quot;txt &quot; + txtRight + &quot; getRight &quot; + yrig); canvas.drawText(txtRight, yrig, getBaseline(), getPaint()); &#125; &#125;&#125; 1234&lt;com.jonzhou.mineutils.ui.customview.EditTextRight android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; mineutils:textright=&quot;幢&quot; /&gt; 自定义属性画正方形 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); Timber.i(&quot; MyView(Context context, AttributeSet attrs)&quot;); &#125; public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Timber.i(&quot;onMeasure(int widthMeasureSpec, int heightMeasureSpec)&quot;); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; Timber.i(&quot;width &quot; + width + &quot; height &quot; + height); setMeasuredDimension(width,height); &#125; private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: //如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST://如果测量模式是最大取值为size //我们将大小取最大值,你也可以取其他值 mySize = size; break; case MeasureSpec.EXACTLY: mySize = size; break; &#125; return mySize; &#125;&#125; 设置 match_parent不是正方形? 关于自定义属性不提示 declare-styleable name要和自定义类名相同，然后重启Ide就好了 那么获取到的mode和size又代表了什么呢？mode代表了我们当前控件的父控件告诉我们控件，你应该按怎样的方式来布局。mode有三个可选值：EXACTLY, AT_MOST, UNSPECIFIED。它们的含义是： EXACTLY：父控件告诉我们子控件了一个确定的大小，你就按这个大小来布局。比如我们指定了确定的dp值和macth_parent的情况。AT_MOST：当前控件不能超过一个固定的最大值，一般是wrap_content的情况。 UNSPECIFIED:当前控件没有限制，要多大就有多大，这种情况很少出现。 下面是一个重写onMeasure的固定伪代码写法： if mode is EXACTLY{ 父布局已经告诉了我们当前布局应该是多大的宽高, 所以我们直接返回从measureSpec中获取到的size}else{ 计算出希望的desiredSize if mode is AT_MOST 返回desireSize和specSize当中的最小值 else: 返回计算出的desireSize } 原文：https://blog.csdn.net/yissan/article/details/51136088 自定义属性不提示 按照如图两名称一致，重启AndroidStudio https://blog.csdn.net/skysmile_/article/details/78833438 https://developer.android.com/guide/topics/ui/custom-components https://developer.android.com/training/custom-views/custom-drawing 绘图http://blog.csdn.net/huaiyiheyuan/article/details/52205969 画圆http://www.jianshu.com/p/d891fe636898 Scroll 滑动https://juejin.im/post/5c7f4f0351882562ed516ab6#heading-17 https://blog.csdn.net/guolin_blog/article/details/48719871 Kotlin12345678910111213class TermRoundView @JvmOverloads constructor( context: Context?, attrs: AttributeSet?, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; init&#123; val a = context?.theme?.obtainStyledAttributes(attrs, R.styleable.TermRoundView, 0, 0) try &#123; isRulerInput = a!!.getBoolean(R.styleable.TermRoundView_isRulerInput, false) &#125; finally &#123; a?.recycle() &#125; &#125;&#125; https://juejin.im/post/6844903909320835080","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/tags/VIEW/"}]},{"title":"MediaPlayer","slug":"MediaPlayer","date":"2018-11-18T01:05:11.000Z","updated":"2021-08-19T11:11:44.127Z","comments":true,"path":"2018/11/18/MediaPlayer/","link":"","permalink":"https://noteforme.github.io/2018/11/18/MediaPlayer/","excerpt":"","text":"https://developer.android.com/reference/android/media/MediaPlayer http://www.runoob.com/w3cnote/android-tutorial-mediaplayer.html 这张状态转换图清晰的描述了MediaPlayer的各个状态，也列举了主要的方法的调用时序，每种方法只能在一些特定的状态下使用，如果使用时MediaPlayer的状态不正确则会引发IllegalStateException异常。 Idle 状态：当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。 End 状态：通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。 Initialized 状态：这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。 Prepared 状态：初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。 Preparing 状态：这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。 Started 状态：显然，MediaPlayer一旦准备好，就可以调用start()方法，这样MediaPlayer就处于Started状态，这表明MediaPlayer正在播放文件过程中。可以使用isPlaying()测试MediaPlayer是否处于了Started状态。如果播放完毕，而又设置了循环播放，则MediaPlayer仍然会处于Started状态，类似的，如果在该状态下MediaPlayer调用了seekTo()或者start()方法均可以让MediaPlayer停留在Started状态。 Paused 状态：Started状态下MediaPlayer调用pause()方法可以暂停MediaPlayer，从而进入Paused状态，MediaPlayer暂停后再次调用start()则可以继续MediaPlayer的播放，转到Started状态，暂停状态时可以调用seekTo()方法，这是不会改变状态的。 Stop 状态：Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。 PlaybackCompleted状态：文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。 Error状态：如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。 原文：https://blog.csdn.net/ddna/article/details/5178864https://blog.csdn.net/biaobiao1217/article/details/51557733","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"mina","slug":"mina","date":"2018-11-03T01:48:09.000Z","updated":"2021-08-19T11:11:44.302Z","comments":true,"path":"2018/11/03/mina/","link":"","permalink":"https://noteforme.github.io/2018/11/03/mina/","excerpt":"","text":"MINA配置 下载 http://mina.apache.org/mina-project/downloads.html apache-mina-2.0.19-bin.zip 解压 下载 https://www.slf4j.org/download.html slf4j-1.7.25.zip解压 在MineUtil项目中有demo实现 IM键盘 https://juejin.im/post/5ef850c9f265da231019f6e4","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"GestureDetector","slug":"GestureDetector","date":"2018-08-13T08:08:19.000Z","updated":"2021-08-19T11:11:43.897Z","comments":true,"path":"2018/08/13/GestureDetector/","link":"","permalink":"https://noteforme.github.io/2018/08/13/GestureDetector/","excerpt":"","text":"GestureDetector总结 https://blog.csdn.net/harvic880925/article/details/39520901 切换动画 https://blog.csdn.net/u013309870/article/details/52873515 http://www.jcodecraeer.com/a/basictutorial/2016/1014/6672.html https://www.jianshu.com/p/a06e4f215f49 1e1, MotionEvent e2坐标滑动距离 速度判断:velocityX：X轴上的移动速度，像素/秒 velocityY：Y轴上的移动速度，像素/秒","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"AndroidSource","slug":"AndroidSource","date":"2018-07-25T01:57:29.000Z","updated":"2025-03-23T13:49:28.274Z","comments":true,"path":"2018/07/25/AndroidSource/","link":"","permalink":"https://noteforme.github.io/2018/07/25/AndroidSource/","excerpt":"","text":"Android docker 史上最简单Android源码编译环境搭建方法 | Weishu’s Notes https://source.android.com/docs/setup/start/requirements#setting-up-a-linux-build-environment https://www.zhihu.com/people/tian-weishu/answers?page=1https://zwc365.com/2020/08/30/android10-baiduwangpan ubuntu environmentubuntu environment user permission Open terminal. Type “su root” in the terminal and press enter You will be asked to enter the password. Type the password and press enter. You will be moved to root.4.Type “usermod -aG sudo username”. Add your username, and enter. Nothing will happend. You will move to next line without any error. Reboot&#x2F;Restart the os.https://www.youtube.com/watch?v=ZxOwFOtcaaA comment download source code https://mirrors.ustc.edu.cn/help/aosp.html Download source code create bin 123456mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo## 如果上述 URL 不可访问，可以用下面的：curl -sSL &#x27;https://gerrit-googlesource.proxy.ustclug.org/git-repo/+/master/repo?format=TEXT&#x27; |base64 -d &gt; ~/bin/repochmod a+x ~/bin/repo update repository Edit the file ~/bin/repo and replace REPO_URL 123REPO_URL = &#x27;https://gerrit-googlesource.proxy.ustclug.org/git-repo&#x27;REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27; sync code &#x2F;&#x2F; 有时候有中断，不用管继续下载 1234mkdir sourcecd sourcerepo init -u https://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-6.0.1_r40repo sync git-repo | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror ubuntu 20.04 运行repo init 提示 &#x2F;usr&#x2F;bin&#x2F;env: ‘python’: No such file or directory 解决方案 sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python https://juejin.cn/post/7071152327482146823 同步源码树（以后只需执行这条命令来同步）： repo sync https://blog.csdn.net/qq_34508943/article/details/133391020 Install required packagesTo install required packages for Ubuntu 18.04 or later, run the following command: 1sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig https://source.android.com/docs/setup/start Docker AOSPhttps://hub.docker.com/r/green369258/aosp 123docker pull green369258/aosp:android-msudo docker run -itd --name android-m -v /home/m/source:/aosp green369258/aosp:android-mdocker exec -it android-m /bin/bash 代码下载在宿主机器上，和容器路径做映射。 问题 Docker环境下编译android源码|编译可运行xposed - iMisty - 博客园 编译有问题 https://hub.docker.com/r/praqma/aosp-build-container https://hub.docker.com/r/davesrl/aosp/tags https://hub.docker.com/r/inteldevcloudx77/aosp/tags SOURCE CODE BUILDandroid 12 源码编译与虚拟机调试_aosp running multiple emulators with the same avd-CSDN博客 初始化编译环境 1source build/envsetup.sh 选择产品76 sdk_phone_x86_64-eng lunch 使用lunch选择要编译的产品，此文档中以编译x86_x64 emulator模拟器镜像为例进行说明。 emulator 修改AndroidProduct.mk使支持x86_x64镜像编译由于android12 默认lunch默认选不到模拟器镜像，所以首先需要修改mk。修改build&#x2F;make&#x2F;target&#x2F;product&#x2F;AndroidProducts.mk文件，添加sdk_phone_x86_64-eng支持 123456789diff --git a/target/product/AndroidProducts.mk b/target/product/AndroidProducts.mkindex 7d9d90e92a..419cccb80a 100644--- a/target/product/AndroidProducts.mk+++ b/target/product/AndroidProducts.mk@@ -84,3 +84,4 @@ COMMON_LUNCH_CHOICES := \\ aosp_arm-eng \\ aosp_x86_64-eng \\ aosp_x86-eng \\+ sdk_phone_x86_64-eng \\ 原文链接：https://blog.csdn.net/qq_17696807/article/details/124302856 lunch sdk_phone_x86_64-eng build issuelibncurses.so.5123prebuilts/clang/host/linux-x86/clang-3289846/bin/clang.real: error while loadingshared libraries: libncurses.so.5: cannot open shared object file: No such fileor directory 32 bit - How to install libncurses.so.5 in Ubuntu 20.04? - Ask Ubuntu https://blog.csdn.net/qq_34508943/article/details/133391020 get into &#x2F;etc&#x2F;apt&#x2F;sources.list.d and locate ubuntu.sources. open the terminal in that directory by right clicking in it. then run sudo nano .&#x2F;ubuntu.sources a pluma editor will open. just add these lines:- 12345Types: debURIs: http://security.ubuntu.com/ubuntu Suites: focal-securityComponents: main universeSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg AOSP 编译Android12源码全记录 - 简书 emulator: ERROR: x86 emulation currently requires hardware accelerationUbentu编译Android源码（AOSP） - 有点理想的码农 - 博客园 python error&#x2F;usr&#x2F;bin&#x2F;env: ‘python’: No such file or directory-CSDN博客 docker errorUSER问题（由于运行的docker 容易没有配置USER环境变量） 123USER: unbound variable out/host/linux-x86/bin/jack-admin: line 27: USER: unbound variable touch out/host/common/obj/JAVA_LIBRARIES/jack_intermediates/kill_server.stamp Install: out/host/linux-x86/framework/jack.jar out/host/linux-x86/bin/jack-admin: line 27: USER: 1export USER=$(whoami) 也可以在docker构建文件Dockerfile中加上如下语句： 1ENV USER root /或者自己需要的名字 android7.0 源码编译问题总结-CSDN博客 Unable to compile AOSP source code on Ubuntu 24.04 system - Stack Overflow https://github.com/alsutton/aosp-build-docker-images import Android studio 12soruce build/envsetup.shmmm development/tools/idegen/ SWAP RAM12345678910111213141516171819202122# Turn swap off# This moves stuff in swap to the main memory and might take several minutessudo swapoff -a# Create an empty swapfile# Note that &quot;1G&quot; is basically just the unit and count is an integer.# Together, they define the size. In this case 16GB.sudo dd if=/dev/zero of=/swapfile bs=1G count=16# Set the correct permissionssudo chmod 0600 /swapfilesudo mkswap /swapfile # Set up a Linux swap areasudo swapon /swapfile # Turn the swap onCheck if it workedgrep Swap /proc/meminfoMake it permanent (persist on restarts)Add this line to the end of your /etc/fstab:/swapfile swap swap sw 0 0 Aosp 14 build error [100% 1&#x2F;1] analyzing Android.bp files and generating ninja file at out&#x2F;soong&#x2F;build.ninja FAILED: out&#x2F;soong&#x2F;build.ninja - Stack Overflow 要学习Android源码需要编译一份，然后安装要求导入AndroidStudio,可以参考: http://blog.csdn.net/huaiyiheyuan/article/details/52069122 Activity启动过程对应用程序Activity进行编译和打包 /home/jon/桌面/LaoLuo/chapter-7/src/packages/experimental/Activity make snod emulator 然后查看activity信息，在这里通过源码里面的 adb cd /home/jon/AOSP/out/host/linux-x86/bin adb shell dumpsys activity Android open source projectAndroid Architecture https://source.android.com/https://source.android.com/devices/architecturehttps://blog.csdn.net/wenzhi20102321/article/details/80739649https://blog.csdn.net/wen0006/article/details/5804639 源码关联阅读 也可以选择对应的文件的 .class文件后，再选择源码后再建立关联。 https://www.jianshu.com/p/8012d5d38b01 Ubuntu 24.04 + Windows 10&#x2F;11 双引导系统无损安装 | AI开源项目 模型微调必备 - YouTube https://www.zhihu.com/people/tian-weishu/answers?page=5 Binder https://www.zhihu.com/question/39440766/answer/81511893 Binder学习指南 | Weishu’s Notes https://github.com/satur9nine/aosp-docker-build-env","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"}]},{"title":"ViewDynamic","slug":"ViewDynamic","date":"2018-07-17T12:25:26.000Z","updated":"2021-08-19T11:11:44.266Z","comments":true,"path":"2018/07/17/ViewDynamic/","link":"","permalink":"https://noteforme.github.io/2018/07/17/ViewDynamic/","excerpt":"","text":"动态添加布局LinearLayout添加 父容器 123456&lt;LinearLayout android:id=&quot;@+id/ll_plan_one&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt; 子布局 123View view1 = inflate.inflate(R.layout.layout_animation, null);View view2 = inflate.inflate(R.layout.ic_hpan_suger_press_y, null);View view3 = inflate.inflate(R.layout.ic_hpan_suger_press_y, null); 添加进容器 123llVertical.addView(view1);llVertical.addView(view2);llVertical.addView(view3); 添加同一个子布局会报错 12llVertical.addView(view1);llVertical.addView(view1); ​ Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child’s parent first.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"Lambda","slug":"Lambda","date":"2018-07-11T06:23:20.000Z","updated":"2021-08-19T11:11:44.095Z","comments":true,"path":"2018/07/11/Lambda/","link":"","permalink":"https://noteforme.github.io/2018/07/11/Lambda/","excerpt":"","text":"http://blog.oneapm.com/apm-tech/226.html android https://maxwell-nc.github.io/android/retrolambda.html https://cloud.tencent.com/developer/article/1526621 https://juejin.im/post/6844903668592934925 kotlin lambda https://juejin.im/post/6844903604613021703 Video Java lambda函数式编程 https://www.bilibili.com/video/av54941486/ http://www.chilangedu.com/sectionq/2132352424 map1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 123public interface Function&lt;T, R&gt; &#123; R apply(T t); //将T类型转为R&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"Bluetooth02","slug":"Bluetooth02","date":"2018-07-05T10:17:23.000Z","updated":"2024-10-02T01:36:25.262Z","comments":true,"path":"2018/07/05/Bluetooth02/","link":"","permalink":"https://noteforme.github.io/2018/07/05/Bluetooth02/","excerpt":"","text":"BLE stack(蓝牙协议栈) 作为 Android 开发者，我们不必理解 BLE 的协议栈每个细节，这里大概介绍一下协议架构。 协议一般都是分层设计的。BLE 协议栈也不例外。我们来看一下这个图。整个协议栈大致分为三部分，从下到上分别为，控制器 （Controller）→主机（Host）→应用（Applications）。 Controller : 它是协议栈的底层的实现，直接与硬件相关，一般直接集成在 SoC 中，由芯片厂商实现，包括物理层和链路层。 HOST : 这是协议栈的上层实现，是硬件的抽象，与具体的硬件和厂家无关 应用层： 就是使用 Host 层提供的 API，开发的应用。 Controller PhysicalLayer(物理层 ): 蓝牙是工作在 2.4GHz 附近，这是工业、科学、医疗 ISM 频段。可以看到它和 WiFi 工作在同一个频段。蓝牙把频段切分为 40 个通道，3 个广播通道，37 个数据通道，按照一定规律跳频通信（高斯频移键控 GFSK）。 HCI : 在 Host 层和 Controller 之间有一个接口层 :主机和控制器之间就是通过 HCI 命令和事件交互的。HCI 这一层是协议栈中是可选的，例如在一些简单小型的设备上可能就没有，但是所有的 Android 设备上肯定是有。这是蓝牙上层应用和芯片的交互的必经之路。后面我们会讲到，这一层的 log，能够很好的帮助我们分析和调试问题。 HostATT (Attribute Protocol)它是 BLE 通信的基础。ATT 把数据封装，向外暴露为“属性”，提供“属性”的为服务端，获取“属性”的为客户端。ATT 是专门为低功耗蓝牙设计的，结构非常简单，数据长度很短 . GATT(Generic Attribute Profile) 全称叫做通用属性配置文件，它是建立在前面说的 ATT 的基础上，对 ATT 进行进一步的逻辑封装，定义数据的交互方式和含义。这是我们做 BLE 开发的时候直接接触的概念。 GATT 按照层级定义了三个概念：服务（Service）、特征（Characteristic）和描述（Descriptor）。 一个 Service 包含若干个 Characteristic，一个 Characteristic 可以包含若干 Descriptor。而 Characteristic 定义了数值和操作。Characteristic 的操作这几种权限：读、写、通知等权限。我们说的 BLE 通信，其实就是对 Characteristic 的读写或者订阅通知。还有最外面一层，Profile配置文件，把若干个相关的 Service 组合在一起，就成为了一个 Profile，Profile 就是定义了一个实际的应用场景。 Service、Characteristic相当于标签（Service相当于他的类别，Characteristic相当于它的名字），而value才真正的包含数据，Descriptor是对这个value进行的说明和描述，当然我们可以从不同角度来描述和说明，因此可以有多个Descriptor. 例如: 常见的小米手环是一个BLE设备，（假设）它包含三个Service,分别是提供设备信息的Service、提供步数的Service、检测心率的Service; 而设备信息的service中包含的characteristic包括厂商信息、硬件信息、版本信息等；而心率Service则包括心率characteristic等，而心率characteristic中的value则真正的包含心率的数据，而descriptor则是对该value的描述说明，比如value的单位啊，描述啊，权限啊等。 GAP(Generic Access Profile)它定义了 BLE 整个通信过程中的流程，例如广播、扫描、连接等流程。还定义了参与通信的设备角色，以及他们各自的职能，例如广播数据的 Broadcaster，接收广播的 Observer，还有被连接的“外设” Peripheral 和发起连接的“中心设备” Central。可以看到，参与交互的设备角色都不是对等 Applications就是使用 Host 提供的 API 开发的低功耗蓝牙应用。 到这里，我们就把 BLE 的协议栈过了一下，为我们开发 BLE 有了一些理论基础。 BLE on Android Central mode : 从Android 4.3 Jelly Bean，也就是 API 18 才开始支持低功耗蓝牙(蓝牙4.0)。这时支持 BLE 的 Central 模式，也就是我们在上面 GAP 中说的，Android 设备只能作为中心设备去连接其他设备。 Peripheral mode:从 Android 5.0 开始才支持外设模式(蓝牙4.1)。Android 设备现在可以发挥蓝牙 LE 外围设备的作用。应用可以利用此功能让附近设备发现它。例如，您可以开发这样的应用：让设备发挥计步器或健康监测仪的作用，并与其他蓝牙 LE 设备进行数据通信。 新增的 android.bluetooth.le API 让您的应用可以发布广告、扫描响应以及与附近的蓝牙 LE 设备建立连接。要使用新增的广告和扫描功能，请在您的清单中添加 BLUETOOTH_ADMIN 权限。当用户更新您的应用或从 Play 商店下载您的应用时，会被要求向您的应用授予以下权限：“Bluetooth connection information:Allows the app to control Bluetooth, including broadcasting to or getting information about nearby Bluetooth devices.” 要启动蓝牙 LE 广播，以便其他设备能发现您的应用，请调用 startAdvertising()，并传入 AdvertiseCallback 类的实现。回调对象会收到广播操作成功或失败的报告。 Android 5.0 引入了 ScanFilter 类，让您的应用可以只扫描其感兴趣的特定类型设备。要开始扫描蓝牙 LE 设备，请调用 startScan()，并传入筛选器列表。在方法调用中，您还必须提供 ScanCallback 的实现，以便在发现蓝牙 LE 广播时进行报告。 https://developer.android.com/about/versions/android-5.0?hl=zh-cn#BluetoothBroadcasting https://en.wikipedia.org/wiki/Bluetooth#Communication_and_connection Android 7.0 蓝牙架构 Android 8.0 蓝牙架构Android 提供支持经典蓝牙和蓝牙低功耗的默认蓝牙堆栈。借助蓝牙，Android 设备可以创建个人区域网络，以便通过附近的蓝牙设备发送和接收数据。 在 Android 4.3 及更高版本中，Android 蓝牙堆栈可提供实现蓝牙低功耗 (BLE) 的功能。要充分利用 BLE API，请遵循 Android 蓝牙 HCI 要求。具有合格芯片组的 Android 设备可以实现经典蓝牙或同时实现经典蓝牙和 BLE。BLE 不能向后兼容较旧版本的蓝牙芯片组。 在 Android 8.0 中，原生蓝牙堆栈完全符合蓝牙 5.0 的要求。要使用可用的蓝牙 5.0 功能，该设备需要具有符合蓝牙 5 要求的芯片组。 注意：Android 8.0 及以前版本之间的原生蓝牙堆栈的最大变化是使用高音。Android 8.0 中的供应商实现必须使用 HIDL 而不是 libbt-vendor。 蓝牙系统服务 蓝牙系统服务（位于 packages/apps/Bluetooth 中）被打包为 Android 应用，并在 Android 框架层实现蓝牙服务和配置文件。此应用通过 JNI 调用原生蓝牙堆栈。 JNI 与 android.bluetooth 相关联的 JNI 代码位于 packages/apps/Bluetooth/jni 中。当发生特定蓝牙操作时（例如发现设备时），JNI 代码会调用蓝牙堆栈。 蓝牙堆栈 系统在 AOSP 中提供了默认蓝牙堆栈，它位于 system/bt 中。该堆栈会实现常规蓝牙 HAL，并通过扩展程序和更改配置对其进行自定义。 供应商实现 供应商设备使用硬件接口设计语言 (HIDL) 与蓝牙堆栈交互。 HIDLHIDL 定义了蓝牙堆栈和供应商实现之间的接口。要生成蓝牙 HIDL 文件，请将蓝牙接口文件传递到 HIDL 生成工具中。接口文件位于 hardware/interfaces/bluetooth 下。 Android 7.x 及更早版本的蓝牙架构 https://developer.android.com/guide/platform/?hl=zh-cn https://source.android.com/setup/ https://source.android.com/devices/bluetooth/?hl=zh-cn Android 中 BLE 操作的过程 这里介绍一下 Android 中 BLE 操作的过程，APP 发起一个 BLE 操作，然后理解返回，操作结果通过回调上报。操作被封装为一个消息，然后放到协议栈的消息队列中，有一个独立的线程获取消息进行处理，类似于 Looper 和 Handler 机制。 因为是使用消息机制，回调的时候必须知道通知哪个客户端？客户端发起请求之前，首先要向协议栈注册客户端，注册成功以后，返回一个 clientIf，这是一个整型，是客户端在协议栈的一个句柄，客户端的后续操作，都只需要带上这个 clientIf 句柄即可。 在操作完成的时候，一般都有一个显式的停止操作，用来释放前面的申请的 clientIf 和资源。如果不能正确的释放，不仅会造成内存泄漏，而且可能会导致后续所有的 BLE 操作都是不能做了。因为这个 clientIf 是有限，在现在蓝牙协议栈中只有 32 个，而且是Android 上所有 APP 共用的。当这些资源用完以后，只有通过杀掉对应的 APP 或者重启蓝牙才能恢复。 BLE 应用BLE 应用可以分为两大类：基于非连接的和连接的。 Beacon 基于非连接的，这种应用就是依赖 BLE 的广播，也叫作 Beacon。这里有两个角色，发送广播的一方叫做 Broadcaster，监听广播的一方叫 Observer。 基于连接的，就是通过建立 GATT 连接，收发数据。这里也有两个角色，发起连接的一方，叫做中心设备—Central，被连接的设备，叫做外设—Peripheral。 非连接它的网络拓扑结构如下。我们知道广播是单向的，Broadcaster 向外广播，监听者接收附近的广播，整体来说形成一个单向的星型。网络中可以有多个外设，也可以有多个监听者 还有些设备，可以同时实现两个角色，既能发送广播，也可以接收广播。一个设备接收到广播，可以通过处理，然后再转发出去，这样就可以形成一个双向的网格，这就是蓝牙的 Mesh。这样的网络可以不受蓝牙传输距离限制了，只要在空间中布置足够密集的节点，就能把信息从网络一点，传递到任何一点。这个可以应用在物联网和智能家居系统中。 前面在介绍协议栈物理层的时候，我们知道广播只在37、38、39这三个广播频道进行广播，监听者也在这三个频道进行监听。我们前面介绍了，蓝牙通信是跳频的，只有双方设备在某个时刻跳到同一个频到上，才能收到广播，这种传播数据效率比较低，数据量也有限，不适合大规模的数据传输。 广播包 ​ 广播数据其实包含两部分：Advertising Data（广播数据） 和 Scan Response Data（扫描响应数据）。通常 情况下，广播的一方，按照一定的间隔，往空中广播 Advertising Data，当某个监听设备监听到这个广播数据时 候，会通过发送 Scan Response Request，请求广播方发送扫描响应数据数据。这两部分数据的长度都是固定的 31 字节。在 Android 中，系统会把这两个数据拼接在一起，返回一个 62 字节的数组。 广播数据包的结构如这个图所示。广播包中是包含一个一个的小 AD structure，每个 AD structure 是一个完整的数据，它的结构是：第一个字节表示长度 n，后面紧接 n 个字节的数据。数据部分第一个字节表示数据类型，也就是后面的数据含义，后面 n - 1 个字节表示真实数据. 这些广播数据可以自己手动去解析，在 Android 5.0 也提供 ScanRecord 帮你解析，直接可以通过这个类获得有意义的数据。 广播数据类型：设备连接属性，标识设备支持的 BLE 模式，这个是必须的。设备名字，设备包含的关键 GATT service，或者 Service data，厂商自定义数据等等。 RSSI （信号强度 ）：RSSI 单位是 dB，通过 RSSI 能够大致推测出距离的远近。但是这个在 Android 设备上非常不靠谱，RSSI 的值波动很大，跟环境和手机的角度关系很大。 ​ Android 作为接收者怎么接收广播数据，扫描设备。代码其实很简单，首先创建一个 LeScanCallback，用来接收收到广播以后，回调上报数据。然后会用 BluetoothAdapter 的 startLeScan 来开始扫描，需要停止扫描的时候，使用 stopLeScan 来停止。 有 BluetoothDevice 这个参数，代表扫描到的设备，关键是设备的的 MAC 地址信息。然后就是 RSSI，表示扫描到的设备的信号强度，接下来 scanRecord 就是我们前面介绍的广播数据，这个数据的长度是62字节。值得提的一点是，BLE 所有回调函数都不是在主线程中的。 这里有几点需要注意，这里在不需要扫描以后，一定要 stopLeScan，而且 start 和 stop 中传入的 LeScanCallback 一定要是同一个，因为 LeScanCallback 就是我们客户端的标识。否者就会出现我们前面说的 clientIf 不释放的问题。在 Android 开发中，我们经常会使用匿名内部类来做参数，在这里就千万不要这么做。 在 Android 5.0 中，提供了全新的扫描 API — BluetoothLeScanner，它提供了对扫描更加精细的控制。 除了这种方法，还可以使用经典蓝牙扫描的方式，BluetoothAdapter 的 startDiscovery()，然后通过 BroadcastReceiver 来接收收到的广播。如果只是做 BLE 的开发，不建议使用这个方法，这是一个非常重的操作，灵活性非常差。 扫描的工作流程 ​ 首先 APP 发起扫描请求，通过蓝牙的 Service 发送请求给蓝牙芯片。蓝牙芯片开始扫描，扫描到了设备，就通过回调上报。我们知道，扫描真正执行实在 BT 芯片中，只要 APP 发送了请求下去以后，Android 系统就可以休眠了，也就是我们常说的 AP （Application Processor），等扫描到了设备以后，底层 BP （Baseband Processor）就会唤醒上层 AP，执行回调通知到 APP，（动画）就像我们图中红色框标出的这样。这里有一个问题，随着我们周围的 BLE 设备逐渐增多，频繁扫描到设备，系统就会被频繁的唤醒，甚至睡眠不下去，从而导致耗电严重。 为了避免这种问题，耗电的问题。我们需要尽可能少的使用扫描。即使需要扫描，我们也希望尽可能少的上报扫描到的设备。这里就可以使用 Android 5.0 上提供的新接口，设置 ScanFilter，通过一定的规则过滤，只有扫描到了符合我们的规则的设备才上报，或者通过设置延迟上报，从而减少唤醒系统的次数。 这里总结一下扫描中一些建议。1、首先，尽可能使用新的 API，功能更强大；2、尽可能少地扫描，因为毕竟扫描是一个比较重的操作，耗电，也会减慢 BLE 连接速度；3、扫描的时候，尽量设置 ScanFilter，只扫描那些你感兴趣的设备，而不是全盘扫描；4、正确使用 API，特别是合理停止扫描，防止资源泄漏。 Android手机 作为 Broadcaster 从 Android 5.0 开始，Android 设备就可以像外设一样发送 BLE 广播了。这时 Android 设备之间就可以通过 BLE 来交互数据，或者发现对方设备了，例如类似 NFC 一样交换简单信息的应用，想象空间还是很大的。 Android 中实现的代码如下，通过前面的介绍，我们知道广播有两种包：Advertising Data 和 Scan Response Data，我们这里设置好这两种包，然后通过 BluetoothLeAdvertier 的 startAdvertising 就可以了。这里需要注意的点和前面一样，Start 了，需要注意 Stop。 基于连接BLE 连接的建立是通过 GAP 来协商和创建连接。Central 设备发起连接，外设接收连接请求，并协商连接参数。 前面我们介绍了 GATT，GATT 核心内容就是 Service、Characteristic 以及 Descriptor。每个 BLE 外设，根据自己的功能，向外暴露 Service 等。其实最重要的获取 Service 中的 Characteristic，Characteristic 可以被读、写、还有变化的时候有通知，这样就实现了双向的通信。 ​ 连接到GATT服务器（发送数据的BLE设备） https://blog.csdn.net/Roshen_android/article/details/76916111 https://www.race604.com/android-ble-in-action/ http://yannischeng.com/Android%20BLE%20%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/","categories":[{"name":"BLE","slug":"BLE","permalink":"https://noteforme.github.io/categories/BLE/"}],"tags":[]},{"title":"Bluetooth01","slug":"Bluetooth01","date":"2018-07-04T10:37:45.000Z","updated":"2025-02-04T13:52:45.081Z","comments":true,"path":"2018/07/04/Bluetooth01/","link":"","permalink":"https://noteforme.github.io/2018/07/04/Bluetooth01/","excerpt":"","text":"蓝牙名称的由来 蓝牙这个名称来自于第十世纪的一位丹麦国王Harald Blatand,Blatand在英文里的意思可以被解为蓝牙， 因为国王喜欢吃蓝梅，牙龈每天都是蓝色的所以叫牙. 蓝牙这个标志的设计：它取自 Harald Bluetooth 名字中的「H」和「B」两个字母，用古北欧字母来表示，将这两者结合起来，就成为了蓝牙的 蓝牙技术联盟官网 它负责蓝牙规范制定和推广的国际组织。做蓝牙相关产品的，少不了和它打交道。蓝牙技术联盟同时也拥有蓝牙商标，如果要使用，需要通过他们的授权。 Bluetooth SIG 蓝牙个版本区别 ​ http://www.sohu.com/a/204758166_100040477 V1.0：定义了蓝牙是一种低功耗的无线技术，传输率约在748~810kb&#x2F;s，因是早期设计，容易受到同频率之产品所干扰下影响通讯质量。 V1.1所有设备都使用79个子频段在2.4GHz的频谱范围之内进行相互通信。此外，Bluetooth 1.1规范也修正了互不兼容的数据格式会引发Bluetooth 1.0设备之间的互操作性问题. V1.2增加了AFH可调式跳频技术这项技术，并主要针对现有蓝牙协议和802.11b&#x2F;g之间的互相干扰问题进行了全面的改进，防止用户在同时使用支持蓝牙和无线局域网(WLAN)的两种装置的时候出现互相干扰的情况。 V2.0 蓝牙2.0标准2.0 是 1.2 的改良提升版，传输率约在 1.8M&#x2F;s~2.1M&#x2F;s 开始支持双工模式——即一面作语音通讯，同时亦可以传输档案&#x2F;高质素图片 2.0 版本当然也支持 Stereo 运作。 V2.1支持通过NFC（Near Field Communication，近距离通讯）进行配对，只需要将两个蓝牙设备靠近，按下一个键就可以配对了，配对密码将通过NFC进行传输，无需手动输入。 V3.0核心是加入了“Generic Alternate MAC&#x2F;PHY”（AMP），使蓝牙设备能最大限度的利用多种高速无线技术中更高的传输速率。这是一种全新的交替射频技术，允许蓝牙协议栈针对任一任务动态地选择正确的射频。 4.0 首先需要说明的是，发布于2010年的蓝牙4.0标准，本身就包含两个蓝牙标准——它包含传统蓝牙部分（也有称之为经典蓝牙Classic Bluetooth），也包含有低功耗蓝牙部分（Bluetooth Low Energy）。所以，毫无疑问的，低功耗蓝牙BLE属于蓝牙4.0！ 蓝牙4.0的两个部分适用于不同的产品和应用场景，如传统蓝牙部分是在之前的1.0、2.0、3.0等基础上发展和完善起来的，主要用于和此前版本蓝牙1.0、2.0、3.0的兼容以及数据量比较大的传输，如语音，音乐，较高数据量传输等。 而低功耗蓝牙部分是在Nokia的Wibree标准上发展起来的。主要用于和蓝牙4.0以及更高标准版本的兼容 ，以及用于数据传输速率比较低的产品，如遥控类的，如鼠标，键盘，遥控鼠标(Air Mouse)，传感设备的数据发送，如心跳带，血压计，温度传感器等。 由于蓝牙4.0集成了传统蓝牙和低功耗蓝牙两个标准，所以蓝牙4.0有双模和单模之分。双模即是传统蓝牙部分+低功耗蓝牙部分，单模即是单纯的低功耗蓝牙部分（BLE）。 一台装配有蓝牙4.0双模模块的手机，当其配对连接的是蓝牙3.0设备时，其耗电量就会相对较高。若其配对的设备是智能手环等采用低功耗蓝牙模块的设备时，其功耗就非常低。针对一对一连接优化，并支持星形拓扑的一对多连接； https://www.jianshu.com/p/c96e0006b34d ​ 单模蓝牙 ​ 双模蓝牙 V 4.1 提升数据传输率 相比蓝牙4.0，蓝牙4.1单包数据传输最大值从20字节上调到23字节，提升了15%的数据传输率。根据该规则，大家可以尝试修改单包数据payload的值，如果该芯片只支持BT4.0，那么修改传输23字节要么会编译报错，要么传输过程中会丢包。 主从共存 central peripheral 链路层Link layer拓扑结构做了更新，允许单设备主从同时共存（时间片轮转方式），以及一主对多从设备的连接拓扑,当BLE作Central的时候可以一对多，但是作Peripheral的时候只能一对一。 例如智能手表可以作为发射方向手机发射身体健康指数，同时作为接收方连接到蓝牙耳机&#x2F;手环或其他设备上 支持32-Bit UUID 32-Bit UUID指的是广播包携带的UUID，并不是指我们所说的针对属性列表的16 bit and 128 bit UUID。可以通过广播的32-Bit UUID映射得到完整的128 Bit UUID从而使得广播包内有效广播数据长度更多。 长期睡眠下的自动唤醒功能。例如在佩戴手环游泳1小时后，回到更衣室手环会自动和手机建立连接传输数据，不需要任何操作 通过IPv6建立网络连接。蓝牙设备只需要通过蓝牙4.1连接到可以上网的设备（如手机），就可以通过IPv6与云端的数据进行同步。即实现“云同步”不再需要wifi连接（wifi模块的成本通常更高，也更费电）。通过IPv6建立网络连接。蓝牙设备只需要通过蓝牙4.1连接到可以上网的设备（如手机），就可以通过IPv6与云端的数据进行同步。即实现“云同步”不再需要wifi连接（wifi模块的成本通常更高，也更费电） V 4.2 LE连接安全 从Spec定义上蓝牙4.0和4.1的配对加密环节都是基于AES-CCM加密，但是由于蓝牙4.1双方共享同一密钥，所以存在被破解风险和漏洞。蓝牙4.2的pairing环节，采用Diffie-HellmanKey Exchange密钥交换算法进行加密，每一个设备有一对密钥对，公钥和私钥，私钥自己保存，公钥公开给对方，数据交互时，一方通过自己的私钥和对方的公钥进行加密文件，接收方通过自己私钥和传输方的公钥进行解密，从而有效的防止中间人破解密钥的事件发生。 隐私保护 蓝牙在广播过程中会携带自己的BD address (bluetooth device address)即为蓝牙唯一的MAC地址，在某些应用，比如物流追踪应用当中是非常有帮助的，可以根据BD address固定物流设备。 但是在某些应用不希望自己的BD address暴露在主端设备的监控下，蓝牙4.2给出了灵活的选择，蓝牙4.2规定，从机设备可以选择在广播模式下发送随机BD address，这样主端设备除了接该到设备之后才能获取其真实BD address，除此该设备广播模式的BD address为随机序列。 大数据传输 蓝牙4.1最大支持23字节单包数据传输，蓝牙4.2最大支持255字节单包数据传输，极大提升了数据传输率。详细可以参考我写的另外一篇文章《提升蓝牙4.2数据传输率的办法 - ATT_MTU》。 5.0 传输距离更快、距离更远 蓝牙 5.0 和前一代蓝牙 4.2 相比，它的传输距离更远、速度更快。理论上的有效距离是 300 米，也就是整个家庭或整间办公室里的移动设备都可以稳定连结。而速度最快则是可以达到 2Mbps，让反应更快、性能更高的蓝牙设备更有可能被使用。除此之外，它还大幅增强了蓝牙广播的数据传输，能为商用蓝牙带来更好的前景，让使用蓝牙做为标准的物联网应用更加强大，可以向下相容旧版本产品 。 蓝牙 Mesh 技术改变传输应用 蓝牙技术联盟（Bluetooth SIG）日前宣布推出蓝牙 Mesh 技术，这项技术将打破传统蓝牙设备间“一对一”的配对转变成“多对多”的讯号传输模式，除了应用在蓝牙 5.0，也会扩展到过往版本。蓝牙技术联盟表示，蓝牙 Mesh 技术是基于低功耗蓝牙技术推出的新网络技术，将为商用和工业用设备网络带来转变，也能让现有的物联网技术更加完整、稳定。 http://www.eet-china.com/news/article/201711190911 蓝牙5.0和wifi的区别 WIFI Wi-Fi 的一大缺陷就是有距离限制，包括过去一对一蓝牙网络在内的传统无线网络，都会受两台设备距离的限制。以 Wi-Fi 来说，有效的传输距离为 50 平方米以内，除非你装中继设备，一旦离开这个区域，你的手机就失去用武之地。 除此之外，Wi-Fi 还有耗电问题，你的手机就算是把屏幕关闭，还是得一天充一次电，Wi-Fi 是一个很重要的因素。 蓝牙 Mesh “蓝牙 Mesh”找到一个聪明的解决办法。这些设备彼此间连接，并将信号传递给附近另一个设备，形成中继资料传输的互连设备网络或网格。这意味着讯息从一个设备传递到另一个设备，再到下一个设备，接力传输。 ▲ 左图为传统 Wi-Fi 的连接方式，必须要有一个 Hub 连系其他设备，因此有距离限制。右图则是蓝牙 Mesh 的方式，越多设备连到这个网络上，范围就会越广。 与传统的交换式网络相比，无线Mesh网络去掉了节点之间的布线需求，但仍具有分布式网络所提供的冗余机制和重新路由功能。在无线Mesh网络里，如果要添加新的设备，只需要简单地接上电源就可以了，它可以自动进行自我配置，并确定最佳的多跳传输路径。添加或移动设备时，网络能够自动发现拓扑变化，并自动调整通信路由，以获取最有效的传输路径。 透过这种接力传输，形成一个无需大量电力消耗或天线广布的可靠网络。蓝牙设备之间可不透过 Wi-Fi 网络就能实现设备与设备的“对话”。换句话说，智能设备采用这种技术，在有限范围内就能完成设备间的沟通，并利用手机等设备来控制。 过去因为家中需要有一个 Hub 连接其他设备，因此有 Google、Apple、Amazon 等这些“语音助手”出现，用这些当成控制中枢。但蓝牙 Mesh 架构下，你不需要另外一个“中枢”，用智能手机就可以掌握一切。家中的蓝牙设备建构自己的网络，手机只要与其中一个蓝牙设备取得联系，就可以控制全家（整个建筑物）设备，监控这些设备的状态。 由于 Mesh 网络不需复杂设定、配对或使用路由器等存取设备，因此并不会造成安装负担，反观采用其他智慧家庭联网技术如 ZigBee、Z-wave 或其他厂商间自有的通讯技术，多需加装闸道器（Gateway）才能确保各种设备沟通无虞。 蓝牙 Mesh 工作原理：为什么还是无法取代 Wi-Fi？ 蓝牙 BLE 通讯协议中，GAP 层（Generic Access Profile）用来控制决定蓝牙设备的扫描、广播和连接等关系，也就是说，GAP 决定蓝牙设备怎样与其他设备连接、被其他设备看到等流程。 在蓝牙 mesh 出现之前，GAP 有一个典型的父子网络关系，其中“父”端决定所有路由，“子”端执行分配的任务。 例如，当你将蓝牙键盘连接到平板电脑，平板为父端、键盘为子端。 GAP 使你的设备被其他设备看见，并决定你的设备是否可以或怎样与其他设备互动。例如常用在室内定位的 Beacon 设备就只是向外广播，不支持连接。智能手环等设备，就可以与你的手机设备连接。 从蓝牙 4.1 开始，GAP 扩大了蓝牙设备的网络能力。蓝牙设备可兼具“父”和“子”的功能，使所有设备能直接连接和广播到任何其他设备。蓝牙也因此适用传输范围内和传输范围外的所有设备。 正是上述这种能直接或间接连接任何数量有 Mesh 功能的设备，因此理论上建构一个长达几公里范围的 Mesh 网络也不是不可能。 如果网络中每个设备都在其他至少一个设备的广播范围内，Mesh 网络理论上可覆盖无限距离。 在这情况下，灯泡就可能成为一个家庭主要 Mesh 网络设备之一，因为一个家庭或是建筑，几乎每个角落都有光线覆盖的需要，因此灯泡就会以保持一定距离的方式连续安装。如果每个灯泡都是蓝牙 Mesh 设备，那么这个网络就得以全面覆盖建筑物。 蓝牙 Mesh 网络不仅有低功耗，还有低频宽的特色。这听起来好像是个缺点？其实不然。 由于蓝牙 Mesh 网络不是用来让你发送影音资料，主要是用来传递维护连接或发送命令，发送一个“关闭”或“打开”的指定，用不到多少频宽。这就是为什么蓝牙 Mesh 网络虽然范围无远弗届，但无法完全取代 Wi-Fi。 乍看很像，但仔细了解后，你会发现它们适合不同的利基市场。 http://www.icsmart.cn/13985/ https://en.wikipedia.org/wiki/Bluetooth#Communication_and_connection","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"Zigbee","slug":"Zigbee","date":"2018-06-20T08:51:26.000Z","updated":"2021-08-19T11:11:44.292Z","comments":true,"path":"2018/06/20/Zigbee/","link":"","permalink":"https://noteforme.github.io/2018/06/20/Zigbee/","excerpt":"","text":"https://blog.csdn.net/qq_34581118/article/details/78452316 0000 01010001 0000 0001 0101 = 1 * 2^4+ 1*2^2 + 1 = 21 = 0X15 12301 02 10 11 02 10 02 10 11 03 10 10 10 10 01 00 11 00 00 11 03 https://blog.csdn.net/feiyangxiaomi/article/details/9257375 https://juejin.im/post/5b124346e51d450684732790","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"VideoNDK","slug":"VideoNDK","date":"2018-06-14T01:21:28.000Z","updated":"2021-08-19T11:11:44.263Z","comments":true,"path":"2018/06/14/VideoNDK/","link":"","permalink":"https://noteforme.github.io/2018/06/14/VideoNDK/","excerpt":"","text":"指针1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char * argv[]) &#123; // insert code here... char* p = (char*)malloc(10); //字符型指针 malloc堆空间分配内存 *p = &#x27;a&#x27;; *(p+1) = &#x27;b&#x27;; *(p+2) = &#x27;c&#x27;; free(p); // p = NULL; printf(&quot;%s \\n&quot;,p); &#125; 输出 abc 指针函数:带指针的函数 函数的返回值为指针类型 函数声明 : int* func(int x,int y) 指针函数调用 12char *q;q = func(m); // q与被调用的函数的返回类型一致 示例112345678910111213141516171819202122#include &lt;stdio.h&gt;char *getWord(char c)&#123; switch (c) &#123; case &#x27;A&#x27;: return &quot;Apple&quot;; case &#x27;B&#x27;: return &quot;Banana&quot;; case &#x27;C&#x27;: return &quot;Cat&quot;; case &#x27;D&#x27;: return &quot;Dog&quot;; default:return &quot;None&quot;; &#125;&#125;int main(int argc, const char * argv[]) &#123; char input; printf(&quot;please input a charactar:&quot;); input = getchar(); printf(&quot;%c\\n&quot;,input); printf(&quot;%s\\n&quot;,getWord(input)); getchar(); return 0;&#125; 运行结果 123please input a charactar:AAApple 输入A ，getWord()返回值为 Apple的首地址,printf(“%s\\n),输出首地址所指向的值 示例212345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;char *getWord2(char c)&#123; char str1[] = &quot;Apple&quot;; char str2[] = &quot;Banana&quot;; char str3[] = &quot;Cat&quot;; char str4[] = &quot;Dog&quot;; char str5[] = &quot;None&quot;; switch (c) &#123; case &#x27;A&#x27;: return str1; case &#x27;B&#x27;: return str2; case &#x27;C&#x27;: return str3; case &#x27;D&#x27;: return str4; default:return str5; &#125;&#125;//#if (0)int main(int argc, const char * argv[]) &#123; char input; printf(&quot;please input a charactar:&quot;); input = getchar(); printf(&quot;%c\\n&quot;,input); printf(&quot;%s\\n&quot;,getWord2(input)); getchar(); return 0;&#125;//#endif 注意: 不要返回局部变量的指针 例子2中,str1数组是局部变量，这个字符数组在子程序结束后，它对应的存储空间会被释放. 函数指针：指向函数的指针指向函数起始地址的指针 函数指针的定义 int (*fptr)(int,int) // (*func)中括号是必要的，这会告诉编译器我们声明的是函数指针而不是声明一个具有返回型为指针的函数 指针变量 : *fptr , 如果*fptr变为函数名，整个就是一个函数 函数指针的使用 fptr = func; int x = fptr(5,8); “%x “ 打印指针本身 示例 1234567891011121314151617181920#include &lt;stdio.h&gt;int square(int num)&#123; return num * num;&#125;int main(int argc, const char * argv[]) &#123; int num; int (*fp)(int); // fp是一个指针，指向返回类型为int，参数为int的函数. printf(&quot;please input a number:&quot;); scanf(&quot;%d&quot;,&amp;num); fp = square; // 函数与指针的联系 printf(&quot;fp = 0x%x, %d\\n&quot;,fp,(*fp)(num)); //&#x27;0x%x&#x27; 打印指针本身 printf(&quot;fp = 0x%x, %d\\n&quot;,fp,fp(num)); // fp直接调用也可以 return 0; &#125; square内存中占据的位置，fp保存square指针的入口地址,fp指向square(),*fp代表 调用square(). 用法 123456789101112131415161718192021#include &lt;stdio.h&gt;int add(int num1,int num2)&#123; return num1+num2;&#125;int sub(int num1,int num2)&#123; return num1-num2;&#125;int calculate(int (*fp)(int,int),int num1,int num2)&#123; //通用功能的函数 return (*fp)(num1,num2);&#125;int main(int argc, const char * argv[]) &#123; printf(&quot;3+5=%d\\n&quot;,calculate(add,3,5)); printf(&quot;3-5=%d\\n&quot;,calculate(sub,3,5)); return 0;&#125; 函数指针数组 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;void function1(int);void function2(int);void function3(int);void function1(int choice)&#123; printf(&quot;input %d, run function1().\\n &quot;,choice);&#125;void function2(int choice)&#123; printf(&quot;input %d, run function2().\\n &quot;,choice);&#125;void function3(int choice)&#123; printf(&quot;input %d, run function3().\\n &quot;,choice);&#125;#if(1)int main(int argc, const char * argv[]) &#123; void (*f[3])(int) = &#123;function1,function2,function3&#125;;//f[3] f是有3个元素的数组，数组的每个元素是指针类型,每个指针指向 参数为(int)类型的函数 int choice; printf(&quot;please enter a digit : [0-2]: &quot;); scanf(&quot;%d&quot;,&amp;choice); while (choice&gt;0&amp;&amp;choice&lt;3) &#123; (*f[choice])(choice); printf(&quot;please enter a digit : [0-2]: &quot;); scanf(&quot;%d&quot;,&amp;choice); &#125; printf(&quot;run end&quot;);&#125;#endif https://www.bilibili.com/video/BV15J411Q7t9?from=search&amp;seid=1110914330533311902 函数指针pft指向了一个已经声明的函数bar()，然后通过pft来实现输出字符和整型的目的。 123456789101112void bar(char, int);typedef void (*PFT)(char, int);int main()&#123; PFT pft; pft = bar; pft(&#x27;e&#x27;,91);&#125;void bar(char ch,int i)&#123; cout&lt;&lt; &quot; bar &quot;&lt;&lt;ch&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl; return;&#125; 函数指针作为函数的参数，我们可以在一个函数的形参列表中传入一个函数指针， 然后便可以在这个函数中使用这个函数指针所指向的函数 123456789101112131415161718typedef void (*PFT)(char, int);void bar(char ch, int i) &#123; cout &lt;&lt; &quot;bar &quot; &lt;&lt; ch &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; endl; return;&#125;void foo(char ch, int i, PFT pf) &#123; pf(ch, i); return;&#125;int main() &#123; PFT pft; pft = bar; foo(&#x27;e&#x27;, 12, pft);&#125; 函数对象 12345678910class A &#123;public: int operator()(int x) &#123; return x; &#125;&#125;;int main()&#123; A a; cout&lt;&lt;a(5)&lt;&lt;endl;&#125; 123456789101112131415161718class Func &#123;public: int operator()(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; &#x27;+&#x27; &lt;&lt; b &lt;&lt; &#x27;=&#x27; &lt;&lt; a + b &lt;&lt; endl; return a; &#125;&#125;;int addFunc(int a, int b, Func &amp;func) &#123; func(a, b); return a;&#125;int main() &#123; Func func; addFunc(1, 3, func);&#125; 结构体结构指针point 1234567struct point *pp; struct point pt = &#123;400,600&#125;; pp = &amp;pt; printf(&quot;pt %d, %d \\n&quot;,pt.x, pt.y);//(*pp.x)中的圆括号是必须的，因为结构成员运算符的 &quot;.&quot; 的优先级比先级高 printf(&quot;*pp %d, %d \\n&quot;,(*pp).x, (*pp).y); printf(&quot;pp-&gt; %d, %d \\n&quot;,pp-&gt;x, pp-&gt;y); 运行 1234pt 400, 600 *pp 400, 600 pp-&gt; 400, 600 结构指针的使用频度非常高，C语言提供了另一种简写方式，假定P指向一个结构的指针，可以用 p-&gt; 结构成员 == *p.结构成员 代码表达式printf(&quot;origin is (%d,%d)\\n&quot;, pp-&gt;x, pp-&gt;y); 123456struct rect r = &#123;&#123;200,300&#125;,&#123;400,500&#125;&#125;; struct rect *rp = &amp;r; printf(&quot;pt1.x %d \\n&quot;,r.pt1.x); printf(&quot;(*rp).pt1.x %d \\n&quot;,(*rp).pt1.x); printf(&quot; rp-&gt;pt1.x %d \\n&quot;,rp-&gt;pt1.x); printf(&quot;r.pt1.x %d \\n&quot;,r.pt1.x); 运行结果 1234pt1.x 200 (*rp).pt1.x 200 rp-&gt;pt1.x 200 r.pt1.x 200 动态内存分配1234567891011121314151617181920212223 int a[5] = &#123;4,10,2,8,6&#125;; int len; printf(&quot;请输入你需要分配的数组的长度：len = &quot;); scanf(&quot;%d&quot;,&amp;len); /** * sizeof(int) *len 分配len个int字节的长度，len =5时，就是20个字节 * malloc返回 指向 第一个字节的地址 * int * 第一个字节的地址，代表Int类型地址， pArr等价于a， pArr+1代表第二个Int地址 */ int *pArr = (int *)malloc(sizeof(int) *len); *pArr = 5; //类似于 a[0] =4; pArr[1] = 10; //类似于a[1]=10;// printf(&quot;%d %d &quot;,*pArr,pArr[1]); for (int i = 0; i &lt;len ; ++i) &#123; scanf(&quot;%d&quot; , &amp;pArr[i]); &#125; for (int i = 0; i&lt;len ; ++i) &#123; printf(&quot;%d\\n &quot; , *(pArr+i)); &#125; free(pArr); //把pArr所代表的动态分配的20个字节的内存释放 结构体变量(hao)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;memory.h&gt;struct Student &#123; int sid; char name[200]; int age;&#125;;void g(struct Student student);void g2(struct Student *pst);void f(struct Student *pst);int main() &#123; struct Student st = &#123;1000, &quot;张三&quot;, 20&#125;; printf(&quot;%d %s %d\\n&quot;, st.sid, st.name, st.age); st.sid = 99;// st.name = &quot;lili&quot;; //error strcpy(st.name, &quot;lili&quot;);//复制 st.age = 22; printf(&quot;%d %s %d\\n&quot;, st.sid, st.name, st.age); struct Student *pst; pst = &amp;st; pst-&gt;sid = 99; // pst -&gt; sid 等价于 (*pst).sid 而(*pst).sid 等价于 st.sid // pst -&gt; sid // 所指向的结构体变量的sid这个成员 g(st); g2(&amp;st); return 0;&#125;void g2(struct Student *pst) &#123; printf(&quot;g2 %d %s %d\\n&quot;, pst-&gt;sid, pst-&gt;name, pst-&gt;age);&#125;//这种方式多耗 208 内存，耗时间 不推荐void g(struct Student st) &#123; printf(&quot;g %d %s %d\\n&quot;, st.sid, st.name, st.age);&#125; 跨函数使用内存123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct Student&#123; int sid; int age;&#125;;struct Student *createStudent(void);void showStudent(struct Student *pst);int main()&#123; struct Student *ps; ps = createStudent(); showStudent(ps);&#125;void showStudent(struct Student *pst) &#123; printf(&quot;%d %d\\n&quot;,pst-&gt;sid,pst-&gt;age);&#125;struct Student *createStudent() &#123; struct Student *p = malloc(sizeof(struct Student)); //表示 struct Student整体的数据类型代表的字节数 p-&gt;sid = 99; p-&gt;age = 88; return p;&#125; 运算符优先级 java运算符优先级 ! &amp;&amp; || 算法https://space.bilibili.com/501486236/video typedef 别名type_1 12345678910111213141516171819typedef int ZHANGSAN;//为int再重新多取一个名字，ZHANGSAN等价于inttypedef struct Student &#123; int sid; char name[100]; char sex;&#125; ST;int main(void) &#123; int i = 10; //等价于 ZHANGSAN i = 10; ZHANGSAN j = 20; printf(&quot;%d\\n&quot;, j); struct Student st;//等价于 ST st; struct Student *ps = &amp;st; // 等价于 ST * ps ST st2; st2.sid = 200; printf(&quot;%d\\n&quot;,st2.sid);&#125; type_2 12345678910111213typedef struct Student &#123; int sid; char name[100]; char sex;&#125; * PST ; //PST等价于 struct Student * ,这样就是一个指针类型了int main(void)&#123; struct Student st; PST ps = &amp;st; ps-&gt;sid = 99; printf(&quot;%d\\n&quot;,ps-&gt;sid); return 0;&#125; type_3 12345678910111213typedef struct Student &#123; int sid; char name[100]; char sex;&#125; * PSTU, STU; //等价于 ST代表了 struct Student st, PST 代表了struct Student *;int main(void) &#123; STU st; //等价于 struct Student st; PSTU ps = &amp;st; //struct Student * ps = &amp;st; ps-&gt;sid = 99; printf(&quot;%d\\n&quot;,ps-&gt;sid); return 0;&#125; C++引用 1C++ 引用引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量 12345678910111213141516#include &lt;iostream&gt;using namespace std;void swap(int &amp;x, int &amp;y) &#123; int t = x; x = y; y = t;&#125;int main() &#123; int a = 3, b = 4; cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; swap(a, b); cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl;&#125; 函数模板123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;T add(T x,T y)&#123; return x+y;&#125;int main()&#123;#if 0 cout&lt;&lt;add&lt;int&gt;(5,3)&lt;&lt;endl; cout&lt;&lt;add&lt;double &gt;(5.3,7.8)&lt;&lt;endl; cout&lt;&lt;add&lt;int&gt;(4,6)&lt;&lt;endl; cout&lt;&lt;add&lt;string&gt;(&quot;hello&quot;,&quot;world&quot;)&lt;&lt;endl;#else //类型自动推断 cout&lt;&lt;add(5,3)&lt;&lt;endl; cout&lt;&lt;add(5.3,7.8)&lt;&lt;endl; cout&lt;&lt;add(4,6)&lt;&lt;endl; cout&lt;&lt;add((double)5,7.8)&lt;&lt;endl;#endif&#125; swift语法1234567891011121314151617181920212223242526272829303132333435363738394041424344var a = 10var b: Int = 20let aa = 40 //constif a&lt;20&#123; print(&quot;a &lt; 20 , true&quot; )&#125;else&#123; print(&quot;a &gt;= 20&quot;)&#125;switch a &#123; case 10: print(&quot;a equals 10&quot;)case 20: print(&quot;a equals 20&quot;)default : print(&quot;other&quot;)&#125;print(&quot;Hello, World!&quot;)for i in 25..&lt;100&#123; print(&quot;aa,i=&quot;,i)&#125;var list = [1,2,3,4,5]for i in list&#123; print(&quot;aa, i=&quot;,i);&#125;var loop = 0while loop&lt;10 &#123; print(&quot;loop, xxx = &quot;,loop) loop = loop + 1&#125;func myFunc(a : Int) -&gt; Int&#123; print(&quot;this is a function&quot;,a) return a&#125;var mm = myFunc(a: 10)print(&quot;Hello, World!&quot;,a,b,aa,mm) environmenthttps://juejin.im/post/5ad98412518825670960c13c https://developer.android.com/ndk/","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"Bluetooth03","slug":"Bluetooth03","date":"2018-06-11T01:41:39.000Z","updated":"2024-10-02T01:36:33.502Z","comments":true,"path":"2018/06/11/Bluetooth03/","link":"","permalink":"https://noteforme.github.io/2018/06/11/Bluetooth03/","excerpt":"","text":"经典蓝牙 低功耗蓝牙的区别http://www.loverobots.cn/the-analysis-is-simple-compared-with-the-classic-bluetooth-and-bluetooth-low-energy-in-android.html 蓝牙适配建议 蓝牙低功耗 ​ Android 4.3 为发挥核心作用的蓝牙低功耗（蓝牙 LE）引入了平台支持。在 Android 5.0 中，Android 设备现在可以发挥蓝牙 LE 外围设备的作用。应用可以利用此功能让附近设备发现它。例如，您可以开发这样的应用：让设备发挥计步器或健康监测仪的作用，并与其他蓝牙 LE 设备进行数据通信。 新增的 android.bluetooth.le API 让您的应用可以发布广告、扫描响应以及与附近的蓝牙 LE 设备建立连接。要使用新增的广告和扫描功能，请在您的清单中添加 BLUETOOTH_ADMIN 权限。当用户更新您的应用或从 Play 商店下载您的应用时，会被要求向您的应用授予以下权限：“Bluetooth connection information:Allows the app to control Bluetooth, including broadcasting to or getting information about nearby Bluetooth devices.” 要启动蓝牙 LE 广播，以便其他设备能发现您的应用，请调用 startAdvertising()，并传入 AdvertiseCallback 类的实现。回调对象会收到广播操作成功或失败的报告。 Android 5.0 引入了 ScanFilter 类，让您的应用可以只扫描其感兴趣的特定类型设备。要开始扫描蓝牙 LE 设备，请调用 startScan()，并传入筛选器列表。在方法调用中，您还必须提供 ScanCallback 的实现，以便在发现蓝牙 LE 广播时进行报告。 蓝牙基本操作蓝牙权限1&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt; 如果您希望您的应用启动设备发现或操作蓝牙设置，则还必须声明 BLUETOOTH_ADMIN 权限。 大多数应用需要此权限仅仅为了能够发现本地蓝牙设备。 除非该应用是将要应用户请求修改蓝牙设置的“超级管理员”，否则不应使用此权限所授予的其他能力。 注：如果要使用 BLUETOOTH_ADMIN 权限，则还必须拥有 BLUETOOTH 权限。 如打开关闭蓝牙 1&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt; 6.0权限12&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt; 设置蓝牙 判断设备是否支持 BluetoothAdapter 12345mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // Device does not support Bluetooth&#125; 启用蓝牙 12345if (mBluetoothAdapter==null||!mBluetoothAdapter.isEnabled())&#123; Toast.makeText(this,&quot;设备不支持蓝牙权限&quot;,Toast.LENGTH_SHORT).show(); &#125;else &#123; Toast.makeText(this,&quot;支持设备&quot;,Toast.LENGTH_SHORT).show(); &#125; 查找设备5.0以下的方式就不贴出来了，代码里有 1234567891011121314151617181920212223242526272829303132/** * android5.0以上使用 */ @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) private void scanDevices()&#123; BluetoothLeScanner mBluetoothScanner = mBluetoothAdapter.getBluetoothLeScanner(); mBluetoothScanner.startScan(scanCallback); &#125; ScanCallback scanCallback = new ScanCallback() &#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; super.onScanResult(callbackType, result); //把byte数组转成16进制字符串，方便查看 Log.e(TAG,&quot;onScanResult :&quot;+result.getScanRecord().toString()); BluetoothDevice device = result.getDevice(); blueAdapter.addDevice(device); ScanRecord scanRecord = result.getScanRecord(); int rssi = result.getRssi(); &#125; @Override public void onBatchScanResults(List&lt;ScanResult&gt; results) &#123; super.onBatchScanResults(results); &#125; @Override public void onScanFailed(int errorCode) &#123; super.onScanFailed(errorCode); &#125; &#125;; 连接设备蓝牙设备经常处于关机状态，先调用下面方法 1BluetoothDevice remoteDevice = adapter.getRemoteDevice(address); 123remoteDevice.connectGatt(context, true, mGattCallback);//参数1：上下文。 //参数2：是否自动连接（当设备可以用时） //参数3：连接回调。 https://www.cnblogs.com/Free-Thinker/p/11507349.html 6、关于autoConnect参数为true的意义？ 在蓝牙核心文档Vol3: Core System Package[Host volume]-&gt;Part C: Generic Access Profile的Connection Modes and Procedures章节中有涉及到自动连接建立规程(Auto Connection Establishment Procedure)的定义。 自动连接建立规程用来向多个设备同时发起连接。一个中央设备的主机与多个外围设备绑定，只要它们开始广播，便立刻与其建立连接。跟多细节请参考蓝牙核心文档和协议栈源码。 回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; /** * Callback indicating when GATT client has connected/disconnected to/from a remote GATT server * @param gatt 返回连接建立的gatt对象 * @param status 返回的是此次gatt操作的结果，成功了返回0 * @param newState 每次client连接或断开连接状态变化，STATE_CONNECTED 0，STATE_CONNECTING 1,STATE_DISCONNECTED 2,STATE_DISCONNECTING 3 */ @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); if (newState == BluetoothProfile.STATE_CONNECTED) &#123; gatt.discoverServices(); //连接成功， 开始搜索服务 Log.i(TAG, &quot;onConnectionStateChange 连接成功&quot; + status); &#125; &#125; /** * Callback invoked when the list of remote services, characteristics and descriptors for the remote device have been updated, ie new services have been discovered. * @param gatt 返回的是本次连接的gatt对象 * @param status */ @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); Log.i(TAG, &quot;onServicesDiscovered status&quot; + status); List&lt;BluetoothGattService&gt; mServiceList = gatt.getServices(); for (BluetoothGattService service : mServiceList) &#123; Log.i(TAG, &quot;onServicesDiscovered &quot; + service.getUuid()); &#125; BluetoothGattService service = gatt.getService(UUID.fromString(GATT_SERVICE_PRIMARY_1)); BluetoothGattCharacteristic characterisetic = service.getCharacteristic(UUID.fromString(CHARACTERISTIC_NOTIFY_1)); //调用以便当命令发送后返回信息可以自动返回 BluetoothGattDescriptor descriptor = characterisetic.getDescriptor(CCC); descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); gatt.writeDescriptor(descriptor); boolean isNotify = gatt.setCharacteristicNotification(characterisetic, true); &#125; //回调响应特征写操作的结果。 @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; Log.i(TAG, gatt.getDevice().getName() + &quot; write successfully&quot;); &#125; //回调响应特征读操作的结果。 @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; Log.i(TAG, gatt.getDevice().getName() + &quot; recieved &quot;); &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); Log.i(TAG, &quot;The response is &quot; + &quot;onCharacteristicChanged&quot;); &#125;&#125;; Android 中 GATT 操作的流程 Android 中 GATT 操作的流程。右边这个图，APP 是我们的应用，右边蓝牙服务端，从左向右箭头是 APP 发起的请求，从右向左的箭头是回调。我们看到所有的操作都是异步的完成的。连接过程是，首先使用 gattConnect 发起连接，收到 onConnectionStateChange() 通知连接是否成功，若成功，则进行下一步的 discoverService()，这一步就是发现设备所有的 GATT Service，若发现成功，通过 onServiceDiscovered() 回调，这时才算真正的连接成功。然后可以通过 BluetoothGatt 的 getService() 来获得BluetoothGattService，进而获得BluetoothGattCharacteristic 等，然后对 Characteristic 进行读写。 office https://developer.android.com/guide/topics/connectivity/bluetooth?hl=zh-cn https://developer.android.com/guide/topics/connectivity/bluetooth-le?hl=zh-cn 官方demo android5.0已过时 https://source.android.google.cn/devices/bluetooth/ un https://juejin.im/entry/5919630444d904006c6e14ca https://www.jianshu.com/p/29a730795294 https://www.jianshu.com/p/046c1f5a7163 设备通知手机5 当你从文档看到遍历出来的UUID有接送通知的功能。这时你就可以设置可以接收通知。通过拿到对应通知UUID的BluetoothGattCharacteristic，调用setCharacteristicNotification().其中00002902-0000-1000-8000-00805f9b34fb是系统提供接受通知自带的UUID，通过设置BluetoothGattDescriptor相当于设置BluetoothGattCharacteristic的Descriptor属性来实现通知，这样只要蓝牙设备发送通知信号，就会回调onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) 方法，这你就可以在这方法做相应的逻辑处理。 https://juejin.im/entry/58c74fc42f301e006bce23fb 经典蓝牙开发https://www.jianshu.com/p/453a5cda5646 设置 00002902-0000-1000-8000-00805f9b34fb 123456789101112131415161718/* 设置特征信息推送 */··· BluetoothGattCharacteristic characteristic; mGatt.setCharacteristicNotification(characteristic,true);/* CCCD 的UUID */private UUID ID_CCCD = UUID.fromString(&quot;00002902-0000-1000-8000-00805f9b34fb&quot;); /* 获取CCCD */BluetoothGattDescriptor cccd = characteristic.getDescriptor(ID_CCCD);/* 设置推送通知，参考值为： * BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE: 通知 * BluetoothGattDescriptor.ENABLE_INDICATION_VALUE: 指示 * BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE: 关闭 */ cccd.setValue(参考值);/* 写入CCCD */mGatt.writeDescriptor(descriptor) https://www.jianshu.com/p/43b1956d9f5c 官方三个蓝牙示例 :https://github.com/googlesamples?utf8=%E2%9C%93&amp;q=bluetooth&amp;type=&amp;language= 问题扫描不到任何设备 https://stackoverflow.com/questions/39646253/android-stops-finding-ble-devices-onclientregistered-status-133-clientif-0","categories":[{"name":"BLE","slug":"BLE","permalink":"https://noteforme.github.io/categories/BLE/"}],"tags":[]},{"title":"DesignPatterns_Observer","slug":"DesignPatterns_Observer","date":"2018-06-06T08:09:58.000Z","updated":"2025-02-04T13:53:45.954Z","comments":true,"path":"2018/06/06/DesignPatterns_Observer/","link":"","permalink":"https://noteforme.github.io/2018/06/06/DesignPatterns_Observer/","excerpt":"","text":"原理图 ​ 奶站\\天气站 用户 Observer观察者模式&#x2F;订阅模式 PUSH 模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//主题对象变化，通知所有的观察者//抽象观察者public interface Observer&#123; public void update(String str);&#125;//具体观察者public class ConcreteObserver implements Observer&#123; @Override public void update(String str) &#123; // TODO Auto-generated method stub System.out.println(str); &#125;&#125;//抽象主题public interface Subject&#123; public void addObserver(Observer observer); public void removeObserver(Observer observer); public void notifyObservers(String str);&#125;//具体主题public class ConcreteSubject implements Subject&#123; // 存放观察者 private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); //注册观察者 @Override public void addObserver(Observer observer) &#123; // TODO Auto-generated method stub list.add(observer); &#125; //移除观察者 @Override public void removeObserver(Observer observer) &#123; // TODO Auto-generated method stub list.remove(observer); &#125; // 遍历所有观察者，并通知 @Override public void notifyObservers(String str) &#123; // TODO Auto-generated method stub for(Observer observer:list)&#123; observer.update(str); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; //一个主题 ConcreteSubject eatSubject = new ConcreteSubject(); //两个观察者 ConcreteObserver p1 = new ConcreteObserver(); ConcreteObserver p2 = new ConcreteObserver(); //观察者订阅主题 eatSubject.addObserver(p1); eatSubject.addObserver(p2); eatSubject.notifyOBservers(&quot;起来敲代码啦！！！&quot;); &#125;&#125; https://juejin.im/post/5bc96afff265da0aa94a4493 https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm PULL模式 而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 https://www.bilibili.com/video/BV1W4411c77E?p=120","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[]},{"title":"Singleton","slug":"DesignPatterns_Singleton","date":"2018-06-06T07:43:06.000Z","updated":"2024-10-01T11:32:19.639Z","comments":true,"path":"2018/06/06/DesignPatterns_Singleton/","link":"","permalink":"https://noteforme.github.io/2018/06/06/DesignPatterns_Singleton/","excerpt":"","text":"单例模式 作用：一个类只有一个实例，减少内存开销 kotlin12345678910class Singleton private constructor() &#123; private object HOLDER &#123; val INSTANCE = Singleton() &#125; companion object &#123; val instance: Singleton by lazy &#123; HOLDER.INSTANCE &#125; &#125;&#125; https://medium.com/swlh/singleton-class-in-kotlin-c3398e7fd76b 常用方式 12345678910111213141516public class Singleton&#123; // 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 private static Singleton singleton=null; //私有构造方法，防止被实例化 private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton==null)&#123; //多个线程在这里聚集就会产生多个对象 synonzied(Singleton.class)&#123; Thread.sleel(1) singleton = new Singleton(); &#125; &#125; return singleton; &#125; &#125; 123456789101112131415public class Singleton&#123; // 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 private static Singleton singleton=null; //私有构造方法，防止被实例化 private Singleton()&#123;&#125; public static Singleton getInstance()&#123; //这里加锁 粒度有问题 synonzied(Singleton.class)&#123; //这样会产生效率问题，多个线程在这空转等待获得锁 if(singleton==null)&#123; Thread.sleel(1) singleton = new Singleton(); &#125; &#125; return singleton; &#125; &#125; 源码有类似的 InputMethodManager，当然我们常用的方式是要传个Context上下文对象给单例类，记得有次面试的时候面试官说单例里面使用弱引用，如果是是为了避免内存泄漏我觉得是可以的，但是我觉得用这种方式更好 Context applicationContext = context.getApplicationContext(); 刚无意中发现Glide单例也是这样使用的。 双重检查模式123456789101112131415public class Singleton &#123; private volatile static Singleton singleton; //volatile 防止指令重排序,指令半初始化，CPU执行指令顺序可能不同 private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; instance= new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 第1个if (singleton&#x3D;&#x3D;null)如果去掉它，那么所有线程都会串行执行，效率低下，这样会产生效率问题，多个线程在这空转等待获得锁，所以两个 check 都是需要保留的。 第2个if (singleton&#x3D;&#x3D;null)假如两个线程同时调用 getInstance() ,由于instance是空的，两个线程都通过第1个if (singleton null),接着锁机制存在，线程1先进入同步语句，并进入第二重if判断,线程2在外面等待. 线程1执行完 new Singleton()后退出synchronized,这时候如果没有 第2个if (singleton&#x3D;&#x3D; null) 线程2也会创建一个实例，此时就破坏了单例原则. volatile作用防止 new Singleton()重排序 在 JVM 中上述语句至少做了以下这 3 件事 第一步是给 singleton 分配内存空间； 然后第二步开始调用 Singleton 的构造函数等，来初始化 singleton； 最后第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。 因为存在指令重排序的优化，也就是说第2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。 如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重if (singleton==null) 检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错. Enum方式和公有域方法在功能上相近，但是更简洁，无偿提供了序列化机制，绝对的防止多次实例化，可以面对复杂的序列化或者反射攻击，虽然没有广泛采用，但是 单元素的枚举类型已经成为实现 Singleton的最佳方法. 12345678910111213141516public class Elvis_03 &#123; public static void main(String[] args) &#123; Elvis.INSTANCE.leaveTheBuilding(); &#125;&#125;/** * 这种方法太NB了, * Effective Java pag15 */enum Elvis &#123; INSTANCE; public void leaveTheBuilding() &#123; &#125;&#125; 嵌套类1234567891011public class Singleton3 &#123; private Singleton3() &#123;&#125; // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性 private static class Holder &#123; private static Singleton3 instance = new Singleton3(); &#125; public static Singleton3 getInstance() &#123; return Holder.instance; &#125;&#125; https://juejin.im/post/5bc96afff265da0aa94a4493","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[]},{"title":"HashMap","slug":"HashMap","date":"2018-05-31T14:54:44.000Z","updated":"2023-01-02T03:31:39.076Z","comments":true,"path":"2018/05/31/HashMap/","link":"","permalink":"https://noteforme.github.io/2018/05/31/HashMap/","excerpt":"","text":"HashMapHash函数是指把⼀个⼤范围映射到⼀个⼩范围。把⼤范围映射到⼀个⼩范围的⽬的往往是为了 节省空间，使得数据容易保存。 HashMap扩容机制12345 int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; new HashMap&lt;Integer,String&gt;(2,0.75f) Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 https://tech.meituan.com/2016/06/24/java-hashmap.html HashMap和HashTable的区别 HashTable是线程安全的 HashTable key不能为空，HashMap可以.存在数组为0的位置 HashMap的实现原理 HashMap数据结构？ JDK1.7 Table数组+ Entry链表 JDK1.8 Table数组+ Entry链表/红黑树（ 为什么用红黑树） 红黑树有自平衡的特点，可以防止不平衡情况的发生，所以可以始终将查找的时间复杂度控制在 O(log(n)) ​ HashMap采用Entry数组存放key-value,每个 key value组成一个实体，Entry类实际上是一个单向的链表结构，它有next指针指向下一 个实体， 1.8中链表大于8时会转成红黑树.长度降到 6 就转换回去. ​ HashMap源码理解 HashMap如何put数据（从HashMap源码角度讲解）？ 对key的Dashcode()做hash运算，计算index. 如果没碰撞直接放到bucket⾥ 如果碰撞了，以链表的形式存在buckets后 如果节点已经存在就替换old value(保证key的唯⼀性) 如果bucket满了(超过load factor*current capacity)，就要resize get数据 对key的hashCode()做hash运算，计算index; 如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;分为下面两种方式. 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 HashMap怎么手写实现？ https://www.jianshu.com/p/985534b21089 HashTable实现原理 ConcurrentHashMap的实现原理 HashTable ConcurrentHashMap 区别Hashtable的实现是基于Dictionary抽象类的。Java5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 https://www.bilibili.com/video/BV1kJ411C7hC?p=9&amp;spm_id_from=pageDriver TreeMap具体实现TreeMap是一个有序的key-value集合，是非线程安全的，基于红黑树（Red-Black tree）实现。其映射根据键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。其基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 https://www.cnblogs.com/nananana/p/10426377.html HashMap与HashSet的区别 基于 HashMap 实现的，底层采用 HashMap 来保存元素 HashSet实现了Set接口，它不允许集合中有重复的值 HashSet与HashMap怎么判断集合元素重复？ l nn为什么不一开始就使用红黑树因为红⿊树需要进⾏左旋，右旋，变⾊这些操作来保持平衡，⽽单链表不需要。当元素⼩于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素⼤于8个的时候，此时需要红⿊树来加快查 询速度，但是新增节点的效率变慢了。因此，如果⼀开始就⽤红⿊树结构，元素太少，新增效率⼜⽐较慢，⽆疑这是浪费性能的。 什么时候退化为链表为6的时候退转为链表。中间有个差值7可以防⽌链表和树之间频繁的转换。假设⼀下，如果设计成链表个数超过8则链表转 换成树结构，链表个数⼩于8则树结构转换成链表，如果⼀个HashMap不停的插⼊、删除元素，链表个数在8左右徘徊，就会 频繁的发⽣树转链表、链表转树，效率会很低。 https://www.youtube.com/watch?v=jwL1W8zEuX4 https://www.bilibili.com/video/BV1if4y167eE?p=4 https://zhuanlan.zhihu.com/p/127147909 https://zhuanlan.zhihu.com/p/348756860 ArrayMapArrayMap类有两个非常重要的静态成员变量mBaseCache和mTwiceBaseCacheSize，用于ArrayMap所在进程的全局缓存功能： 传入ArrayMap(4) 或者ArrayMap(8),性能会有变化吗 构造方法12345678910111213public ArrayMap(int capacity, boolean identityHashCode) &#123; // 如果传入一个 capacity =4 mIdentityHashCode = identityHashCode; if (capacity &lt; 0) &#123; mHashes = EMPTY_IMMUTABLE_INTS; mArray = EmptyArray.OBJECT; &#125; else if (capacity == 0) &#123; mHashes = EmptyArray.INT; mArray = EmptyArray.OBJECT; &#125; else &#123; allocArrays(capacity); // 走到这里 &#125; mSize = 0;&#125; 123456789101112131415161718192021222324252627282930313233343536private void allocArrays(final int size) &#123; if (mHashes == EMPTY_IMMUTABLE_INTS) &#123; throw new UnsupportedOperationException(&quot;ArrayMap is immutable&quot;); &#125; if (size == (BASE_SIZE*2)) &#123; synchronized (ArrayMap.class) &#123; if (mTwiceBaseCache != null) &#123; final Object[] array = mTwiceBaseCache; mArray = array; mTwiceBaseCache = (Object[])array[0]; mHashes = (int[])array[1]; array[0] = array[1] = null; mTwiceBaseCacheSize--; if (DEBUG) Log.d(TAG, &quot;Retrieving 2x cache &quot; + mHashes + &quot; now have &quot; + mTwiceBaseCacheSize + &quot; entries&quot;); return; &#125; &#125; &#125; else if (size == BASE_SIZE) &#123; // 走到这里 synchronized (ArrayMap.class) &#123; if (mBaseCache != null) &#123; final Object[] array = mBaseCache; mArray = array; mBaseCache = (Object[])array[0]; mHashes = (int[])array[1]; array[0] = array[1] = null; mBaseCacheSize--; if (DEBUG) Log.d(TAG, &quot;Retrieving 1x cache &quot; + mHashes + &quot; now have &quot; + mBaseCacheSize + &quot; entries&quot;); return; &#125; &#125; &#125; mHashes = new int[size]; mArray = new Object[size&lt;&lt;1];&#125; https://juejin.cn/post/7049631659116888094 http://gaozhipeng.me/posts/arraymap/ http://gityuan.com/2019/01/13/arraymap/ https://www.youtube.com/watch?v=I16lz26WyzQ https://juejin.cn/post/6844904119098982414 https://juejin.cn/post/6844903762470060045 ArrayMap和HashMap的区别ArrayMap相比传统的HashMap速度更慢，因为其查找方法是二分法，并且当删除或添加数据时，会对空间重新调整，可以说ArrayMap是牺牲了时间来换空间，ArrayMap与HashMap的区别主要在： 存储方式不同：HashMap内部有一个HashMapEntry&lt;K,V&gt;[ ]对象，而ArrayMap是一个&lt;key,value&gt;映射的数据结构，内部使用两个数组进行数据存储，一个数组记录key的hash值，另一个数组记录value值。 添加数据时扩容的处理不一样：HashMap进行了new操作，重新创建对象，开销很大，而ArrayMap用的是copy数据，效率相对高很多。 ArrayMap提供了数组收缩的功能，在clear或remove之后，会重新收缩数组，释放空间。 ArrayMap采用的是二分法查找。 https://juejin.cn/post/7049631659116888094 SparseArray key是int类型的Map，Android再次提供效率更高的数据结构SparseArray，可避免自动装箱过程,SparseArray不需要保存key所对应的哈希值，所以比ArrayMap还能再节省1/3的内存。 SparseArray构造mKeys mValues两个数组，默认长度10，也可以自己定义initialCapacity 12345678910public SparseArray(int initialCapacity) &#123; if (initialCapacity == 0) &#123; mKeys = EmptyArray.INT; mValues = EmptyArray.OBJECT; &#125; else &#123; mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity); mKeys = new int[mValues.length]; &#125; mSize = 0; &#125; 12345678910111213141516171819202122232425262728public void put(int key, E value) &#123; // 二分查找,key在mKeys列表中对应的index,注意binarySearch返回做了 ~操作. //如果没找到，返回的是当前元素将要插入的位置 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; mValues[i] = value; //找到后给对应的value数组赋值 &#125; else &#123; i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; //插入数据，内部做了排序 mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125;&#125; 123456789public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; //标记该数据为DELETE mGarbage = true; // 设置存在GC &#125; &#125;&#125; https://blog.csdn.net/zxt0601/article/details/78333328 http://www.jcodecraeer.com/a/anzhuokaifa/2017/0912/8504.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"Concurrency_Locking","slug":"Concurrency_Locking","date":"2018-05-24T14:31:57.000Z","updated":"2025-03-10T00:48:40.100Z","comments":true,"path":"2018/05/24/Concurrency_Locking/","link":"","permalink":"https://noteforme.github.io/2018/05/24/Concurrency_Locking/","excerpt":"","text":"锁的7大类偏向锁&#x2F;轻量级锁&#x2F;重量级锁； 偏向锁 ​ 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。 轻量级锁 ​ JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的 竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。 重量级锁 ​ 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。 锁升级 synchronized锁升级 偏向锁： markword记录这个线程ID -》如果线程争用升级为自旋锁 -》10次以后升级为重量级锁 synchronized的monitor 锁同步代码块1234567public class SynTest &#123; public void synBlock() &#123; synchronized (this) &#123; System.out.println(&quot;lagou&quot;); &#125; &#125;&#125; 反编译后的字节码 123456789101112131415161718192021public void synBlock(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 7: ldc #3 // String lagou 9: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 12: aload_1 13: monitorexit 14: goto 22 17: astore_2 18: aload_1 19: monitorexit 20: aload_2 21: athrow 22: return synchronized 代码块实际上多了 monitorenter 和 monitorexit 指令，标红的第3、13、19行指令分别对应的是 monitorenter 和 monitorexit.可以把执行 monitorenter 理解为加锁，执行 monitorexit 理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为 0。 monitorenter 执行 monitorenter 的线程尝试获得 monitor 的所有权，会发生以下这三种情况之一： a. 如果该 monitor 的计数为 0，则线程获得该 monitor 并将其计数设置为 1。然后，该线程就是这个 monitor 的所有者。 b. 如果线程已经拥有了这个 monitor ，则它将重新进入，并且累加计数。 c. 如果其他线程已经拥有了这个 monitor，那个这个线程就会被阻塞，直到这个 monitor 的计数变成为 0，代表这个 monitor 已经被释放了，于是当前这个线程就会再次尝试获取这个 monitor。 monitorexitmonitorexit 的作用是将 monitor 的计数器减 1，直到减为 0 为止。代表这个 monitor 已经被释放了，已经没有任何线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。 从上面也可看到 synchronized是可重入锁 synchronized 方法​ 同步代码块是使用 monitorenter 和 monitorexit 指令实现的。而对于 synchronized 方法，并不是依靠 monitorenter 和 monitorexit 指令实现的，被 javap 反汇编后可以看到，synchronized 方法和普通方法大部分是一样的，不同在于，这个方法会有一个叫作 ACC_SYNCHRONIZED 的 flag 修饰符，来表明它是同步方法。 123public synchronized void method() &#123; method body&#125; 反编译后的指令 123456789101112131415 public synchronized void synMethod(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 16: 0 被 synchronized 修饰的方法会有一个 ACC_SYNCHRONIZED 标志。当某个线程要访问某个方法的时候，会首先检查方法是否有 ACC_SYNCHRONIZED 标志，如果有则需要先获得 monitor 锁，然后才能开始执行方法，方法执行之后再释放 monitor 锁。其他方面， synchronized 方法和刚才的 synchronized 代码块是很类似的，例如这时如果其他线程来请求执行方法，也会因为无法获得 monitor 锁而被阻塞。 synchronized 和 Lock选择 如果能不用最好既不使用 Lock 也不使用 synchronized。因为在许多情况下你可以使用 java.util.concurrent 包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。 如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在 finally 里 unlock，代码可能会出很大的问题，而使用 synchronized 更安全。 如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock。 Lock12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; lock() lock() 是最基础的获取锁的方法,获取锁和释放锁都是显式的，不像 synchronized 那样是隐式的，所以 Lock 不会像 synchronized 一样在异常时自动释放锁（synchronized 即使不写对应的代码也可以释放）,使用 lock() 时必须由我们自己主动去释放锁，因此最佳实践是执行 lock() 后，首先在 try{} 中操作同步资源，如果有必要就用 catch{} 块捕获异常，然后在 finally{} 中释放锁，以保证发生异常时锁一定被释放. 12345678Lock lock = ...;lock.lock();try&#123; //获取到了被本锁保护的资源，处理任务 //捕获异常&#125;finally&#123; lock.unlock(); //释放锁&#125; tryLock() ​ 尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回 true，否则返回 false，代表获取锁失败。该方法会立即返回，即便在拿不到锁时也不会一直等待，所以通常情况下，我们用 if 语句判断 tryLock() 的返回结果. 12345678910Lock lock = ...;if(lock.tryLock()) &#123; try&#123; //处理任务 &#125;finally&#123; lock.unlock(); //释放锁 &#125; &#125;else &#123; //如果不能获取锁，则做其他事情&#125; 这个方法可以方便的解决死锁问题 1234567891011121314151617181920public void tryLock(Lock lock1, Lock lock2) throws InterruptedException &#123; while (true) &#123; if (lock1.tryLock()) &#123; try &#123; if (lock2.tryLock()) &#123; try &#123; System.out.println(&quot;获取到了两把锁，完成业务逻辑&quot;); return; &#125; finally &#123; lock2.unlock(); &#125; &#125; &#125; finally &#123; lock1.unlock(); &#125; &#125; else &#123; Thread.sleep(new Random().nextInt(1000)); &#125; &#125; &#125; 如果代码中我们不用 tryLock() 方法,比如有两个线程同时调用这个方法，传入的 lock1 和 lock2 恰好是相反的，那么如果第一个线程获取了 lock1 的同时，第二个线程获取了 lock2，它们接下来便会尝试获取对方持有的那把锁，但是又获取不到，于是便会陷入死锁，使用tryLock()后，如果获取到了 lock1 但没有获取到 lock2，那么也会释放掉 lock1 tryLock(long time, TimeUnit unit) 使用 tryLock(long time, TimeUnit unit) 时，在等待了一段指定的超时时间后，线程会主动放弃这把锁的获取，避免永久等待；在等待的期间，也可以随时中断线程，这就避免了死锁的发生。 lockInterruptibly() 如果这个锁当前是可以获得的，那么这个方法会立刻返回,，但是如果这个锁当前是不能获得的（被其他线程持有），那么当前线程便会开始等待，除非它等到了这把锁或者是在等待的过程中被Thread的interrupt()方法中断了，否则这个线程便会一直在这里执行这行代码。一直尝试获取直到获取到为止。 相比于不能响应中断的 synchronized 锁，lockInterruptibly() 可以让程序更灵活，可以在获取锁的同时，保持对中断的响应。我们可以把这个方法理解为超时时间是无穷长的 tryLock(long time, TimeUnit unit)，因为 tryLock(long time, TimeUnit unit) 和 lockInterruptibly() 都能响应中断，只不过 lockInterruptibly() 永远不会超时。 123456789101112public void lockInterruptibly() &#123; try &#123; lock.lockInterruptibly(); try &#123; System.out.println(&quot;操作资源&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; unlock() 最后要介绍的方法是 unlock() 方法，是用于解锁的，u方法比较简单，对于 ReentrantLock 而言，执行 unlock() 的时候，内部会把锁的“被持有计数器”减 1，直到减到 0 就代表当前这把锁已经完全释放了，如果减 1 后计数器不为 0，说明这把锁之前被“重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。 https://www.yinxiang.com/everhub/note/c27d346d-ed4d-4e7b-aef9-0b501a44deb7 https://www.bilibili.com/video/BV1NT4y1G7WE?p=5 https://www.bilibili.com/video/BV1qE411q7fk?p=10 https://www.cnblogs.com/aspirant/p/11470858.html 可重入锁&#x2F;非可重入锁；​ 可重入锁 ： 可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。 ​ synchronized是可冲入锁 12345678910111213141516171819202122232425public class T &#123; synchronized void m1()&#123; System.out.println(&quot;m1 start&quot;); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; m2(); System.out.println(&quot;m1 end&quot;); &#125; private void m2() &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;m2&quot;); &#125; public static void main(String[] args) &#123; new T().m1(); &#125;&#125; 运行结果 123m1 startm2m1 end 如果synchronized不是可重入锁，执行m1()执行m2()会发生死锁, 为什么synchronized必须是可重入锁呢? 如果父类m2()是synchronized方法,子类重写m2()方法，调用子类m2(),接着调用super.m2()就会发生死锁 共享锁&#x2F;独占锁 共享锁 共享锁指的是我们同一把锁可以被多个线程同时获得 独占锁 这把锁只能同时被一个线程获得 读写锁就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。 整体思路是它有两把锁，第 1 把锁是写锁，获得写锁之后，既可以读数据又可以修改数据，而第 2 把锁是读锁，获得读锁之后，只能查看数据，不能修改数据。读锁可以被多个线程同时持有，所以多个线程可以同时查看数据。 我们在使用读写锁时遵守下面的获取规则： 如果有一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为读写不能同时操作。 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，都必须等待之前的线程释放写锁，同样也因为读写不能同时，并且两个线程不应该同时写。 所以我们用一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。也可以总结为：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 描述： 演示读写锁用法 */public class ReadWriteLockDemo &#123; private static final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock( false); private static final ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock .readLock(); private static final ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock .writeLock(); private static void read() &#123; readLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;得到读锁，正在读取&quot;); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + &quot;释放读锁&quot;); readLock.unlock(); &#125; &#125; private static void write() &#123; writeLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;得到写锁，正在写入&quot;); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + &quot;释放写锁&quot;); writeLock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; read()).start(); new Thread(() -&gt; read()).start(); new Thread(() -&gt; write()).start(); new Thread(() -&gt; write()).start(); &#125;&#125; 运行结果 12345678Thread-0得到读锁，正在读取Thread-1得到读锁，正在读取Thread-0释放读锁Thread-1释放读锁Thread-2得到写锁，正在写入Thread-2释放写锁Thread-3得到写锁，正在写入Thread-3释放写锁 读锁可以同时被多个线程获得，而写锁不能。 为什么要对读加锁 : 读本身是线程安全的，加读锁，主要是为了让写锁感知到，在有人读取的时候，不要同时写入。 ReentrantReadWriteLockTest.java 1234567891011121314151617181920212223242526272829303132333435private static ReentrantReadWriteLock reentrantLock = new ReentrantReadWriteLock();private static ReentrantReadWriteLock.ReadLock readLock = reentrantLock.readLock();private static ReentrantReadWriteLock.WriteLock writeLock = reentrantLock.writeLock();public static void read() &#123; readLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;获取读锁，开始执行&quot;); Thread.sleep(2000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readLock.unlock(); System.out.println(Thread.currentThread().getName() + &quot;释放读锁&quot;); &#125;&#125;public static void write() &#123; writeLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;获取写锁，开始执行&quot;); Thread.sleep(2000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; writeLock.unlock(); System.out.println(Thread.currentThread().getName() + &quot;释放写锁&quot;); &#125;&#125;public static void main(String[] args) &#123; new Thread(() -&gt; read(), &quot;Thread1&quot;).start(); new Thread(() -&gt; read(), &quot;Thread2&quot;).start(); new Thread(() -&gt; write(), &quot;Thread3&quot;).start(); new Thread(() -&gt; write(), &quot;Thread4&quot;).start();&#125; 运行结果: Thread1获取读锁，开始执行Thread2获取读锁，开始执行Thread1释放读锁Thread2释放读锁Thread3获取写锁，开始执行Thread3释放写锁Thread4获取写锁，开始执行Thread4释放写锁 线程1和线程2可以同时获取读锁，而线程3和线程4只能依次获取写锁，因为线程4必须等待线程3释放写锁后才能获取到锁 https://blog.csdn.net/fanrenxiang/article/details/104312606 公平锁&#x2F;非公平锁； 公平锁 线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思，公平锁指的是按照线程请求的顺序，来分配锁 非公平锁 它会在一定情况下，忽略掉已经在排队的线程，发生插队现象，而非公平锁指的是不完全按照请求的顺序，在一定情况下，可以允许插队 公平锁 new ReentrantLock(false); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class FairAndUnfair &#123; public static void main(String args[]) &#123; PrintQueue printQueue = new PrintQueue(); Thread thread[] = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; thread[i] = new Thread(new Job(printQueue), &quot;Thread &quot; + i); &#125; for (int i = 0; i &lt; 10; i++) &#123; thread[i].start(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Job implements Runnable &#123; private PrintQueue printQueue; public Job(PrintQueue printQueue) &#123; this.printQueue = printQueue; &#125; @Override public void run() &#123; System.out.printf(&quot;%s: Going to print a job\\n&quot;, Thread.currentThread().getName()); printQueue.printJob(new Object()); System.out.printf(&quot;%s: The document has been printed\\n&quot;, Thread.currentThread().getName()); &#125;&#125;class PrintQueue &#123; private final Lock queueLock = new ReentrantLock(false); //非公平锁 public void printJob(Object document) &#123; queueLock.lock(); try &#123; Long duration = (long) (Math.random() * 10000); System.out.printf(&quot;%s: PrintQueue: Printing a Job during %d seconds\\n&quot;, Thread.currentThread().getName(), (duration / 1000)); Thread.sleep(duration); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; queueLock.unlock(); &#125; queueLock.lock(); try &#123; Long duration = (long) (Math.random() * 10000); System.out.printf(&quot;%s: PrintQueue: Printing a Job during %d seconds\\n&quot;, Thread.currentThread().getName(), (duration / 1000)); Thread.sleep(duration); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; queueLock.unlock(); &#125; &#125;&#125; ​ 运行结果 12345678910111213141516171819202122232425262728293031323334353637383940Thread 0: Going to print a jobThread 0: PrintQueue: Printing a Job during 8 secondsThread 1: Going to print a jobThread 2: Going to print a jobThread 3: Going to print a jobThread 4: Going to print a jobThread 5: Going to print a jobThread 6: Going to print a jobThread 7: Going to print a jobThread 8: Going to print a jobThread 9: Going to print a jobThread 0: PrintQueue: Printing a Job during 2 secondsThread 0: The document has been printedThread 1: PrintQueue: Printing a Job during 8 secondsThread 1: PrintQueue: Printing a Job during 8 secondsThread 1: The document has been printedThread 2: PrintQueue: Printing a Job during 7 secondsThread 2: PrintQueue: Printing a Job during 5 secondsThread 2: The document has been printedThread 3: PrintQueue: Printing a Job during 5 secondsThread 3: PrintQueue: Printing a Job during 0 secondsThread 3: The document has been printedThread 4: PrintQueue: Printing a Job during 5 secondsThread 4: PrintQueue: Printing a Job during 9 secondsThread 4: The document has been printedThread 5: PrintQueue: Printing a Job during 6 secondsThread 5: PrintQueue: Printing a Job during 6 secondsThread 5: The document has been printedThread 6: PrintQueue: Printing a Job during 1 secondsThread 6: PrintQueue: Printing a Job during 5 secondsThread 6: The document has been printedThread 7: PrintQueue: Printing a Job during 1 secondsThread 7: PrintQueue: Printing a Job during 1 secondsThread 7: The document has been printedThread 8: PrintQueue: Printing a Job during 6 secondsThread 8: PrintQueue: Printing a Job during 1 secondsThread 8: The document has been printedThread 9: PrintQueue: Printing a Job during 1 secondsThread 9: PrintQueue: Printing a Job during 0 secondsThread 9: The document has been printed 可以看到thread1释放锁后又重新获取到锁 ​ ReentrantLockTest.java 123456789101112131415161718192021private static final int COUNT = 100;private static int start = 1;static ReentrantLock lock = new ReentrantLock(true);public static void main(String[] args) &#123; Runnable task = () -&gt; &#123; for (; ; ) &#123; lock.lock(); try &#123; if (start &lt;= COUNT) &#123; System.out.println(Thread.currentThread().getName() + &quot;=&gt; &quot; + start++); &#125; else &#123; System.exit(0); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;; new Thread(task).start(); new Thread(task).start(); 运行结果: Thread-0&#x3D;&gt; 1Thread-1&#x3D;&gt; 2Thread-0&#x3D;&gt; 3Thread-1&#x3D;&gt; 4…Thread-1&#x3D;&gt; 36Thread-1&#x3D;&gt; 37Thread-1&#x3D;&gt; 38Thread-1&#x3D;&gt; 39 Thread-1&#x3D;&gt; 40Thread-1&#x3D;&gt; 41Thread-1&#x3D;&gt; 42Thread-1&#x3D;&gt; 43Thread-1&#x3D;&gt; 44Thread-1&#x3D;&gt; 45Thread-1&#x3D;&gt; 46Thread-1&#x3D;&gt; 47Thread-1&#x3D;&gt; 48 Otherwise this lock does not guarantee any particular access order.可见公平锁不保证有序。 https://juejin.cn/post/6844903983308341261 https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html 悲观锁&#x2F;乐观锁； 悲观锁 必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁. 它认为如果不锁住这个资源，别的线程就会来争抢，就会造成数据结果错误，所以悲观锁为了确保结果的正确性，会在每次获取并修改数据时，都把数据锁住，让其他线程无法访问该数据，这样就可以确保数据内容万无一失。 Java 中悲观锁的实现包括 synchronized 关键字和 Lock 相关类等，我们以 Lock 接口为例，例如 Lock 的实现类 ReentrantLock，类中的 lock() 等方法就是执行加锁，而 unlock() 方法是执行解锁。处理资源之前必须要先加锁并拿到锁，等到处理完了之后再解开锁，这就是非常典型的悲观锁思想。 synchronized 关键字和 Lock 接口 大喜大悲：数据库 数据库中同时拥有悲观锁和乐观锁的思想。例如，我们如果在 MySQL 选择 select for update 语句，那就是悲观锁，在提交之前不允许第三方来修改该数据，这当然会造成一定的性能损耗，在高并发的情况下是不可取的 相反，我们可以利用一个版本 version 字段在数据库中实现乐观锁。在获取及修改数据时都不需要加锁，但是我们在获取完数据并计算完毕，准备更新数据时，会检查版本号和获取数据时的版本号是否一致，如果一致就直接更新，如果不一致，说明计算期间已经有其他线程修改过这个数据了，那我就可以选择重新获取数据，重新计算，然后再次尝试更新数据。 乐观锁 利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。 为了确保数据正确性，在更新之前，会去对比在我修改数据期间，数据有没有被其他线程修改过：如果没被修改过，就说明真的只有我自己在操作，那我就可以正常的修改数据；如果发现数据和我一开始拿到的不一样了，说明其他线程在这段时间内修改过数据，那说明我迟了一步，所以我会放弃这次修改，并选择报错、重试等策略。 ​ 自旋锁&#x2F;非自旋锁； 自旋锁 自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋” 阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。 非自旋锁 如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。 123456789101112131415161718192021222324252627282930313233343536373839/** * 持有锁的线程，null表示锁未被线程持有 */private AtomicReference&lt;Thread&gt; ref = new AtomicReference&lt;&gt;();public void lock()&#123; Thread currentThread = Thread.currentThread(); while(!ref.compareAndSet(null, currentThread))&#123; //当ref为null的时候compareAndSet返回true，反之为false //通过循环不断的自旋判断锁是否被其他线程持有 &#125;&#125;public void unLock() &#123; Thread cur = Thread.currentThread(); if(ref.get() != cur)&#123; //exception ... &#125; ref.set(null);&#125;static int count = 0;public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(100); CountDownLatch countDownLatch = new CountDownLatch(100); SimpleSpinningLock simpleSpinningLock = new SimpleSpinningLock(); for (int i = 0 ; i &lt; 100 ; i++)&#123; executorService.execute(() -&gt; &#123; simpleSpinningLock.lock(); ++count; simpleSpinningLock.unLock(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); System.out.println(count);&#125; 可中断锁&#x2F;不可中断锁。第 7 种分类是可中断锁和不可中断锁。在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。 死锁 条件 互斥条件 : 任务使用的资源至少有一个是不能共享的；chopstick一次只能被一个Philosopher使用 请求保持条件: 至少有一个任务必须持有跟一个资源且正在等待获取一个当前被别的任务持有的资源 不可剥夺条件: 资源不能被任务抢占 环路等待条件: 必须有循环等待。一个任务等待其他任务所持有的资源，后者又等待另一个任务所持有的资源,使得大家都被锁住. 当两个（或多个）线程（或进程）相互持有对方所需要的资源，却又都不主动释放自己手中所持有的资源，导致大家都获取不到自己想要的资源 那么为什么会产生死锁呢? 学过操作系统的朋友应该都知道，死锁的产生必须具备以下四个条件 。 互斥条件: 指线程对己经获取到的资源进行排它性使用 ，即该资源同时只由 一个线程占用。如果 此时 还有其 他 线程请求获取该资源 ，则 请求者只能等待，直至占有资源 的 线程释放该资源。 .请求并持有条件 : 指一个线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其 他 线程占有，所 以 当前线程会被阻塞 ，但 阻塞 的同时 并不释放自 己己经获取的资源。 不可剥夺条件 : 指线程获取到的资源在自己使用完之前不能被其他线程抢占 ， 只有在自己使用完 毕后才 由 自 己释放该资源。 环路等待条件 : 指在发生死锁时 ，必然存在一个线程→资源的环形链 ，即线程集合{TO,TLT2，…，Tn}中的TO正在等待一个Tl占用的资源， Tl正在等待T2占 用的资源，……Tn正在等待己被 TO 占用的资源。 避免死锁要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可， 但是学过操作系统 的读者应该都知道，目前只有请求并持有和环路等待条件是可 以被破坏 的。造成死锁的原因其实和申请资源的顺序有很大关系 ， 经典的哲学家吃饭问题 5位哲学家 ，5只筷子在他们之间. 筷子 123456789101112public class Chopstick &#123; private boolean taken = false; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; private int number; public synchronized void take(int numChop) throws InterruptedException &#123; while (taken) &#123; Print.print(numChop+&quot; wait&quot;); wait(); &#125; taken = true; &#125; public synchronized void drop() &#123; taken = false; notifyAll(); &#125; } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* 哲学家 ```javapublic class Philosopher implements Runnable &#123; private Chopstick left; private Chopstick right; private final int id; private final int ponderFactor; private Random rand = new Random(47); private void pause() throws InterruptedException &#123; if (ponderFactor == 0) return; TimeUnit.MILLISECONDS.sleep(rand.nextInt(ponderFactor * 250)); &#125; public Philosopher(Chopstick left, Chopstick right, int id, int ponderFactor) &#123; this.id = id; this.ponderFactor = ponderFactor; this.left = left; this.right = right; &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; Print.print(this + &quot; &quot; + &quot;need thinking &quot; + ponderFactor + &quot; 毫秒&quot;); pause(); //Philosopher becomes hungry Print.print(this + &quot; &quot; + &quot;grabbing right 第&quot; + (id + 1) + &quot; 号筷子&quot;); right.take(id + 1);// if (id == 2) &#123;// System.out.println(right.taken);// &#125; pause(); //拿起右边的筷子进入等待状态 Print.print(this + &quot; .&quot; + &quot;try grabbing left 第 &quot; + (id) + &quot; 号筷子&quot;); //尝试拿起左边的筷子 left.take(id); Print.print(this + &quot; &quot; + &quot;eating&quot;); pause(); right.drop(); left.drop(); &#125; &#125; catch (InterruptedException e) &#123; Print.print(this + &quot; &quot; + &quot;exiting via interrupt&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Philosopher&quot; + id; &#125;&#125; 运行 1234567891011121314151617181920212223242526public class DeadlockingDiningPhilosophers &#123; public static void main(String[] args) throws Exception &#123; int ponder = 5; //默认 Philosopher思考的时间 if (args.length &gt; 0) ponder = Integer.parseInt(args[0]); int size = 5; //默认筷子的个数 if (args.length &gt; 1) size = Integer.parseInt(args[1]); ExecutorService exec = Executors.newCachedThreadPool(); Chopstick[] sticks = new Chopstick[size]; for (int i = 0; i &lt; size; i++) sticks[i] = new Chopstick(); for (int i = 0; i &lt; size; i++) exec.execute(new Philosopher(sticks[i], sticks[(i + 1) % size], i, ponder));// if (args.length == 3 &amp;&amp; args[2].equals(&quot;timeout&quot;)) TimeUnit.SECONDS.sleep(5);// else &#123;// System.out.println(&quot;Press &#x27;&#x27;Enter to quit&quot;);// System.in.read();// &#125; exec.shutdownNow(); &#125;&#125; 结果 12345678910111213141516171819202122232425Philosopher0 need thinking 5 毫秒Philosopher3 need thinking 5 毫秒Philosopher2 need thinking 5 毫秒Philosopher1 need thinking 5 毫秒Philosopher4 need thinking 5 毫秒Philosopher0 grabbing right 第1 号筷子Philosopher3 grabbing right 第4 号筷子Philosopher2 grabbing right 第3 号筷子Philosopher1 grabbing right 第2 号筷子Philosopher4 grabbing right 第5 号筷子Philosopher0 .try grabbing left 第 0 号筷子Philosopher3 .try grabbing left 第 3 号筷子Philosopher2 .try grabbing left 第 2 号筷子Philosopher1 .try grabbing left 第 1 号筷子Philosopher4 .try grabbing left 第 4 号筷子2 wait3 wait4 wait0 wait1 waitPhilosopher1 exiting via interruptPhilosopher4 exiting via interruptPhilosopher0 exiting via interruptPhilosopher3 exiting via interruptPhilosopher2 exiting via interrupt 银行转账问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class TransferMoney implements Runnable &#123; int flag; static Account a = new Account(800); static Account b = new Account(600); static class Account &#123; public Account(int balance) &#123; this.balance = balance; &#125; int balance; &#125; @Override public void run() &#123; if (flag == 1) &#123; transferMoney(a, b, 200); &#125; if (flag == 0) &#123; transferMoney(b, a, 200); &#125; &#125; public static void transferMoney(Account from, Account to, int amount) &#123; //先获取两把锁，然后开始转账 int fromHash = System.identityHashCode(from); int toHash = System.identityHashCode(to); System.out.println(Thread.currentThread().getName() + &quot; fromHash &lt; toHash &quot;+(fromHash &lt; toHash)); if (fromHash &lt; toHash) &#123; synchronized (from) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁A &quot; + from.balance); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125; synchronized (to) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁B &quot; + to.balance); if (from.balance - amount &lt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 余额不足，转账失败。&quot;); return; &#125;// from.balance -= amount;// to.balance += amount; System.out.println(Thread.currentThread().getName() + &quot; 成功转账&quot; + amount + &quot;元&quot;); &#125; &#125; &#125; else if (fromHash &gt; toHash) &#123; synchronized (to) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁A &quot; + to.balance); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125; synchronized (from) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁B &quot; + from.balance); if (from.balance - amount &lt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 余额不足，转账失败。&quot;); return; &#125;// from.balance -= amount;// to.balance += amount; System.out.println(Thread.currentThread().getName() + &quot; 成功转账&quot; + amount + &quot;元&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TransferMoney r1 = new TransferMoney(); TransferMoney r2 = new TransferMoney(); r1.flag = 1; r2.flag = 0; Thread t1 = new Thread(r1, &quot;t1&quot;); Thread t2 = new Thread(r2, &quot;t2&quot;); t1.start(); t2.start(); t1.join(); t2.join();// System.out.println(&quot;a的余额&quot; + a.balance);// System.out.println(&quot;b的余额&quot; + b.balance); &#125;&#125; 打印结构 t1 fromHash 1967932108 toHash 2072748565 fromHash &lt; toHash truet2 fromHash 2072748565 toHash 1967932108 fromHash &lt; toHash falset1 获得锁At1 获得锁Bt1 成功转账200元t2 获得锁Bt2 获得锁At2 成功转账200元a的余额500 b的余额500 使用 HashCode 的值来决定顺序 主要思想是，两个线程都先获取 锁A,再获取锁B,这样就不会有死锁了 主键 ID 具有唯一、不重复的特点 由主键 ID 大小来决定获取锁的顺序，就可以确保避免死锁。 CASAtomicStampedReference 在变量前面添加版本号，每次变量更新的时候都把版本号加1 AQShttps://www.cnblogs.com/dennyzhangdd/p/7218510.html 信号量12345678910111213141516171819202122232425262728293031323334353637383940public class SemaphoreTestMain &#123; static Semaphore sSemaphore = new Semaphore(6); public static void main(String[] args) &#123; final SemaphoreTestMain semaphoreTestMain = new SemaphoreTestMain(); for (int i = 0 ; i &lt; 1000;i++) &#123; Thread myThread = new Thread() &#123; @Override public void run() &#123; super.run(); try &#123; semaphoreTestMain.test(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; myThread.setName(&quot;threat index:&quot; + i); myThread.start(); &#125; &#125; public void test() throws InterruptedException &#123; sSemaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;--in&quot;); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot;--out&quot; ); sSemaphore.release(); &#125;&#125; https://www.bilibili.com/video/BV1B7411L7tE https://tech.meituan.com/2018/11/15/java-lock.html https://blog.csdn.net/javazejian/article/details/72828483#t2 https://tech.meituan.com/2018/11/15/java-lock.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"https://noteforme.github.io/tags/concurrency/"}]},{"title":"CaptureApp","slug":"CaptureApp","date":"2018-04-21T05:24:41.000Z","updated":"2024-01-07T07:53:54.108Z","comments":true,"path":"2018/04/21/CaptureApp/","link":"","permalink":"https://noteforme.github.io/2018/04/21/CaptureApp/","excerpt":"","text":"Charles抓包 按照这个地址配置 https://www.jianshu.com/p/e8dd1091d6d7 设置http代理 Https乱码问题 安装证书 断点修改代理这样就可以修改了 https://www.jianshu.com/p/0caaea590c8c Other -&gt; keychain Access 还有设置就解决了https乱码的问题 https://www.jianshu.com/p/0caaea590c8c type “ chls.pro/ssl ” in broswer 然后手机用这个地址配置下载 http://chls.pro/ssl Okhttp https://juejin.im/post/5ddddd2a6fb9a07161483fb2 Mock data https://zhuanlan.zhihu.com/p/140942687 Fiddlerhttps://www.jianshu.com/p/4a8dae519efehttps://www.jianshu.com/p/99b6b4cd273c WireShark安装https://www.linuxidc.com/Linux/2016-08/134526.htm http://www.cnblogs.com/wangqiguo/p/4529250.htmlhttp://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html https://juejin.im/post/5cc313755188252d6f11b463","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"Generics","slug":"Generics","date":"2018-04-16T06:36:29.000Z","updated":"2023-01-02T03:31:39.074Z","comments":true,"path":"2018/04/16/Generics/","link":"","permalink":"https://noteforme.github.io/2018/04/16/Generics/","excerpt":"","text":"https://www.bilibili.com/video/BV1T441117u8 泛型继承类型1class Button extends TextView 不能把子类的List对象 ArrayList 赋值给父类的List引用 List Java ? extends TextView1234567891011121314151617 List&lt;TextView&gt; textViews=new ArrayList&lt;&gt;(); List&lt;TextView&gt; textViews=new ArrayList&lt;Button&gt;(); //报错 // 解决办法 List&lt;? extends TextView&gt; textViews =new ArrayList&lt;Button&gt;(); //解除了赋值限制//新增了限制， 只能消费使用,不能生产 TextView textView = new TextView(this); textViews.add(textView); //报错， 不能调用textViews的包含 类型参数的方法 TextView textView = textViews.get(0); // 没有问题 List&lt;Button&gt; buttons=new ArrayList&lt;Button&gt;(); textView = buttons;//报错 ? super Button12345678910ArrayList&lt;Button&gt; textViews1 = new ArrayList&lt;TextView&gt;();ArrayList&lt;? super Button&gt; textViews2 = new ArrayList&lt;TextView&gt;(); //新增了限制Button button = textViews2.get(0); //报错, 不能使用，只能生产textViews1.add(new Button(this)); // 没有问题 Java kotlin对比Java 123List&lt;? extends TextView&gt; textViews;List&lt;? super Button&gt; textViews; Kotlin 12var textVies: List&lt;out TextView&gt;var textVies: List&lt;in TextView&gt; kotlin新增用法表示我这个类型,这个类只用来输出或者输入 1234567interface Producer&lt;out T&gt;&#123; fun produce(): T&#125;interface Consumer&lt;in T&gt;&#123; fun consume(product:T)&#125; *用法Java 123List&lt;?&gt; textViews;相当于List&lt;? extends Object&gt; textViews; Kotlin 123var textVies: List&lt;*&gt;相当于var textVies: List&lt;out Any&gt; 如果类型声明里，已经有了out或者in,这个限制在变量声明时也依然存在,不会因为*去掉 1234567interface Counter&lt;out T : Number&gt;&#123; fun count(): T&#125;var counter: Counter&lt;*&gt; =;那么Counter&lt;*&gt;就相当于下面的情况 Counter&lt;out Number&gt;var counter: Counter&lt;out Number&gt; 类型声明上界注意这里是T extend Animal ，和带? extend Animal 的声明不是一个东西 java 123class Monster&lt;T extends Animal &amp; Food&gt;&#123;&#125; kotlin 1234class Monster&lt;T : Animal&gt;&#123;&#125; // 一个上界class Monster&lt;T&gt; where T : Animal, T : Food&#123;&#125; // 多个上界 refieldjava 123&lt;T&gt; void printIfTypeMatch(Object item)&#123; if(item instanceof T)&#123;&#125; // 报错，不能检查一个对象,是不是一个T的实例 &#125; kotlin 12345678fun &lt;T&gt; void printIfTypeMatch(item : Any)&#123; if(item instanceof T)&#123;&#125; // 报错，不能检查一个对象,是不是一个T的实例 &#125;inline fun &lt;reified T&gt; void printIfTypeMatch(item : Any)&#123;//reified自身限制，只能用在inline if(item instanceof T)&#123;&#125; // 正常编译 &#125; Java泛型类1234567891011121314151617181920212223public class Order&lt;T&gt; &#123; String orderName; int orderId; T orderT; public Order() &#123; &#125; public Order(String orderName, int orderId, T orderT) &#123; this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125;&#125; 子类不是泛型类 父类指明类型,由于子类在继承带泛型的父类时，指明了泛型类型，则实例化子类对象时，不再需要指明泛型。 123456789public class SubOrder extends Order&lt;Integer&gt; &#123;&#125;@Testpublic void test1()&#123; //由于子类在继承带泛型的父类时，指明了泛型类型，则实例化子类对象时，不再需要指明泛型。 SubOrder subOrder = new SubOrder(); subOrder.setOrderT(1122); &#125; 子父类关系类A是类B的父类，G和G二者不具备父子类关系,也不具任何关系。 类A是类B的父类，A是 B的父类。 反证法: https://www.bilibili.com/video/BV1fi4y1b7NM?p=11 子类是泛型类12345public class SubOrder1&lt;T&gt; extends Order&lt;T&gt; &#123;&#125;SubOrder1&lt;String&gt; sub2 = new SubOrder1&lt;&gt;();sub2.setOrderT(&quot;order...&quot;); 泛型方法123456789101112131415161718public class Person3&lt;T&gt; &#123; //泛型普通方法 public void show(T name) &#123; System.out.println(name + &quot;正在演讲&quot;); &#125; public &lt;M&gt; void show1(M name) &#123; System.out.println(name + &quot;正在演讲&quot;); &#125; //静态泛型方法中的类型占位符和类中的泛型占位符是没有关系的 public static &lt;W&gt; void show2(W name) &#123; System.out.println(name + &quot;：静态方法正在演讲!&quot;); &#125; public static &lt;E&gt; E show3(E name) &#123; return name; &#125;&#125; 泛型接口123interface PerInt&lt;T&gt; &#123; fun show(name: T)&#125; 泛型接口的实现类 可以指定具体的泛型接口的具体泛型类型 1234class PerImtImpl : PerInt&lt;String&gt; &#123; override fun show(name: String) &#123; &#125;&#125; 泛型接口的实现类，如果没有指定具体的泛型类型，必须要在这个实现类中声明一个泛型类型的占位符给接口用 1234class PerImtImpl01&lt;T&gt; : PerInt&lt;T&gt; &#123; override fun show(name: T) &#123; &#125;&#125; 类型擦除Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。 泛型的作用是能在编译期间就提示错误，而不是运行时。 1234val p1 = PerImtImpl01&lt;String&gt;()val p2 = PerImtImpl01&lt;Int&gt;()println(p1.javaClass == p2.javaClass)println(p1.javaClass === p2.javaClass) 通配符Java中的继承 ，在泛型中并不是父子类关系 12345678910111213141516class PerImtImpl01&lt;T&gt; : PerInt&lt;T&gt; &#123; var name: T get() &#123; return name &#125; set(value) &#123; name = value &#125; override fun show(name: T) &#123; &#125; fun show(p: PerImtImpl01&lt;*&gt;) &#123;//如果是T类型 编译报错，虽然Int:Number,但是在泛型中不存在继承关系 name = p.name as T &#125;&#125; 1234val p3 = PerImtImpl01&lt;Number&gt;()val p4 = PerImtImpl01&lt;Int&gt;()p3.name = 111p4.show(p3) 符号区别Java用 ？ Kotlin 用 * 无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型 类A是类B的父类，G和G的公共的父类是: G&lt;?&gt; 遍历List12345678910111213141516171819202122232425@Test public void test2()&#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; List&lt;?&gt; list = null; list = list1; list = list2; print(list1); print(list2); &#125; public void print(List&lt;?&gt; list)&#123; Iterator&lt;?&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; Object o = iterator.next(); System.out.println(o); &#125; list.forEach(o -&gt; &#123; System.out.println(o); &#125;); &#125; 对于List 就不能向其添加数据。如果任何类型引用通过赋值给 List 能添加数据，那定义泛型就没意义了 123456789101112131415 List&lt;?&gt; list = null; ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); list3.add(&quot;AA&quot;); list3.add(&quot;BB&quot;); list3.add(&quot;CC&quot;); list = list3; //添加(写入):对于List&lt;?&gt; 就不能向其添加数据，如果能添加数据，那定义泛型就没意义了。 //除了添加null之外// list.add(&quot;MED&quot;);// list.add(&quot;?&quot;); list.add(null); //可以获取数据，读取的数据类型为Object Object o = list.get(0); System.out.println(o); 上下界如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： &quot;StaticGenerator cannot be refrenced from static context&quot; */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。 上界通配符 &lt;? extends T&gt;泛型中的继承 泛型中的继承不是Java中的继承。也就是说java中的父子类关系， 在泛型中 并不是父子类关系。 1234567891011121314151617181920212223class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Plate&lt;T&gt; &#123; T item; public Plate() &#123; &#125; public Plate(T item) &#123; this.item &#x3D; item; &#125; public T get() &#123; return item; &#125; public void set(T item) &#123; this.item &#x3D; item; &#125;&#125; ? extends Fruit赋值 ，无法添加数据，不知道子类到底多小.? extends Fruit 可以理解为 &lt;= Fruit, List&lt;? extends Fruit&gt; 可以作为 List ， List的父类。 1234567891011121314151617// List&lt;Fruit&gt; list1 = new ArrayList&lt;Apple&gt;(); //编译报错，泛型具体类型 List&lt;Fruit&gt; ,ArrayList&lt;Apple&gt; 不存在继承关系 // ? extends Fruit 可以理解为 &lt;= Fruit // List&lt;? extends Fruit&gt; // 可以作为 List&lt;Apple&gt; ， List&lt;Fruit&gt;的父类。 List&lt;? extends Fruit&gt; list4 = new ArrayList&lt;Apple&gt;(); List&lt;? extends Fruit&gt; list5= new ArrayList&lt;Fruit&gt;();// List&lt;? extends Fruit&gt; list5 =new ArrayList&lt;Object&gt;(); //编译报错，Object类不在 &lt;= Fruit范围内 /** * 只能读取数据 , 不能修改数据 */ Fruit fruit = list4.get(0);// Apple apple =list2.get(0); //编译不通过， &lt;= Fruit范围，list1.get(0)实际类型可能是Fruit，是Apple的父类。// list1.add(new Apple()); //编译报错，&lt;= Fruit范围， List&lt;? extends Fruit&gt;实际类型可能比是GreenApple,比Apple范围还小，随意存不了数据 读取数据? extends Fruit 所以泛型最大的父类就是Fruit,子类型可以直接复制给父类 12345678 /** * 只能读取数据 , 不能修改数据 */ Fruit fruit = list4.get(0);// Apple apple =list2.get(0); //编译不通过， &lt;= Fruit范围，list1.get(0)实际类型可能是Fruit，是Apple的父类。// list1.add(new Apple()); //编译报错，&lt;= Fruit范围， List&lt;? extends Fruit&gt;实际类型可能比是GreenApple,比Apple范围还小，随意存不了数据 你会发现无法往里面设置任何数据，按道理说我们将泛型类型设置为? extend Fruit。按理说我们往里面添加Fruit的子类应该是可以的。但是Java编译器不允许这样操作。&lt;? extends Fruit&gt;会使往盘子里放东西的set()方法失效。但取东西get()方法还有效 原因是：Java编译期只知道容器里面存放的是Fruit和它的子类，具体是什么类型不知道，可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在后面看到Plate&lt; Apple &gt;赋值以后，盘子里面没有标记为“苹果”。只是标记了一个占位符“CAP#1”，来表示捕获一个Fruit或者Fruit的派生类，具体是什么类型不知道。所有调用代码无论往容器里面插入Apple或者Meat或者Fruit编译器都不知道能不能和这个“CAP#1”匹配，所以这些操作都不允许。 一个Plate&lt;? extends Fruit&gt;的引用，可能是一个Plate 类型的盘子，要往这个盘子里放当然是不被允许的. 但是上界通配符是允许读取操作的。例如代码 这个我们很好理解，由于上界通配符设定容器中只能存放Fruit及其子类，那么获取出来的我们都可以隐式的转为Fruit基类。所以上界描述符Extends适合频繁读取的场景。 Java类型擦除只会擦除到Fruit类型,如果没有指明边界，那么类型参数将被擦除到Object. 写入数据可以发现任何数据都不能存入。[-∞,Fruit]范围，-∞不知道具体的类型小到多少 1list1.add(new Apple()); //编译报错，&lt;= Fruit范围， List&lt;? extends Fruit&gt;实际类型可能比是GreenApple,比Apple范围还小，随意存不了数据 下界通配符 &lt;? super T&gt; ? super Fruit赋值,只能添加数据 。 ? super Fruit 可以理解为 &gt;= Fruit 12345678910 //只能修改数据，不能读取数据 // &lt;? super Fruit&gt; List&lt;? super Fruit&gt; list6 = new ArrayList&lt;Fruit&gt;(); // ? super Fruit 可以理解为 &gt;= Fruit List&lt;? super Fruit&gt; list7 = new ArrayList&lt;Object&gt;(); Object object = list6.get(0); //理论上不能读取，但是都到Object还是可以的// Food food = list2.get(0); //编译不通过，&gt;=Fruit范围，list2.get(0)实际类型可能是Object,不能赋值给小于它子类，所以只能是Object 读取数据123 Object object = list6.get(0); //理论上不能读取，但是都到Object还是可以的// Food food = list2.get(0); //编译不通过，&gt;=Fruit范围，list2.get(0)实际类型可能是Object,不能赋值给小于它子类，所以只能是Object 写入数据 ? super Fruit范围是是 [Fruit,+∞), 所以Fruit范围内的都可以添加 123 list6.add(new Fruit()); list6.add(new Apple()); //// list6.add(new Food()); // ? super Fruit范围是是 [Fruit,+∞), 所以Fruit范围内的都可以添加 下界通配符&lt;? super Fruit&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。 下界通配符规定了元素最小的粒度，必须是Fruit或其基类，那么我往里面存储Fruit及其子类都是可以的，因为它都可以隐式的转化为Fruit类型。但是往外读就不好控制了，里面存储的都是Fruit及其基类，无法转型为任何一种类型，只有Object基类才能装下。 https://juejin.im/post/5b614848e51d45355d51f792 www.jianshu.com/p/dd34211f2565 https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/ https://www.bilibili.com/video/BV1xJ411n77R?p=7 kotlinout in 和 extend super没关系 out只能获取 不能修改 1234 var list:MutableList&lt;out Fruit&gt; = ArrayList&lt;Apple&gt;() // ? extends Fruit 实际类型可能比是Apple小// list.add(Apple()) 编译报错 var list2: ArrayList&lt;in Apple&gt; = ArrayList&lt;Fruit&gt;() // ? super Fruit 实际类型可能比是Apple大很多// list2.get(0) https://www.bilibili.com/video/BV1xv411k7Dd?p=4&amp;spm_id_from=pageDriver https://noteforme.github.io/2021/08/21/kotlin-object/#Out-In https://www.bilibili.com/video/BV1Hy4y1H7oS?p=7 泛型数组 可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象 123456789ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;();intList.add(100); ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();strList.add(&quot;abc&quot;);listArr[0] = strList;String s = listArr[0].get(0);System.out.println(s); 可以通过java.lang.reflect.Array的newInstance(Class,int) 创建T[]数组 12345678910111213141516171819public class FruitArr&lt;T&gt; &#123; private T[] array; public FruitArr(Class&lt;T&gt; clz, int length) &#123; this.array = (T[]) Array.newInstance(clz, length); &#125; public void put(int index, T item) &#123; array[index] = item; &#125; public T get(int index)&#123; return array[index]; &#125; public T[] getArray()&#123; return array; &#125;&#125; 123456FruitArr&lt;String&gt; fruit = new FruitArr&lt;&gt;(String.class,3);fruit.put(0,&quot;苹果&quot;);fruit.put(1,&quot;西瓜&quot;);fruit.put(2,&quot;香蕉&quot;);String s1 = Arrays.toString(fruit.getArray());System.out.println(s1); ​ 泛型与反射123Class&lt;Person&gt; personClass = Person.class;Constructor&lt;Person&gt; constructor = personClass.getConstructor();Person person = constructor.newInstance(); ​ https://www.bilibili.com/video/BV1xJ411n77R?p=12 $i$f$withM 有时候看到$以为是操作符，其实就是$i$f$withM整体的变量 123Array&lt;out Any&gt; 对应于 Java 的 Array&lt;? extends Object&gt;Array&lt;in String&gt; 对应于 Java 的 Array&lt;? super String&gt;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"token","slug":"token","date":"2018-03-29T09:41:28.000Z","updated":"2021-08-19T11:11:44.316Z","comments":true,"path":"2018/03/29/token/","link":"","permalink":"https://noteforme.github.io/2018/03/29/token/","excerpt":"","text":"rxjava 方式http://alighters.com/blog/2016/05/02/rxjava-plus-retrofitshi-xian-wang-luo-dai-li/http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/ 最流行的网络请求框架Rxjava2+Retrofit之Token处理 https://blog.csdn.net/jdsjlzx/article/details/52442113 https://blog.csdn.net/qq_20521573/article/details/76100558 拦截器做控制https://blog.csdn.net/u012771445/article/details/79750648 https://blog.csdn.net/bestlbw/article/details/53984647 https://www.jianshu.com/p/c325f5c32709 RxjavaPlugin处理tokenhttps://github.com/ssseasonnn/RxErrorHandler","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"RxJava01","slug":"RxJava01","date":"2018-03-28T09:58:39.000Z","updated":"2021-08-19T11:11:44.237Z","comments":true,"path":"2018/03/28/RxJava01/","link":"","permalink":"https://noteforme.github.io/2018/03/28/RxJava01/","excerpt":"","text":"RxJavaDescribe subscribeOn() 指定上游发送事件的线程, observeOn 指定的是下游接收事件的线程 多次指定上游的线程只有第一次指定的有效,就是subscribeOn()只有第一次有效,其余忽略 可以多次指定下游线程,每调用一次observeOn(),下游的线程就会切换一次 Demo在 AndroidDemo -&gt; RXLeran-&gt;RX基础-&gt;Rx线程切换 链式调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758RetrofitFactory.create(ICommonApis.class) .imgUpServer(part) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;PictureUp&gt;() &#123; @Override public void accept(PictureUp pictureUp) throws Exception &#123; List&lt;PictureUp.ModelListBean&gt; picList = pictureUp.getModel_list(); if (picList != null &amp;&amp; !picList.isEmpty()) &#123; String feet_id = picList.get(0).getFile_group_id(); //上传成功 if (!isEmpty(feet_id) &amp;&amp; mvpView != null) &#123; mvpView.upFeetId(feet_id); &#125; &#125; &#125; &#125;) .observeOn(Schedulers.io()) .flatMap(new Function&lt;PictureUp, ObservableSource&lt;BaseCount&gt;&gt;() &#123; @Override public ObservableSource&lt;BaseCount&gt; apply(PictureUp pictureUp) throws Exception &#123; List&lt;PictureUp.ModelListBean&gt; picList = pictureUp.getModel_list(); if (picList != null &amp;&amp; !picList.isEmpty()) &#123; String feet_id = picList.get(0).getFile_group_id(); //上传成功 if (!isEmpty(feet_id) &amp;&amp; mvpView != null) &#123; mvpView.upFeetId(feet_id); &#125;else &#123; return Observable.error(new Exception()); &#125; &#125; return RetrofitFactory.create(ICommonApis.class).offlineBoxInfo(requestBody); &#125; &#125;) .subscribe(new Consumer&lt;BaseCount&gt;() &#123; @Override public void accept(BaseCount baseCount) throws Exception &#123; if (mvpView == null) &#123; return; &#125; if (baseCount.getMeta().getStatusCode() == AUTH_FAILED) &#123; mvpView.unOfficeEquip(baseCount); &#125; else if (baseCount.getMeta().getStatusCode() == 0) &#123; mvpView.upSuccess(); &#125; else &#123; if (baseCount.getMeta() != null &amp;&amp; !isEmpty(baseCount.getMeta().getDescribe())) &#123; ToastUtil.showBiggerText(baseCount.getMeta().getDescribe()); &#125; &#125; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; if (mvpView != null) &#123; mvpView.upUserInfoFailed(); &#125; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536fun getImgScan() &#123; val request = RetrofitWeChatFactory.create(IApiStore::class.java) request.get_access_token() .flatMap &#123; request.getTicket(it.access_token, 2) &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(object : Observer&lt;WeChatSecond&gt; &#123; override fun onComplete() &#123; &#125; override fun onSubscribe(d: Disposable) &#123; &#125; override fun onNext(t: WeChatSecond) &#123; val noncestr = LoginNewActivity.getRandomString(8) val timeStamp = (System.currentTimeMillis() / 1000).toString() t.ticket?.let &#123; val string1 = String.format( &quot;appid=%s&amp;noncestr=%s&amp;sdk_ticket=%s&amp;timestamp=%s&quot;, WeChatAppID, noncestr, it, timeStamp ) val sha = EncryptUtils.getSHA(string1) mvpView.sign(noncestr, timeStamp, sha) &#125; &#125; override fun onError(e: Throwable) &#123; &#125; &#125;)&#125; http://yamlee.me/2020/03/11/2020-03-11-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E4%B8%8ERxKotlin/ http://reactivex.io/documentation/operators.html https://www.jianshu.com/p/fa1828d70192 https://www.cnblogs.com/fuyaozhishang/p/8697404.html Sample水管系列 https://github.com/ReactiveX/RxAndroidhttps://github.com/amitshekhariitbhu/RxJava2-Android-Sampleshttps://github.com/rengwuxian/RxJavaSample https://github.com/ssseasonnn/RxJava2Demo https://juejin.im/post/5b8f536c5188255c352d3528 RxJava 只看这一篇文章就够了(上) RxJava 只看这一篇文章就够了 (中) RxJava 只看这一篇文章就够了 (下) 使用MVP Dagger2 https://juejin.im/post/5d5ce44d5188252231108e68 https://juejin.im/user/590210f4ac502e0063d338f5/posts","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://noteforme.github.io/tags/RxJava/"}]},{"title":"interview-answer","slug":"interview-answer","date":"2018-03-12T04:44:01.000Z","updated":"2024-10-01T12:00:04.537Z","comments":true,"path":"2018/03/12/interview-answer/","link":"","permalink":"https://noteforme.github.io/2018/03/12/interview-answer/","excerpt":"","text":"阿里面试题1.android事件分发机制，请详细说下整个流程 事件分发（面试）.png 2.android view绘制机制和加载过程，请详细说下整个流程 1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。 2.performMeasure()会调用最外层的ViewGroup的measure()–&gt;onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()–&gt;setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。 3.performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()–&gt;子View.layout()。 4.performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。 5.MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。 6.三种方式获取measure()后的宽高： 1.Activity#onWindowFocusChange()中调用获取 2.view.post(Runnable)将获取的代码投递到消息队列的尾部。 3.ViewTreeObservable. 自定义 View 的绘制顺序 3.android四大组件的加载过程，请详细介绍下 1.android四大组件的加载过程:这是我总结的一篇博客 4.Activity的启动模式 1.standard:默认标准模式，每启动一个都会创建一个实例， 2.singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始 3.singleTask：栈内复用，本栈内只要用该类型Activity就会将其顶部的activity出栈 4.singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈， 5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的 1.这个题目需要深入了解activity的启动模式 2.最后的答案是：两个栈，前台栈是只有D，后台栈从底至上是A、B、C 6.Activity缓存方法 1.配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。 2.内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。 7.Service的生命周期，两种启动方法，有什么区别 1.context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running–&gt;(如果调用context.stopService() )-&gt;onDestroy() -&gt;Service shut down 1.如果Service还没有运行，则调用onCreate()然后调用onStart()； 2.如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。 3.调用stopService的时候直接onDestroy， 4.如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。 2.context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running–&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop 1.onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。 2.这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind-&gt;onDestroy相应退出。 3.所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。 8.怎么保证service不被杀死 1.提升service优先级 2.提升service进程优先级 3.onDestroy方法里重启service 9.静态的Broadcast 和动态的有什么区别 1.动态的比静态的安全 2.静态在app启动的时候就初始化了 动态使用代码初始化 3.静态需要配置 动态不需要 4.生存期，静态广播的生存期可以比动态广播的长很多 5.优先级动态广播的优先级比静态广播高 10.Intent可以传递哪些数据类型 1.Serializable 2.charsequence: 主要用来传递String，char等 3.parcelable 4.Bundle 11.Json有什么优劣势、解析的原理 1.JSON的速度要远远快于XML 2.JSON相对于XML来讲，数据的体积小 3.JSON对数据的描述性比XML较差 4.解析的基本原理是：词法分析 12.一个语言的编译过程 1.词法分析：将一串文本按规则分割成最小的结构，关键字、标识符、运算符、界符和常量等。一般实现方法是自动机和正则表达式 2.语法分析：将一系列单词组合成语法树。一般实现方法有自顶向下和自底向上 3.语义分析：对结构上正确的源程序进行上下文有关性质的审查 4.目标代码生成 5.代码优化：优化生成的目标代码， 13.动画有哪几类，各有什么特点 1.动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。 2.View动画:只是影像变化，view的实际位置还在原来的地方。 3.帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。 4.View的属性动画： 1.插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比 2.估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类 14.Handler、Looper消息队列模型，各部分的作用 1.MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。 2.Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。 3.Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。 4.系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。 5.MessageQueue和Looper是一对一关系，Handler和Looper是多对一 15.怎样退出终止App 1.自己设置一个Activity的栈，然后一个个finish() 16.Android IPC:Binder原理 1.在Activity和Service进行通讯的时候，用到了Binder。 1.当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作 2.当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。 2.系统给我们生成的Binder： 1.Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service 2.Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。 3.哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。 4.当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。 5.如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。 6.IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket 17.描述一次跨进程通讯 1.client、proxy、serviceManager、BinderDriver、impl、service 2.client发起一个请求service信息的Binder请求到BinderDriver中，serviceManager发现BinderDiriver中有自己的请求 然后将clinet请求的service的数据返回给client这样完成了一次Binder通讯 3.clinet获取的service信息就是该service的proxy，此时调用proxy的方法，proxy将请求发送到BinderDriver中，此时service的 Binder线程池循环发现有自己的请求，然后用impl就处理这个请求最后返回，这样完成了第二次Binder通讯4.中间client可挂起，也可以不挂起，有一个关键字oneway可以解决这个 18.android重要术语解释 1.ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期 2.ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作 3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。 4.ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。 5.Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。 6.ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。 7.ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。 8.TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。 19.理解Window和WindowManager 1.Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏) 2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。 3.Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。 4.WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View 5.Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。 6.Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。 20.Bitmap的处理 1.当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。 2.BitMap的缓存： 1.使用LruCache进行内存缓存。 2.使用DiskLruCache进行硬盘缓存。 3.实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取 1.同步加载只创建一个线程然后按照顺序进行图片加载 2.异步加载使用线程池，让存在的加载任务都处于不同线程 3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载 21.如何实现一个网络框架 1.缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。 2.网络请求队列，使用线程池进行请求。 3.提供各种不同类型的返回值的解析如String，Json，图片等等。 22.ClassLoader的基础知识 1.双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。 2.可以动态加载Jar通过URLClassLoader 3.ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。 4.加载不同Jar包中的公共类： 1.让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java) 2.重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java) 3.在生成包含公共Jar的Jar时候把公共Jar去掉。 25.线程同步的问题，常用的线程同步 1.sycn：保证了原子性、可见性、有序性 2.锁：保证了原子性、可见性、有序性 1.自旋锁:可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环。 1.优点:线程被挂起的几率减少，线程执行的连贯性加强。用于对于锁竞争不是很激烈，锁占用时间很短的并发线程。 2.缺点:过多浪费CPU时间，有一个线程连续两次试图获得自旋锁引起死锁 2.阻塞锁:没得到锁的线程等待或者挂起，Sycn、Lock 3.可重入锁:一个线程可多次获取该锁，Sycn、Lock 4.悲观锁:每次去拿数据的时候都认为别人会修改，所以会阻塞全部其他线程 Sycn、Lock 5.乐观锁:每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。cas 6.显示锁和内置锁:显示锁用Lock来定义、内置锁用synchronized。 7.读-写锁:为了提高性能，Java提供了读 3.volatile 1.只能保证可见性，不能保证原子性 2.自增操作有三步，此时多线程写会出现问题 4.cas 1.操作:内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。 2.解释:本地副本为A，共享内存为V，线程A要把V修改成B。某个时刻线程A要把V修改成B，如果A和V不同那么就表示有其他线程在修改V，此时就表示修改失败，否则表示没有其他线程修改，那么把V改成B。 3.局限:如果V被修改成V1然后又被改成V，此时cas识别不出变化，还是认为没有其他线程在修改V，此时就会有问题 4.局限解决:将V带上版本。 5.线程不安全到底是怎么回事： 1.一个线程写，多个线程读的时候，会造成写了一半就去读 2.多线程写，会造成脏数据 26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法） 1.Asynctask：异步任务类，单线程线程池+Handler 2.线程池： 1.ThreadPoolExecutor：通过Executors可以构造单线程池、固定数目线程池、不固定数目线程池。 2.ScheduledThreadPoolExecutor：可以延时调用线程或者延时重复调度线程。 3.GC相关：重要 1.搜索算法： 1.引用计数 2.图搜索，可达性分析 2.回收算法： 1.标记清除复制：用于青年代 2.标记整理：用于老年代 3.堆分区： 1.青年区eden 80%、survivor1 10%、survivor2 10% 2.老年区 4.虚拟机栈分区： 1.局部变量表 2.操作数栈 3.动态链接 4.方法返回地址 5.GC Roots: 1.虚拟机栈(栈桢中的本地变量表)中的引用的对象 2.方法区中的类静态属性引用的对象 3.方法区中的常量引用的对象 4.本地方法栈中JNI的引用的对象 28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下29.13.APK打包流程和其内容 1.流程 1.aapt生成R文件 2.aidl生成java文件 3.将全部java文件编译成class文件 4.将全部class文件和第三方包合并成dex文件 5.将资源、so文件、dex文件整合成apk 6.apk签名 7.apk字节对齐 2.内容：so、dex、asset、资源文件 31.java类加载过程： 1.加载时机：创建实例、访问静态变量或方法、反射、加载子类之前 2.验证：验证文件格式、元数据、字节码、符号引用的正确性 3.加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象 4.准备：在堆上为静态变量划分内存 5.解析：将常量池中的符号引用转换为直接引用 6.初始化：初始化静态变量 7.书籍推荐：深入理解java虚拟机，博客推荐：Java&#x2F;Android阿里面试JVM部分理解 32.retrofit的了解 1.动态代理创建一个接口的代理类 2.通过反射解析每个接口的注解、入参构造http请求 3.获取到返回的http请求，使用Adapter解析成需要的返回值。 33.bundle的数据结构，如何存储 1.键值对储存 2.传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。 3.当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口 34.listview内点击buttom并移动的事件流完整拦截过程： 1.点下按钮的时候： 1.产生了一个down事件，activity–&gt;phoneWindow–&gt;ViewGroup–&gt;ListView–&gt;botton,中间如果有重写了拦截方法，则事件被该view拦截可能消耗。 2.没拦截，事件到达了button，这个过程中建立了一条事件传递的view链表 3.到button的dispatch方法–&gt;onTouch–&gt;view是否可用–&gt;Touch代理 2.移动点击按钮的时候: 1.产生move事件，listView中会对move事件做拦截 2.此时listView会将该滑动事件消费掉 3.后续的滑动事件都会被listView消费掉 3.手指抬起来时候：前面建立了一个view链表，listView的父view在获取事件的时候，会直接取链表中的listView让其进行事件消耗。 35.service的意义：不需要界面，在后台执行的程序36.android的IPC通信方式，线程（进程间）通信机制有哪些 1.ipc通信方式：binder、contentprovider、socket 2.操作系统进程通讯方式：共享内存、socket、管道 37.操作系统进程和线程的区别 1.简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 2.线程的划分尺度小于进程，使得多线程程序的并发性高。 3.另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4.多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。 1.简单来说HashMap就是一个会自动扩容的数组链表 2.put过程 1.对key的hashCode()做hash，然后再计算index; 2.如果没碰撞直接放到bucket里； 3.如果碰撞了，以链表的形式存在buckets后； 4.如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 5.如果节点已经存在就替换old value(保证key的唯一性) 6.如果bucket满了(超过load factor*current capacity)，就要resize。 3.resize：当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中 4.get过程 1.根据key的hash算出数组下表 2.使用equals遍历链表进行比较 39.mvc、mvp、mvvm： 1.mvc:数据、View、Activity，View将操作反馈给Activity，Activitiy去获取数据，数据通过观察者模式刷新给View。循环依赖 1.Activity重，很难单元测试 2.View和Model耦合严重 2.mvp:数据、View、Presenter，View将操作给Presenter，Presenter去获取数据，数据获取好了返回给Presenter，Presenter去刷新View。PV，PM双向依赖 1.接口爆炸 2.Presenter很重 3.mvvm:数据、View、ViewModel，View将操作给ViewModel，ViewModel去获取数据，数据和界面绑定了，数据更新界面更新。 1.viewModel的业务逻辑可以单独拿来测试 2.一个view 对应一个 viewModel 业务逻辑可以分离，不会出现全能类 3.数据和界面绑定了，不用写垃圾代码，但是复用起来不舒服 40.java的线程如何实现 1.Thread继承 2.Runnale 3.Future 4.线程池 41.ArrayList 如何删除重复的元素或者指定的元素； 1.删除重复：Set 2.删除指定：迭代器 42.如何设计在 UDP 上层保证 UDP 的可靠性传输； 1.简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制,等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制。 2.比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输。 3.基于udp的可靠传输协议有：RUDP、RTP、UDT 43.Java 中内部类为什么可以访问外部类 1.因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去 44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)45.红黑树特点 1.root节点和叶子节点是黑色 2.红色节点后必须为黑色节点 3.从root到叶子每条路径的黑节点数量相同 46.linux异步和同步i&#x2F;o: 1.同步：对于client，client一直等待，但是client不挂起：主线程调用 2.异步：对于client，client发起请求，service好了再回调client：其他线程调用，调用完成之后进行回调 3.阻塞：对于service，在准备io的时候会将service端挂起，直至准备完成然后唤醒service：bio 3.非阻塞：对于service，在准备io的时候不会将service端挂起，而是service一直去轮询判断io是否准备完成，准备完成了就进行操作：nio、linux的select、poll、epoll 4.多路复用io：非阻塞io的一种优化，java nio，用一个线程去轮询多个 io端口是否可用，如果一个可用就通知对应的io请求，这使用一个线程轮询可以大大增强性能。 1.我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用。 2.而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。 5.异步io：aio，用户线程完全不感知io的进行，所有操作都交给内核，io完成之后内核通知用户线程。 1.这种io才是异步的，2、3、4都是同步io，因为内核进行数据拷贝的过程都会让用户线程阻塞。 2.异步IO是需要操作系统的底层支持，也就是内核支持，Java 7中，提供了Asynchronous IO 47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因: 1.HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 2.ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 48.HandlerThread是什么 1.MessageQueue + Looper + Handler 49.IntentService是什么 1.含有HandlerThread的Service，可以多次startService()来多次在子线程中进行 onHandlerIntent()的调用。 50.class和dex 1.dvm执行的是dex格式文件，jvm执行的是class文件，android程序编译完之后生产class文件。然后dex工具会把class文件处理成dex文件，然后把资源文件和.dex文件等打包成apk文件。 2.dvm是基于寄存器的虚拟机，而jvm执行是基于虚拟栈的虚拟机。寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。 3.class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的class文件整合到dex文件中。减少了I&#x2F;O操作，提高了类的查找速度 51.内存泄漏 1.其他线程持有一个Listener，Listener操作activity。那么在线程么有完毕的时候，activity关闭了，原本是要被回收的但是，不能被回收。 2.例如Handler导致的内存泄漏，Handler就相当于Listener。 3.在activity关闭的时候注意停止线程，或者将Listener的注册取消 3.使用弱引用，这样即使Listener持有了activity，在GC的时候还是会被回收 4.工具:LeakCanary 52.过度绘制、卡顿优化: 1.过度绘制： 1.移除Window默认的Background：getWidow.setBackgroundDrawable(null); 2.移除XML布局文件中非必需的Background 3.减少布局嵌套(扁平化的一个体现，减少View数的深度，也就减少了View树的遍历时间，渲染的时候，前后期的工作，总是按View树结点来) 4.在引入布局文件里面，最外层可以用merge替代LinearLayout,RelativeLayout，这样把子UI元素直接衔接在include位置 5.工具：HierarchyViewer 查看视图层级 2.卡顿优化：16ms数据更新 53.apk瘦身: 1.classes.dex：通过代码混淆，删掉不必要的jar包和代码实现该文件的优化 2.资源文件：通过Lint工具扫描代码中没有使用到的静态资源 3.图片资源：使用tinypng和webP，下面详细介绍图片资源优化的方案,矢量图 4.SO文件将不用的去掉，目前主流app一般只放一个arm的so包 54.ANR的形成，各个组件上出现ARN的时间限制是多少 1.只要是主线程耗时的操作就会ARN 如io 2.broadcast超时时间为10秒 按键无响应的超时时间为5秒 前台service无响应的超时时间为20秒，后台service为200秒 55.Serializable和Parcelable 的区别 1.P 消耗内存小 2.网络传输用S 程序内使用P 3.S将数据持久化方便 4.S使用了反射 容易触发垃圾回收 比较慢 56.Sharedpreferences源码简述 1.储存于硬盘上的xml键值对，数据多了会有性能问题 2.ContextImpl记录着SharedPreferences的重要数据，文件路径和实例的键值对 3.在xml文件全部内加载到内存中之前，读取操作是阻塞的，在xml文件全部内加载到内存中之后，是直接读取内存中的数据 4.apply因为是异步的没有返回值, commit是同步的有返回值能知道修改是否提交成功 5.多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 3.edit()每次都是创建新的EditorImpl对象. 6.博客推荐：**全面剖析SharedPreferences** 57.操作系统如何管理内存的： 1.使用寄存器进行将进程地址和物理内存进行映射 2.虚拟内存进行内存映射到硬盘上增大内存 3.虚拟内存是进行内存分页管理 4.页表实现分页，就是 页+地址偏移。 5.如果程序的内存在硬盘上，那么就需要用页置换算法来将其调入内存中：先进先出、最近未使用最少等等 6.博客推荐：**现代操作系统部分章节笔记** 58.浏览器输入地址到返回结果发生了什么 1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面 6.连接结束 59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。 1.发生在编译的时候 2.PECS，extends善于提供精确的对象 A是B的子集，Super善于插入精确的对象 A是B的超集 3.博客推荐：**Effective Java笔记（不含反序列化、并发、注解和枚举）、android阿里面试java基础锦集** 60.activity的生命周期 1.a启动b，后退键再到a的生命周期流程：a.create–&gt;a.start–&gt;a.resume–&gt;a.pause–&gt;b.create–&gt;b.start–&gt;b.resume–&gt;b界面绘制–&gt;a.stop–&gt;b.pause–&gt;b.stop–&gt;b.destroy–&gt;a.restart–&gt;a.start–&gt;a.resume 2.意外销毁会调用saveInstance，重新恢复的时候回调用restoreInstance。储存数据的时候使用了委托机制，从activity–&gt;window–&gt;viewGroup–&gt;view 会递归调用save来保持本view的数据，restore则是递归恢复本view数据。我们可以在里面做一些自己需要的数据操作。 61.面试常考的算法 1.快排、堆排序为首的各种排序算法 2.链表的各种操作：判断成环、判断相交、合并链表、倒数K个节点、寻找成环节点 3.二叉树、红黑树、B树定义以及时间复杂度计算方式 4.动态规划、贪心算法、简单的图论 5.推荐书籍：算法导论，将图论之前的例子写一遍 62.Launcher进程启动另外一个进程的过程：启动一个app63.开源框架源码 1.Fresco 1.mvc框架： 1.Controller控制数据显示在Hierarchy中的Drawable的显隐 2.ImagePipeline在Controller中负责进行数据获取，返回的数据是CloseableImage 3.Drawee把除了初始化之外的操作全部交给Holder去做，Holder持有Controller和Hierarchy 2.Drawable层次以及绘制： 1.如果要绘制一次Drawable就调用invalidateSelf()来触发onDraw() 2.Drawable分为：容器类(保存一些Drawable)、自我绘制类(进度条)、图形变换类(scale、rotate、矩阵变换)、动画类(内部不断刷新，进行webp和gif的帧绘制) 3.ImagePipeline返回的CloseableImage是由一个个DrawableFactory解析成Drawable的 4.webp和gif动画是由jni代码解析的，然后其他静态图片是根据不同的android平台使用BitmapFactory来解析的 3.职责链模式：producer不做操作标n，表示只是提供一个consumer。获取图片–》解码图片缓存Producer–》后台线程Producer–》client图片处理producer(n)–》解码producer(n)–》旋转或剪裁producer(n)–》编码图片内存缓存producer–》读硬盘缓存producer–》写硬盘缓存producer(n)–》网络producer提供CloseableImage《–解码图片缓存consumer《–client图片处理consumer《–解码consumer《–旋转或剪裁consumer《–编码图片内存缓存consumer《–写硬盘缓存consumer《–图片数据 4.内存缓存： 1.一个CountingLruMap保存已经没有被引用的缓存条目，一个CountingLruMap保存所有的条目包括没有引用的条目。每当缓存策略改变和一定时间缓存配置的更新的时候，就会将 待销毁条目Map中的条目一个个移除，直到缓存大小符合配置。 2.这里的引用计数是用Fresco组件实现的引用计数器。 3.缓存有一个代理类，用来追踪缓存的存取。 4.CountingLruMap是使用LinkedHashMap来储存数据的。 5.硬盘缓存： 1.DefaultDiskStorage使用Lru策略。 2.为了不让所有的文件集中在一个文件中，创建很多命名不同的文件夹，然后使用hash算法把缓存文件分散 3.DiskStorageCache封装了DefaultDiskStorage，不仅进行缓存存取追踪，并且其在内存里面维持着一个 &lt;key,value&gt; 的键值对，因为文件修改频繁，所有只是定时刷新，因此如果在内存中找不到，还要去硬盘中找一次。 4.删除硬盘的缓存只出现在硬盘数据大小超限的时候，此时同时也会删除缓存中的key，所以不会出现内存中有key，但是硬盘上没有的情况。 5.在插入硬盘数据的时候，采用的是插入器的形式。返回一个Inserter，在Inserter.writeData()中传入一个CallBack(里面封装了客户端插入数据的逻辑和文件引用)，让内部实现调用CallBack的逻辑来插入文件数据，前面写的文件后缀是.temp,只有调用commit()之后才会修改后缀，让文件对客户端可见。 6.使用了java提供的FileTreeVisitor来遍历文件 6.对象池： 1.使用数组来存储一个桶，桶内部是一个Queue。数组下标是数据申请内存的byte大小，桶内部的Queue存的是内存块的。所以数组使用的是稀疏数组 2.申请内存的方式有两种 1.java堆上开辟的内存 2.ashme 的本地内存中开辟的内存 7.设计模式：Builder、职责链、观察者、代理、组合、享元、适配器、装饰者、策略、生产者消费者、提供者 8.自定义计数引用：类似c++智能指针 1.使用一个静态IdentityHashMap &lt;储存需要被计数引用的对象,其被引用的次数&gt; 2.用SharedReference分装需要被计数引用的对象，提供一个销毁资源的销毁器，提供一个静态工厂方法来复制自己，复制一个引用计数加一。提供一个方法销毁自己，表示自己需要变成无人引用的对象了，此时引用计数减一。 3.引用计数归零，销毁器将销毁资源，如bitmap的recycle或者是jni内存调用jni方法归还内存。 9.博客推荐：**Android Fresco源码文档翻译、从零开始撸一个Fresco之硬盘缓存、从零开始撸一个Fresco之gif和Webp动画、从零开始撸一个Fresco之内存缓存、从零开始撸一个Fresco之总结** 2.oKhttp： 1.同步和异步： 1.异步使用了Dispatcher来将存储在 Deque 中的请求分派给线程池中各个线程执行。 2.当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，它将正在运行的任务Call从队列runningAsyncCalls中移除后，主动的把缓存队列向前走了一步。 2.连接池： 1.一个Connection封装了一个socket，ConnectionPool中储存s着所有的Connection，StreamAllocation是引用计数的一个单位 2.当一个请求获取一个Connection的时候要传入一个StreamAllocation，Connection中存着一个弱引用的StreamAllocation列表，每当上层应用引用一次Connection，StreamAllocation就会加一个。反之如果上层应用不使用了，就会删除一个。 3.ConnectionPool中会有一个后台任务定时清理StreamAllocation列表为空的Connection。5分钟时间，维持5个socket 3.选择路线与建立连接 1.选择路线有两种方式： 1.无代理，那么在本地使用DNS查找到ip，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源 2.有代理HTTP：设置socket的ip为代理地址的ip，设置socket的端口为代理地址的端口 3.代理好处：HTTP代理会帮你在远程服务器进行DNS查询，可以减少DNS劫持。 2.建立连接 1.连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步 2.根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手 3.将建立成功的RealConnection放入(put)连接池缓存 4.如果存在TLS，就根据SSL版本与证书进行安全握手 5.构造HttpStream并维护刚刚的socket连接，管道建立完成 4.职责链模式：缓存、重试、建立连接等功能存在于拦截器中网络请求相关，主要是网络请求优化。网络请求的时候遇到的问题 5.博客推荐：**Android数据层架构的实现 上篇、Android数据层架构的实现 下篇** 3.okio 1.简介； 1.sink：自己–》别人 2.source：别人–》自己 3.BufferSink：有缓存区域的sink 4.BufferSource：有缓存区域的source 5.Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行 2.比java io的好处： 1.减少内存申请和数据拷贝 2.类少，功能齐全，开发效率高 3.内部实现： 1.Buffer的Segment双向链表，减少数据拷贝 2.Segment的内部byte数组的共享，减少数据拷贝 3.SegmentPool的共享和回收Segment 4.sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source 5.最终okio只是对java io的封装，所有操作都是基于java io 的 写在最后:能看到这里的人,我挺佩服你的.这篇文章是我在头条面试之前整理的,最后**80%**的题目都命中了,所以祝你好运. 不贩卖焦虑，也不标题党。分享一些这个世界上有意思的事情。题材包括且不限于：科幻、科学、科技、互联网、程序员、计算机编程。下面是我的微信公众号：世界上有意思的事，干货多多等你来看。 作者：何时夕链接：https://www.jianshu.com/p/cf5092fa2694来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 百度面试题电话面试 1234561. 安卓View绘制流程2. 事件分发机制3. JAVA基础思想4. 多线程和安全问题5. 安卓性能优化和兼容问题6. 再问一下常规的组件相关问题 现场笔试 1234567891011121314151617181920212223242526272829303132331 请描述安卓四大组建之间的关系，并说下安卓MVC的设计模式。2 线程中sleep()和wait()有和却别，各有什么含义 3 abstract和interface的区别?4 array,arrayList, List ,三者有何区别？5 hashtable和hashmap的区别,并简述Hashmap的实现原理6 StringBuilder和],String ,subString方法的细微差别7 请写出四种以上你知道的设计模式，并介绍下实现原理8 安卓子线程是否能更新UI，如果能请说明具体细节。9 ANR产生的原因和解决步骤10 JavaGC机制的原理和内存泄露11 安卓布局优化方案， 12 请在100个电话号码找出135的电话号码 注意 不能用正则，（类似怎么最好的遍历LogGat日志）13 Handler机制，请写出一种更新UI的方法和代码14 请解释安卓为啥要加签名机制。15 你觉得安卓开发最关键的技术在哪里？13 Handler机制，请写出一种更新UI的方法和代码14 请解释安卓为啥要加签名机制。15 你觉得安卓开发最关键的技术在哪里？ 一轮面试： 12345678910111213141516171819202122232425262728291 ANR 具体产生的类型有哪些，具体说下其产生的最大超时时间。2 多线程多点下载的过程3 http协议的理解和用法4 安卓解决线程并发问题5 你知道的数据结构有哪些，说下具体实现机制6 十六进制数据怎么和十进制和二进制之间转换7 谈下对Java OOP中多态的理解8 activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信9 怎么让自己的进程不被第三方应用杀掉，系统杀掉之后怎么能启动起来。10 说下平时开发中比较注意的一些问题，答 ：可以熟说下svn和git的细节，和代码规范问题，和一些安全信息的问题等11 自定义view效率高于xml定义吗？说明理由。13 广播注册一般有几种，各有什么优缺点14 服务启动一般有几种，服务和activty之间怎么通信，服务和服务之间怎么通信15 布局优化主要哪些？具体优化？16 数据库的知识，包括本地数据库优化点。 二轮面试 123456789101112131415161718192021222324252627282930313233343536371 安卓事件分发机制，请详细说下整个流程2 安卓view绘制机制和加载过程，请详细说下整个流程3 activty的加载过程 请详细介绍下（不是生命周期切记）4 安卓采用自动垃圾回收机制，请说下安卓内存管理的原理5 说下安卓虚拟机和java虚拟机的原理和不同点 6 多线程中的安全队列一般通过什么实现？线程池原理？（java）7 安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以（操作系统）8 socket短线重连怎么实现，心跳机制又是怎样实现，四次握手步骤有哪些（网络通讯原理）9 http中TCP和UDP有啥区别，说下HTTP请求的IP报文结构（计算机网络）10 你知道的安全加密有哪些？ （如果你说了一个加密，面试官就会接着跟进提问，所以之前你必须要会，不会的话背也要背下来）（安全加密）11 你知道的数据存储结构？堆栈和链表内部机制。（数据结构）12 说下Linux进程和线程的区别。进程调度优先级，和cpu调度进程关系。（操作系统）13 请你详细说下你知道的一种设计模式，并解释下java的高内聚和低耦合。14 spring 的反射和代理，在安卓中应用场景（插件和ROM数据框架）15 JNI 调用过程中 混淆问题16 看过安卓源码吗，请说出一个你看过的API或者组建内部原理。17 android 5.0 6.0 以及7.0预测新特性18 hybrid混合开发，响应式编程等17为啥离职呢 对待加班看法18 你擅长什么，做了那些东西。 名企面试题Android基础 [Android 源码中的设计模式(你需要知道的设计模式全在这里)](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 源码中的设计模式(你需要知道的设计模式全在这里).md) 全面了解Activity Service全面总结 IntentService使用详解和实例介绍 [Fragment 全解析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Fragment 全解析.md) ContentProvider实例详解 BroadcastReceiver使用总结 Android异步任务机制之AsycTask Android启动过程图解 [Android 自定义View入门](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 自定义View入门.md) [Android 自定义ViewGroup入门实践](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 自定义ViewGroup入门实践.md) [Android 缓存机制](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 缓存机制.md) [Android 数据存储五种方式使用与总结](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 数据存储五种方式使用与总结.md) [Android 异步消息处理机制源码解析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 异步消息处理机制（Handler 、 Looper 、MessageQueue）源码解析.md) [Android View事件分发机制源码分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android View事件分发机制源码分析.md) [Android SQLite的使用入门](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android SQLite的使用入门.md) AIDL的使用情况和实例介绍 [Android 名企面试题及答案整理（一）](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 名企面试题及答案整理（一）.md) 问题 Android5.0、6.0、7.0新特性 Android中弱引用与软引用的应用场景 Android长连接，怎么处理心跳机制 Asset目录与res目录的区别 Binder机制原理和底层实现 Json优劣势 ListView优化 android中图片缓存 两类动画 五大布局易混淆知识 保证service不被杀死 加速启动activity 怎样退出终止App activity切换动画 外链 布局性能优化(include, viewstub, merge) DOM、SAX、Pull解析XML Java基础 [ArrayList、LinkedList、Vector的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] ArrayList、LinkedList、Vector的区别.md) [Collection包结构，与Collections的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Collection包结构，与Collections的区别.md) [Excption与Error包结构,OOM和SOF](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Excption与Error包结构%2COOM和SOF.md) [HashMap和HashTable的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] HashMap和HashTable的区别.md) [HashMap源码分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] HashMap源码分析.md) [Hashcode的作用](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Hashcode的作用.md) [Map、Set、List、Queue、Stack的特点与用法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Map、Set、List、Queue、Stack的特点与用法.md) [Object有哪些公用方法？](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Object有哪些公用方法？.md) [Override和Overload的使用规则和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Override和Overload的使用规则和区别.md) [Switch能否用string做参数？](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Switch能否用string做参数？.md) [ThreadLocal的使用规则和源码分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] ThreadLocal的使用规则和源码分析.md) [ThreadPool用法与示例](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] ThreadPool用法与示例.md) [equals与&#x3D;&#x3D;的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] equals与%3D%3D的区别.md) [try catch finally，try里有return，finally还执行么？](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] try catch finally，try里有return，finally还执行么？.md) [九种基本数据类型的大小，以及他们的封装类](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 九种基本数据类型的大小，以及他们的封装类.md) [从源码分析String、StringBuffer与StringBuilder区别和联系](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 从源码分析String、StringBuffer与StringBuilder区别和联系.md) [多线程下生产者消费者问题的五种同步方法实现](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 多线程下生产者消费者问题的五种同步方法实现.md) [实现多线程的两种方法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 实现多线程的两种方法.md) [接口（Interface）与 抽象类 （Abstract）使用规则和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 接口（Interface）与 抽象类 （Abstract）使用规则和区别.md) [方法锁、对象锁和类锁的意义和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 方法锁、对象锁和类锁的意义和区别.md) [四种引用，强弱软虚，用到的场景](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 的四种引用，强弱软虚，用到的场景.md) [线程同步的方法：sychronized、lock、reentrantLock分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 线程同步的方法：sychronized、lock、reentrantLock分析.md) [集合框架的层次结构和使用规则梳理](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 集合框架的层次结构和使用规则梳理.md) [面向对象的三个特征与含义](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 面向对象的三个特征与含义.md) [static的作用和意义](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java] static的作用和意义.md) [多态实现的JVM调用过程](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java] 多态实现的JVM调用过程.md) wait()和sleep()的区别 git命令使用 Java与C++对比 外链 java反射 java回调 Java泛型 java 新特性 Java IO与NIO foreach与正常for循环效率对比 [数据结构](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/tree/master/data structure)基础 [九大基础排序总结与对比(排序算法一网打尽)](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 九大基础排序总结与对比.md) [AVL树和AVL旋转、哈夫曼树和哈夫曼编码](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] AVL树和AVL旋转、哈夫曼树和哈夫曼编码.md) [B(B-)树、B+树、B树](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] B(B-)树、B%2B树、B树.md) [Hash表、Hash函数及冲突解决](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] Hash表、Hash函数及冲突解决.md) [KMP的一个简单解释](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] KMP的一个简单解释.md) [二分查找与变种二分查找](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 二分查找与变种二分查找.md) [二叉树前中后、层次遍历算法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 二叉树前中后、层次遍历算法.md) [图的BFS、DFS、prim、Dijkstra算法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 图的BFS、DFS、prim、Dijkstra算法.md) [字符串操作](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 字符串操作.md) [数组与链表的优缺点和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 数组与链表的优缺点和区别.md) [红黑树](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 红黑树.md) [队列和栈](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure&#x2F;[数据结构] 队列和栈.md) 外链 海量数据处理 算法基础 二叉搜索树与双向链表 [二叉树中 和为某值 的所有路径](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/二叉树中 和为某值 的所有路径.md) 二叉树的镜像 二维数组中的查找 二进制中1的个数 从上往下打印二叉树 从尾到头打印链表 判断二叉搜索树的后序遍历序列 判断栈的弹出序列 判断树B是不是树A的子结构 包含min函数的栈 反转链表 变态跳台阶 合并两个排序链表 复杂链表的复制 字符串中空格替换 字符串的顺序全排列 数组中出现次数超过一半的数字 斐波那契数列 旋转数组的最小数字 浮点数的整数次方 用两个栈实现队列 矩形覆盖 调整数组顺序使奇数位于偶数前面 跳台阶 重建二叉树 链表中倒数第k个结点 顺时针打印矩阵 外链 分治算法 动态规划 贪心算法 分支限界法 作者：菜刀文链接：https://www.jianshu.com/p/735be5ece9e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 面试和必备的技能这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。 一般情况下第一轮都是基础面试，需要扎实的基础 最常用的Android 基础知识 Java 基础知识 了解一些 常用东西的原理，例如：handler， thread 等 项目中的技术点 第二轮的时候需要了解更深层次的东西 Android 事件分发机制原理 Android 绘图机制原理 WindowManager 的相关知识 进程间传输方式 Java 内存管理机制 一些常用的 list,map 原理，以及子类之间的差别 能进入第三轮基本没什么问题，但是要注意以下问题 该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度 当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。 我们的面试原则就是拿到合理薪资，得到 offer 个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。 你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。 Android 高级面试题及答案 1.如何对 Android 应用进行性能分析 2.什么情况下会导致内存泄露 3.如何避免 OOM 异常 4.Android 中如何捕获未捕获的异常 5.ANR 是什么？怎样避免和解决 ANR（重要） 6.Android 线程间通信有哪几种方式 7.Devik 进程，linux 进程，线程的区别 8.描述一下 android 的系统架构 9.android 应用对内存是如何限制的?我们应该如何合理使用内存？ 10. 简述 android 应用程序结构是哪些 11.请解释下 Android 程序运行时权限与文件系统权限的区别 12.Framework 工作方式及原理，Activity 是如何生成一个 view 的，机制是什么 13.多线程间通信和多进程之间通信有什么不同，分别怎么实现 14.Android 屏幕适配 15.什么是 AIDL 以及如何使用 16.Handler 机制 17.事件分发机制 18.子线程发消息到主线程进行更新 UI，除了 handler 和 AsyncTask，还有什么 19.子线程中能不能 new handler？为什么 20.Android 中的动画有哪几类，它们的特点和区别是什么 21.如何修改 Activity 进入和退出动画 22.SurfaceView &amp; View 的区别 23.开发中都使用过哪些框架、平台 24.使用过那些自定义View 25.自定义控件：绘制圆环的实现过程 26.自定义控件：摩天轮的实现过程 28.流式布局的实现过程 29.第三方登陆 [30.第三方支付](","categories":[],"tags":[{"name":"inter","slug":"inter","permalink":"https://noteforme.github.io/tags/inter/"}]},{"title":"TextView","slug":"TextView","date":"2018-03-04T13:16:56.000Z","updated":"2023-02-23T14:17:11.784Z","comments":true,"path":"2018/03/04/TextView/","link":"","permalink":"https://noteforme.github.io/2018/03/04/TextView/","excerpt":"","text":"Width 绘制分析没有其他属性影响的话，宽度应该就是字体的宽度，在横向的recycleview adater中不同的字体会增加间距。 1234android:autoSizeTextType&#x3D;&quot;uniform&quot;android:autoSizeMinTextSize&#x3D;&quot;8sp&quot;android:autoSizeMaxTextSize&#x3D;&quot;12sp&quot;android:autoSizeStepGranularity&#x3D;&quot;1sp&quot; TextView颜色变化SpannableString https://juejin.im/entry/5729d28f1ea49300606854c9SpannableString有一个不方便的地方是截取字符串 123456789101112131415161718 TextView tvRegister = findViewById(R.id.tv_register); //将TextView的显示文字设置为SpannableString​ tvRegister.setText(getClickableSpan());​ //设置该句使文本的超连接起作用​ tvRegister.setMovementMethod(LinkMovementMethod.getInstance());​ ​ private SpannableString getClickableSpan() &#123;​ SpannableString spanTxt = new SpannableString(&quot;阅读并同意&lt;&lt;用户注册协议&gt;&gt;&quot;);​ //设置文字的前景色​ spanTxt.setSpan(new ForegroundColorSpan(Color.GREEN),5, 15,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);​ spanTxt.setSpan(new ClickableSpan() &#123; ​ @Override​ public void onClick(View widget) &#123;​ Intent intent = new Intent(TextViewActivity.this, FirstActivity.class);​ startActivity(intent);​ &#125;​ &#125;, 5, 15, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);​ ​ Html标签方式 123TextView textView = (TextView) findViewById(R.id.text_for_test);String textSource = &quot;修改TextView中部分文字的&lt;font color=&#x27;#ff0000&#x27;&gt;&lt;big&gt;大&lt;/big&gt;&lt;small&gt;小&lt;/small&gt;&lt;/font&gt;和&lt;font color=&#x27;#00ff00&#x27;&gt;颜色&lt;/font&gt;，展示多彩效果！&quot;;textView.setText(Html.fromHtml(textSource)); http://www.jianshu.com/p/f6cef78e8652 https://github.com/liqy/TextViewDemo EditTextstyle里面的配置 12&lt;item name&#x3D;&quot;android:focusable&quot;&gt;true&lt;&#x2F;item&gt; &lt;item name&#x3D;&quot;android:focusableInTouchMode&quot;&gt;true&lt;&#x2F;item&gt; https://blog.csdn.net/u011630575/article/details/50775639 下划线颜色 https://blog.csdn.net/lindroid20/article/details/72551102 自定义解析器 https://my.oschina.net/ososchina/blog/3018393 密码输入框 https://github.com/li504799868/ZEditText 超出字符显示省略号https://www.jianshu.com/p/025f49696882 监听器设置 https://blog.csdn.net/xiao_ziqiang/article/details/50790168 https://blog.csdn.net/u014748504/article/details/79083501 https://www.jianshu.com/p/1d0777d9bfdf","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"LeakMemory","slug":"LeakMemory","date":"2018-02-09T08:15:17.000Z","updated":"2023-01-02T03:31:39.092Z","comments":true,"path":"2018/02/09/LeakMemory/","link":"","permalink":"https://noteforme.github.io/2018/02/09/LeakMemory/","excerpt":"","text":"内存泄漏 https://mp.weixin.qq.com/s/tO1yxFs2qNQlQ2bJ8vGzQA https://www.jianshu.com/p/ac00e370f83d 内存泄漏总结 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SampleActivity extends Activity &#123; &#x2F;** * Instances of static inner classes do not hold an implicit * reference to their outer class. *&#x2F; private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity &#x3D; new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; SampleActivity activity &#x3D; mActivity.get(); if (activity !&#x3D; null) &#123; &#x2F;&#x2F; ... &#125; &#125; &#125; private final MyHandler mHandler &#x3D; new MyHandler(this); &#x2F;** * Instances of anonymous classes do not hold an implicit * reference to their outer class when they are &quot;static&quot;. *&#x2F; private static final Runnable sRunnable &#x3D; new Runnable() &#123; @Override public void run() &#123; &#x2F;* ... *&#x2F; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#x2F;&#x2F; Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 * 60 * 10); &#x2F;&#x2F; Go back to the previous Activity. finish(); &#125;&#125; kotin Fragment方式 12345678910111213class MyHandler : Handler &#123; private var mFragment: WeakReference&lt;Any&gt; constructor(fragment: Fragment) &#123; mFragment &#x3D; WeakReference(fragment) &#125; override fun handleMessage(msg: android.os.Message?) &#123; super.handleMessage(msg) val fragment &#x3D; mFragment.get() as PayProFragment fragment.reloadPay() &#125; &#125; 内存泄漏处理-Handler 查找方式 https://www.jianshu.com/p/bdfd2a6b2681 ​ https://developer.android.com/studio/profile/memory-profiler leakcanaryhttps://square.github.io/leakcanary/recipes/ https://juejin.im/post/5d617d6851882575e8054fab 内存抖动Profiler https://www.bilibili.com/video/BV1oz4y1m7Gw?p=14 App瘦身 大图转成 webapp svg批量转换 设置 vectorDrawables.useSupportLibrary = true 然后 app:srcCompat = 否则会在每个drawable生成一个png图片，达不到效果了。 tink修改图片颜色 国际化 12345android&#123; defaultConfig&#123; resConfigs &#x27;en&#x27; //只适配英语 &#125;&#125; 这样只会保存 语言的映射 so库 一般像微信用Armeabi-v7a 虚拟机运行 还需要 x86 删除无用资源 12345debug&#123; minifyEnabled true // 删除无用代码 shrinkResource true //删除资源文件 minifyEnabled 为true,删除了无用代码，这个才知道删除哪些资源。 &#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"Hilt","slug":"Hilt","date":"2018-01-23T07:11:40.000Z","updated":"2023-12-17T12:43:26.284Z","comments":true,"path":"2018/01/23/Hilt/","link":"","permalink":"https://noteforme.github.io/2018/01/23/Hilt/","excerpt":"","text":"https://developer.android.google.cn/training/dependency-injection Hilt作用 https://www.bilibili.com/video/BV18o4y1S7KH 「社区说」《Hilt-把握住Android依赖项注入的“利器”》 https://www.bilibili.com/video/BV1eM4y1G7aR 码牛 https://www.bilibili.com/video/BV1Ki4y1A7hA 动脑学院 https://services.google.cn/fh/files/misc/hilt-annotations-2.3.3_zh-cn.pdf https://mp.weixin.qq.com/s/OEX1d2cU1zGG5BBM-nANBg https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh-cn Component种注入了Activity对象 ，Factory提供的Module对象和Activity关联起来. 依赖注入有什么用 自动加载 自动加载的关键 : 数据共享 https://www.bilibili.com/video/BV1e54y1S72A/ 由于会和Dagger冲突，所以写在JYKot里 用法使用Hilt 注入 配置HiltAndroidApp注解 12@HiltAndroidApp // 1. HiltAndroidApp注解,生成相应的组件class MyApp : Application() &#123;&#125; 构造方法注入12// 构造方法绑定class User @Inject() constructor() 1234567891011121314@AndroidEntryPointclass HiltMainActivity : AppCompatActivity() &#123; private val TAG = javaClass.simpleName @Inject lateinit var user: User override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val biding = ActivityHiltMainBinding.inflate(layoutInflater) setContentView(biding.root) Log.i(TAG, &quot;user: $user&quot;) &#125;&#125; Module对象注入建立绑定,就是说User对象实例由谁提供 可以通AppModule提供 1class User1 12345678910//Module装载到ApplicationComponent中,Module作用域就被限定起来了@InstallIn(ApplicationComponent.class) //通过这种方式和组件关联@Modulepublic class AppModule &#123; @Provides User1 provideUser() &#123; return new User1(); &#125;&#125; 往Activity注入实例 主要是@AndroidEntryPoint @Inject 1234567891011121314151617@AndroidEntryPointpublic class HiltActivity extends AppCompatActivity &#123; String TAG =&quot;HiltActivity&quot;; @Inject User user; //inject注解作用在User变量上,注入对象实例 @Inject User1 user1; // 方式2 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_hilt); Log.i(TAG, &quot;user: &quot; + user); Log.i(TAG, &quot;user1: &quot; + user1); &#125;&#125; 运行结果 28743-28743/com.john.kot I/HiltActivity: user: com.john.kot.hilt.User@d33a8d528743-28743/com.john.kot I/HiltActivity: user1: com.john.kot.hilt.User1@62df8ea 默认标准组件 Component lifetimes Hilt 也允许将绑定的作用域限定为特定组件。Hilt 只为绑定作用域限定到的组件的每个实例创建一次限定作用域的绑定，对该绑定的所有请求共享同一实例。 组件实例由关联的Android类来创建的 1234567891011//Module装载到ActivityComponent中@InstallIn(ActivityComponent.class) //通过这种方式和组件关联@Modulepublic class AppModule1 &#123; @ActivityScoped //ActivityComponent只能设置ActivityScoped作用域 @Provides User1 provideUser() &#123; return new User1(); &#125;&#125; 123456789101112131415161718192021222324@AndroidEntryPointpublic class HiltActivity extends AppCompatActivity &#123; String TAG =&quot;HiltActivity&quot;; //inject注解作用在User变量上,注入对象实例 @Inject User1 user1; // 方式2 @Inject User1 user2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_hilt); //测试 ActivityComponent Log.i(TAG, &quot;user1: &quot; + user1); Log.i(TAG, &quot;user2: &quot; + user2); startActivity(new Intent(this,SecondActivity.class)); &#125;&#125; 123456789101112@AndroidEntryPointpublic class SecondActivity extends AppCompatActivity &#123; String TAG = &quot;SecondActivity&quot;; @Inject User1 user3; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.i(TAG, &quot;user3: &quot; + user3); &#125;&#125; 运行结果 2021-09-25 23:02:57.595 29397-29397/com.john.kot I/HiltActivity: user1: com.john.kot.hilt.User1@62df8ea2021-09-25 23:02:57.595 29397-29397/com.john.kot I/HiltActivity: user2: com.john.kot.hilt.User1@62df8ea2021-09-25 23:02:57.883 29397-29397/com.john.kot I/SecondActivity: user3: com.john.kot.hilt.User1@1aa35b5 可以看到作用域在Activity中 单例对象的注入构造方法单例12@Singletonclass User6 @Inject constructor() 12@Injectlateinit var user6: User6 // 方式2 在Activity这样注入后，User6的对象就是单例的了。 AppModule1修改成 ApplicationComponent 和Singleton 1234567891011//Module装载到ApplicationComponent中@InstallIn(ApplicationComponent.class) //通过这种方式和组件关联@Modulepublic class AppModule1 &#123; @Singleton //ActivityComponent只能设置ActivityScoped作用域 @Provides User1 provideUser() &#123; return new User1(); &#125;&#125; 运行结果 2021-09-25 23:09:24.752 29553-29553/com.john.kot I/HiltActivity: user1: com.john.kot.hilt.User1@62df8ea2021-09-25 23:09:24.752 29553-29553/com.john.kot I/HiltActivity: user2: com.john.kot.hilt.User1@62df8ea2021-09-25 23:09:25.106 29553-29553/com.john.kot I/SecondActivity: user3: com.john.kot.hilt.User1@62df8ea 明显一样的实例了 方式一12345678910111213141516@InstallIn(SingletonComponent::class) //通过这种方式和组件关联@Moduleclass AppModule5 &#123; @Singleton @Provides fun provideUser(): UserHilt5 &#123; return UserHilt5() &#125; @Singleton @Provides fun provideUserParam5(user: UserHilt5): UserParam5 &#123; return UserParam5(user) &#125;&#125; 1234Log.i(TAG, &quot;userParam: $&#123;userParam.user1&#125;&quot;)Log.i(TAG, &quot;userParam5: $&#123;userParam5.user5&#125;&quot;)Log.i(TAG, &quot;userParam: $&#123;userParam.user1&#125;&quot;)Log.i(TAG, &quot;userParam5: $&#123;userParam5.user5&#125;&quot;) 从下面结果可以看到userParam5是相同的对象 1234com.john.kot I/HiltActivity: userParam: com.john.kot.hilt.model.User1@7459850com.john.kot I/HiltActivity: userParam5: com.john.kot.hilt.model.UserHilt5@aea6a49com.john.kot I/HiltSecondActivity: userParam: com.john.kot.hilt.model.User1@bf41510com.john.kot I/HiltSecondActivity: userParam5: com.john.kot.hilt.model.UserHilt5@aea6a49 方式2但是在Dagger里，组建注入不同的Activity对象后，对象也是不相同的,只有在相同Activity才是单例的。 必须用Application组建，才能实现全局APP的单例 123456789101112@InstallIn(SingletonComponent::class) //通过这种方式和组件关联@Moduleclass AppModule5 &#123; @Singleton @Provides fun provideUser(): User5 &#123; return User5() &#125;&#125;class UserParam5 @Inject constructor(var user5: User5) 方式31234@Singletonclass User5 @Inject constructor()class UserParam5 @Inject constructor(var user5: User5) 组件作用域组件和组件作用域一一对应. Android class Generated component Scope Application SingletonComponent @Singleton Activity(应该是view model) ActivityRetainedComponent @ActivityRetainedScoped ViewModel ViewModelComponent @ViewModelScoped Activity ActivityComponent @ActivityScoped Fragment FragmentComponent @FragmentScoped View ViewComponent @ViewScoped View annotated with @WithFragmentBindings ViewWithFragmentComponent @ViewScoped Service ServiceComponent @ServiceScoped @ActivityScoped123456789101112131415161718192021@AndroidEntryPointclass HiltMainActivity : AppCompatActivity() &#123; private val TAG = javaClass.simpleName @Inject lateinit var user3: User2 @Inject lateinit var user4: User2 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val biding = ActivityHiltMainBinding.inflate(layoutInflater) setContentView(biding.root) Log.i(TAG, &quot;user3: $user3&quot;) Log.i(TAG, &quot;user4: $user4&quot;) startActivity(Intent(this,HiltSecondActivity::class.java)) &#125;&#125; 1234567891011//Module装载到ActivityComponent中@InstallIn(ActivityComponent::class) //通过这种方式和组件关联@Moduleclass AppModule2 &#123; // ApplicationComponent对应的作用域 @Singleton @ActivityScoped @Provides fun provideUser(): User2 &#123; return User2() &#125;&#125; @ActivityScoped必须用ActivityComponent, 可以看到在Activity生命周期内对象相同 123469 5433-5433/com.john.kot I/HiltMainActivity: user3: com.john.kot.hilt.dn.di.User2@1ca33ad469 5433-5433/com.john.kot I/HiltMainActivity: user4: com.john.kot.hilt.dn.di.User2@1ca33ad521 5433-5433/com.john.kot I/HiltSecondActivity: user5: com.john.kot.hilt.dn.di.User2@8d0e984 @Singleton1234567891011//Module装载到ActivityComponent中@InstallIn(SingletonComponent::class) //通过这种方式和组件关联@Moduleclass AppModule2 &#123; // ApplicationComponent对应的作用域 @Singleton @Singleton @Provides fun provideUser(): User2 &#123; return User2() &#125;&#125; 可以看到，这种情况应用内单例 123773 5726-5726/com.john.kot I/HiltMainActivity: user3: com.john.kot.hilt.dn.di.User2@aa56b56773 5726-5726/com.john.kot I/HiltMainActivity: user4: com.john.kot.hilt.dn.di.User2@aa56b56816 5726-5726/com.john.kot I/HiltSecondActivity: user5: com.john.kot.hilt.dn.di.User2@aa56b56 组件层次结构 ApplicationComponent 顶级父组件 ,下一层ActivityRetanedComponent是的子组件，往下是子子组件。 那么ActivityRetanedComponent可以获取到ApplicationComponent提供的对象的实例. 1234567891011//Module装载到ActivityComponent中@InstallIn(SingletonComponent::class) //通过这种方式和组件关联@Moduleclass AppModule2 &#123; // ApplicationComponent对应的作用域 @Singleton @Singleton @Provides fun provideUser(): User2 &#123; return User2() &#125;&#125; 例如就像上面一样， Activity中可以访问SingletonComponent组件的实例。 组件默认绑定 Android component Default bindings SingletonComponent Application ActivityRetainedComponent Application ViewModelComponent SavedStateHandle ActivityComponent Application, Activity FragmentComponent Application, Activity, Fragment ViewComponent Application, Activity, View ViewWithFragmentComponent Application, Activity, Fragment, View ServiceComponent Application, Service ApplicationComponent这里ViewModel和jetpack viewmodel还没有关联 。 老师说HiltViewModel3 默认装载到了ApplicationComponent中,我觉得不是，应该是装载到ActivityComponent，如果SingletonComponent是获取不到Activity的。 12345678910111213// HiltViewModel3 默认装载到了ApplicationComponent中class HiltViewModel3 @Inject constructor( var user: User3, var application: Application, var activity: Activity) &#123; var TAG = javaClass.simpleName fun test() &#123; Log.i(TAG, &quot;test:user $user&quot;) Log.i(TAG, &quot;test: application $application&quot;) Log.i(TAG, &quot;test: activity$activity&quot;) &#125;&#125; 123456789101112@AndroidEntryPointclass HiltMainActivity : AppCompatActivity() &#123; private val TAG = javaClass.simpleName @Inject lateinit var viewModel: HiltViewModel3 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val biding = ActivityHiltMainBinding.inflate(layoutInflater) setContentView(biding.root) viewModel.test() &#125;&#125; 1236613/com.john.kot I/ViewModel: test:user com.john.kot.hilt.dn.di.User3@1ca33ad6613/com.john.kot I/ViewModel: test: application com.john.kot.MyApp@3a4e6e26613/com.john.kot I/ViewModel: test: activitycom.john.kot.hilt.dn.HiltMainActivity@211813d 可以看到都有 Application, Activity实例对象,这就是默认绑定 Activity默认绑定下面的没有 @Inject 12345678class HiltViewModel4(var user: User3, var application: Application, var activity: Activity) &#123; var TAG = javaClass.simpleName fun test() &#123; Log.i(TAG, &quot;test:user $user&quot;) Log.i(TAG, &quot;test: application $application&quot;) Log.i(TAG, &quot;test: activity$activity&quot;) &#125;&#125; 123456789101112131415//Module装载到ActivityComponent中@InstallIn(ActivityComponent::class) //这里用SingletonComponent会报错,因为Application不能提供activity实例@Moduleclass AppModule4 &#123; @Singleton //Singleton,因为Application不能提供activity实例 @Provides fun provideViewModel( user: User3, application: Application, activity: Activity ): HiltViewModel4 &#123; return HiltViewModel4(user, application, activity) &#125;&#125; 1viewModel1.test(); 123com.john.kot I/HiltViewModel4: test:user com.john.kot.hilt.dn.di.User3@5b5a73com.john.kot I/HiltViewModel4: test: application com.john.kot.MyApp@3a4e6e2com.john.kot I/HiltViewModel4: test: activitycom.john.kot.hilt.dn.HiltMainActivity@211813d 可以看到也能提供Appilicaton和activity默认绑定的实例 预定义限定符提供了几种预定义限定符(Qualifier) : @ApplicationContext 和 @ActivityContext ApplicationContext VS ActivityContext ?Hilt支持Jetpack组件ViewModel User由我们自己提供 Application application, Activity activity由 Dagger提供 Context预定义的限定符. 123456789101112131415161718192021222324public class MainViewModel extends ViewModel &#123; String TAG = &quot;MainViewModel&quot;; User3 user; Application application; Activity activity; Context context; @ViewModelInject public MainViewModel(User3 user, Application application, Activity activity,@ApplicationContext Context context) &#123; this.user = user; this.application = application; this.activity = activity; this.context =context; &#125; public void test()&#123; Log.i(TAG, &quot;test:user=&quot;+user); Log.i(TAG, &quot;test: application=&quot;+application); Log.i(TAG, &quot;test: activity=&quot;+activity); Log.i(TAG, &quot;test: context=&quot;+context); &#125;&#125; https://www.bilibili.com/video/BV1Ki4y1A7hA?spm_id_from=333.999.0.0 https://www.bilibili.com/video/BV1BK4y1V7no?p=4&amp;spm_id_from=pageDriver https://developer.android.com/codelabs/android-hilt?hl=zh-cn#7 Interface inject 接口注入https://juejin.cn/post/6967148539277213733 1234567@InstallIn(ActivityComponent::class)@Moduleabstract class BannerRepoModule &#123; //BannerRepository实例自动new出来交给对应的接口 @Binds abstract fun bannerRepo(repoImpl: BannerRepository): IBannerApi &#125; viewModel在ViewModel上添加@HiltViewModel，必须有带参的构造函数，用Inject注入 1. viewModel在ViewModel上添加@HiltViewModel，必须有带参的构造函数，用Inject注入 1234@HiltViewModelclass DataViewModel @Inject constructor( private val dataRepo: DataRepository) : ViewModel() 2. fragment和activity在fragment和activity上添加@AndroidEntryPoint注解 然后可以使用by viewModels()直接获取viewmodel 1234@AndroidEntryPointclass DataFragment : Fragment() &#123; private val dataViewModel: DataViewModel by viewModels()&#125; 3. 遇到的坑通过ViewPager创建的Fragment无法使用@HiltViewModel，只能通过普通的方式注入，弄了很久都没有找到解决方案。配合navigation使用的话没有问题 字节码技术Javassit 动态修改字节码 Hilt UnitTesthttps://mahendranv.github.io/posts/hilt-instrument/ Entry pointDependency injection with Hilt &nbsp;|&nbsp; Android Developers 12345678class AnalyticsServiceImpl @Inject constructor( @ApplicationContext context: Context) : AnalyticsService &#123; ... &#125;// The Application binding is available without qualifiers.class AnalyticsServiceImpl @Inject constructor( application: Application) : AnalyticsService &#123; ... &#125; 12345678910class ExampleContentProvider : ContentProvider() &#123; @EntryPoint @InstallIn(SingletonComponent::class) interface ExampleContentProviderEntryPoint &#123; fun analyticsService(): AnalyticsService &#125; ...&#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"TEST_Espresso","slug":"TEST_Espresso","date":"2018-01-22T13:58:05.000Z","updated":"2022-06-12T03:17:58.728Z","comments":true,"path":"2018/01/22/TEST_Espresso/","link":"","permalink":"https://noteforme.github.io/2018/01/22/TEST_Espresso/","excerpt":"","text":"the difficulty tip is on recycleview ‘s content that not visible in firtpage, which you can search for and find the views that match the non-unique R.id: https://developer.android.com/training/testing/espresso/lists 官方test可以指定key 和value,是因为这个 1234567@VisibleForTestingprotected static Map&lt;String, Object&gt; makeItem(int forRow) &#123; Map&lt;String, Object&gt; dataRow = Maps.newHashMap(); dataRow.put(ROW_TEXT, String.format(ITEM_TEXT_FORMAT, forRow)); dataRow.put(ROW_ENABLED, forRow == 1); return dataRow;&#125; 但是我们的项目是没有的。 Adapter view warningsNoMatchingViewException and AdapterView widgets are present in the view hierarchy, the most common solution is to use onData(). The exception message will include a warning with a list of the adapter views. You may use this information to invoke onData() to load the target view. onData() used in AdapterView like recyclieview , not AdapterView use ondata() will have error No views in hierarchy found matching: is assignable from class: class android.widget.AdapterView Espresso warns users about presence of AdapterView widgets. When an onView() operation throws a exception 12345678910111213141516171819202122232425262728293031@Rule@JvmFieldval rule &#x3D; ActivityTestRule(TestActivity::class.java)@Testfun useAppContext() &#123; val appContext &#x3D; InstrumentationRegistry.getInstrumentation().targetContext assertEquals(&quot;com.john.kot&quot;, appContext.packageName)&#125;@Testfun user_can_enter_first_name()&#123; onView(withId(R.id.firstName)).perform(typeText(&quot;Daniel&quot;))&#125;@Testfun user_can_enter_last_name()&#123; onView(withId(R.id.lastName)).perform(typeText(&quot;Malone&quot;))&#125;@Testfun when_user_enters_first_and_last_name_check_to_confirm_that_message_is_correct()&#123; onView(withId(R.id.firstName)).perform(typeText(&quot;Jake&quot;)) onView(withId(R.id.lastName)).perform(typeText(&quot;Smith&quot;)) onView(withId(R.id.button)).perform(click()) onView(withId(R.id.message)).check(matches(withText(&quot;Welcome,Jake Smith&quot;)))&#125; 12345678910111213141516171819202122232425262728&lt;android.support.constraint.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; tools:context&#x3D;&quot;.test.InstrumentActivity&quot;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tv_name&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt; &lt;EditText android:id&#x3D;&quot;@+id&#x2F;et_name&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_marginTop&#x3D;&quot;@dimen&#x2F;dimen_10&quot; android:hint&#x3D;&quot;输入姓名&quot; app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;tv_name&quot; &#x2F;&gt; &lt;Button android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_marginTop&#x3D;&quot;@dimen&#x2F;dimen_10&quot; android:onClick&#x3D;&quot;sayClick&quot; android:text&#x3D;&quot;Say HELLO&quot; app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;et_name&quot; &#x2F;&gt;&lt;&#x2F;android.support.constraint.ConstraintLayout&gt; 12345public void sayClick(View v) &#123; TextView textView &#x3D; findViewById(R.id.tv_name); EditText editText &#x3D; findViewById(R.id.et_name); textView.setText(&quot;Say HELLO!&quot; + editText.getText().toString() + &quot;!&quot;);&#125; 1234567891011121314151617@RunWith(AndroidJUnit4.class)@LargeTestpublic class InstrumentActivityTest &#123; private static final String STRING_TO_BE_TYPED = &quot;Jon&quot;; @Rule public ActivityTestRule&lt;InstrumentActivity&gt; instrumentActivityTestRule = new ActivityTestRule&lt;&gt;(InstrumentActivity.class); @Test public void sayHelloTest() &#123; Espresso.onView(ViewMatchers.withId(R.id.et_name)).perform(ViewActions.typeText(STRING_TO_BE_TYPED), closeSoftKeyboard()); Espresso.onView(ViewMatchers.withText(&quot;Say HELLO&quot;)).perform(click()); String expectedText = &quot;Say HELLO!&quot; + STRING_TO_BE_TYPED + &quot;!&quot;; Espresso.onView(ViewMatchers.withId(R.id.tv_name)).check(ViewAssertions.matches(ViewMatchers.withText(expectedText))); &#125;&#125; https://testing.googleblog.com/2008/12/static-methods-are-death-to-testability.html https://www.jianshu.com/p/dc30338a3e84 https://www.jianshu.com/p/03118c11c199https://github.com/googlesamples/android-testing https://developer.android.com/training/testing Fragment Testhttps://developer.android.google.cn/training/basics/fragments/testing 问题 class not found https://blog.csdn.net/xiaoluoli88/article/details/78657364","categories":[{"name":"TEST","slug":"TEST","permalink":"https://noteforme.github.io/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://noteforme.github.io/tags/Test/"}]},{"title":"TEST-MOCKK","slug":"TEST-MOCKK","date":"2018-01-22T10:04:40.000Z","updated":"2022-06-12T03:17:58.725Z","comments":true,"path":"2018/01/22/TEST-MOCKK/","link":"","permalink":"https://noteforme.github.io/2018/01/22/TEST-MOCKK/","excerpt":"","text":"https://mockk.io/ presenter https://www.jianshu.com/p/899e80120071 https://blog.csdn.net/hard_working1/article/details/105613362 https://juejin.cn/post/6877824384694747143 LIST COMPARE12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 @Test fun `compare to list`() &#123; val actual = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val expected = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) //All passed / true //1. Test equal. //All passed / true //1. Test equal. Assert.assertThat(actual, CoreMatchers.`is`(expected)) //2. If List has this value? //2. If List has this value? Assert.assertThat(actual, CoreMatchers.hasItems(&quot;b&quot;)) //3. Check List Size //3. Check List Size Assert.assertThat(actual, Matchers.hasSize(3)) Assert.assertThat(actual.size, CoreMatchers.`is`(3)) //4. List order // Ensure Correct order //4. List order // Ensure Correct order Assert.assertThat(actual, Matchers.contains(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) // Can be any order // Can be any order Assert.assertThat(actual, IsIterableContainingInAnyOrder.containsInAnyOrder(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;)) //5. check empty list //5. check empty list Assert.assertThat(actual, CoreMatchers.not(IsEmptyCollection.empty()))// assertThat(ArrayList(), IsEmptyCollection.empty()) &#125; https://stackoverflow.com/questions/46788032/compare-2-liststring-if-they-contain-same-elements-in-any-order-junit-assethttps://mkyong.com/unittest/junit-how-to-test-a-list/ http://hamcrest.org/JavaHamcrest/distributables mock与spy的区别1234567891011 @Testpublic void mockDifSpy() throws Exception &#123; User userMock &#x3D; mock(User.class); userMock.setNumber(2); int num &#x3D; userMock.getNumber(); System.out.println(&quot;mock返回 &quot;+num); User userSpy &#x3D; spy(User.class); userSpy.setNumber(5); System.out.println(&quot;spy返回 &quot;+userSpy.getNumber());&#125; mock返回 0 spy返回 5 mock : 如果不指定mock方法的特定行为，一个mock对象的所有非void方法都将返回默认值：int、long类型方法将返回0，boolean方法将返回false，对象方法将返回null等等；而void方法将什么都不做。 spy : spy对象的方法默认调用真实的逻辑，mock对象的方法默认什么都不做，或直接返回默认值。 https://www.jianshu.com/p/0a8bbfe6cba2 实例讲解 http://blog.csdn.net/qq_17766199/article/details/78450007 https://github.com/ChrisZou/android-unit-testing-tutorialhttps://github.com/qingmei2/Sample_AndroidTest 一个Android项目搞定所有主流架 mvp生成模板https://www.diycode.cc/topics/309https://github.com/boredream/DesignResCollection Robolectrichttp://robolectric.org/getting-started/ Robolectric 123456789testImplementation &quot;org.robolectric:robolectric:3.8&quot;android &#123; testOptions &#123; unitTests &#123; includeAndroidResources &#x3D; true &#125; &#125;&#125; MockkConstructor mocksverify失败 123456789101112131415161718192021 @Test fun `mock different constuctor`()&#123; mockkConstructor(MockCls::class) every &#123; constructedWith&lt;MockCls&gt;().add(1) &#125; returns 2 every &#123; constructedWith&lt;MockCls&gt;(OfTypeMatcher&lt;String&gt;(String::class)).add(2) // Mocks the constructor which takes a String &#125; returns 3 every &#123; constructedWith&lt;MockCls&gt;(EqMatcher(4)).add(any()) // Mocks the constructor which takes an Int &#125; returns 4 assertEquals(1, MockCls().add(1)) assertEquals(3, MockCls(&quot;2&quot;).add(2)) assertEquals(4, MockCls(4).add(7)) verify &#123; constructedWith&lt;MockCls&gt;().add(1) //这里不通过 // constructedWith&lt;MockCls&gt;(&quot;2&quot;).add(2) constructedWith&lt;MockCls&gt;(EqMatcher(4)).add(7) &#125; 为无返回值的方法分配默认行为把 every {…} 后面的 Returns 换成 just Runs ，就可以让 MockK 为这个没有返回值的方法分配一个默认行为。 1234567@Testfun testGetGoods() &#123; val goods = presenter!!.getGoods(1) every &#123; view.showLoading() &#125; just Runs verify &#123; view.showLoading() &#125; assertEquals(goods.name, &quot;纸巾&quot;)&#125; 为所有模拟对象的方法分配默认行为1234@Beforefun setUp() &#123; MockKAnnotations.init(this, relaxed = true)&#125; Annotation只要在 @Before 方法裡面加上 MockKAnnotations.init(this) 就能在外面用 Annotation 的方式 Mock 物件。 12345678910111213141516171819202122class KidAnnotationTest &#123; @MockK lateinit var mother: Mother lateinit var kid: Kid @Before fun setUp() &#123; val mother = mockk&lt;Mother&gt;() // 不使用Annotation的版本 MockKAnnotations.init(this) kid = Kid(mother) &#125; @Test fun wantMoney() &#123; every &#123; mother.giveMoney() &#125; returns 30 kid.wantMoney() assertEquals(30, kid.money) &#125;&#125; https://proandroiddev.com/understanding-unit-tests-for-android-in-2021-71984f370240 https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-2-4-4be059331110 https://tngdigital.yuque.com/tngd-mobile/key-battle/wldcgt","categories":[{"name":"TEST","slug":"TEST","permalink":"https://noteforme.github.io/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://noteforme.github.io/tags/Test/"}]},{"title":"Operators","slug":"Operators","date":"2018-01-07T12:41:41.000Z","updated":"2023-01-02T03:31:39.095Z","comments":true,"path":"2018/01/07/Operators/","link":"","permalink":"https://noteforme.github.io/2018/01/07/Operators/","excerpt":"","text":"JAVA运算符 赋值运算符＆= 按位与赋值运算符 C＆= 2等价于C = C＆2 | = 按位或赋值操作符 C | = 2等价于C = C | 2 http://www.runoob.com/java/java-operators.html Java位运算符Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下： 1234567A &#x3D; 0011 1100B &#x3D; 0000 1101-----------------A&amp;B &#x3D; 0000 1100A | B &#x3D; 0011 1101A ^ B &#x3D; 0011 0001~A&#x3D; 1100 0011 下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13： 操作符 描述 例子 ＆ 按位与 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 | 按位或 如果相对应位都是 0，则结果为 0，否则为 1 （A | B）得到61，即 0011 1101 ^ 按位异或 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; int a = 60; /* 60 = 0011 1100 */ int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a &amp; b; /* 12 = 0000 1100 */ System.out.println(&quot;a &amp; b = &quot; + c ); c = a | b; /* 61 = 0011 1101 */ System.out.println(&quot;a | b = &quot; + c ); c = a ^ b; /* 49 = 0011 0001 */ System.out.println(&quot;a ^ b = &quot; + c ); c = ~a; /*-61 = 1100 0011 */ System.out.println(&quot;~a = &quot; + c ); c = a &lt;&lt; 2; /* 240 = 1111 0000 */ System.out.println(&quot;a &lt;&lt; 2 = &quot; + c ); c = a &gt;&gt; 2; /* 15 = 1111 */ System.out.println(&quot;a &gt;&gt; 2 = &quot; + c ); c = a &gt;&gt;&gt; 2; /* 15 = 0000 1111 */ System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + c ); &#125;&#125; 运行结果 1234567a &amp; b = 12a | b = 61a ^ b = 49~a = -61a &lt;&lt; 2 = 240a &gt;&gt; 2 = 15a &gt;&gt;&gt; 2 = 15 Kotlin 位运算对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数，例如: 1val x &#x3D; (1 shl 2) and 0x000FF000 这是完整的位运算列表（只用于 Int 与 Long）： shl(bits) – 有符号左移 shr(bits) – 有符号右移 ushr(bits) – 无符号右移 and(bits) – 位与 or(bits) – 位或 xor(bits) – 位异或 inv() – 位非 https://www.kotlincn.net/docs/reference/basic-types.html#%E8%BF%90%E7%AE%97 https://juejin.cn/post/6844903841293402126 操作符优先级https://www.cs.bilkent.edu.tr/~guvenir/courses/CS101/op_precedence.html https://www.jianshu.com/p/9d2204712097","categories":[],"tags":[{"name":"Operators","slug":"Operators","permalink":"https://noteforme.github.io/tags/Operators/"}]},{"title":"Navigation_Drawer","slug":"NavigationDrawer","date":"2017-12-27T07:05:34.000Z","updated":"2021-08-19T11:11:44.128Z","comments":true,"path":"2017/12/27/NavigationDrawer/","link":"","permalink":"https://noteforme.github.io/2017/12/27/NavigationDrawer/","excerpt":"","text":"Drawer使用 业务 123456789101112131415161718192021222324252627282930313233343536373839private void initView() &#123; mPlanetTitles = getResources().getStringArray(R.array.recycle_array); mDrawerLayout = findViewById(R.id.drawer_layout); mDrawerList = findViewById(R.id.left_drawer); // Set the adapter for the list view mDrawerList.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.drawer_list_item, mPlanetTitles)); mDrawerList.setOnItemClickListener(new DrawerItemClickListener()); &#125; private class DrawerItemClickListener implements ListView.OnItemClickListener &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) &#123; selectItem(position); &#125; &#125; /** * Swaps fragments in the main content view */ private void selectItem(int position) &#123; // Create a new fragment and specify the planet to show based on position Fragment fragment = new PullToRefreshFragment(); // Insert the fragment by replacing any existing fragment FragmentManager fragmentManager = getFragmentManager(); fragmentManager.beginTransaction().replace(R.id.content_frame, fragment) .commit(); setTitle(mPlanetTitles[position]); mDrawerLayout.closeDrawer(mDrawerList); &#125; @Override public void setTitle(CharSequence title) &#123; super.setTitle(title);// getActionBar().setTitle(title); &#125; xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.jonzhou.mineutils.RecycleView.RecycleViewActivity&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/content_frame&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;ListView android:id=&quot;@+id/left_drawer&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:background=&quot;#111&quot; android:choiceMode=&quot;singleChoice&quot; android:divider=&quot;@android:color/transparent&quot; android:dividerHeight=&quot;0dp&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 原生用法 一般情况抽屉内容都不会很多所以就可以用 NavigationView替换ListView 1234567891011121314151617181920212223242526 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:openDrawer=&quot;start&quot;&gt; &lt;include layout=&quot;@layout/app_bar_navigation&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:fitsSystemWindows=&quot;true&quot; app:headerLayout=&quot;@layout/nav_header_navigation&quot; app:menu=&quot;@menu/activity_navigation_drawer&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 查看NavigationView,可以看到 headerLayout，menu分别时抽屉的上下两部分，activity_navigation_drawer最好别用这个名称，否则可能加载系统默认布局怎么改都没用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_navigation); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, &quot;Replace with your own action&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;Action&quot;, null).show(); &#125; &#125;); DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); drawer.addDrawerListener(toggle); toggle.syncState(); NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view); navigationView.setNavigationItemSelectedListener(this);&#125;@Overridepublic void onBackPressed() &#123; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.START)) &#123; drawer.closeDrawer(GravityCompat.START); &#125; else &#123; super.onBackPressed(); &#125;&#125;@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.navigation, menu); return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item);&#125;@SuppressWarnings(&quot;StatementWithEmptyBody&quot;)@Overridepublic boolean onNavigationItemSelected(MenuItem item) &#123; // Handle navigation view item clicks here. int id = item.getItemId(); if (id == R.id.nav_camera) &#123; // Handle the camera action &#125; else if (id == R.id.nav_gallery) &#123; &#125; else if (id == R.id.nav_slideshow) &#123; &#125; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); drawer.closeDrawer(GravityCompat.START); return true;&#125; 动态修改 headLayout的内容 View headerLayout = navView.getHeaderView(0); TextView tevtView = headerLayout.findViewById(R.id.textView); tevtView.setText(&quot;nishiminglema &quot;); 注意 NavigationView也可以添加头部参考： https://segmentfault.com/a/1190000004151222 https://developer.android.com/reference/android/support/design/widget/NavigationView.html https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html https://developer.android.com/training/implementing-navigation/nav-drawer.html?hl=zh-cn","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"Drawer","slug":"Drawer","permalink":"https://noteforme.github.io/tags/Drawer/"}]},{"title":"TAB_VIEWPAGER","slug":"TAB_VIEWPAGER","date":"2017-12-26T07:32:39.000Z","updated":"2021-08-19T11:11:44.238Z","comments":true,"path":"2017/12/26/TAB_VIEWPAGER/","link":"","permalink":"https://noteforme.github.io/2017/12/26/TAB_VIEWPAGER/","excerpt":"","text":"https://developer.android.com/reference/com/google/android/material/tabs/TabLayout ViewPagerTabLayout方式 动态 1234TabLayout tabLayout = ...; tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab 1&quot;)); tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab 2&quot;)); tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab 3&quot;)); 静态 123456789101112&lt;com.google.android.material.tabs.TabLayout android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;match_parent&quot;&gt; &lt;com.google.android.material.tabs.TabItem android:text=&quot;@string/tab_text&quot;/&gt; &lt;com.google.android.material.tabs.TabItem android:icon=&quot;@drawable/ic_android&quot;/&gt; &lt;/com.google.android.material.tabs.TabLayout&gt; 滑动TAB12345678910&lt;androidx.viewpager.widget.ViewPager android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.tabs.TabLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;top&quot; /&gt; &lt;/androidx.viewpager.widget.ViewPager&gt; 设置Tab 12345678910111213TabLayout tabVp = rootView.findViewById(R.id.tab_vp);viewPager = rootView.findViewById(R.id.view_pager); framgents = new LinkedHashMap&lt;&gt;();framgents.put(&quot;项目详情&quot;, introFragment);framgents.put(&quot;相关图片&quot;, imageFragment);framgents.put(&quot;投资记录&quot;, rankFragment);titles = new LinkedList&lt;&gt;();titles.addAll(framgents.keySet());viewPager.setAdapter(new MyPagerAdapter(getFragmentManager()));tabVp.setupWithViewPager(viewPager); 默认设置 12mTabLayout.getTabAt(roomType).select();viewpager.setCurrentItem(1); https://segmentfault.com/a/1190000008753052 自定义TabItem tab_item.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_item_title&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/bg_tab_item_select&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@drawable/bg_tab_item_select_txt&quot; android:textSize=&quot;@dimen/text_size_14&quot; /&gt; &lt;View android:id=&quot;@+id/view_line&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;1dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;@dimen/dimen_10&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@android:color/darker_gray&quot; /&gt;&lt;/LinearLayout&gt; 1234567891011121314tabLayout = findViewById(R.id.tb_layout); for (int i = 0; i &lt; tabTitles.length; i++) &#123; tabLayout.addTab(tabLayout.newTab()); &#125; for (int i = 0; i &lt; tabTitles.length; i++) &#123; TabLayout.Tab tab = tabLayout.getTabAt(i); tab.setCustomView(R.layout.tab_item); TextView tvItemTitle = tab.getCustomView().findViewById(R.id.tv_item_title); tvItemTitle.setText(tabTitles[i]); if (i == tabTitles.length - 1) &#123; tab.getCustomView().findViewById(R.id.view_line).setVisibility(View.GONE); &#125; &#125; https://www.jianshu.com/p/ed129686f2cc https://blog.csdn.net/android_zhengyongbo/article/details/74726176 修改指示器颜色https://codeday.me/bug/20170629/35704.html 设置Tab选择背景https://blog.csdn.net/jdsjlzx/article/details/52171075 首先设置 tabGravity fill模式 center是居中 通过layer-list设置间距 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_selected=&quot;true&quot;&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left=&quot;@dimen/dimen_10&quot; android:right=&quot;@dimen/dimen_10&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;corners android:radius=&quot;3dp&quot; /&gt; &lt;solid android:color=&quot;#ffa2cb79&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item &gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/transparent&quot;&gt;&lt;/solid&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left=&quot;@dimen/dimen_10&quot; android:right=&quot;@dimen/dimen_10&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;corners android:radius=&quot;3dp&quot; /&gt; &lt;solid android:color=&quot;#ffdddddd&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; ViewPager2migrationhttps://developer.android.com/training/animation/screen-slide-2#kotlin https://developer.android.com/training/animation/vp2-migration https://github.com/android/views-widgets-samples/tree/master/ViewPager2 123456&lt;androidx.viewpager2.widget.ViewPager2 android:id=&quot;@+id/view_pater2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_marginTop=&quot;27dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt; 1view_pater2.adapter = ScreenSlidePagerAdapter(this) 12345678910private inner class ScreenSlidePagerAdapter(fa: Fragment) : FragmentStateAdapter(fa) &#123; override fun getItemCount(): Int = 2 override fun createFragment(position: Int): Fragment&#123; return if (position==1)&#123; BodyDataFragment.newInstance() &#125;else&#123; SleepFragment.newInstance() &#125; &#125;&#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"TabLayout","slug":"TabLayout","permalink":"https://noteforme.github.io/tags/TabLayout/"}]},{"title":"Keyboard","slug":"Keyboard","date":"2017-12-21T06:49:56.000Z","updated":"2021-08-19T11:11:44.095Z","comments":true,"path":"2017/12/21/Keyboard/","link":"","permalink":"https://noteforme.github.io/2017/12/21/Keyboard/","excerpt":"","text":"https://developer.android.com/training/keyboard-input/style.html 12345678910111213141516171819 static Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; showSoftKeyboard(etInvestMoney); &#125; &#125;, 200);private void showSoftKeyboard(View view) &#123; if (view.requestFocus()) &#123; InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(view, InputMethodManager.RESULT_UNCHANGED_SHOWN); &#125; &#125; http://www.jianshu.com/p/215b388a6e7d https://juejin.im/post/5eddf8456fb9a04804041738","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"keyboard","slug":"keyboard","permalink":"https://noteforme.github.io/tags/keyboard/"}]},{"title":"proguard","slug":"proguard","date":"2017-12-18T23:29:23.000Z","updated":"2025-02-04T13:32:00.799Z","comments":true,"path":"2017/12/19/proguard/","link":"","permalink":"https://noteforme.github.io/2017/12/19/proguard/","excerpt":"","text":"ProGuard File开启ProGuard，Android工程被Build后，会生成以下文件：\\app\\build\\outputs\\mapping\\release dump.txtapk文件中所有类的构成一览 mapping.txt记录了混淆后的名字与混淆前的名字的对应关系，每一次混淆结果和映射关系都不一样。当遇到Bug是，查看到的堆信息，要和混淆前的源码关联起来，所以管理这个文件很重要。retrace.bat -verbose mapping.txt stacktrace.txt com.rensanning.example.androidsample.User -&gt; com.rensanning.example.androidsample.g: java.lang.String name -&gt; a java.lang.String hometown -&gt; b java.util.ArrayList getUsers() -&gt; a seeds.txt未被混淆的类和方法一览 usage.txt记录了从apk文件中删掉的代码。这个文件一定要认真确认，是否这些代码真的是多余的。 https://developer.android.com/build/shrink-code http://blog.csdn.net/guolin_blog/article/details/50451259 https://mp.weixin.qq.com/s/WmJyiA3fDNriw5qXuoA9MA Android config123456789buildTypes &#123; release &#123; isMinifyEnabled = true proguardFiles( getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;), &quot;proguard-rules.pro&quot; ) &#125;&#125; proguard-android-optimize.txt in this file &#x2F;home&#x2F;mc&#x2F;Android&#x2F;Sdk&#x2F;tools&#x2F;proguard&#x2F;proguard-android-optimize.txt 把Apk后缀改成 zip ,解压后把 classes.dex 文件拖到 jadx里面 https://blog.csdn.net/xiaohai695943820/article/details/72367896 https://www.itread01.com/content/1548717866.html 反编译工具介绍 https://www.cnblogs.com/zhen-android/p/7830249.html 脱糖 即在编译阶段将在语法层面一些底层字节码不支持的特性转换为基础的字节码结构，(比如List上的泛型脱糖后在字节码层面实际为Object)； Android工具链对Java8语法特性脱糖的过程可谓丰富多彩，当然他们的最终目的是一致的：使更新的语法可以在所有的设备上运行。 https://juejin.cn/post/6844903828756643854","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"proguard","slug":"proguard","permalink":"https://noteforme.github.io/tags/proguard/"}]},{"title":"NewFeatures","slug":"NewFeatures","date":"2017-12-17T14:26:11.000Z","updated":"2023-02-23T14:17:11.781Z","comments":true,"path":"2017/12/17/NewFeatures/","link":"","permalink":"https://noteforme.github.io/2017/12/17/NewFeatures/","excerpt":"","text":"ANDROID新特性 apk安装 StrictMode API政策 在AndroidManifest.xml添加 12345678&lt;provider android:name&#x3D;&quot;android.support.v4.content.FileProvider&quot; android:authorities&#x3D;&quot;$&#123;applicationId&#125;.fileProvider&quot; &#x2F;&#x2F; com.cqian是包名 android:grantUriPermissions&#x3D;&quot;true&quot; android:exported&#x3D;&quot;false&quot;&gt; &lt;meta-data android:name&#x3D;&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource&#x3D;&quot;@xml&#x2F;provider_install&quot;&#x2F;&gt; &lt;&#x2F;provider&gt; 编写provider_install.xml文件 新建xml指定共享目录 有下面几种存储方式, name不变，path就是下面得apkCacheFile 12345678910&lt;files-path name&#x3D;&quot;name&quot; path&#x3D;&quot;path&quot; &#x2F;&gt; 物理路径相当于Context.getFilesDir() + &#x2F;path&#x2F; &lt;cache-path name&#x3D;&quot;name&quot; path&#x3D;&quot;path&quot; &#x2F;&gt; 物理路径相当于Context.getCacheDir() + &#x2F;path&#x2F; &lt;external-path name&#x3D;&quot;name&quot; path&#x3D;&quot;path&quot; &#x2F;&gt; 物理路径相当于Environment.getExternalStorageDirectory() + &#x2F;path&#x2F; &lt;external-files-path name&#x3D;&quot;name&quot; path&#x3D;&quot;path&quot; &#x2F;&gt; 物理路径相当于Context.getExternalFilesDir(String) + &#x2F;path&#x2F; &lt;external-cache-path name&#x3D;&quot;name&quot; path&#x3D;&quot;path&quot; &#x2F;&gt; 物理路径相当于Context.getExternalCacheDir() + &#x2F;path&#x2F; 由于我的存储目录用这个，apkCacheFile是SDk卡上得目录名称 String downFile = context.getExternalCacheDir() + &quot;apkCacheFile&quot; 123&lt;external-cache-path name&#x3D;&quot;name&quot; path&#x3D;&quot;apkCacheFile&quot; &#x2F;&gt; 安装APK 就这个安装方法 12345678910111213141516171819private static void installApk(Context context, File apkFile) &#123; Intent intent &#x3D; new Intent(); &#x2F;&#x2F; 由于没有在Activity环境下启动Activity,设置下面的标签 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction(Intent.ACTION_VIEW); String type &#x3D; &quot;application&#x2F;vnd.android.package-archive&quot;; Uri uri; if (Build.VERSION.SDK_INT &gt;&#x3D; 24) &#123; &#x2F;&#x2F; 参数2 清单文件中provider节点里面的authorities ; 参数3 共享的文件,即apk包的file类 uri &#x3D; FileProvider.getUriForFile(context, &quot;getPackageName().fileProvider&quot;, apkFile); &#x2F;&#x2F;对目标应用临时授权该Uri所代表的文件 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); &#125; else &#123; uri &#x3D; Uri.fromFile(apkFile); &#125; intent.setDataAndType(uri, type); context.startActivity(intent); &#125; https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html http://blog.csdn.net/github_2011/article/details/74297460 图片拍照Android P veridex工具使用 win10安装ubuntu https://www.linuxidc.com/Linux/2018-03/151256.htm 对test.apk进行扫描 ./appcompat.sh –dex-file=test.apk 在cmd里敲bash，找到/mnt，你会发现下面有c d e f ，这些就是你win下的硬盘，你可以直接对win下的文件进行操作，包括执行一些linux指令或者编译Linux程序 用mv /mnt/x/a/b-c.zip /home/user/b.zip这类命令 示例: http://www.10tiao.com/html/227/201812/2650244825/1.html android 11适配https://juejin.im/post/6860370635664261128 android12适配Splashhttps://www.youtube.com/watch?v=8F0lK2i3VJk https://developer.android.com/develop/ui/views/launch/splash-screen#elements","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"AndroidNewFeatures","slug":"AndroidNewFeatures","permalink":"https://noteforme.github.io/tags/AndroidNewFeatures/"}]},{"title":"Dialog","slug":"Dialog ","date":"2017-12-11T02:15:44.000Z","updated":"2021-08-19T11:11:43.802Z","comments":true,"path":"2017/12/11/Dialog /","link":"","permalink":"https://noteforme.github.io/2017/12/11/Dialog%20/","excerpt":"","text":"Dialoghttps://developer.android.com/guide/topics/ui/dialogs.htmlhttps://developer.android.com/reference/android/app/DialogFragment.html 中间弹出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class UpdateDialogFragment extends DialogFragment implements View.OnClickListener &#123; public static final String UPDATE_MSG = &quot;UPDATE_MSG&quot;; private UpdateBean updateMsg; public static DialogFragment newInstance(UpdateBean updateBean) &#123; UpdateDialogFragment upDialog = new UpdateDialogFragment(); Bundle bundle = new Bundle(); bundle.putParcelable(UPDATE_MSG, updateBean); upDialog.setArguments(bundle); return upDialog; &#125; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; updateMsg = getArguments().getParcelable(UPDATE_MSG); AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); // Get the layout inflater LayoutInflater inflater = getActivity().getLayoutInflater(); // Inflate and set the layout for the dialog // Pass null as the parent view because its going in the dialog layout View view = inflater.inflate(R.layout.dialog_update, null); TextView tvUpdatetitle = (TextView) view.findViewById(R.id.tv_update_title); TextView tvUpDescribe = (TextView) view.findViewById(R.id.tv_up_describe); tvUpDescribe.setText(updateMsg.getDesc()); TextView tvUpdateYes = (TextView) view.findViewById(R.id.tv_update_yes); TextView tvUpdateNo = (TextView) view.findViewById(R.id.tv_update_no); tvUpdateYes.setOnClickListener(this); tvUpdateNo.setOnClickListener(this); builder.setView(view); // Add action buttons return builder.create(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_update_yes: mListener.onDialogPositiveClick(this,updateMsg); break; case R.id.tv_update_no: mListener.onDialogNegativeClick(this); break; &#125; &#125; /* The activity that creates an instance of this dialog fragment must * implement this interface in order to receive event callbacks. * Each method passes the DialogFragment in case the host needs to query it. */ public interface NoticeDialogListener &#123; void onDialogPositiveClick(DialogFragment dialog,UpdateBean updateBean); void onDialogNegativeClick(DialogFragment dialog); &#125; // Use this instance of the interface to deliver action events NoticeDialogListener mListener; // Override the Fragment.onAttach() method to instantiate the NoticeDialogListener @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); // Verify that the host activity implements the callback interface try &#123; // Instantiate the NoticeDialogListener so we can send events to the host mListener = (NoticeDialogListener) activity; &#125; catch (ClassCastException e) &#123; // The activity doesn&#x27;t implement the interface, throw exception throw new ClassCastException(activity.toString() + &quot; must implement NoticeDialogListener&quot;); &#125; &#125;&#125; 底部弹出https://github.com/umano/AndroidSlidingUpPanelhttps://material.io/guidelines/components/dialogs.html#dialogs-specs http://www.jianshu.com/p/0a7383e0ad0f guide usehttps://blog.csdn.net/u014626094/article/details/105430981 https://mp.weixin.qq.com/s/VadRKHau_YBsV8miFiggEw","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"LOG","slug":"LOG","date":"2017-12-09T08:41:05.000Z","updated":"2021-08-19T11:11:44.095Z","comments":true,"path":"2017/12/09/LOG/","link":"","permalink":"https://noteforme.github.io/2017/12/09/LOG/","excerpt":"","text":"Timber 添加库 implementation &#39;com.jakewharton.timber:timber:4.6.0&#39; **注意 **: 一开始日志打印不了还以为 okhttplogger冲突，BuildConfig需要导入项目的包import com.jonzhou.nytime.BuildConfig;，而不是Timber或其他的包 12345678910111213141516171819202122232425262728293031323334public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (BuildConfig.DEBUG) &#123; Timber.plant(new Timber.DebugTree()); &#125; else &#123; Timber.plant(new CrashReportingTree()); &#125; &#125; /** * A tree which logs important information for crash reporting. */ private static class CrashReportingTree extends Timber.Tree &#123; @Override protected void log(int priority, String tag, @NonNull String message, Throwable t) &#123; if (priority == Log.VERBOSE || priority == Log.DEBUG) &#123; return; &#125; FakeCrashLibrary.log(priority, tag, message); if (t != null) &#123; if (priority == Log.ERROR) &#123; FakeCrashLibrary.logError(t); &#125; else if (priority == Log.WARN) &#123; FakeCrashLibrary.logWarning(t); &#125; &#125; &#125; &#125;&#125; 使用 jake的例子 LintActivity 123456789101112131415161718192021222324252627282930313233343536373839 // LogNotTimber Log.d(&quot;TAG&quot;, &quot;msg&quot;); Log.d(&quot;TAG&quot;, &quot;msg&quot;, new Exception()); android.util.Log.d(&quot;TAG&quot;, &quot;msg&quot;); android.util.Log.d(&quot;TAG&quot;, &quot;msg&quot;, new Exception()); // StringFormatInTimber Timber.w(String.format(&quot;%s&quot;, getString())); Timber.w(format(&quot;%s&quot;, getString())); // ThrowableNotAtBeginning Timber.d(&quot;%s&quot;, new Exception()); // BinaryOperationInTimber String foo = &quot;foo&quot;; String bar = &quot;bar&quot;; Timber.d(&quot;foo&quot; + &quot;bar&quot;); Timber.d(&quot;foo&quot; + bar); Timber.d(foo + &quot;bar&quot;); Timber.d(foo + bar); // TimberArgCount Timber.d(&quot;%s %s&quot;, &quot;arg0&quot;); Timber.d(&quot;%s&quot;, &quot;arg0&quot;, &quot;arg1&quot;); Timber.tag(&quot;tag&quot;).d(&quot;%s %s&quot;, &quot;arg0&quot;); Timber.tag(&quot;tag&quot;).d(&quot;%s&quot;, &quot;arg0&quot;, &quot;arg1&quot;); // TimberArgTypes Timber.d(&quot;%d&quot;, &quot;arg0&quot;); Timber.tag(&quot;tag&quot;).d(&quot;%d&quot;, &quot;arg0&quot;); // TimberTagLength Timber.tag(&quot;abcdefghijklmnopqrstuvwx&quot;); Timber.tag(&quot;abcdefghijklmnopqrstuvw&quot; + &quot;x&quot;); // TimberExceptionLogging Timber.d(new Exception(), new Exception().getMessage()); Timber.d(new Exception(), &quot;&quot;); Timber.d(new Exception(), null); */&#125;private String getString() &#123; return &quot;foo&quot;;&#125; Xlog1 . 环境配置 安装 pyelliptic1.5.7 sudo python setup.py install 解码日志 python mars/log/crypt/decode_mars_nocrypt_log_file.py MarsSample_20200417.xlog 但是现在碰到了问题 mq初始化有日志，接收消息没有日志，可能在不同的线程里，需要做处理","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"Permission","slug":"Permission","date":"2017-12-02T12:11:32.000Z","updated":"2023-08-26T07:51:44.920Z","comments":true,"path":"2017/12/02/Permission/","link":"","permalink":"https://noteforme.github.io/2017/12/02/Permission/","excerpt":"","text":"https://developer.android.com/training/permissions/requesting https://developer.android.com/guide/topics/permissions/overview#normal-dangerous 权限管理Normal permissionsDangerous permissions Android11权限申请申请位置权限，先申请前台，后申请后台权限。 https://zhuanlan.zhihu.com/p/275758740 基本使用123456789101112131415161718192021222324252627282930313233343536373839 public static final int PERMISSION_REQUEST_CODE = 1000; void requestPermission() &#123; // Here, thisActivity is the current activity if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; //则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;// 当某条权限之前已经请求过，并且用户已经拒绝了该权限时 //异步向用户显示解释，这里先弹出解释框，再请求权限. Log.d(TAG, &quot;用户看到解释后，再次常识请求权限&quot;); ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, PERMISSION_REQUEST_CODE); &#125; else &#123; //无需解释，首次请求许可 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, PERMISSION_REQUEST_CODE); Log.d(TAG, &quot;requestPermissions&quot;); &#125; &#125; else &#123; //权限已经授予 Log.d(TAG, &quot;requestPermissions is ok&quot;); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case PERMISSION_REQUEST_CODE: &#123; // If request is cancelled, the result arrays are empty. 如果取消请求，则grantResult 为空 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; Log.d(TAG, &quot;onRequestPermissionResult:ok&quot;); &#125; else &#123; Log.d(TAG, &quot;onRequestPermissionResult:no&quot;); &#125; return; &#125; &#125; &#125; 注意:需要在androidmanifest.xml声明 否则一直返回false 12&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_COARSE_LOCATION&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_FINE_LOCATION&quot; &#x2F;&gt; 1、检查权限是否授予。 12Activity.javapublic int checkSelfPermission(permission) 2、申请权限。 12Activity.java public final void requestPermissions( new String[permission1,permission2,...], requestCode) 这个时候，会弹出系统授权弹窗（授权弹窗是不支持自定义的，原因理所当然）。 3、权限回调。 用户在系统弹窗里面选择后，结果会通过Activity的 onRequestPermissionsResult方法回调APP。 123public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; &#x2F;&#x2F;继续执行逻辑或者提示权限获取失败&#125; 4、权限说明。 用户如果选择了拒绝，下一次在需要声明该权限的时候，Google建议APP开发者给予用户更多的说明，因此提供了下面这个API,这个方法返回值在使用过程中会发现有点纠结（具体解析见下面代码块说明）。 1234567public boolean shouldShowRequestPermissionRationale(permission)&#123; 1、APP没有申请这个权限的话，返回false 2、用户拒绝时，勾选了不再提示的话，返回false 3、用户拒绝，但是没有勾选不再提示的话，返回true 因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。&#125; 这个 看情况选用 参考 https://juejin.im/entry/58b2e490ac502e0069d9ae62 https://developer.android.com/guide/topics/security/permissions?hl=zh-cn#normal-dangerous http://www.10tiao.com/html/227/201610/2650237473/1.html PERMISSION​ 12345678910111213141516171819&lt;!-- 这个权限用于进行网络定位--&gt; &lt;permission android:name&#x3D;&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;&#x2F;permission&gt; &lt;!-- 这个权限用于访问GPS定位--&gt; &lt;permission android:name&#x3D;&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;&#x2F;permission&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;permission android:name&#x3D;&quot;android.permission.ACCESS_WIFI_STATE&quot;&gt;&lt;&#x2F;permission&gt; &lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot;&gt;&lt;&#x2F;permission&gt; &lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;permission android:name&#x3D;&quot;android.permission.CHANGE_WIFI_STATE&quot;&gt;&lt;&#x2F;permission&gt; &lt;!-- 用于读取手机当前的状态--&gt; &lt;permission android:name&#x3D;&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;&#x2F;permission&gt; &lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&gt; &lt;permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;&#x2F;permission&gt; &lt;!-- 访问网络，网络定位需要上网--&gt; &lt;permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt; &lt;!-- SD卡读取权限，用户写入离线定位数据--&gt; &lt;permission android:name&#x3D;&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;&#x2F;permission&gt; One-time permissionsStarting in Android 11 (API level 30), whenever your app requests a permission related to location, microphone, or camera, the user-facing permissions dialog contains an option called Only this time. If the user selects this option in the dialog, your app is granted a temporary one-time permission. Permission groups If the app has already been granted another dangerous permission in the same permission group, the system immediately grants the permission without any interaction with the user. For example, if an app had previously requested and been granted the READ_CONTACTS permission, and it then requests WRITE_CONTACTS, the system immediately grants that permission without showing the permissions dialog to the user. Caution: Future versions of the Android SDK might move a particular permission from one group to another. Therefore, don’t base your app’s logic on the structure of these permission groups. For example, READ_CONTACTS is in the same permission group as WRITE_CONTACTS as of Android 8.1 (API level 27). If your app requests the READ_CONTACTS permission, and then requests the WRITE_CONTACTS permission, don’t assume that the system can automatically grant the WRITE_CONTACTS permission. 多权限申请https://github.com/permissions-dispatcher/PermissionsDispatcher https://github.com/googlesamples/android-RuntimePermissions https://www.jianshu.com/p/a51593817825 https://developer.android.com/training/permissions/requesting livedata https://mp.weixin.qq.com/s/Hw_FI0GRpUDWJ1NwjK652w https://mp.weixin.qq.com/s/7RpGzTjXo9rnHRCVEnrYWQ https://mp.weixin.qq.com/s/i8K-6CSxYuLanR4x1WNSGA https://mp.weixin.qq.com/s/gaSmpT5UQLqNa4Ck0r0eOg http://blog.csdn.net/huaiyiheyuan/article/details/52473984https://developer.android.com/training/permissions/requesting.html Android 10权限在后台运行时访问设备位置信息需要权限 &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot;/&gt; 该权限允许应用程序在后台访问位置。如果请求此权限，则还必须请求ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION权限。只请求此权限无效果 在Android 10的设备上，如果你的应用的 targetSdkVersion &lt; 29，则在请求ACCESS_FINE_LOCATION 或ACCESS_COARSE_LOCATION权限时，系统会自动同时请求ACCESS_BACKGROUND_LOCATION。在请求弹框中，选择“始终允许”表示同意后台获取位置信息，选择“仅在应用使用过程中允许”或”拒绝”选项表示拒绝授权。 如果你的应用的 targetSdkVersion &gt;= 29，则请求ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION权限表示在前台时拥有访问设备位置信息的权限。在请求弹框中，选择“始终允许”表示前后台都可以获取位置信息，选择“仅在应用使用过程中允许”只表示拥有前台的权限。 https://developer.android.com/about/versions/10/privacy/changes https://juejin.im/post/6844904073024503822#heading-5 request permission demohttps://github.com/android/platform-samples/tree/main/samples/privacy/permissions Custom Permissioncan run Demo https://github.com/Ibtisam/Dangerous-Activity https://github.com/Ibtisam/Using-Dangerous-Activity https://github.com/commonsguy/cwac-netsecurity https://medium.com/code-procedure-and-rants/android-permissions-create-custom-permissions-5784188311f3 https://www.youtube.com/watch?v=YeLmufMZfcI https://stackoverflow.com/questions/28975706/start-activity-with-permissions https://stackoverflow.com/questions/26700767/custom-permission-for-activity SensorsAn acceleration sensor measures the acceleration applied to the device, including the force of gravity. The following code shows you how to get an instance of the default acceleration sensor: 12val sensorManager &#x3D; getSystemService(Context.SENSOR_SERVICE) as SensorManagerval sensor: Sensor? &#x3D; sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) https://developer.android.com/guide/topics/sensors/sensors_motion.html#sensors-motion-accel If you are publishing your application on Google Play you can use the element in your manifest file to filter your application from devices that do not have the appropriate sensor configuration for your application. The element has several hardware descriptors that let you filter applications based on the presence of specific sensors. The sensors you can list include: accelerometer, barometer, compass (geomagnetic field), gyroscope, light, and proximity. The following is an example manifest entry that filters apps that do not have an accelerometer: 12&lt;uses-feature android:name&#x3D;&quot;android.hardware.sensor.accelerometer&quot; android:required&#x3D;&quot;true&quot; &#x2F;&gt;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"English-Pronounce","slug":"English-Pronounce","date":"2017-11-23T11:28:27.000Z","updated":"2024-11-17T13:44:54.301Z","comments":true,"path":"2017/11/23/English-Pronounce/","link":"","permalink":"https://noteforme.github.io/2017/11/23/English-Pronounce/","excerpt":"","text":"BOOK 1个练习1个月 让你职场英文流利自信！ - YouTube James Clear: Atomic Habits Atomic Habits by James Clear (Audiobook) - YouTube The Almanac of Naval Ravikant https://archive.org/details/the-almanack-of-naval-ravikant/page/n11/mode/2up PronunciatiionAmerican English Vowels | IPA (International Phonetic Alphabet) vowel chart FREE DOWNLOAD - YouTube [ʌ]stuff [stʌf] [ɑ]job &#x2F;dʒɑːb&#x2F; 在重音上，[ɑ] 变成 [ɑ:] [æ]pure [æ]sat [sæt] Followed by M[m] or N[n][æ] + [m] or [n] 加上后面两个音就不同了 aa - uh [æ] + n &#x3D; aa-uh-n [æ] + n &#x3D; aa-uh-m man [mæn] maa-uh-n hand [hænd] [æ] + [ŋ] seems [eɪ]ay[eɪ] gang &#x2F;ɡæŋ&#x2F;, thanks &#x2F;θæŋks&#x2F; [ɛ]stressred [rɛd] never [nɛv.ər] embrace &#x2F;ˈen.tər&#x2F;. &#x2F;ˈɛn.tər&#x2F; 和[ɑ] 一样 强调后 重音拉长。 unstressedempoy,但是字典不一样.字典是i [u]issue &#x2F;ˈɪʃ.uː&#x2F; [ə]和 [ʌ] 差不多，不过只会出现在 非重音字节里。 fllowed by L , M , N ,R,被吸收有一点没理解。 allow extra data again visa about Book感谢楼主楼主 Dicthttps://forum.freemdict.com/ https://mdx.mdict.org/ https://mdx.mdict.org/%E6%8C%89%E8%AF%8D%E5%85%B8%E8%AF%AD%E7%A7%8D%E6%9D%A5%E5%88%86%E7%B1%BB/ https://freemdict.com/ https://mdict.org/ 划词翻译https://www.bilibili.com/video/av16816801/ https://www.youtube.com/watch?v=SIojtnMplHc https://www.bilibili.com/video/av455529337 English grammar in usehttps://dl.304304.xyz/uploads/Ludovicus/%E8%8B%B1%E8%AF%AD-%E6%90%AC%E8%BF%90/ 安装完air,然后从安装文件选择资源grammar in use右键选择 windows 7安装 点击brower 选择安装的文件 IELTShttps://improvemyielts.com/ielts-speaking-topics-part-2-3 定语从句一个句子作定语修饰限定名词 This is the job which I have dreamed of for years. The job &#x3D; which Which 作为 宾语成分. 物 which&#x2F;that 人 Who&#x2F;whom&#x2F;that 人的&#x2F;物的 Whose 时间 When 地点 Where 原因 Why 定语从句中每个关系词都做成分 包括 that 关系词作宾语可省略 I have a class which&#x2F;that begins at 8:00. 主语 The lawyer whom&#x2F;that&#x2F;who my brother called didn’t answer the phone. My daughter asked me a question which&#x2F;that I couldn’t answer. The people who&#x2F;that sat in the stadium cheered for the home team. Leo is the student whose bike was stolen Australia is one of the few country where people drive on the left. Sunday is the day when people usually don’t go to work. Is there any particular reason why you can’t come. 定语从句分类 ： 限定性、非限定性 限定性 I meet you friend who is staying in Paris. 很多朋友 非限定性 I met your mother, who is staying in Paris. 只有一个妈妈,用”,”隔开 区别: 先行词的范围是否明确 特殊的非限定性定语从句 The company will get back to you in three days, which is one of the typical rules. 介词提前的定语从句 Humans have the ability to modify the environment in which they live. The theory on which it is based may be right. 定语从句和同位语从句的区别 定语从句 : n + that , that 作成分 同位语从句 : that 不作成分 During the past generation, the American middle class family that one could count on hard work and fair play to keep itself financially secure has been transformed by economic risk and new realites. 状语从句一个句子作状语表达秒属性的信息 时间状语从句 When , while , As , Before After Since Until , as soon as , No sooner than 地点状语从句 where 原因状语从句 Because Since As 结果状语从句 So&#x2F;such…that , In order that 目的状语从句 So…that , In order that 条件状语从句 If unless , As long as 让步状语从句 Although Through Even thought As 明让步，暗转折 比较状语从句 Than as I am as tall as you (are). 方式状语从句 As Do it as I told you yesterday. 状语从句的时态 时间状语从句中表示将来，条件状语从句中表示将来，他们都用一般现在是 If it rains tomorrow,we will not got to the park. I will let him know,when he comes home later 条件状语从句： if 条件状语从句，主句 表语从句My concern is that people don’t care about others.The question remains whether people will buy it. 同位语从句位置: 需要解释的抽象N后,解释名词 Fact idea news dream suggestion advice report I support the argumentu&gt; that the problems of school buses must be taken seriously. The man wanted to fly to Rockcallu&gt;,a lonely island. 主语从句Whether we will go camping depend on the weather. It depends on the weather Whether we will go camping. chathow about tw","categories":[],"tags":[{"name":"ENGLISH","slug":"ENGLISH","permalink":"https://noteforme.github.io/tags/ENGLISH/"}]},{"title":"ubuntu_server","slug":"ubuntu-server","date":"2017-11-20T13:11:58.000Z","updated":"2025-03-22T11:07:55.433Z","comments":true,"path":"2017/11/20/ubuntu-server/","link":"","permalink":"https://noteforme.github.io/2017/11/20/ubuntu-server/","excerpt":"","text":"Linux下上传http://www.jianshu.com/p/c3e4f96ced97在html目录下放文件就可以了 scp /home/jon/桌面/img.jpg root@45.77.222.97:/var/www/html/ nexus-3.20.0-04: not a regular file scp -r /home/jon/桌面/img.jpg root@45.77.222.97:/var/www/html/ windows下上传 安装Xshell 给ubuntu安装管理器 apt-get install -y lrzsz https://www.linuxidc.com/Linux/2015-05/117975.ht、 rz命令上传，会弹出一个框选择文件 查看图片 http://45.77.222.97/homedetail_pic.png JDK Environment ubuntu when I wget tar.gz from oracle office. I couldn’t tar tar.gz ,so I upload one. scp jdk-11.0.5_linux-x64_bin.tar.gz root@xxx&#x2F;opt&#x2F;java&#x2F; tar -zxvf FileName.tar.gz Edit &#x2F;etc&#x2F;profile, touch it if not have, 或者直接在根目录‘ cd &#x2F; ’输入下面的这些，也可以，具体写入到哪先不管了 #set java JDK export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk1.8.0_231 export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH make it work source &#x2F;etc&#x2F;profile set jdk. on Mac 123Open ~/.bash_profile export JAVA_HOME=$(/usr/libexec/java_home)source ~/.bash_profile 在64位机器上跑x86的jdk一直提示 -bash: &#x2F;opt&#x2F;jdk&#x2F;jdk1.8.0_231&#x2F;bin&#x2F;java: No such file or directory free -m SSH Server1~/.ssh/known_hosts Install SSH server: 12sudo apt updatesudo apt install openssh-server Start and enable the SSH service: 12sudo systemctl enable sshsudo systemctl start ssh connect with another teminal 1ssh username@ip_address ssh远程连接Ubuntu（局域网和非局域网） 内网穿透 ssh远程连接Ubuntu（局域网和非局域网）_ssh连接ubuntu-CSDN博客 2.非局域网 远程连接Attention:ssh只能用于可以相互ping通的主机之间 使用Zerotier可以将接入的设备放在一个虚拟的局域网中，这样你在外网，只要机子配置了Zerotier和另一台机子在一个Network中，就可以直接访问了，废话不多说看操作。 1.登录zerotier 官网 创建一个new network ，复制NETWORK ID 上图中的NETWORK ID就是命令行中的你的network ID2.Ubuntu安装zerotier curl -s https://install.zerotier.com | sudo bash13.Ubuntu加入zerotier局域网 sudo zerotier-cli join 你的network ID14.Windows安装zerotier并加入局域网客户端下载地址：Download - ZeroTier 安装之后右键join network，输入你的network ID 5.返回zerotier 官网在Ubuntu和Windows前面打勾 授权 6.在Windows客户端打开ssh连接，输入上图中Ubuntu的Manager IPs，即可连接成功。 Zerotier常用命令： 启动Zerotier sudo systemctl start zerotier-one.service 重启Zerotier sudo systemctl restart zerotier-one.service 设置开机自启动 sudo systemctl enable zerotier-one.service 查看服务状态 zerotier-cli status 加入网络 zerotier-cli join 8850xxxxxxxxxxxxxxx 离开网络 zerotier-cli leave 8850xxxxxxxxxxxxxxx 查看所有网络 zerotier-cli listnetworks———————————————— ssh远程连接Ubuntu（局域网和非局域网）_ssh连接ubuntu-CSDN博客 Visit desktop8:00 端口转发 13:20 DDNS-Go 外网访问家庭内网的两大最优方案，零基础教程 远程控制家庭电脑 - YouTube 如何从外网远程桌面访问自己的电脑 - YouTube Ubuntu技巧-Ubuntu远程访问之电信公网IP-CSDN博客 https://www.youtube.com/watch?v=NZVxl5-efSs 外网访问家庭内网的两大最优方案，零基础教程 远程控制家庭电脑 ，公网访问家庭局域网 - 哔哩哔哩 Ubuntu技巧-Ubuntu远程访问之电信公网IP-CSDN博客 route config 端口转发 试用xrdp 远程访问 一直访问不了，重启后又可以了，估计是要设置密码，ubuntu电脑不能先进入到桌面. 12345sudo apt updatesudo apt install xrdpsudo systemctl enable xrdpsudo ufw allow from any to any port 3389 proto tcp Linux科学上网工具，支持Clash和v2ray，linux翻墙clash客户端，虚拟机翻墙 &#8211; 科技分享","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"view_flow","slug":"view_flow","date":"2017-11-12T13:24:33.000Z","updated":"2023-01-02T03:31:39.351Z","comments":true,"path":"2017/11/12/view_flow/","link":"","permalink":"https://noteforme.github.io/2017/11/12/view_flow/","excerpt":"","text":"自定义View函数调用流程 构造函数执行一次 onMeasure(), onLayout(), onDraw()都可能运行很多次。 所以onMeasure() 用的变量不能在构造方法初始化。 http://www.gcssloop.com/category/customview.html 窗口显示 每个Activity包含一个Window对象，Android中window对象由PhoneWindow实现，PhoneWindow将一个DecorView设置为整个应用窗口的根View,DecorView作为窗口界面的顶层视图，封装了窗口操作的通用方法，DecorView将要显示的具体内容显示在PhoneWindow上，这里所有的View监听事件通过WindowMangerService来接收,通过Activity对象来回调相应的onCLicklistener.显示是将屏幕分成两部分，一个TitleView，另一个是ContentView. Measure如果是原始的 View,通过measure方法就完成了测量过程,如果是ViewGroup,除了完成自己的测量外，还需要遍历所有的子View,各个子元素再去递归执行这个流程. View OnMeasure()方法1234567891011121314151617181920val widthMode &#x3D; MeasureSpec.getMode(widthMeasureSpec);val widthSize &#x3D; MeasureSpec.getSize(widthMeasureSpec); widthSize父控件留个子空间的最大宽度val heightMode &#x3D; MeasureSpec.getMode(heightMeasureSpec);val heightSize &#x3D; MeasureSpec.getSize(heightMeasureSpec);var width &#x3D; 10var height &#x3D; 10if (widthMode &#x3D;&#x3D; MeasureSpec.EXACTLY) &#123; &#x2F;&#x2F;如果match_parent或者具体的值，直接赋值 width &#x3D; widthSize&#125; else if (widthMode &#x3D;&#x3D; MeasureSpec.AT_MOST) &#123; &#x2F;&#x2F;w，我们要得到控件需要多大的尺寸 width &#x3D; paddingLeft + mBound.width() + paddingRight&#125;&#x2F;&#x2F;高度跟宽度处理方式一样if (heightMode &#x3D;&#x3D; MeasureSpec.EXACTLY) &#123; height &#x3D; heightSize&#125; else if (heightMode &#x3D;&#x3D; MeasureSpec.AT_MOST) &#123; height &#x3D; paddingTop + mBound.height() + paddingBottom&#125;setMeasuredDimension(width, height) 理解onMeasure https://blog.csdn.net/tuke_tuke/article/details/73302595 加载布局 onSizeChanged因为View的大小不仅由View本身控制，而且受父控件的影响，所以我们在确定View大小的时候最好使用系统提供的onSizeChanged回调函数。它又四个参数，分别为 宽度，高度，上一次宽度，上一次高度。这个函数比较简单，我们只需关注 宽度(w), 高度(h) 即可，这两个参数就是View最终的大小。 链接：https://juejin.cn/post/6844903448186454030 Layoutpublic void layout(int l, int t, int r, int b) 该控件的左 上 右 下边距 ScrollerscrollTo scrollBy在 View 类中，有两个变量 mScrollX 和 mScrollY，它们记录的是 View 的内容的偏移值。mScrollX 和 mScrollY 的默认值都是 0，即默认不偏移。另外我们需要知道一点，向左滑动，mScrollX 为正数，反正为负数。假设我们令 mScrollX = 10，那么该 View 的内容会相对于原来向左偏移 10px。 看看系统的 View 类中的源码： 123456789101112131415161718public class View &#123; /** * The offset, in pixels, by which the content of this view is scrolled * horizontally. * &#123;@hide&#125; */ protected int mScrollX; //整个滑动过程的 X移动范围 /** * The offset, in pixels, by which the content of this view is scrolled * vertically. * &#123;@hide&#125; */ protected int mScrollY; &#125; 滑动绝对距离 1public void scrollTo(int x, int y) 滑动相对距离 1public void scrollBy(int x, int y) Scroller辅助类HorizontalScrollViewEx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class HorizontalScrollViewEx extends ViewGroup &#123; private static final String TAG = &quot;HorizontalScrollViewEx&quot;; private int mChildrenSize; private int mChildWidth; private int mChildIndex; // 分别记录上次滑动的坐标 private int mLastX = 0; private int mLastY = 0; // 分别记录上次滑动的坐标(onInterceptTouchEvent) private int mLastXIntercept = 0; private int mLastYIntercept = 0; private Scroller mScroller; private VelocityTracker mVelocityTracker; public HorizontalScrollViewEx(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mScroller = new Scroller(getContext()); mVelocityTracker = VelocityTracker.obtain(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mVelocityTracker.addMovement(event); int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; scrollBy(-deltaX, 0); break; &#125; case MotionEvent.ACTION_UP: &#123; int scrollX = getScrollX();// int scrollToChildIndex = scrollX / mChildWidth; mVelocityTracker.computeCurrentVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity(); if (Math.abs(xVelocity) &gt;= 50) &#123; mChildIndex = xVelocity &gt; 0 ? mChildIndex - 1 : mChildIndex + 1; &#125; else &#123; mChildIndex = (scrollX + mChildWidth / 2) / mChildWidth; &#125; mChildIndex = Math.max(0, Math.min(mChildIndex, mChildrenSize - 1)); Log.d(TAG, &quot;xVelocity &quot;+xVelocity+ &quot; mChildIndex &quot; +mChildIndex +&quot; mChildWidth &quot; + mChildWidth); int dx = mChildIndex * mChildWidth - scrollX; Log.d(TAG, &quot; scrollX &quot; + scrollX + &quot; dx &quot; + dx); smoothScrollBy(dx, 0); mVelocityTracker.clear(); break; &#125; default: break; &#125; mLastX = x; mLastY = y; return true; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; Log.d(TAG, &quot;left &quot; + l + &quot; top &quot; + t + &quot; right &quot; + r + &quot; bottom &quot; + b); int childLeft = 0; final int childCount = getChildCount(); mChildrenSize = childCount; for (int i = 0; i &lt; childCount; i++) &#123; final View childView = getChildAt(i); if (childView.getVisibility() != View.GONE) &#123; final int childWidth = childView.getMeasuredWidth(); mChildWidth = childWidth; childView.layout(childLeft, 0, childLeft + childWidth, childView.getMeasuredHeight()); childLeft += childWidth; &#125; &#125; &#125; private void smoothScrollBy(int dx, int dy) &#123; mScroller.startScroll(getScrollX(), 0, dx, 0, 500); invalidate(); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; Log.d(TAG,&quot;getCurrX &quot;+mScroller.getCurrX() + &quot;mScroller.getCurrY() &quot; +mScroller.getCurrY()); scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125; @Override protected void onDetachedFromWindow() &#123; mVelocityTracker.recycle(); super.onDetachedFromWindow(); &#125;&#125; 可知View的scrollTo()、scrollBy()是瞬间完成的，当我们的手指在屏幕上移动时，内容会跟着手指滑动，但是当我们手指一抬起时，滑动就会停止,为使得滚动更加平滑,Scroller只是计算辅助类，它的startScroll()和computeScrollOffset()方法中也只是对一些轨迹参数进行设置和计算，真正需要进行滑动还是得通过View的scrollTo()、scrollBy()方法 123// 开始滚动，并记下当前时间点作为开始滚动的时间点startX startY，滑动时起点偏移量，public void startScroll(int startX, int startY, int dx, int dy, int duration) 开始一个动画控制，由(startX , startY)在duration时间内前进(dx,dy)个单位，即到达偏移坐标为(startX+dx , startY+dy)处。 滑动日志,startX+dx是1080 2160,印证了上面的判断 12com.ryg.chapter_3 D&#x2F;HorizontalScrollViewEx: scrollX 821 dx 259com.ryg.chapter_3 D&#x2F;HorizontalScrollViewEx: scrollX 2007 dx 153 实际滑动处理类，Scroller类应该有个插值器，提供滑动控制 12345678@Overridepublic void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; Log.d(TAG,&quot;getCurrX &quot;+mScroller.getCurrX() + &quot;mScroller.getCurrY() &quot; +mScroller.getCurrY()); scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125;&#125; http://chanthuang.github.io/2016/08/31/Android-View-%E7%9A%84%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86%E5%92%8C-Scroller%E3%80%81VelocityTracker-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/ https://www.jianshu.com/p/f10809e1964b DrawPaint 为了展示方便，容易看出效果，之前使用的模式一直为填充模式，实际上画笔有三种模式，如下： 123STROKE &#x2F;&#x2F;描边FILL &#x2F;&#x2F;填充FILL_AND_STROKE &#x2F;&#x2F;描边加填充 为了区分三者效果我们做如下实验： 123456789101112131415Paint paint &#x3D; new Paint();paint.setColor(Color.BLUE);paint.setStrokeWidth(40); &#x2F;&#x2F;为了实验效果明显，特地设置描边宽度非常大&#x2F;&#x2F; 描边paint.setStyle(Paint.Style.STROKE);canvas.drawCircle(200,200,100,paint);&#x2F;&#x2F; 填充paint.setStyle(Paint.Style.FILL);canvas.drawCircle(200,500,100,paint);&#x2F;&#x2F; 描边加填充paint.setStyle(Paint.Style.FILL_AND_STROKE);canvas.drawCircle(200, 800, 100, paint); 画布坐标操作 1canvas.scale(1,-1); &#x2F;&#x2F; 翻转Y轴 setWillNotDrawViewGroup默认情况下，出于性能考虑，会被设置成WILL_NOT_DROW，这样，ondraw就不会被执行了。 如果我们想重写一个viewgroup的ondraw方法，有两种方法： 1，构造函数中，给viewgroup设置一个颜色。 2，构造函数中，调用setWillNotDraw（false），去掉其WILL_NOT_DRAW flag。 在viewgroup初始化的时候，它调用了一个私有方法：initViewGroup，它里面会有一句setFlags（WILLL_NOT_DRAW,DRAW_MASK）;相当于调用了setWillNotDraw（true），所以说，对于ViewGroup，他就认为是透明的了，如果我们想要重写onDraw，就要调用setWillNotDraw（false）。 https://www.jianshu.com/p/7df7e8a0b1a6 https://juejin.im/post/5e6e0b91f265da5716712288 RelativeLayout就是拓扑排序，用到了不光是树，还有图。所以数据结构与算法真的非常重要，他会让你的学习不会再那么枯燥。 childview https://www.jianshu.com/p/c84693096e41 https://mp.weixin.qq.com/s/psrDADxwl782Fbs_vzxnQg UI 优化系列专题https://www.jianshu.com/p/ea464eb15436 淘宝详情onLayout 两个子view切换绘制 https://juejin.cn/post/6844903828035207182 invalidate() Calling invalidate() is done when you want to schedule a redraw of the view. It will result in onDraw being called eventually (soon, but not immediately). An example of when a custom view would call it is when a text or background color property has changed. The view will be redrawn but the size will not change. requestLayout() If something about your view changes that will affect the size, then you should call requestLayout(). This will trigger onMeasure and onLayout not only for this view but all the way up the line for the parent views. Calling requestLayout() is not guaranteed to result in an onDraw (contrary to what the diagram in the accepted answer implies), so it is usually combined with invalidate(). 12invalidate();requestLayout(); An example of this is when a custom label has its text property changed. The label would change size and thus need to be remeasured and redrawn. forceLayout() When there is a requestLayout() that is called on a parent view group, it does not necessary need to remeasure and relayout its child views. However, if a child should be included in the remeasure and relayout, then you can call forceLayout() on the child. forceLayout() only works on a child if it occurs in conjunction with a requestLayout() on its direct parent. Calling forceLayout() by itself will have no effect since it does not trigger a requestLayout() up the view tree. Read this Q&amp;A for a more detailed description of forceLayout(). https://stackoverflow.com/questions/13856180/usage-of-forcelayout-requestlayout-and-invalidate","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[]},{"title":"View_CanvasApi","slug":"View_CanvasApi","date":"2017-11-12T04:34:50.000Z","updated":"2021-08-19T11:11:44.279Z","comments":true,"path":"2017/11/12/View_CanvasApi/","link":"","permalink":"https://noteforme.github.io/2017/11/12/View_CanvasApi/","excerpt":"","text":"Canvas的常用操作速查表 操作类型 相关API 备注 绘制颜色 drawColor, drawRGB, drawARGB 使用单一颜色填充整个画布 绘制基本形状 drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧 绘制图片 drawBitmap, drawPicture 绘制位图和图片 绘制文本 drawText, drawPosText, drawTextOnPath 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字 绘制路径 drawPath 绘制路径，绘制贝塞尔曲线时也需要用到该函数 顶点操作 drawVertices, drawBitmapMesh 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用 画布剪裁 clipPath, clipRect 设置画布的显示区域 画布快照 save, restore, saveLayerXxx, restoreToCount, getSaveCount 依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数 画布变换 translate, scale, rotate, skew 依次为 位移、缩放、 旋转、错切 Matrix(矩阵) getMatrix, setMatrix, concat 实际画布的位移，缩放等操作的都是图像矩阵Matrix，只不过Matrix比较难以理解和使用，故封装了一些常用的方法。 PS： Canvas常用方法在上面表格中已经全部列出了，当然还存在一些其他的方法未列出，具体可以参考官方文档 Canvas Use CanvasPath lineTo简单实现 12345canvas.translate(DeviceUtil.mWidth / 2, DeviceUtil.mHeight / 2); //原点移动到屏幕中心 Path path = new Path(); path.lineTo(200, 200); path.lineTo(200, 0); canvas.drawPath(path, mPaint); 从字面意思 lineto,顾名思义肯定就有from的坐标点，再看这个借的图，第一条线是从原点开始的，第二条线是从A开始的， 1path.close(); //形成封闭的图形 这些操作都可以叠加 Rect RectF区别: Rect是使用int类型作为数值，RectF是使用float类型作为数值。 四个参数是 矩形左上角和右下角两个点的坐标 画线 1234Path path = new Path();path.moveTo(100, 100);path.rLineTo(100, 200);canvas.drawPath(path, mPaint); Draw Circle 画笔 1234mPaint = new Paint();mPaint.setColor(Color.BLUE);mPaint.setStyle(Paint.Style.FILL); // Fill是空心圆 ，STROKE实心圆,空心圆就需要设置setStrokeWidth这个属性 canvas.drawCircle(getWidth()/2,getHeight()/2,getWidth()/2,mPaint); public void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) oval :指定圆弧的外轮廓矩形区域。startAngle: 圆弧起始角度，单位为度。sweepAngle: 圆弧扫过的角度(起始位置 X轴)，顺时针方向，单位为度,从右中间开始为零度。useCenter: 如果为True时，在绘制圆弧时将圆心包括在内，通常用来绘制扇形 RectF是矩形的内接圆,left top right bottom分别对象 左上角和右下角 坐标 drawText坐标(0,0)位于左下角 1canvas?.drawText(&quot;测试文字&quot;,0f,0f,mPaint) measure textSize 123456val kgRect = Rect()var kgText = &quot;hello world&quot;mDialPaint.getTextBounds(kgText,0,kgText.length,kgRect)var txtHeight = kgRect.height()var txtWidth = kgRect.width() 123456canvas.drawPoint(200, 200, mPaint); canvas.drawPoints(new float[]&#123; //绘制一组点，坐标位置由float数组指定 500, 500, 500, 600, 500, 700 &#125;, mPaint); 位移(translate) 1234567// 在坐标原点绘制一个黑色圆形 canvas.translate(200, 200); canvas.drawCircle(0, 0, 100, mPaint); // 在坐标原点绘制一个蓝色圆形 mPaint.setColor(Color.BLUE); canvas.translate(200, 200); canvas.drawCircle(0, 0, 100, mPaint); 缩放(scale) 12345678910111213141516canvas.translate(mWidth / 2, mHeight / 2); RectF rect = new RectF(0, -400, 400, 0); // 矩形区域 mPaint.setColor(Color.BLACK); // 绘制黑色矩形 canvas.drawRect(rect, mPaint); canvas.scale(-0.5f, -0.5f); // 画布缩放 &lt;-- 缩放中心向右偏移了200个单位 mPaint.setColor(Color.BLUE); // 绘制蓝色矩形 canvas.drawRect(rect, mPaint); RectF rect = new RectF(-400, -400, 400, 400); canvas.drawRect(rect, mPaint); for (int i = 0; i &lt; 20; i++) &#123; canvas.scale(0.9f, 0.9f); canvas.drawRect(rect, mPaint); &#125; 旋转(rotate) 1canvas.rotate(180); drawPicture 三个方法 public void drawPicture (Picture picture) public void drawPicture (Picture picture, Rect dst) public void drawPicture (Picture picture, RectF dst) drawBitmap 三个方法 // 第一种 public void drawBitmap (Bitmap bitmap, Matrix matrix, Paint paint) // 第二种 public void drawBitmap (Bitmap bitmap, float left, float top, Paint paint) // 第三种 public void drawBitmap (Bitmap bitmap, Rect src, Rect dst, Paint paint) public void drawBitmap (Bitmap bitmap, Rect src, RectF dst, Paint paint) 直接看第三种方法 1234567// 指定图片绘制区域(左上角的四分之一)Rect src = new Rect(0, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);// 指定图片在屏幕上显示的区域Rect dst = new Rect(0, 0, 400, 500);//绘制图片canvas.drawBitmap(bitmap, src, dst, null); Angle 在常见的数学坐标系中角度增大方向为逆时针， 在默认的屏幕坐标系中角度增大方向为顺时针。 sweepAngle扫过的角度 12drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint) canvas?.drawArc(rectF,0f,145f,false,mDialPaint) save restoreSaveRestoreView 12345 canvas?.drawLine(0f,200f,700f,200f,linePaint)// canvas?.save() //将画布状态保存 canvas?.rotate(90f, px / 2, py / 2);// canvas?.restore();//恢复画布状态 这个操作能撤销到 上次保存的画布状态 canvas?.drawLine(0f,400f,700f,400f,bgPaint) 运行效果： 打开注释后的运行效果，这样运行后相当于 没有发生选择画布这件事。 saveslayer 图层https://blog.csdn.net/cquwentao/article/details/51423371 https://www.jianshu.com/p/0bd672626c8d Canvas demo https://medium.com/better-programming/learn-all-android-canvas-draw-functions-dd5d6595884a","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/tags/VIEW/"}]},{"title":"Gogs","slug":"Gogs","date":"2017-11-12T01:08:56.000Z","updated":"2021-08-19T11:11:43.902Z","comments":true,"path":"2017/11/12/Gogs/","link":"","permalink":"https://noteforme.github.io/2017/11/12/Gogs/","excerpt":"","text":"ubuntu 17.04 Gogs搭建git服务器 gogs Install创建git用户12345678910sudo apt-get upgradesudo adduser git //创建用户 密码 ******* (1234)su git//切换到git用户cd ~ //进入用户git根目录git --version //检查git是否安装 修改git密码 到root下 passwd git 然后输入密码http://wangchujiang.com/linux-command/c/passwd.html # 创建数据库 这个可以选择默认的sqlite3救不需要安装mysql 123456mysql -u root -pmysql&gt; SET GLOBAL storage_engine = &#x27;InnoDB&#x27;;mysql&gt; CREATE DATABASE gogs CHARACTER SET utf8 COLLATE utf8_bin;mysql&gt; GRANT ALL PRIVILEGES ON gogs.* TO ‘root’@‘localhost’ IDENTIFIED BY ‘itadmin’;mysql&gt; FLUSH PRIVILEGES;mysql&gt; QUIT； ## 安装golang环境(可以忽略) 1234567891011121314su git环境变量export GOROOT=$HOME/go //目录下export GOARCH=amd64 #系统位数，386表示32位系统，amd64表示64位系统。export GOOS=linux #系统类型export PATH=$PATH:$GOROOT/bin//使环境变量生效：source ~/.bashrcwget https://github.com/gogits/gogs/releases/download/v0.11.29/go1.9.2.linux-amd64.tar.gztar zxvf go1.9.2.linux-amd64.tar.gzmv go $GOROOT //这一步有点问题，已存在文件go env //测试这个一步 倒是没问题 安装Gogs123456su git cd ~wget https://github.com/gogits/gogs/releases/download/v0.11.29/linux_amd64.tar.gztar zxvf linux_amd64.tar.gz //解压后会右gogs文件 cd gogs ./gogs web 安装配置浏览器输入 http://yourip:3000/install 进行配置 如图 把localhost改成yourip 后台运行1234su gitcd /home/git/gogs nohup ./gogs web&amp; 参考：雨巷前端 雨巷前端 重启查找gogs目录 find / -name &#39;gogs&#39; 然后按照后台运行 Gogs upgrade sudo su - git cd ~ pwd ls mv gogs gogs_old wget https://dl.gogs.io/0.11.91/gogs_0.11.91_linux_amd64.tar.gz tar -zxvf gogs_0.11.91_linux_amd64.tar.gz ls cp -R gogs_old&#x2F;{custom,data,log} gogs cd gogs .&#x2F;gogs web https://gogs.io/docs/upgrade/upgrade_from_binary clone地址为 localhost问题 &#x2F;home&#x2F;git&#x2F;gogs&#x2F;custom&#x2F;conf下把app.ini，DOMAIN ROOT_URL 改成主机ip Draw12/root/DRAW/apache-tomcat-8.5.65/bin./startup.sh","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://noteforme.github.io/categories/LINUX/"}],"tags":[]},{"title":"background_draw (背景图形绘制)","slug":"background_draw","date":"2017-11-03T01:59:57.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2017/11/03/background_draw/","link":"","permalink":"https://noteforme.github.io/2017/11/03/background_draw/","excerpt":"","text":"** 为了提高App性能，经常会用到代码写背景 ** 基本属性 solid : 填充内容 stroke: 绘制边框 代码里设置颜色 Color.parseColor(&quot;#fa6d62&quot;) 点击选中状态 android:state_pressed 是否按下，如一个按钮触摸或者点击。 android:state_focused 是否取得焦点，比如用户选择了一个文本框。 android:state_hovered 光标是否悬停，通常与focused state相同，它是4.0的新特性 android:state_selected 被选中，它与focus state并不完全一样，如一个list view 被选中的时候，它里面的各个子组件可能通过方向键，被选中了。 android:state_checkable 组件是否能被check。如：RadioButton是可以被check的。 android:state_checked 被checked了，如：一个RadioButton可以被check了。 android:state_enabled 能够接受触摸或者点击事件 android:state_activated 被激活(这个麻烦举个例子，不是特明白) android:state_window_focused 应用程序是否在前台，当有通知栏被拉下来或者一个对话框弹出的时候应用程序就不在前台了 注意:如果有多个item，那么程序将自动从上到下进行匹配，最先匹配的将得到应用。（不是通过最佳匹配） 如果一个item没有任何的状态说明，那么它将可以被任何一个状态匹配。 https://blog.csdn.net/yinbucheng/article/details/52922759 seleced用于单选，checked用于多选, selected是选择很多项，但是只取当前的项，即最后一个选中的 checked是选中很多项，都选中。 shape layer-list selector设置Button按钮背景 12345678910&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;corners android:radius=&quot;20dp&quot; /&gt; &lt;!-- 边框的颜色--&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#009cff&quot; /&gt; &lt;!--填充的颜色 --&gt; &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt;&lt;/shape&gt; shape &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;#2e97f3&quot; /&gt; //填充颜色 &lt;stroke android:width=&quot;2dp&quot; //描边宽度 android:color=&quot;#2e97f3&quot; /&gt; //描边颜色 &lt;/shape&gt; layer-list&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;#2e97f3&quot; /&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#2e97f3&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:top=&quot;50dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_green_dark&quot; /&gt; &lt;padding android:left=&quot;50dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:top=&quot;100dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_orange_light&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; LayerDrawable 是管理其他可绘制对象阵列的可绘制对象。列表中的每个可绘制对象按照列表的顺序绘制，列表中的最后一个可绘制对象绘于顶部。每个可绘制对象由单一 元素内的 元素表示。我们需要注意的是layer-list中有item的先后顺序会影响展示效果，不同顺序的效果可能大相径庭，因为，后面的item总是在之前的item之上并覆盖显示。 selector 底部选择器 123456789101112131415161718192021 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_selected=&quot;true&quot;&gt; &lt;layer-list&gt; &lt;item&gt; &lt;color android:color=&quot;#2e97f3&quot; /&gt; &lt;/item&gt; &lt;item android:bottom=&quot;5dp&quot; android:drawable=&quot;@color/white&quot; /&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item&gt; &lt;color android:color=&quot;#2e97f3&quot; /&gt; &lt;/item&gt; &lt;item android:drawable=&quot;@color/white&quot; /&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; 参考 https://keeganlee.me/post/android/20150909 背景选择器 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/bg_circle_tab_yellow&quot; android:state_selected=&quot;true&quot; /&gt; &lt;item android:drawable=&quot;@drawable/bg_circle_tab_gray&quot; /&gt;&lt;/selector&gt; 字体颜色选择器 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:color=&quot;@color/white&quot; android:state_selected=&quot;true&quot; /&gt; &lt;item android:color=&quot;#999999&quot; /&gt;&lt;/selector&gt; 后面的item在之前的item上显示，所有前面设置的padding,后面叠加形成图层 http://blog.csdn.net/xiehuimx/article/details/70242676https://developer.android.com/guide/topics/resources/drawable-resource.html#Transition 首页阴影效果office前端时间一直找这种资料，效果一直不如意，不得已用了图片，真是 踏破铁鞋无觅处https://developer.android.com/training/material/shadows-clipping.html 123456789 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#f9fafc&quot; /&gt; &lt;corners android:radius=&quot;2dp&quot; /&gt; &lt;solid android:color=&quot;@color/white&quot; /&gt;&lt;/shape&gt; 不过这种方法还是差强人意 another可以试试下面这种方式 http://blog.csdn.net/u011421608/article/details/51923812http://yifeng.studio/2017/02/26/android-elevation-and-shadow/ 画虚线&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;line&quot;&gt; &lt;!-- jon 虚线--&gt; &lt;size android:height=&quot;1dp&quot; /&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;@color/white&quot; android:dashGap=&quot;2dp&quot; android:dashWidth=&quot;4dp&quot; /&gt; &lt;!-- dashwidth是指- - -中每一个-的宽度--&gt; &lt;!-- dashGap是指虚线中每一个间隔的宽度 --&gt; height比height高 关闭硬件加速 android:layerType=”software” 12345&lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;10dp&quot; android:layout_below=&quot;@+id/rl_time_day&quot; android:background=&quot;@drawable/bg_dash_line&quot; /&gt; 参考： https://lianyuchen.github.io/2017/05/09/%E5%85%B3%E4%BA%8Eshape%E7%94%BB%E8%99%9A%E7%BA%BF/ http://www.jianshu.com/p/75cc93195f7a?from=jiantop.com https://keeganlee.me/post/android/20150909 LinearLayout默认横线 android:divider=&quot;@drawable/shape_line android:dividerPadding=&quot;@dimen/dimen_15&quot; 123* shape_line.xml &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/line_color&quot; /&gt; &lt;size android:height=&quot;0.5dp&quot; /&gt; &lt;/shape&gt; https://blog.csdn.net/BingShuShu/article/details/51444206","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[]},{"title":"Resource","slug":"Resource","date":"2017-10-21T00:53:39.000Z","updated":"2021-12-26T12:11:20.570Z","comments":true,"path":"2017/10/21/Resource/","link":"","permalink":"https://noteforme.github.io/2017/10/21/Resource/","excerpt":"","text":"12@ColorInt 表明该参数、变量或者函数返回值应该是一个颜色值而不是颜色资源引用，例如应该是一个 AARRGGBB 的整数值。@ColorRes 表明该参数、变量或者函数返回值应该是一个 color 类型的资源，而不是颜色值。注意和 ColorInt 区别 ColorInt: Color.Red 和R.color.refrence是有区别的 https://www.jianshu.com/p/2edbd53fa7b0 https://blog.csdn.net/ziwang_/article/details/70513932 有时候想写点东西 苦于没有素材 https://icons8.com/http://www.iconfont.cn https://icomoon.io/http://fontello.com/ 也可以导入矢量图https://developer.android.com/studio/write/vector-asset-studio.html?hl=zh-cn https://material.io/icons/ 官方图","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"hot_patch（热更新）","slug":"hot-patch","date":"2017-10-17T07:25:56.000Z","updated":"2021-08-19T11:11:44.300Z","comments":true,"path":"2017/10/17/hot-patch/","link":"","permalink":"https://noteforme.github.io/2017/10/17/hot-patch/","excerpt":"","text":"为了预防项目紧急问题，使用热更新比发版要好点 热更新选择 VitrualApk 滴滴开源的方案，之前的dynamic-load-apk推动的热更新的发展,不过这个开源没多久，准备后面迁移到这上面来 Tinker-Bugly 这个很不错免费，就是只支持 冷启动，配合bugly教程用起来方便 sophix 这个支持热启动 配置也方便，不过5万设备以上就要收费，对于收费我觉得也无可厚非，毕竟是别人的劳动成果， 作为开发者的角度，还是开源最好，以后可以学习下。 所以先选择Tinker-Bugly 接入 按照接入文档 配合Demo接入配置，然后就开始做自己的app 定义 修改appid bugly平台申请后的 AppId 123// 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId // 调试时，将第三个参数改为true Bugly.init(getApplication(), &quot;f7b6508f55&quot;, true); 第三个参数设置 log是否展示 tinkerId 每次修改 基线版本和 补丁版本都要修改 tinkerId 12tinkerId = &quot;1.0.6-patch&quot; 点击 assembleDebug 生成 基线版本 https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix-demo/ 1实际应用中，请注意保存线上发布版本的基准apk包、mapping文件、R.txt文件，如果线上版本有bug，就可以借助我们tinker-support插件进行补丁包的生成。 修改 def baseApkDir , 修改 tinkerId 修改bug baseApkDir是根据基线版本生成的目录 修改tinkerId 编译patch包 点击 buildTinkerPatchRelease，生成patch_signed_7zip.apk上传,然后重启就可以了 对于开发设备和全量设备 修改 12//指定为开发设备 Bugly.setIsDevelopmentDevice(getApplication(),true); 参考 ： https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/ https://github.com/Tencent/tinker https://github.com/BuglyDevTeam/Bugly-Android-Demo UncaughtExceptionHandler Bugly冲突 不上报日志https://blog.csdn.net/ZPCrobot/article/details/97390156 从零开始实现一个插件化框架https://blog.csdn.net/qq_22090073/article/details/103946596 https://www.jianshu.com/p/af8c47fabb12","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"ConstraintLayout","slug":"ConstraintLayout","date":"2017-10-15T02:37:39.000Z","updated":"2023-02-23T14:17:11.776Z","comments":true,"path":"2017/10/15/ConstraintLayout/","link":"","permalink":"https://noteforme.github.io/2017/10/15/ConstraintLayout/","excerpt":"","text":"introducehttps://developer.android.google.cn/reference/androidx/constraintlayout/widget/ConstraintLayout https://developer.android.com/develop/ui/views/layout/constraint-layout https://juejin.cn/post/6949186887609221133#heading-6 Widgets dimensionwidget的尺寸可以通过设置android:layout_width和android:layout_height的属性值来指定，有如下三种方式： 使用具体值 使用WRAP_CONTENT，这样widget会计算自身的尺寸 Using 0dp, which is the equivalent of “MATCH_CONSTRAINT“ (使用0dp，这等于“MATCH_CONSTRAINT” ) Group可以控制一组控件的隐藏和显示 123456&lt;androidx.constraintlayout.widget.Group android:id&#x3D;&quot;@+id&#x2F;gp_1&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:visibility&#x3D;&quot;gone&quot; app:constraint_referenced_ids&#x3D;&quot;cl_h4,cl_h2&quot; &#x2F;&gt; 1((Group)findViewById(R.id.gp_1)).setVisibility(View.GONE); ​ findViewById(R.id.gp_2).setVisibility(View.INVISIBLE); doesnt not work https://juejin.cn/post/6844903875569254414#heading-17 Guideline使用https://developer.android.com/reference/android/support/constraint/Guideline.html 12app:layout_constraintGuide_percent&#x3D;&quot;0.2&quot;app:layout_constraintGuide_begin&#x3D;&quot;100dp&quot; 特色属性layout_constraintDimensionRatio指定高度，宽度随着宽高比自适应 1234567&lt;ImageView android:id&#x3D;&quot;@+id&#x2F;iv_img01&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:src&#x3D;&quot;@mipmap&#x2F;img_1&quot; app:layout_constraintDimensionRatio&#x3D;&quot;1:1&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; &#x2F;&gt; layout_constraintHorizontal_bias 先设置约束 Bias上面的水平居中,是使用的与父亲左侧对齐+与父亲右侧对齐. 可以理解为左右的有一种约束力,默认情况下,左右的力度是一样大的,那么view就居中了. 当左侧的力度大一些时,view就会偏向左侧.就像下面这样. layout_constraintHorizontal_bias 水平约束力layout_constraintVertical_bias 垂直约束力 1234567&lt;android.support.constraint.ConstraintLayout &lt;Button android:text=&quot;按钮1&quot; app:layout_constraintHorizontal_bias=&quot;0.3&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 上面代码就偏左约束 WRAP_CONTENT: 强制约束我们可能希望使用WRAP_CONTENT，同时仍然强制执行约束以限制最终的尺寸 app:layout_constrainedWidth=”true|false” button1居中显示，button2约束在button1的右边、parent的左边： 123456789101112131415161718192021&lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;aaaaaaa&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;&lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;22222222222222222222222222222&quot; app:layout_constrainedWidth=&quot;true&quot; android:layout_marginTop=&quot;40dp&quot; app:layout_constraintTop_toTopOf=&quot;@id/button1&quot; app:layout_constraintStart_toEndOf=&quot;@id/button1&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot;/&gt; 对button2使不使用app:layout_constrainedWidth=&quot;true&quot;的效果如下： 约束width前 &amp; 约束width后 占用父布局的比例chain 3个Button 两两依赖,相当于组成了一个链 Button均分 width = match_constraint (0dp) 1234567891011121314151617181920212223&lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_00&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_00&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_01&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_01&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_01&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_00&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_02&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_02&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_02&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_01&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; &#x2F;&gt; app:layout_constraintHorizontal_weight=”2”` 看属性也可以猜到是干嘛用的了. 12345678910111213141516171819202122232425262728293031&lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width&#x3D;&quot;match_parent&quot; app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;guideline_00&quot; android:layout_height&#x3D;&quot;wrap_content&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_00&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_00&quot; app:layout_constraintHorizontal_weight&#x3D;&quot;2&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_01&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_01&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_01&quot; app:layout_constraintHorizontal_weight&#x3D;&quot;1&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_00&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_02&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_02&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; app:layout_constraintHorizontal_weight&#x3D;&quot;1&quot; android:text&#x3D;&quot;Button_02&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_01&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; &#x2F;&gt; &lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt; Button均份 宽度不为match_constraint 1234567891011121314151617181920212223&lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_10&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_00&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_11&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_11&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_01&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_10&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_12&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_12&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Button_02&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_11&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; &#x2F;&gt; chainStyleChains are controlled by attributes set on the first element of the chain (the “head” of the chain): The head is the left-most widget for horizontal chains, and the top-most widget for vertical chains.第一个元素决定链style 而且只有放在头节点才有效，否则都没用 spread Chainlayout_constraintHorizontal_chainStyle 这个属性默认是spread 元素展开 mineutil activity_constraint.xml 1234567891011121314151617181920212223&lt;Button android:id=&quot;@+id/bt_00&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_00&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_01&quot; /&gt;&lt;Button android:id=&quot;@+id/bt_01&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_01&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_00&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_02&quot; /&gt;&lt;Button android:id=&quot;@+id/bt_02&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_02&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_01&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; Spread inside chain endpoints of the chain will not be spread out (两端不会展开) 其实就相当于两端的约束去掉了 123456789101112131415161718192021222324252627&lt;Button android:id=&quot;@+id/bt_10&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Inside&quot; android:background=&quot;@android:color/holo_blue_light&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_11&quot; /&gt;&lt;Button android:id=&quot;@+id/bt_11&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Inside&quot; android:background=&quot;@android:color/holo_blue_light&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_10&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_12&quot; /&gt;&lt;Button android:id=&quot;@+id/bt_12&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Inside&quot; android:background=&quot;@android:color/holo_blue_light&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_11&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; Weighted chains看上面官方的图就能理解了 packed chains 123456789101112131415161718192021222324252627&lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_20&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:background&#x3D;&quot;@android:color&#x2F;holo_blue_light&quot; android:text&#x3D;&quot;packed&quot; app:layout_constraintHorizontal_chainStyle&#x3D;&quot;packed&quot; &#x2F;&#x2F;第一个有效 app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_21&quot; &#x2F;&gt;&lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_21&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:background&#x3D;&quot;@android:color&#x2F;holo_blue_light&quot; android:text&#x3D;&quot;packed&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_20&quot; app:layout_constraintRight_toLeftOf&#x3D;&quot;@+id&#x2F;bt_22&quot; &#x2F;&gt;&lt;Button android:id&#x3D;&quot;@+id&#x2F;bt_22&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:background&#x3D;&quot;@android:color&#x2F;holo_blue_light&quot; android:text&#x3D;&quot;packed&quot; app:layout_constraintLeft_toRightOf&#x3D;&quot;@+id&#x2F;bt_21&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; &#x2F;&gt; Packed Chain with Bias 12345678910111213141516171819202122232425262728&lt;Button android:id=&quot;@+id/bt_30&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:text=&quot;packedBias&quot; app:layout_constraintHorizontal_bias=&quot;0.2&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_31&quot; /&gt;&lt;Button android:id=&quot;@+id/bt_31&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:text=&quot;packedBias&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_30&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_32&quot; /&gt;&lt;Button android:id=&quot;@+id/bt_32&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:text=&quot;packedBias&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_31&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; Barrier用于控制 Barrier 相对于给定的 View 的位置， app:barrierDirection=”right”,表示barrier在constraint_referenced_ids给定ID的右侧,constraint_referenced_ids的id就是左侧的这些控件 输入信息挺有用的 https://mp.weixin.qq.com/s/QIuww9b0TsNjajEUS8c2fg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;android.support.constraint.ConstraintLayout android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_margin&#x3D;&quot;@dimen&#x2F;dimen_11&quot;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tv_order_num&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;订单编号：10002220000001234&quot; android:textColor&#x3D;&quot;#ff999999&quot; android:textSize&#x3D;&quot;19sp&quot; app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot; &#x2F;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tv_order_pro&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_marginTop&#x3D;&quot;@dimen&#x2F;dimen_11&quot; android:text&#x3D;&quot;订购产品：爱达康高血压监护服务&quot; android:textColor&#x3D;&quot;#ff666666&quot; android:textSize&#x3D;&quot;21sp&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;tv_order_num&quot; &#x2F;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tv_service_team&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;服务团队：爱达康远程监护团队&quot; android:textColor&#x3D;&quot;#ff666666&quot; android:textSize&#x3D;&quot;21sp&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;tv_order_pro&quot; &#x2F;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tv_period_valid&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;有效期：2019-03-01至2019-12-31&quot; android:textColor&#x3D;&quot;#ff999999&quot; android:textSize&#x3D;&quot;19sp&quot; app:layout_constraintStart_toEndOf&#x3D;&quot;@+id&#x2F;barrier&quot; &#x2F;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tv_order_time&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_marginTop&#x3D;&quot;@dimen&#x2F;dimen_11&quot; android:text&#x3D;&quot;订购时间：2019-03-11 12:00:00&quot; android:textColor&#x3D;&quot;#ff666666&quot; android:textSize&#x3D;&quot;21sp&quot; app:layout_constraintStart_toEndOf&#x3D;&quot;@+id&#x2F;barrier&quot; app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;tv_period_valid&quot; &#x2F;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tv_order_count&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;订购数量：500次&quot; android:textColor&#x3D;&quot;#ff666666&quot; android:textSize&#x3D;&quot;21sp&quot; app:layout_constraintStart_toEndOf&#x3D;&quot;@+id&#x2F;barrier&quot; app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;tv_order_time&quot; &#x2F;&gt; &lt;android.support.constraint.Barrier android:id&#x3D;&quot;@+id&#x2F;barrier&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; app:barrierDirection&#x3D;&quot;right&quot; app:constraint_referenced_ids&#x3D;&quot;tv_order_num,tv_order_pro,tv_service_team&quot; &#x2F;&gt; &lt;&#x2F;android.support.constraint.ConstraintLayout&gt; Dimensions constraintsYou can define minimum and maximum sizes for the ConstraintLayout itself: android:minWidth set the minimum width for the layout android:minHeight set the minimum height for the layout 可以设置百分比 Practice需求是美女跟在文字后面，如果文字太长就用省略号 主要着两个属性 123app:layout_constrainedWidth=&quot;true&quot; // 如果不用这个约束，文字太长,会把直接在Learn more后面app:layout_constraintHorizontal_bias=&quot;0&quot; // 去掉左边的约束app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; // 让文字和美女在一起 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;ImageView android:id=&quot;@+id/iv_duitnow&quot; android:layout_width=&quot;36dp&quot; android:layout_height=&quot;36dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;TextView android:id=&quot;@+id/tv_duit_text&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;9dp&quot; android:textColor=&quot;#282828&quot; android:textSize=&quot;22sp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@id/iv_duitnow&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; android:text=&quot;Reload via Transfer:&quot; /&gt;&lt;TextView android:id=&quot;@+id/tv_duitnow_id&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;4dp&quot; android:ellipsize=&quot;end&quot; android:lines=&quot;1&quot; android:textColor=&quot;#0064FF&quot; android:textSize=&quot;14sp&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/img_copy&quot; app:layout_constraintHorizontal_bias=&quot;0&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintStart_toStartOf=&quot;@+id/tv_duit_text&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv_duit_text&quot; android:text=&quot;0124455660124455660124455666&quot; /&gt;&lt;ImageView android:id=&quot;@+id/img_copy&quot; android:layout_width=&quot;30dp&quot; android:layout_height=&quot;30dp&quot; android:scaleType=&quot;fitXY&quot; android:src=&quot;@drawable/meitu111e33&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/tv_duitnow_id&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/bt_learn_more&quot; app:layout_constraintStart_toEndOf=&quot;@+id/tv_duitnow_id&quot; app:layout_constraintTop_toTopOf=&quot;@+id/tv_duitnow_id&quot; /&gt;&lt;TextView android:id=&quot;@+id/bt_learn_more&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;15dp&quot; android:paddingTop=&quot;7dp&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:paddingRight=&quot;15dp&quot; android:paddingBottom=&quot;7dp&quot; android:textSize=&quot;10sp&quot; android:textStyle=&quot;normal&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/tv_duitnow_id&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/tv_duitnow_id&quot; android:text=&quot;Learn_More&quot; /&gt; https://blog.yorek.xyz/android/other/constraintlayout/#63-wrap_content-11 https://juejin.cn/post/6844903733948579847 https://jishuin.proginn.com/p/763bfbd5c73f","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://noteforme.github.io/tags/ConstraintLayout/"}]},{"title":"tool_pc_phone","slug":"tool-miflash","date":"2017-10-13T15:22:47.000Z","updated":"2021-08-19T11:11:44.317Z","comments":true,"path":"2017/10/13/tool-miflash/","link":"","permalink":"https://noteforme.github.io/2017/10/13/tool-miflash/","excerpt":"","text":"mi救砖前两天不小心把 新买的小米４给刷成黑砖了，我的操作是双击磁盘模式工具目录里的“清除fastboot进磁盘操作.bat”进入磁盘模式 使用这种方式把fastboot清掉了，然后手机都没法进入fastboot模式，插入电脑无法识别 我的方法进入方法三：通过线刷升级 点以下链接 http://www.miui.com/shuaji-393.html,下载通用刷机工具，安装后(需要 一段时间)，插上已成砖手机，windows设备管理器 端口我的显示9006 下载fastboot完整包 也是在上面链接路径下面 下载 miflash 我下载的是15版的miflash 新版 .bat文件不同会报各种错误 链接: https://pan.baidu.com/s/1pKPLJdD 密码: 94mi 救活 选择下载的fastboot包，刷机，然后是等待 看到一篇文章高通下教程 http://www.miui.com/thread-2689657-1-1.html Thinkpad更换固态硬盘 视频教程: https://v.qq.com/x/page/k0157zxhob1.html https://www.youtube.com/watch?v=Qgh5v6ccMOg http://v.youku.com/v_show/id_XMzE3NTU5MjA4OA==.html?spm=a2hzp.8244740.0.0 文字教程: http://www.xinxunwei.com/bjbcj/2016/0119/5261.html Ubuntu系统安装: https://blog.csdn.net/dkh_321/article/details/79304377","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"StateBar","slug":"StateBar","date":"2017-10-12T08:35:05.000Z","updated":"2022-05-06T11:24:51.263Z","comments":true,"path":"2017/10/12/StateBar/","link":"","permalink":"https://noteforme.github.io/2017/10/12/StateBar/","excerpt":"","text":"https://developer.android.com/training/appbar/setting-up.html https://github.com/xiewenfeng/statusbartextcolorchange https://mp.weixin.qq.com/s/NvmOlJzEkdrJREueIFd_DA 目前只要考虑 5.0以上系统就可以了,有些flag虽然被标记为Deprecated,但是系统也还在用，所以有必要研究。 statebarhttps://www.jianshu.com/p/f84f7e07e0d6 https://blog.csdn.net/u011200604/article/details/107959340 实现沉浸式状态栏主要跟以下四个Api相关: View#setSystemUiVisibility() Window#addFlags() View#setFitsSystemWindows Window#setStatusBarColor() View#setSystemUiVisibility()及其各种Flags首先setSystemUiVisibility()这个方法就是设置状态栏或者导航栏的各种属性的，哪都有些可以设置的属性呢？ View.SYSTEM_UI_FLAG_FULLSCREEN 视图全屏并隐藏状态栏，当用户交互时（如下滑状态栏）会恢复隐藏的状态栏（例子：电子书阅读）缺点：进入Activity会产生一个从非全屏到全屏的闪动效果 View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY 粘性沉浸模式，需要和SYSTEM_UI_FLAG_FULLSCREEN或者SYSTEM_UI_FLAG_HIDE_NAVIGATION联用，当使用View.setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN|View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY)联用时视图全屏，当用户产生交互时（如下滑状态栏）不会恢复状态栏，只会以半透明的方式覆盖在视图上面并在一定时间内自动消失 1getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN|View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) View.SYSTEM_UI_FLAG_IMMERSIVE： 沉浸模式，只能和View.SYSTEM_UI_FLAG_FULLSCREEN联用，效果和View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY一样，目前已被后者替代。 View.SYSTEM_UI_FLAG_LOW_PROFILE: 低配模式，会隐藏一些不重要的状态栏和导航栏的图标,(用模拟器跑，只剩下电池了) View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN： 视图全屏且不会产生闪动，如果没有toolbar,contentview会占住statebar的位置，状态栏会覆盖在contentview上面. 1234567891011var isWhite = falsefun change_statebar_element_color(view: View) &#123; if (isWhite) &#123; window.decorView.systemUiVisibility = SYSTEM_UI_FLAG_LAYOUT_STABLE //statebar 元素显示白色 isWhite = false &#125; else &#123; window.decorView.systemUiVisibility = SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or SYSTEM_UI_FLAG_LIGHT_STATUS_BAR //显示黑色 isWhite = true &#125;&#125; View.SYSTEM_UI_FLAG_LAYOUT_STABLE： 使视图稳定，当使用fitSystemWindows（）（下面会介绍这个方法）需要视图稳定，一般和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN联用,我使用这个属性后，能使statebar的电池条变成白色。 View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR: Android6.0系统以上增加的属性，设置了这个属性，状态栏会以与状态栏背景颜色兼容的模式绘制。什么意思呢？就是说如果当前的状态栏颜色是浅色，那么就有可能造成状态栏上的图标看不清了，但是如果你设置这个属性以后，状态栏的图标就会以深色绘制，这样就没有什么UI上的问题了。 Window#addFlags()这种方式感觉是setSystemUiVisibility之前的用法了。 WindowManager.LayoutParams相关属性： FLAG_TRANSLUCENT_STATUS: Android4.4系统增加的属性，它会使状态栏透明,并且自动执行View.SYSTEM_UI_FLAG_LAYOUT_STABLE和View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN FLAG_FULLSCREEN: 视图全屏并隐藏状态栏，效果相当于View.SYSTEM_UI_FLAG_FULLSCREEN+View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY，并且视图稳定（不会因为系统控件的变化（如输入法），而重新布局） FLAG_FORCE_NOT_FULLSCREEN： 重写了FLAG_FULLSCREEN并强制显示状态栏（没有啥用） FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS： Android5.0系统以上支持，如果设置了该属性，系统栏（状态栏和导航栏）将以透明背景绘制，并且该窗口中的相应区域将填充setStatusBar（）和setNavigationBarColor（）中设置的颜色。 现在项目就是用这种方式。 感觉这也是设置stateBar颜色一种主要的方式。 另一种就是自己设置statebar颜色。 几种全屏模式Lean back倾斜模式 When users want to bring back the system bars, they simply tap the screen anywhere. 12window.decorView.systemUiVisibility = SYSTEM_UI_FLAG_FULLSCREEN or SYSTEM_UI_FLAG_HIDE_NAVIGATION 轻触屏幕 会显示 底部导航如返回按钮 Immersive沉浸模式：从边缘滑动，显示系统Bar,也可以通过回调显示系统控件 12window.decorView.systemUiVisibility = SYSTEM_UI_FLAG_FULLSCREEN or SYSTEM_UI_FLAG_HIDE_NAVIGATION or SYSTEM_UI_FLAG_IMMERSIVE Sticky immersive从边缘滑动，显示系统Bar,statebar.又恢复了。 12window.decorView.systemUiVisibility = SYSTEM_UI_FLAG_FULLSCREEN or SYSTEM_UI_FLAG_HIDE_NAVIGATION or SYSTEM_UI_FLAG_IMMERSIVE_STICKY https://developer.android.com/training/system-ui/immersive android 11 systemUiVisibility过期需要更新 Statabar Color Application AppTheme statusBarColor 1234567&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:statusBarColor&quot;&gt; @android:color/white&lt;/item&gt;&lt;/style&gt; Activity设置 123456789if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.R) &#123; window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR&#125; else &#123; window.insetsController?.setSystemBarsAppearance( WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS, WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS )&#125; Statabar element Color两种方式 systemUiVisibility123window.decorView.systemUiVisibility = SYSTEM_UI_FLAG_LAYOUT_STABLE //statebar 元素显示白色window.decorView.systemUiVisibility = SYSTEM_UI_FLAG_LIGHT_STATUS_BAR //显示黑色 主题配置&gt;231&lt;item name=&quot;android:windowLightStatusBar&quot;&gt;false&lt;/item&gt; false : 白色 true : 黑色 https://developer.android.com/training/system-ui https://blog.csdn.net/shanshui911587154/article/details/86623646 WindowInsetsControllerAndroid11 使用 statabar text color123456789101112131415@RequiresApi(Build.VERSION_CODES.R)fun AppearanceLightStatusBars(view: android.view.View) &#123; if (isWhite) &#123; controller?.setSystemBarsAppearance( WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS, WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS ) &#125; else &#123; controller?.setSystemBarsAppearance( 0, WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS ) &#125; isWhite = !isWhite&#125; statebar hide12345678910var isHide = true@RequiresApi(Build.VERSION_CODES.R)fun hide_state_bar(view: android.view.View) &#123; if (isHide) &#123; controller?.hide(WindowInsetsCompat.Type.statusBars()) &#125; else &#123; controller?.show(WindowInsetsCompat.Type.statusBars()) &#125; isHide = !isHide&#125; https://blog.csdn.net/jingzz1/article/details/111468726 https://juejin.cn/post/6940048488071856164 https://blog.csdn.net/qq_39038178/article/details/119657376 https://segmentfault.com/a/1190000022129198 ToolBar颜色设置 AppTheme下的设置 12345678&lt;application android:name=&quot;.application.NBBApplication&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/icon&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; Toolbar颜色:&lt;item name=&quot;colorPrimary&quot;&gt;@color/toolbar_color&lt;/item&gt; 状态栏设置 :&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 在 API 19 及更高版本上，Toolbar 内容延伸至状态栏上去了, statebar把toolbar给覆盖了 要解决这个问题就需要下面的属性 android:fitsSystemWindows =”true” 这个属性能保持与statebar一定 的padding,能解决上面windowTranslucentStatus的重叠问题 参考: 亦枫 去掉阴影线 toolbar底部会有一条阴影线,通过AppBarLayout标签下的app:elevation=”0dp”去掉 自定义返回键 mToolbar.setNavigationIcon(R.mipmap.ic_back);//自定义返回键 或者这样设置 app:navigationIcon=&quot;@mipmap/ic_back&quot; toolbar.xml解读123456789101112131415161718192021222324252627&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.AppBarLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;wrap_content&quot; app:elevation&#x3D;&quot;0dp&quot;&gt; &#x2F;&#x2F;设置仰角,0dp可以去掉底部的线 &lt;android.support.v7.widget.Toolbar android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;?attr&#x2F;actionBarSize&quot; android:minHeight&#x3D;&quot;?actionBarSize&quot; android:theme&#x3D;&quot;@style&#x2F;ThemeOverlay.AppCompat.ActionBar&quot; &#x2F;&#x2F;toolbar主题 app:popupTheme&#x3D;&quot;@style&#x2F;ThemeOverlay.AppCompat.Light&quot;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;tb_title&quot; style&#x3D;&quot;@style&#x2F;TextAppearance.AppCompat.Widget.ActionBar.Title&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center&quot; android:text&#x3D;&quot;标题&quot; android:textColor&#x3D;&quot;#333333&quot; android:textSize&#x3D;&quot;18sp&quot; &#x2F;&gt; &lt;&#x2F;android.support.v7.widget.Toolbar&gt;&lt;&#x2F;android.support.design.widget.AppBarLayout&gt; 还有一种方式是在application设置，这样就不用集成baseActivity http://blog.csdn.net/a553181867/article/details/51336899 menu设置AppBarLayout下的 app:theme=&quot;@style/toolbar_menu&quot;用于设置menu menu字体颜色需要设置 app:theme ,用 android:theme不起作用. &lt;item name=&quot;android:actionMenuTextColor&quot;&gt;@color/text_my_black&lt;/item&gt; menu事件@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_login, menu); menu.findItem(R.id.item_right_text).setTitle(&quot;注册&quot;); //设置文字 return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; break; &#125; return super.onOptionsItemSelected(item); &#125; https://blog.csdn.net/guyuealian/article/details/51721167 使用toolbar过程中遇到了一些问题 问题 1 弹出键盘后 editext不见了，应该是toolbar被拉伸了 暂时解决方式: 12345&lt;activity android:name=&quot;.activity.WebActivity&quot; android:hardwareAccelerated=&quot;true&quot; android:screenOrientation=&quot;portrait&quot; android:windowSoftInputMode=&quot;adjustPan&quot; /&gt; https://github.com/CoolThink/StatusBarAdapt/issues/2 fragment使用toolbarhttp://wuxiaolong.me/2015/12/21/fragmentToolbar/ 三条线的颜色修改1234&lt;style name=&quot;DrawerArrowStyle&quot; parent=&quot;Base.Widget.AppCompat.DrawerArrowToggle&quot;&gt; &lt;item name=&quot;spinBars&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;color&quot;&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; 具体可以查看mineutil:PopupWindowActivity 溢出菜单三个点离右边的距离 AppTheme中设置 1234567&lt;item name=&quot;android:actionOverflowButtonStyle&quot;&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;style name=&quot;OverflowMenuStyle&quot; parent=&quot;Widget.AppCompat.Light.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt; &lt;item name=&quot;android:src&quot;&gt;@mipmap/doc_ic_new_patient&lt;/item&gt; &lt;item name=&quot;android:paddingRight&quot;&gt;15dp&lt;/item&gt; &lt;/style&gt; 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 | 如果相对应位都是 0，则结果为 0，否则为 1 （A | B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 https://noteforme.github.io/2018/01/07/Operators/ Support display cutouts刘海屏 https://developer.android.com/guide/topics/display-cutout https://blog.csdn.net/m0_64314432/article/details/121437314 https://developer.android.com/guide/topics/display-cutout?authuser=1 123456789101112131415161718192021222324252627@TargetApi(28)fun getNotchParams() &#123; val decorView: View = window.decorView if (decorView != null) &#123; decorView.post(Runnable &#123; val windowInsets: WindowInsets = decorView.rootWindowInsets if (windowInsets != null) &#123; // 当全屏顶部显示黑边时，getDisplayCutout()返回为null val displayCutout = windowInsets.displayCutout Log.e(&quot;TAG&quot;, &quot;安全区域距离屏幕左边的距离 SafeInsetLeft:&quot; + displayCutout!!.safeInsetLeft) Log.e(&quot;TAG&quot;, &quot;安全区域距离屏幕右部的距离 SafeInsetRight:&quot; + displayCutout.safeInsetRight) Log.e(&quot;TAG&quot;, &quot;安全区域距离屏幕顶部的距离 SafeInsetTop:&quot; + displayCutout.safeInsetTop) Log.e(&quot;TAG&quot;, &quot;安全区域距离屏幕底部的距离 SafeInsetBottom:&quot; + displayCutout.safeInsetBottom) // 获得刘海区域 val rects: List&lt;Rect&gt; = displayCutout.boundingRects if (rects == null || rects.isEmpty()) &#123; Log.e(&quot;TAG&quot;, &quot;不是刘海屏&quot;) &#125; else &#123; Log.e(&quot;TAG&quot;, &quot;刘海屏数量:&quot; + rects.size) for (rect in rects) &#123; Log.e(&quot;TAG&quot;, &quot;刘海屏区域：$rect&quot;) &#125; &#125; &#125; &#125;) &#125;&#125; 骨架屏加载效果https://juejin.cn/post/6963143268448239653 https://github.com/ethanhua/Skeleton https://www.jianshu.com/p/ded3c7e8adfe DialogFragment 修改底部导航了 https://www.jianshu.com/p/e28a54b44bdc","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"DesignPattern-Builder","slug":"DesignPattern_Builder","date":"2017-10-07T09:45:46.000Z","updated":"2024-10-01T11:59:22.050Z","comments":true,"path":"2017/10/07/DesignPattern_Builder/","link":"","permalink":"https://noteforme.github.io/2017/10/07/DesignPattern_Builder/","excerpt":"","text":"Builder模式不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个builder对象，然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数 既能保证像重叠构造器模式那样的安全性，也能保证像JavaBeans模式那么好的可读性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class NutritionFacts_03_Builder &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder&#123; //Required parameters private final int servingSize; private final int servings; //Optional parameters = initialized to default values private int calories = 0; private int fat = 0; private int carbohydrate = 0; private int sodium = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val)&#123; calories = val; return this; &#125; public Builder fat(int val)&#123; this.fat = fat; return this; &#125; public Builder carbohydrate(int val)&#123; carbohydrate = val; return this; &#125; public Builder sodium(int val)&#123; sodium = val; return this; &#125; public NutritionFacts_03_Builder build()&#123; return new NutritionFacts_03_Builder(this); &#125; &#125; private NutritionFacts_03_Builder(Builder builder) &#123; this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; this.carbohydrate = builder.carbohydrate; &#125; public static void main(String[] args) &#123; NutritionFacts_03_Builder cocaCola = new NutritionFacts_03_Builder.Builder(240,9) .calories(100).sodium(35).carbohydrate(27).build(); &#125;&#125; 返回的this时怎么替代对象的 对象创建更加灵活当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；当 isRef 为 false 的时候，arg、type 都需要设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ConstructorArg &#123; private boolean isRef; private Class type; private Object arg; private ConstructorArg(Builder builder) &#123; this.isRef = isRef; this.type = type; this.arg = arg; &#125; public static class Builder &#123; private static boolean isRef; private static Class type; private static Object arg; public Builder(boolean isRef) &#123; this.isRef = isRef; &#125; public Builder setType(Class type) &#123; this.type = type; return this; &#125; public Builder setArg(Object arg) &#123; this.arg = arg; return this; &#125; public ConstructorArg build() &#123; if (isRef) &#123; if (!(arg instanceof String)) &#123; //这里refBeanId是ConstructorArg吗？只是判断了下arg类型是否为String throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，arg 表示 String 类型refBeanId&quot;); &#125; if (type != null) &#123; throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，type 不需要设置&quot;); &#125; &#125; if (!isRef) &#123; if (arg == null || type == null) &#123; throw new IllegalArgumentException(&quot;当 isRef 为 false 的时候，arg、type 都需要设置&quot;); &#125; &#125; return new ConstructorArg(this); &#125; &#125;&#125;","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"}],"tags":[]},{"title":"Fragment","slug":"Fragment","date":"2017-10-05T11:54:50.000Z","updated":"2023-09-04T00:33:26.027Z","comments":true,"path":"2017/10/05/Fragment/","link":"","permalink":"https://noteforme.github.io/2017/10/05/Fragment/","excerpt":"","text":"https://juejin.cn/post/6970998913754988552#heading-16 https://developer.android.com/reference/android/app/Fragment.html https://developer.android.com/guide/components/fragments.html https://www.51cto.com/article/672135.html https://juejin.cn/post/7021398731056480269 12345678static final int INVALID_STATE &#x3D; -1; &#x2F;&#x2F; 为空时无效static final int INITIALIZING &#x3D; 0; &#x2F;&#x2F; 未创建static final int CREATED &#x3D; 1; &#x2F;&#x2F; 已创建，位于后台static final int ACTIVITY_CREATED &#x3D; 2; &#x2F;&#x2F; Activity已经创建，Fragment位于后台static final int STOPPED &#x3D; 3; &#x2F;&#x2F; 创建完成，没有开始static final int STARTED &#x3D; 4; &#x2F;&#x2F; 开始运行，但是位于后台static final int RESUMED &#x3D; 5; &#x2F;&#x2F; 显示到前台 作者：小松漫步链接：https://juejin.cn/post/7021398731056480269 下面的lifecycle也可以看到,fragment生命周期的状态转移。 Lifecyclehttps://developer.android.com/guide/fragments/lifecycle onViewCreated(View view, Bundle savedInstanceState) Called immediately after onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle) has returned, but before any saved state has been restored in to the view. 状态转移Fragment 123456789static final int INITIALIZING = -1; // Not yet attached.static final int ATTACHED = 0; // Attached to the host.static final int CREATED = 1; // Created.static final int VIEW_CREATED = 2; // View Created.static final int AWAITING_EXIT_EFFECTS = 3; // Downward state, awaiting exit effectsstatic final int ACTIVITY_CREATED = 4; // Fully created, not started.static final int STARTED = 5; // Created and started, not resumed.static final int AWAITING_ENTER_EFFECTS = 6; // Upward state, awaiting enter effectsstatic final int RESUMED = 7; // Created started and resumed. 这个图和现在fragment状态有点不同，现在新增了一些状态，有必要的话，自己研究绘制一张。 commit1234commit();commitAllowingStateLoss();commitNow();commitNowAllowingStateLoss(); commitAllowingStateLoss VS commit()可以看到 allowStateLoss 如果是false，mHost,mDestroyed=true,就会crash了,否则只是return了,所以从这里看，他们区别不大。 123456789101112131415161718192021222324void enqueueAction(@NonNull OpGenerator action, boolean allowStateLoss) &#123; if (!allowStateLoss) &#123; if (mHost == null) &#123; if (mDestroyed) &#123; throw new IllegalStateException(&quot;FragmentManager has been destroyed&quot;); &#125; else &#123; throw new IllegalStateException(&quot;FragmentManager has not been attached to a &quot; + &quot;host.&quot;); &#125; &#125; checkStateLoss(); &#125; synchronized (mPendingActions) &#123; if (mHost == null) &#123; if (allowStateLoss) &#123; // This FragmentManager isn&#x27;t attached, so drop the entire transaction. return; &#125; throw new IllegalStateException(&quot;Activity has been destroyed&quot;); &#125; mPendingActions.add(action); scheduleCommit(); &#125;&#125; https://huxian99.github.io/2016/08/28/cj3qymo360000owxk9zp17alo/ commitNow VS commit()FragmentFragment tag1234567891011121314151617181920212223ArrayList&lt;Op&gt; mOps &#x3D; new ArrayList&lt;&gt;();void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) &#123; if (tag !&#x3D; null) &#123; if (fragment.mTag !&#x3D; null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException(&quot;Can&#39;t change tag of fragment &quot; + fragment + &quot;: was &quot; + fragment.mTag + &quot; now &quot; + tag); &#125; fragment.mTag &#x3D; tag; &#125; if (containerViewId !&#x3D; 0) &#123; if (fragment.mFragmentId !&#x3D; 0 &amp;&amp; fragment.mFragmentId !&#x3D; containerViewId) &#123; throw new IllegalStateException(&quot;Can&#39;t change container ID of fragment &quot; + fragment + &quot;: was &quot; + fragment.mFragmentId + &quot; now &quot; + containerViewId); &#125; fragment.mContainerId &#x3D; fragment.mFragmentId &#x3D; containerViewId; &#125; addOp(new Op(opcmd, fragment));&#125; 最终是把 fragment加入到 mOps 中 Fragment本质是View 「当然了Fragment本质是View但是又不仅限于此，」 在真实的项目中，界面往往很复杂，业务逻辑也很复杂，往往需要处理各种UI状态变化，比如：增加一组View，替换一组View，删除一组View，还需要和Activity协作。总之，如果让开发者自己去实现这一套逻辑，恐怕比使用Fragment要麻烦的多吧。尽管Fragment看起来蛮复杂的，但是还是远比我们自己去实现相同功能简单的多。 3.1.2 Fragment本质不仅限于View Fragment作为一个View可以被添加到Activity的布局中去。但是他更强大，还有以下几个特性： 处理生命周期，比Activity生命周期还要复杂 通过FragmentTransaction操作多个Fragment 通过FragmentManager维护一个回退栈，回退到上一个FragmentTransaction操作的界面 https://www.51cto.com/article/672135.html commit() vs commitAllowingStateLoss() commit()和commitAllowingStateLoss()在实现上唯一的不同就是当你调用commit()的时候, FragmentManger会检查mDestory, mHost 如果mHost ==null, 就抛出IllegalStateException. https://juejin.cn/post/7063377212736536607 FragmentPagerAdapter与FragmentStatePagerAdapter的区别 FragmentPagerAdapter适用于页面较少的情况，destroyItem方法中只是调用了fragmentransaction的detach方法 FragmentStatePagerAdapter适用于页面较多的情况，每次切换ViewPager的时候是回收内存的。destroyItem调用了fragmentransaction的remove方法 Fragment 各个方法细节 https://fuhongliang.gitbooks.io/android/content/di-shi-san-zhang-mian-shi-ti/mu-ke-wang-quan-mian-sheng-ji-android-mian-shi/fragmentmian-shi-ti.html onSaveInstanceState 方法啥时候调用。 但是为什么要这么做呢？ 原因是在Android 11版本后的activity会管理fragment，也就是说在activity 在执行onSaveInstanceState()的时候会保存fragment的状态，用于在恢复activity的时候使用。那么在保存fragment的状态后，就不能再去改变fragment的状态，也就是不允许提交事务，这样才能保障activity恢复的时候，可以显示原来fragment的状态。 https://blog.csdn.net/xx326664162/article/details/88379490 https://blog.csdn.net/qq_19560943/article/details/78112903 横竖屏切换 被系统回收（复现 进入开发者选项 -》不保留活动） https://www.jianshu.com/p/c12a98a36b2b BottomNavigationView error使用BottomNavigationView出现很严重的问题,很久才找到原因 12Caused by: android.view.InflateException: Binary XML file line #16: Binary XML file line #16: Error inflating class com.google.android.material.bottomnavigation.BottomNavigationView Caused by: android.view.InflateException: Binary XML file line #16: Error inflating class com.google.android.material.bottomnavigation.BottomNavigationView 因为 AndroidManifest.xml application下的android:theme=”@style/AppTheme”多出了,把下面的删除了就好了. 123&lt;item name&#x3D;&quot;android:textColorSecondary&quot;&gt;#ffffff&lt;&#x2F;item&gt;&lt;item name&#x3D;&quot;android:actionOverflowButtonStyle&quot;&gt;@style&#x2F;OverflowMenuStyle&lt;&#x2F;item&gt;&lt;item name&#x3D;&quot;android:listDivider&quot;&gt;@drawable&#x2F;divider&lt;&#x2F;item&gt; 重叠原因 旋转屏幕时候，创建的homeFragment会被回收,在销毁前，执行了onSaveInstanceState(Bundle outState)这个方法。这个方法会保存activity的一些信息，其中就包括添加过的fragment，Activity重建后，再次初始化homeFragment，接着显示，导致了重叠的问题。 代码验证1234567891011121314151617181920private fun initFragment() &#123; if (homeFragment &#x3D;&#x3D; null) &#123; homeFragment &#x3D; HomeFragment() addFragment(homeFragment!!) showFragment(homeFragment) &#125;&#125;override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) Timber.d(&quot;onCreate() $homeFragment&quot;) initFragment() Timber.d(&quot;initFragment() $homeFragment&quot;) &#125; override fun onDestroy() &#123; super.onDestroy() Timber.tag(TAG).d(&quot;onDestroy() homeFragment $homeFragment&quot;) &#125; 日志 12345678910111213141516D&#x2F;TabBottomActivity LaunchModeActivity: onCreate() taskId 641D&#x2F;TabBottomActivity LaunchModeActivity: onCreate() homeFragment nullD&#x2F;TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;1adc3fa&#125; (b0660244-39c4-4104-b558-f5384c7adb0d) id&#x3D;0x7f09010e&#125;D&#x2F;TabBottomActivity LaunchModeActivity: onStart()D&#x2F;TabBottomActivity LaunchModeActivity: onResume()D&#x2F;TabBottomActivity LaunchModeActivity: onPause()D&#x2F;TabBottomActivity LaunchModeActivity: onSaveInstanceState()D&#x2F;TabBottomActivity LaunchModeActivity: onStop()D&#x2F;TabBottomActivity LaunchModeActivity: onDestroy()D&#x2F;TabBottomActivity LaunchModeActivity: onDestroy() homeFragment HomeFragment&#123;1adc3fa&#125; (d84f5956-fa2c-4cd2-8397-0904040d2a6f)&#125;D&#x2F;TabBottomActivity LaunchModeActivity: onCreate() taskId 641D&#x2F;TabBottomActivity LaunchModeActivity: onCreate() homeFragment nullD&#x2F;TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;ac076db&#125; (f8ee348b-6ff7-4b1e-ba27-6e47e848f623) id&#x3D;0x7f09010e&#125;D&#x2F;TabBottomActivity LaunchModeActivity: onStart()D&#x2F;TabBottomActivity LaunchModeActivity: onRestoreInstanceState()D&#x2F;TabBottomActivity LaunchModeActivity: onResume() 从 initFragment（） 1adc3fa , ac076db 可以看到，HomeFrgment重新创建了. 处理方法 onSaveInstanceState 不保存信息 123 override fun onSaveInstanceState(outState: Bundle) &#123;// super.onSaveInstanceState(outState) &#125; 这种方式的弊端就是，切换后总是回到首页. onSaveInstanceState() 保存Fragment 123456789101112131415161718192021222324252627282930override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) if (savedInstanceState !&#x3D; null) &#123; &#x2F;*获取保存的fragment 没有的话返回null*&#x2F; homeFragment &#x3D; supportFragmentManager.getFragment(savedInstanceState, HOME_FRAGMENT_KEY) as HomeFragment? healthFragment &#x3D; supportFragmentManager.getFragment(savedInstanceState, DASHBOARD_FRAGMENT_KEY) as HealthFragment? personFragment &#x3D; supportFragmentManager.getFragment(savedInstanceState, NOTICE_FRAGMENT_KEY) as PersonFragment? addToList(homeFragment) addToList(healthFragment) addToList(personFragment) &#125; else &#123; initFragment() &#125; &#125; override fun onSaveInstanceState(outState: Bundle) &#123; super.onSaveInstanceState(outState) Timber.d(&quot;MainActivity onSaveInstanceState&quot;) &#x2F;*fragment不为空时 保存*&#x2F;if (homeFragment !&#x3D; null) &#123; supportFragmentManager.putFragment(outState!!, HOME_FRAGMENT_KEY, homeFragment!!) &#125; if (healthFragment !&#x3D; null) &#123; supportFragmentManager.putFragment(outState!!, DASHBOARD_FRAGMENT_KEY, healthFragment!!) &#125; if (personFragment !&#x3D; null) &#123; supportFragmentManager.putFragment(outState!!, NOTICE_FRAGMENT_KEY, personFragment!!) &#125; &#125; 这种方式，可以解决问题，但是打印的日志HomeFragment还是不一样，是什么情况？ 12345678910111213141516171819202122232425D&#x2F;TabBottomActivity LaunchModeActivity: onCreate() taskId 4437 D&#x2F;TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;dc2914d&#125; (5f30b0dd-a8d2-4b3c-a27f-1d160a9da58e) id&#x3D;0x7f09010e&#125; D&#x2F;TabBottomActivity LaunchModeActivity: onStart() D&#x2F;TabBottomActivity LaunchModeActivity: onResume() D&#x2F;TabBottomActivity$onCreate: navigation_health D&#x2F;TabBottomActivity LaunchModeActivity: onPause() D&#x2F;TabBottomActivity LaunchModeActivity: onSaveInstanceState() D&#x2F;TabBottomActivity: MainActivity onSaveInstanceState D&#x2F;TabBottomActivity LaunchModeActivity: onStop() D&#x2F;TabBottomActivity LaunchModeActivity: onDestroy() D&#x2F;TabBottomActivity LaunchModeActivity: onDestroy() homeFragment HomeFragment&#123;dc2914d&#125; (ab276ea2-5fa2-4d79-b6a6-af7143b114e8)&#125; D&#x2F;TabBottomActivity LaunchModeActivity: onCreate() taskId 4437 D&#x2F;TabBottomActivity: fragmentList数量1 D&#x2F;TabBottomActivity: fragmentList数量2 D&#x2F;TabBottomActivity: fragmentList数量2 D&#x2F;TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;9139494&#125; (5f30b0dd-a8d2-4b3c-a27f-1d160a9da58e) id&#x3D;0x7f09010e&#125; D&#x2F;TabBottomActivity LaunchModeActivity: onStart() D&#x2F;TabBottomActivity LaunchModeActivity: onRestoreInstanceState() D&#x2F;TabBottomActivity LaunchModeActivity: onResume() D&#x2F;TabBottomActivity LaunchModeActivity: onPause() D&#x2F;TabBottomActivity LaunchModeActivity: onSaveInstanceState() D&#x2F;TabBottomActivity: MainActivity onSaveInstanceState D&#x2F;TabBottomActivity LaunchModeActivity: onStop() D&#x2F;TabBottomActivity LaunchModeActivity: onDestroy() D&#x2F;TabBottomActivity LaunchModeActivity: onDestroy() homeFragment HomeFragment&#123;9139494&#125; (cadcb63f-8516-4d44-8f3c-75b0c8e9f27f)&#125; https://blog.csdn.net/yuzhiqiang_1993/article/details/75014591 https://www.jianshu.com/p/78ec81b42f92 下面这种方式没理解https://www.jianshu.com/p/d9143a92ad94 https://www.jianshu.com/p/c12a98a36b2b 横竖屏切换，Fragment实例复用setRetainInstance=true retainInstance = true已经过期，改用ViewModel LifeFragment 1234override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) retainInstance &#x3D; true&#125; 12345678private fun initFragment() &#123; var lifeFragment &#x3D; supportFragmentManager.findFragmentById(R.id.fl_content) if (lifeFragment &#x3D;&#x3D; null) &#123; lifeFragment &#x3D; LifeFragment() supportFragmentManager.beginTransaction().add(R.id.fl_content, lifeFragment).commit() &#125; Timber.d(&quot;LifeFragment $lifeFragment&quot;)&#125; 切换屏幕后 LifeFragment,ondestroy()没志行,后面的Oncreate()也没有创建. 12345678910111213141516171819D&#x2F;LifeActivity LaunchModeActivity: onCreate() taskId 599D&#x2F;LifeActivity: LifeFragment LifeFragment&#123;6a86311&#125; (70133a14-6dcf-4f8b-beee-6cd31d6623ba) id&#x3D;0x7f090109&#125;D&#x2F;LifeFragment LaunchModeFragment: onAttach(Context context)D&#x2F;LifeFragment LaunchModeFragment: onCreate() savedInstanceState nullD&#x2F;LifeFragment LaunchModeFragment: onCreateView()D&#x2F;LifeFragment LaunchModeFragment: onActivityCreated()D&#x2F;LifeFragment LaunchModeFragment: onStart()D&#x2F;LifeFragment LaunchModeFragment: onResume()D&#x2F;LifeFragment LaunchModeFragment: onPause() D&#x2F;LifeFragment LaunchModeFragment: onStop()D&#x2F;LifeFragment LaunchModeFragment: onDestroyView()D&#x2F;LifeFragment LaunchModeFragment: onDetach()D&#x2F;LifeFragment LaunchModeFragment: onAttach(Context context)D&#x2F;LifeActivity LaunchModeActivity: onCreate() taskId 599D&#x2F;LifeActivity: LifeFragment LifeFragment&#123;6a86311&#125; (70133a14-6dcf-4f8b-beee-6cd31d6623ba) id&#x3D;0x7f090109&#125;D&#x2F;LifeFragment LaunchModeFragment: onCreateView()D&#x2F;LifeFragment LaunchModeFragment: onActivityCreated()D&#x2F;LifeFragment LaunchModeFragment: onStart()D&#x2F;LifeFragment LaunchModeFragment: onResume() Fragment之间传递数据 Fragment.setArguments()方法传递bundle findFragmentById()找到tag,然后直接操作Framgent 123456789101112131415161718public void onArticleSelected(int position) &#123; ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment); if (articleFrag != null) &#123; articleFrag.updateArticleView(position); &#125; else &#123; ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); transaction.commit(); &#125; &#125; 接口回调 ViewModel Livedata 给已经创建frament传递数据也是直接 Fragment.refresh(),第一行代码第三版P227，也是这样做的。 fragment回退栈tx.addToBackStack(null); 添加回退功能，类似Activity压栈的过程 https://www.jianshu.com/p/fe16553ca2ca https://blog.csdn.net/zhiyuan0932/article/details/52593039 Fragment控制父Fragment展示 Communication between nested fragments in Android https://blog.csdn.net/u011481547/article/details/71552720 Fragmet全局流程图 https://kotlintc.com/articles/5693 https://mp.weixin.qq.com/s/MOWdbI5IREjQP1Px-WJY1Q https://juejin.im/post/5bcd58b6e51d45404c71d23f https://mp.weixin.qq.com/s/_hdbMOA2TVvX4jFnMu15bg","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"https://noteforme.github.io/tags/Fragment/"}]},{"title":"onActivityResult","slug":"onActivityResult","date":"2017-09-26T06:01:53.000Z","updated":"2023-01-02T03:31:39.310Z","comments":true,"path":"2017/09/26/onActivityResult/","link":"","permalink":"https://noteforme.github.io/2017/09/26/onActivityResult/","excerpt":"","text":"传统方式单个页面跳转 主要有三个方法实现 startActivityForResult(@RequiresPermission Intent intent, int requestCode) setResult(int resultCode, Intent data) onActivityResult(int requestCode, int resultCode, Intent data) 下面是简单例子跳转MainActivity 目标SecondAcitivty 其中数据传递很简单,特别注意requestCode，resultCode不同的区分的区别 requestCode：假设 MainActivity button1 button2到SecondAcitivty,回来的在onActivityResult就需要 判断是哪个button点击的 resultCode: 假设MainActivity button1跳转到SecondAcitivty, button2到ThirdActiivty,回来后onActivityResult 就需要判断是哪个Activity回来的 参考:http://blog.csdn.net/jiangwei0910410003/article/details/16983049 注意:onActivityResult方法用的算比较普遍，刚好有个困惑，回传数据时intent.putExtra(&quot;text&quot;,122); 使用 String couponId = data.getStringExtra(&quot;text&quot;); 接收时为null,里面跳转和回传,存的值是int类型，获取string类型 Fragment接收onActivityResult必须使用Fragment 的 startActivityForResult()* 12345public static void startForResult(Activity activity, Fragment fragment) &#123; Intent intent = new Intent(activity, LoginActivity.class); fragment.startActivityForResult(intent, REQUEST_CODE_MINE_FRAGMENT); &#125; setResult(RESULT_OK, result); ,finish()后 onActivityResult 返回 resultCode Activity嵌套Fragment,他们各自发起startActivityForResult发起数据请求结论 Fragment发起 Fragment onActivityResult能接收。Activity onActivityResult能接收,但是requestCode不正确。 Activity发起 Fragment不能接收。 Activity onActivityResult能接收。 代码验证FirstResultActivity 12345678910111213141516171819val requestCode = 1000 override fun initView() &#123; super.initView() val intent = Intent(this, SecondResultActivity::class.java) findViewById&lt;View&gt;(R.id.bt_activity).setOnClickListener &#123; startActivityForResult(intent, requestCode) Timber.i(&quot;startActivityForResult $requestCode&quot;) &#125; &#125; override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) Timber.d(&quot;onActivityResult resultCode $requestCode resultCode $resultCode data $&#123;data?.getStringExtra(SecondResultActivity.sData)&#125;&quot;) &#125; private fun initFragment() &#123; val ftn = supportFragmentManager.beginTransaction().replace(R.id.fl_content, newInstance(&quot;数据&quot;)) ftn.commit() &#125; ResultOkFragment 123456789101112131415161718private val requestCode: Int = 2000override fun onActivityCreated(savedInstanceState: Bundle?) &#123; super.onActivityCreated(savedInstanceState) val intent = Intent(context, SecondResultActivity::class.java) bt_fragment.setOnClickListener &#123; startActivityForResult(intent, requestCode) Timber.d(&quot;startActivityForResult $requestCode&quot;) &#125;&#125;override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) Timber.d(&quot;onActivityResult resultCode $requestCode resultCode $resultCode data $&#123;data?.getStringExtra(SecondResultActivity.sData)&#125;&quot;)&#125; SecondResultActivity 12setResult(21, new Intent().putExtra(sData, &quot;我要回调啦!!!&quot;));finish(); Activity发起 12I&#x2F;FirstResultActivity$initView: startActivityForResult 1000D&#x2F;FirstResultActivity: onActivityResult resultCode 1000 resultCode 21 data 我要回调啦!!! Fragment发起 123D&#x2F;ResultOkFragment$onActivityCreated: startActivityForResult 2000D&#x2F;ResultOkFragment: onActivityResult resultCode 2000 resultCode 21 data 我要回调啦!!!D&#x2F;FirstResultActivity: onActivityResult resultCode 329680 resultCode 21 data 我要回调啦!!! 跳转多个页面 回来中间页面不能finish，也需要在onActivityResult方法内部 起到桥梁作用，回传数据 http://blog.csdn.net/lanyachuanshu/article/details/52172143https://developer.android.com/training/basics/intents/result.html http://45.77.222.97:3000/root/MineUtils/src/master/app/src/main/java/com/jonzhou/mineutils/result/FirstResultActivity.java https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826252&amp;idx=1&amp;sn=9ec620d630706c9f8de328e87bb8a0f1&amp;chksm=80b7b292b ActivityResultContract新方式https://mp.weixin.qq.com/s/o2_2DeAIcJGYSvm2WlhUxg 回调作用123456789101112131415161718class PlayStoreActivity : AppCompatActivity() &#123; binding.opengoogle.setOnClickListener &#123; intent.action = &quot;com.google.android.payments.standard.TOPUP_V2&quot; intent.putExtra(&quot;gspTopUpRequest&quot;, resources.getString(R.string.secret_key)) resultLauncher.launch(intent) &#125; var resultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt; when (result.resultCode) &#123; Activity.RESULT_OK -&gt; Toast.makeText(this, &quot;succuss&quot;, Toast.LENGTH_SHORT).show() 0 -&gt; Toast.makeText(this, &quot;user topup Abandon&quot;, Toast.LENGTH_SHORT).show() 1 -&gt; Toast.makeText(this, &quot;topup Failed&quot;, Toast.LENGTH_SHORT).show() &#125; &#125;&#125; 12345678910111213class GoogleTopUpActivity : BaseActivity() &#123; val biding by lazy &#123; ActivityGoogleTopUpBinding.inflate(layoutInflater) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(biding.root) biding.btPage.setOnClickListener &#123; onTopUpAbandon() &#125; biding.btGoReload.setOnClickListener &#123; startActivity(Intent(this, ReloadActivity::class.java)) finish() &#125; &#125; 12345678910class ReloadActivity : AppCompatActivity() &#123; val biding by lazy &#123; ActivityReloadBinding.inflate(layoutInflater) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(biding.root) biding.btReloadPage.setOnClickListener &#123; finish() &#125; &#125;&#125; PlayStoreActivity -&gt; GoogleTopUpActivity -&gt; ReloadActivity GoogleTopUpActivity的时候已经关闭了,ReloadActivity 关闭后回到PlayStoreActivity还是会有回调","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"ScreenCompatibility","slug":"ScreenCompatibility","date":"2017-09-23T13:41:20.000Z","updated":"2024-02-21T00:48:48.674Z","comments":true,"path":"2017/09/23/ScreenCompatibility/","link":"","permalink":"https://noteforme.github.io/2017/09/23/ScreenCompatibility/","excerpt":"","text":"Android屏幕的一些技巧 官网适配方案https://developer.android.com/training/basics/supporting-devices/index.htmlhttps://developer.android.com/training/multiscreen/screensizes.html 资源图片适配Provide alternative bitmaps To provide good graphical qualities on devices with different pixel densities, you should provide multiple versions of each bitmap in your app—one for each density bucket, at a corresponding resolution. Otherwise, Android must scale your bitmap so it occupies the same visible space on each screen, resulting in scaling artifacts such as blurring. Figure 2. Relative sizes for bitmaps at different density sizes There are several density buckets available for use in your apps. Table 1 describes the different configuration qualifiers available and what screen types they apply to. Table 1. Configuration qualifiers for different pixel densities. Density qualifier Description ldpi Resources for low-density (ldpi) screens (~120dpi). mdpi Resources for medium-density (mdpi) screens (~160dpi). (This is the baseline density.) hdpi Resources for high-density (hdpi) screens (~240dpi). xhdpi Resources for extra-high-density (xhdpi) screens (~320dpi). xxhdpi Resources for extra-extra-high-density (xxhdpi) screens (~480dpi). xxxhdpi Resources for extra-extra-extra-high-density (xxxhdpi) uses (~640dpi). nodpi Resources for all densities. These are density-independent resources. The system does not scale resources tagged with this qualifier, regardless of the current screen’s density. tvdpi Resources for screens somewhere between mdpi and hdpi; approximately 213dpi. This is not considered a “primary” density group. It is mostly intended for televisions and most apps shouldn’t need it—providing mdpi and hdpi resources is sufficient for most apps and the system will scale them as appropriate. If you find it necessary to provide tvdpi resources, you should size them at a factor of 1.33*mdpi. For example, a 100px x 100px image for mdpi screens should be 133px x 133px for tvdpi. To create alternative bitmap drawables for different densities, you should follow the 3:4:6:8:12:16 scaling ratio between the six primary densities. For example, if you have a bitmap drawable that’s 48x48 pixels for medium-density screens, all the different sizes should be: 36x36 (0.75x) for low-density (ldpi) 48x48 (1.0x baseline) for medium-density (mdpi) 72x72 (1.5x) for high-density (hdpi) 96x96 (2.0x) for extra-high-density (xhdpi) 144x144 (3.0x) for extra-extra-high-density (xxhdpi) 192x192 (4.0x) for extra-extra-extra-high-density (xxxhdpi) Then, place the generated image files in the appropriate subdirectory under res/ and the system will pick the correct one automatically based on the pixel density of the device your app is running on: 1234567891011res/ drawable-xxxhdpi/ awesome-image.png drawable-xxhdpi/ awesome-image.png drawable-xhdpi/ awesome-image.png drawable-hdpi/ awesome-image.png drawable-mdpi/ awesome-image.png Then, any time you reference @drawable/awesomeimage, the system selects the appropriate bitmap based on the screen’s dpi. If you don’t provide a density-specific resource for that density, the system picks the next best match and scales it to fit the screen. This means that if you generate a 200x200 image for xhdpi devices, you should generate the same resource in 150x150 for hdpi, 100x100 for mdpi, and 75x75 for ldpi devices.而UI问我们需要多少大小的图，如果效果图根据750*1334的话，可以告诉他，不过PS有个叫cutterman的工具可以自动生成不同分辨率的图片 PX转 dp 以5X 为例: 5X的dpi =420, PPI = 420/160 = 2.625设置view的宽度我们用 match_parent,那么在5X上，他是多少dp呢？ 5X : width = 1080 pxdp = 1080 / PPI = 411.428571429,所以411dp就是5X的match_parent http://blog.csdn.net/u010983881/article/details/51993157 实际应用 开发中的实际转化 生成主流屏幕的values，安宽分成320份,高400份 假设ＵＩ根据 iphone6(750×1334)设计的效果图 根据下图公式计算 Dpi iphone6是4.7寸的 分辨率 750 * 1334, 它的dpi 就是 √(750²+1334²)/4.7 = 325 ​ 和drawable-xhdpi 320接近 drawable-xhdpi 480上做的图就是大概是1.5倍的样子 ,分辨率在1920 *1080上的也是一样的 ​ 然而pixel 2的模拟器是420 真机是441，这是什么原因呢!!! http://blog.csdn.net/zengd0/article/details/52464627 所以说 给的1334 * 750 图就是 10px 我们写5dp ​ 参考: http://www.jianshu.com/p/ec5a1a30694b http://blog.csdn.net/lmj623565791/article/details/45460089 DPI参考 自己计算按照上面的公式很简单，最棘手的还是手机尺寸给出一个手机dpi网站 get what you wanthttp://dpi.lv/ https://mp.weixin.qq.com/s/v_aauFjx-f91WrpCAaNMVQ) https://developer.android.com/guide/practices/screens_support 今日头条适配 https://www.jianshu.com/p/55e0fca23b4f https://github.com/JessYanCoding/AndroidAutoSize 为什么原来长度 ic_launcher.png 192*192 到了nexus5 中显示是216 * 216 而不是原来的尺寸","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/tags/VIEW/"}]},{"title":"Package-signature","slug":"Package-signature","date":"2017-09-21T02:56:13.000Z","updated":"2021-08-19T11:11:44.199Z","comments":true,"path":"2017/09/21/Package-signature/","link":"","permalink":"https://noteforme.github.io/2017/09/21/Package-signature/","excerpt":"","text":"Apk打包流程 相同签名 不同包名问题现在把项目重新生成签名，然后安装，安装后会安装失败，因为和以前的app冲突 应用安装后会在data/data 目录生成和包名一样的文件夹 虽然生成了了新的签名但是会覆盖 打包android studio更新了新版本 打包的时候v1和v2都需要勾选才能安装 http://blog.h5min.cn/daihuimaozideren/article/details/77842549 walle打包生成渠道包 生成渠道包 ./gradlew clean assembleReleaseChannels 支持 productFlavors ./gradlew clean assembleMeituanReleaseChannels https://github.com/Meituan-Dianping/walle","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"ubuntu_guide","slug":"ubuntu_guide","date":"2017-09-20T13:42:17.000Z","updated":"2021-08-19T11:11:44.318Z","comments":true,"path":"2017/09/20/ubuntu_guide/","link":"","permalink":"https://noteforme.github.io/2017/09/20/ubuntu_guide/","excerpt":"","text":"解决Ubuntu 16.04 系统的一些错误 Unable to mount root fs on unknown-block 看到Ubuntu系统有更新就点了下，早上打开电脑 Ubuntu直接进不去最下面弹出这这样的 错误 Unable to mount root fs on unknown-block 而且只能强制关机，心想完了我的 资料，还有辛苦编译的源码，不过好在晚上回来倒腾了一把 终于好了。 步骤1、 Advanced options for Ubuntu２、ubuntu Linux 4.4.0-96… (recovery mdoe) 这里我选择的是第二个，第一个点击后还是 会报错3、Menu界面 ，把能清的先清了，然后点击grub,执行后续操作 4、登录进入命令行界面 12345sudo mount -o rw //这一行和参考资料不同sudo dpkg --configure -a //在这里等了很久 Device ....Start的字样,接着就按了 Ctrl + Alt + Delete , 重启就好了sudo apt-get install -f # to finish upgrades 最好加这个吧type reboot https://askubuntu.com/questions/875862/kernel-panic-unable-to-mount-root-in-ubuntu-16-04/875868 解压乱码在windows上压缩的文件，是以系统默认编码中文来压缩文件。由于zip文件中没有声明其编码，所以linux上的unzip一般以默认编码解压，中文文件名会出现乱码。可以使用终端zip文件进行解压并指定解压的编码 unzip -O GBK xxx.zip解压后的文件的路径为当前终端所在的路径 参考： Eric Chan ** 17.10的问题 ** Android studio3.1无法输入中文 使用 fcitx 选择sunpingying 也可以选择 google pinyin 然后输入这两行命令 pidof fcitx | xargs kill #找到原有的fcitx端口并kill掉 fcitx #开启fcitx 参考： https://blog.csdn.net/he729164860/article/details/78484713 安装Gnome shell12sudo apt-get install gnome-tweak-toolsudo apt-get install chrome-gnome-shell 打开tweak可以看到按钮 浏览点击 ||| off按钮系统就会安装 开源chromium加载有问题，使用firefox 很有用的插件 https://extensions.gnome.org/extension/545/hide-top-bar/ 参考:https://www.mobibrw.com/2017/9342 ctrl + alt + left （Intellij idea shortcut conflict） install Dconf Editor in ubuntu software launch Dconf Editor, go to /org/gnome/desktop/wm/keybindings/switch-to-workspace-left double click like below use default value(click Off) -&gt; Custom value(like me or else) you could use it in intellij idea now . genymotion安装 下载Virtualbox 下载genymotion 下载Android stuido genymotion插件 12chmod +x genymotion-2.6.0-linux_x64.bin ./genymotion-2.6.0-linux_x64.bin -d /home/qiu/Work/genymotion //注意： chmod +x 有空格 输入法设置ubuntu 18.04 intellij 输入法选择有问题，可以用命令行安装 ibus-pinyin，然后input souce选择拼音输入法","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://noteforme.github.io/categories/LINUX/"}],"tags":[]},{"title":"SDK_Integration","slug":"SDK_Integration","date":"2017-09-19T06:44:01.000Z","updated":"2021-08-19T11:11:44.237Z","comments":true,"path":"2017/09/19/SDK_Integration/","link":"","permalink":"https://noteforme.github.io/2017/09/19/SDK_Integration/","excerpt":"","text":"平常集成SDK虽然简单，但是过了半年就全忘了，又得重新来过 友盟分享微信开发者平台创建应用需要 应用签名 需要签名工具,可以从 微信资源中心 获取 注意要打包才能运行 商汤认证文档 身份证认证 在common-idcard包中的assets目录下添加 SenseID_OCR.lic文件就可以了 在androidmanifest.xml注册activity 活体认证 最终调用onDetectOver 1public void onDetectOver(ResultCode code, String id, List imageData) 会返回id,然后把id,身份证number,name传给商汤对比 极光推送 集成过程 按照文档，主要是要注意这个广播接收器就可以了 1234567891011121314151617&lt;receiver android:name=&quot;.jpush.MyReceiver&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!--Required 用户注册SDK的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.REGISTRATION&quot; /&gt; &lt;!--Required 用户接收SDK消息的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.MESSAGE_RECEIVED&quot; /&gt; &lt;!--Required 用户接收SDK通知栏信息的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.NOTIFICATION_RECEIVED&quot; /&gt; &lt;!--Required 用户打开自定义通知栏的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.NOTIFICATION_OPENED&quot; /&gt; &lt;!-- 接收网络变化 连接/断开 since 1.6.3 --&gt; &lt;action android:name=&quot;cn.jpush.android.intent.CONNECTION&quot; /&gt; &lt;category android:name=&quot;com.zhujia.land&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 有点疑惑的是推送给特定的APP 目前获取RegistrationID，登陆接口把 RegistrationID传给服务端, 然后Server推送过来就可以了 http://blog.jiguang.cn/push_audience_tech-2/ 暂时别试用Jcenter集成,会出现各种问题 微信登陆App登录https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Resource_Center_Homepage.html 问题1 E/MtaSDK: [pool-4-thread-1(320): null:705] - Server response error code:404, error:&#123;&quot;ret&quot;:-1, &quot;msg&quot;:&quot;invalid appkey&quot;&#125; Demo里的wechat-sdk-android-with-mta 换成 api ‘com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+’ 这个弄了一上午 问题2 No value for openid. WXEntryActivity {“errcode”:40029,”errmsg”:”invalid code”} WXEntryActivity appid secret错误 1234567if (resp.getType() == ConstantsAPI.COMMAND_SENDAUTH) &#123; SendAuth.Resp authResp = (SendAuth.Resp)resp; final String code = authResp.code; NetworkUtil.sendWxAPI(handler, String.format(&quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot; + &quot;appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code&quot;, &quot;wx930ea5d5a258f4f&quot;, &quot;1d6d1d57a3dd06336d917bc0b44d964&quot;, code), NetworkUtil.GET_TOKEN);&#125; 1GET https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code demo中 appid wxd930ea5d5a2584f要换成自己的 secret 1d6d1d57a3dd063b36d91bc0b44d964也要换成自己的 问题3 需要注册，否则WXEntryActivity不能收到回调 1234567891011121314151617181920212223private static final String APP_ID = &quot;wx88888888&quot;;// IWXAPI 是第三方app和微信通信的openApi接口private IWXAPI api;private regToWx() &#123; // 通过WXAPIFactory工厂，获取IWXAPI的实例 api = WXAPIFactory.createWXAPI(this, APP_ID, true); // 将应用的appId注册到微信 api.registerApp(APP_ID); //建议动态监听微信启动广播进行注册到微信 registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // 将该app注册到微信 api.registerApp(Constants.APP_ID); &#125; &#125;, new IntentFilter(ConstantsAPI.ACTION_REFRESH_WXAPP));&#125; 二维码扫码登录https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Login_via_Scan.html 登录公众平台 https://mp.weixin.qq.com/cgi-bin/home?t=home ,点击配置进入IP白名单 点击配置进入IP白名单设置页 https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&amp;key=1495617578&amp;version=1&amp;lang=zh_CN&amp;platform=2&amp;token=38764305 二维码扫码登录的appid secret key用开放平台的 https://open.weixin.qq.com/cgi-bin/index?t=home/index&amp;lang=zh_CN 注意两个不同的平台配置 二维码失效: 首先普及一下二维码是有失效时间以及失效状态的，一旦你扫过一次二维码或者在某段时间内没有扫描页面上的二维码，该二维码就失效了 app分享拉新规则 https://mp.weixin.qq.com/s/3bsmiv78yJ4XKwd8iu-0Ig Wechat Payhttps://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5 Alipayhttps://opendocs.alipay.com/open/204/105296 orderInfo订单信息 由接口拼接就可以了 https://mp.weixin.qq.com/s/wWB5ENo3eQJH03OXvoup8w https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&amp;mid=2247485318&amp;idx=1&amp;sn=174338566ad8c0426c95815c4f4aee5a&amp;scene=21#wechat_redirect 推送相关 https://juejin.im/post/6881414546859229192","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"JavaIo","slug":"JavaIo","date":"2017-09-12T02:14:41.000Z","updated":"2021-08-19T11:11:44.087Z","comments":true,"path":"2017/09/12/JavaIo/","link":"","permalink":"https://noteforme.github.io/2017/09/12/JavaIo/","excerpt":"","text":"![Screen Shot 2020-09-12 at 5.20.14 PM](JavaIo/Screen Shot 2020-09-12 at 5.20.14 PM.png) ![Screen Shot 2020-09-12 at 5.22.29 PM](JavaIo/Screen Shot 2020-09-12 at 5.22.29 PM.png) Byte Stream : 对于二进制文件或处理 数字字母之类的数据 https://www.javazhiyin.com/17362.html FileInputStream单个字节读 123456789101112FileInputStream fis = null;try &#123; fis = new FileInputStream(&quot;/Users/john/Documents/jywork/THINKJAVA/src/main/resource/a.txt&quot;); int data; while ((data = fis.read()) != -1) &#123; System.out.print((char) data+&quot; &quot;); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 读到bytes数组里面 12345678910111213FileInputStream fis = null;try &#123; byte[] bytes = new byte[14]; fis = new FileInputStream(&quot;/Users/john/Documents/jywork/THINKJAVA/src/main/resource/a.txt&quot;); int read = fis.read(bytes); String s = new String(bytes); System.out.println(s); System.out.println(read);&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 读到bytes里面 ,限定读的字节个数 12345678910111213FileInputStream fis = null;try &#123; byte[] bytes = new byte[14]; fis = new FileInputStream(&quot;/Users/john/Documents/jywork/THINKJAVA/src/main/resource/a.txt&quot;); int read = fis.read(bytes,0,4); String s = new String(bytes); System.out.println(s); System.out.println(read);&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 对于为什么必须继承装饰器父类 FilterInputStream的思考 实际上，如果去查看 JDK 的源码，你会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？我们再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。这一部分稍微有点不好理解，你自己多思考一下。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"WebView","slug":"WebView","date":"2017-09-01T08:07:15.000Z","updated":"2023-01-02T03:31:39.097Z","comments":true,"path":"2017/09/01/WebView/","link":"","permalink":"https://noteforme.github.io/2017/09/01/WebView/","excerpt":"","text":"https://developer.android.com/guide/webapps/webview.html 使用加载apk包中的html页面 webView.loadUrl(&quot;file:///android_asset/java.html&quot;); Enabling JavaScript12345678910111213141516171819202122WebView myWebView &#x3D; (WebView) findViewById(R.id.webview);WebSettings webSettings &#x3D; myWebView.getSettings(); &#x2F;&#x2F;支持JavaScript&#x2F;&#x2F; webSettings.setJavaScriptEnabled(true); &#x2F;&#x2F; 在 onStop 和 onResume 里分别把 setJavaScriptEnabled() 给设置成 false 和 true 即可 &#x2F;** * 设置自适应屏幕,两者合用 *&#x2F; webSettings.setUseWideViewPort(true); &#x2F;&#x2F;将图片调整到适合webview的大小 webSettings.setLoadWithOverviewMode(true); &#x2F;&#x2F;缩放至屏幕的大小 &#x2F;** * 缩放操作 *&#x2F; webSettings.setSupportZoom(true); &#x2F;&#x2F;支持缩放，默认为true。是下面那个的前提。 webSettings.setBuiltInZoomControls(true); &#x2F;&#x2F;设置内置的缩放控件。若为false，则该WebView不可缩放 webSettings.setDisplayZoomControls(false);&#x2F;&#x2F;隐藏原生的缩放控件&#x2F;&#x2F; myWebView.setWebChromeClient(new MyWebViewClient()); myWebView.setWebViewClient(new MyViewClient()); 上面是一些常用的操作 Binding JavaScript code to Android code(JS交互)When developing a web application that’s designed specifically for the WebView in your Android application, you can create interfaces between your JavaScript code and client-side Android code. For example, your JavaScript code can call a method in your Android code to display a Dialog, instead of using JavaScript’s alert() function. To bind a new interface between your JavaScript and Android code, call addJavascriptInterface(), passing it a class instance to bind to your JavaScript and an interface name that your JavaScript can call to access the class. office Demo 12345678910111213inner class WebLoginInterface(context: Context?) &#123; @JavascriptInterface fun showToast() &#123; Timber.i(&quot;appLogin&quot;) mWebView?.post &#123; val mSessionId &#x3D; SharedPreferencesUtils.getParam(AppCtxUtil.getApp(), GsonUtil.SHARE_TOKEN_KEY, &quot;&quot;) as String Timber.i(&quot;mSessionId $&#123;mSessionId&#125;&quot;) val jsMethodName &#x3D; &quot;javascript:appLoginCallBack(&#39;$mSessionId&#39;,&#39;4&#39;)&quot;; &#x2F;&#x2F;需要参数的JS函数名 Timber.i(&quot;jsMethodName $jsMethodName&quot;) mWebView?.loadUrl(jsMethodName) &#125; &#125; &#125; 注意 Caution: If you’ve set your targetSdkVersion to 17 or higher, you must add the @JavascriptInterface annotation to any method that you want available to your JavaScript (the method must also be public). If you do not provide the annotation, the method is not accessible by your web page when running on Android 4.2 or higher. html小例子 1234567&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;Say hello&quot; onClick&#x3D;&quot;showAndroidToast(&#39;Hello Android!&#39;)&quot; &#x2F;&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; function showAndroidToast(toast) &#123; Android.showToast(toast); &#125;&lt;&#x2F;script&gt; 接着加载JS 12WebView webView &#x3D; (WebView) findViewById(R.id.webview);webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;); http://www.jianshu.com/p/3c94ae673e2a http://www.jianshu.com/p/c20513cad758 缓存方案office (原生缓存)1234567891011121314 WebSettings webSettings &#x3D; wbNews.getSettings(); webSettings.setJavaScriptEnabled(true);&#x2F;&#x2F; 启用支持javascript webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);&#x2F;&#x2F;缓存模式 webSettings.setDomStorageEnabled(true); &#x2F;&#x2F; 开启DOM storage API 功能 &#x2F;&#x2F; 开启database storage API功能 webSettings.setDatabaseEnabled(true); webSettings.setAllowFileAccess(true);&#x2F;&#x2F;可以访问文件 webSettings.setBuiltInZoomControls(true);&#x2F;&#x2F;支持缩放 &#x2F;&#x2F; 设置数据库缓存路径 String cacheDirPath &#x3D; getFilesDir().getAbsolutePath() + APP_CACHE_DIRNAME; webSettings.setAppCachePath(cacheDirPath); webSettings.setAppCacheEnabled(true); http://blog.csdn.net/coder_pig/article/details/48468969 图片替换方式https://github.com/GcsSloop/diycode/blob/master/blog/journal-02.md 其他常用方式美团点评腾讯 https://juejin.im/post/5a94f9d15188257a63113a74 页面白屏1webSettings.setDomStorageEnabled(true); &#x2F;&#x2F; 开启DOM storage API 功能 ​ https://blog.csdn.net/ONLYMETAGAIN/article/details/78390643 https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/ 不显示图片的问题 1234webSettings.setBlockNetworkImage(false);if (Build.VERSION.SDK_INT&gt;&#x3D;Build.VERSION_CODES.LOLLIPOP)&#123; webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);&#125; 但是我的还是不显示 1android:hardwareAccelerated&#x3D;&quot;false&quot; WebView缓存功能 https://github.com/yale8848/CacheWebView http://blog.leanote.com/post/zbyzhlsp/%E6%BC%AB%E8%B0%88Android-Webview%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95 https://www.zybuluo.com/zyl06/note/737188 https://juejin.im/post/5b94ca52e51d450e7d097f38 2、缓存模式(5种) LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。 LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式 LOAD_NO_CACHE: 不使用缓存，只从网络获取数据. LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。如：www.taobao.com的cache-control为no-cache，在模式LOAD_DEFAULT下，无论如何都会从网络上取数据，如果没有网络，就会出现错误页面；在LOAD_CACHE_ELSE_NETWORK模式下，无论是否有网络，只要本地有缓存，都使用缓存。本地没有缓存时才从网络上获取。www.360.com.cn的cache-control为max-age=60，在两种模式下都使用本地缓存数据。 https://juejin.im/entry/5ad70987f265da239148a614 zip离线缓存 https://mp.weixin.qq.com/s/AV2SwFfwwJH7xyrIBJemgw 安全问题WebView漏洞的根源在于强制其访问攻击者控制的网页。网页中含有攻击者可以控制的JS,因此可能钓鱼，窃取私有文件，甚至是 RCE,带来比较大的危害。 下面主要是4.4系统以上的机型 Webview密码明文存储漏洞WebView默认开启密码保存功能mWebView.setSavePassword(true),如果未关闭，用户输入密码时，会弹出提示框，询问用户是否保存密码，如果选是，密码会明文保存到 /data/data/com.package.name/databases/webview.db WebView域控制不严格漏洞setAllowFileAccess(true) : 窃取APP任意目录下的私有文件 setAllowUniversalAccessFromFileURLs : 允许通过file域url中的 javascript访问其他的源。 方案 通过以下设置，防止越权访问，跨域等安全问题 12345setAllowFileAccess(false)setAllowFileAccessFromFileURLs(false)setAllowUniversalAccessFromFileURLs(false) WebSettings.setSavePassword(false) 关闭密码保存提醒功能 建议开发者通过以下方式移除该JavaScript接口 12345removeJavascriptInterface(&quot;searchBoxJavaBridge_&quot;)removeJavascriptInterface(&quot;accessibility&quot;)；removeJavascriptInterface(&quot;accessibilityTraversal&quot;) https://zhuanlan.zhihu.com/p/21787366 https://zhuanlan.kanxue.com/article-14155.htm","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"Camera","slug":"Camera","date":"2017-08-28T14:16:43.000Z","updated":"2021-08-19T11:11:43.750Z","comments":true,"path":"2017/08/28/Camera/","link":"","permalink":"https://noteforme.github.io/2017/08/28/Camera/","excerpt":"","text":"https://developer.android.com/training/camera/photobasics.html#TaskPath Get the thumbnail(缩略图)12345678public static final int REQUEST_IMAGE_CAPTURE = 1;private void btAlbum() &#123; Intent takePictureIntent = new Intent( Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);&#125; 123456789@Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == Activity.RESULT_OK) &#123; data?.extras?.let &#123; val imageBitmap = it.get(&quot;data&quot;) as Bitmap img_show.setImageBitmap(imageBitmap) &#125; &#125; Save the full-size photo provider_camera.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;external-path name=&quot;my_images&quot; path=&quot;Android/data/com.zhujia.land/files/Pictures&quot; /&gt;&lt;/paths&gt; 跳转拍照 : 还得注意申请权限 1234567891011121314151617181920212223private void dispatchTakePictureIntent(int num) &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(this.getPackageManager()) != null) &#123; try &#123; photoFile = createImageFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (photoFile == null) &#123; return; &#125; Uri imgUri; if (Build.VERSION.SDK_INT &lt; 24) &#123; imgUri = Uri.fromFile(photoFile); &#125; else &#123; //Android 7.0系统开始 使用本地真实的Uri路径不安全,使用FileProvider封装共享Uri //参数二:fileprovider绝对路径 com.dyb.testcamerademo：项目包名 imgUri = FileProvider.getUriForFile(this, &quot;com.zhujia.land.fileprovider&quot;, photoFile); &#125; takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, imgUri); &#125; startActivityForResult(takePictureIntent, num); &#125; 12345678910111213override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == Activity.RESULT_OK) &#123; //如果拍照成功，将Uri用BitmapFactory的decodeStream方法转为Bitmap val imageBitmap = BitmapFactory.decodeStream(photoURI?.let &#123; contentResolver.openInputStream( it ) &#125;) galleryAddPic(mImageUriFromFile) //将拍的照片添加到相册 img_show.setImageBitmap(imageBitmap) &#125; &#125; 照片添加到相册 123456789/** * 将拍的照片添加到相册 * * @param uri 拍的照片的Uri */private fun galleryAddPic(uri: Uri?) &#123; val mediaScanIntent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,uri) sendBroadcast(mediaScanIntent)&#125; But it has a question 12345678910111213141516 fun createImageFile(context: Context): File? &#123; // Create an image file name val timeStamp: String = SimpleDateFormat(yyyyMMDD_HHmmss).format(Date())// val storageDir: File? = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) val storageDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) return File.createTempFile( &quot;JPEG_$&#123;timeStamp&#125;_&quot;, /* prefix */ &quot;.jpg&quot;, /* suffix */ storageDir /* directory */ ).apply &#123; // Save a file: path for use with ACTION_VIEW intents var currentPhotoPath = absolutePath Timber.i(&quot;createImageFile $currentPhotoPath&quot;) &#125; &#125; ACTION_MEDIA_SCANNER_SCAN_FILE 还有一个限制条件，那就是传递进去的文件绝对路径，必须是以 Environment.getExternalStorageDirectory() 方法的返回值开头。 这样 ‘context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)’ 这个暂时没弄好 https://juejin.im/post/5ae0541df265da0b9d77e45a https://www.jianshu.com/p/f269bcda335f# https://www.jianshu.com/p/26d29e187f89 servlethttps://my.oschina.net/u/2008084/blog/524937 7.0https://blog.csdn.net/u011418943/article/details/77712662 Android 10 https://mp.weixin.qq.com/s/31esIqMudRRDBY8JDs8D4A https://juejin.im/post/5a33a5106fb9a04525782db5","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"ConcurrencyThreadPool","slug":"ConcurrencyThreadPool","date":"2017-08-27T02:40:55.000Z","updated":"2021-08-19T14:06:15.145Z","comments":true,"path":"2017/08/27/ConcurrencyThreadPool/","link":"","permalink":"https://noteforme.github.io/2017/08/27/ConcurrencyThreadPool/","excerpt":"","text":"线程池状态切换 1、RUNNING (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！ 1 2、 SHUTDOWN (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。 3、STOP (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。 4、TIDYING (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 5、 TERMINATED (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。 https://blog.csdn.net/nmjhehe/article/details/115901549 https://www.cnblogs.com/east7/p/14417977.html 线程池工作原理 各参数含义corePoolSize线程池初始化时线程数默认为 0，当有新的任务提交后，会创建新线程执行任务，如果不做特殊设置，此后线程数通常不会再小于 corePoolSize ，因为它们是核心线程，即便未来可能没有可执行的任务也不会被销毁。 maximumPoolSize​ maximumPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maximumPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize、workQueue、maximumPoolSize，如果依然不能满足需求，则会拒绝任务。 keepAliveTime+时间单位​ 当线程池中线程数量多于核心线程数时，而此时又没有任务可做，线程池就会检测线程的 keepAliveTime，如果超过规定的时间，无事可做的线程就会被销毁，以便减少内存的占用和资源消耗。但是要注意到了核心线程数就不会销毁了。 如上图所示，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为 0，则新建线程并执行任务，随着任务的不断增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务被不断提交，就会被放入 workQueue 任务队列中，等待核心线程执行完当前任务后重新从 workQueue 中提取正在等待被执行的任务。 此时，假设我们的任务特别的多，已经达到了 workQueue 的容量上限，这时线程池就会启动后备力量，也就是 maximumPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maximumPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize、workQueue、maximumPoolSize，如果依然不能满足需求，则会拒绝任务。 6 种线程池 FixedThreadPool 它的核心线程数和最大线程数是一样的 CachedThreadPool 它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1),当我们提交一个任务后，线程池会判断已创建的线程中是否有空闲线程，如果有空闲线程则将任务直接指派给空闲线程，如果没有空闲线程，则新建线程去执行任务，这样就做到了动态地新增线程。 12345ExecutorService service = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 1000; i++) &#123; service.execute(new Task() &#123; &#125;); &#125; 使用 for 循环提交 1000 个任务给 CachedThreadPool，假设这些任务处理的时间非常长，会发生什么情况呢？因为 for 循环提交任务的操作是非常快的，但执行任务却比较耗时，就可能导致 1000 个任务都提交完了但第一个任务还没有被执行完，所以此时 CachedThreadPool 就可以动态的伸缩线程数量，随着任务的提交，不停地创建 1000 个线程来执行任务，而当任务执行完之后，假设没有新的任务了，那么大量的闲置线程又会造成内存资源的浪费，这时线程池就会检测线程在 60 秒内有没有可执行任务，如果没有就会被销毁，最终线程数量会减为 0。 ScheduledThreadPool 周期性的执行任务 SingleThreadExecutor 它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务 SingleThreadScheduledExecutor 它实际和第三种 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程. ForkJoinPool 我们有一个 Task，这个 Task 可以产生三个子任务，三个子任务并行执行完毕后将结果汇总给 Result。 拒绝策略 第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。 第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。 第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。 第四种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。 提交任务的线程是不固定的，取决于具体是哪个线程执行submit等方法的 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=248 线程数量和CPU核数关系线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间） 线程平均等待时间所占比例越高，就需要越多的线程 耗时 IO 型任务 , 比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间 , 因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费,而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。 线程的平均工作时间所占比例越高，就需要越少的线程 平均工作时间长 : CPU密集型任务，加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。 可以通过写代码等办法统计到各部分语句的运行时长 如果我们执行的任务类型不是固定的，比如可能一段时间是 CPU 密集型，另一段时间是 IO 密集型，或是同时有两种任务相互混搭。那么在这种情况下，我们可以把最大线程数设置成核心线程数的几倍，以便应对任务突发情况。当然更好的办法是用不同的线程池执行不同类型的任务，让任务按照类型区分开，而不是混杂在一起，这样就可以按照上一课时估算的线程数或经过压测得到的结果来设置合理的线程数了，达到更好的性能。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=254 阻塞队列5种常见的线程池 12345ExecutorService fixedThreadPool = Executors.newFixedThreadPool(1); //LinkedBlockingQueueExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); // LinkedBlockingQueueExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // SynchronousQueueScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(1); //DelayedWorkQueueScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor(); //DelayedWorkQueue 上图 前面是线程池，后面是使用的阻塞队列 LinkedBlockingQueue (FixedThreadPool,SingleThreadExector) 使用的有 FixedThreadPool ,SingleThreadExector,它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue,可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。 缺点: 最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是OutOfMemoryError. SynchronousQueue (CachedThreadPool) 对应的线程池是 CachedThreadPool,线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。和LinkedBlockingQueue阻塞队列重复相反， 缺点: 当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足。 DelayedWorkQueue (DelayedWorkQueue) 顾名思义，特点就是可以延迟执行任务 缺点: 它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过多的任务，就可能导致 OOM OkHttp线程池12ThreadPoolExecutor executor = new ThreadPoolExecutor( 0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 可以看到 corePoolSize 0 , MaxPoolSize Integer.MAX_VALUE 根据线程池执行流程： 首先核心线程，corePoolSize 为0 。 把任务加入SynchronousQueue，但是这个队列加入就会失败。 创建非核心线程，数量为Integer.MAX_VALUE，可以创建。 当任务执行完后，3创建的非核心线程 根据keepAliveTime时间，逐步销毁。 问题OkHttpThreadPool.java 12345678910111213141516171819ThreadPoolExecutor executor = new ThreadPoolExecutor( 0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;());executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread()); while (true) &#123; &#125;&#125;);executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread());&#125;);executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread());&#125;); 运行结果: 任务1Thread[pool-1-thread-1,5,main] 如果 new LinkedBlockingDeque&lt;&gt;(1)能正常执行，因为LinkedBlockingDeque加入 任务1 就满了，后面的任务创建非核心线程 但是有点疑惑，我这里核心线程是0，任务都加入到LinkedBlockingDeque, 按照线程池流程，非核心就不应该创建呀？怎么任务1就执行了呢 https://www.bilibili.com/video/BV15y4y1B7Rw?p=5 https://mp.weixin.qq.com/s/BHDrSgwUVXkzvswK1khidQ https://github.com/Snailclimb/programmer-advancement https://juejin.im/post/6855586076132655118 https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485441&amp;idx=1&amp;sn=303a25ab02fa9f14a319923e6b0d9759&amp;chksm=cea247caf9d5cedc3a5e1d31f26c08d8ae4c11c349fbdc91ac1d90d8b35807517accb5f5d527&amp;token=2128752750&amp;lang=zh_CN#rd","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"https://noteforme.github.io/tags/concurrency/"}]},{"title":"Handler","slug":"Handler","date":"2017-08-21T09:06:35.000Z","updated":"2021-12-10T09:58:02.917Z","comments":true,"path":"2017/08/21/Handler/","link":"","permalink":"https://noteforme.github.io/2017/08/21/Handler/","excerpt":"","text":"Handler作用既然process内的thread share their memories. why we need handler.我们直接可以 subThread get data,赋值给Ui thread的变量呀。 正常来说是没问题的。但是像下面这种情况。 12345678910111213141516171819202122232425public class MainActivity extends AppCompatActivity &#123; private static final String TAG = &quot;123&quot;; public static int anInt = 1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 子 new Thread(new Runnable() &#123; @Override public void run() &#123; anInt = 2; Log.i(TAG, &quot;子线程: &quot; + anInt); &#125; &#125;).start(); // 主 Log.i(TAG, &quot;主线程: &quot; + anInt); &#125;&#125;————————————————版权声明：本文为CSDN博主「dev晴天」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_38350635/article/details/90440833 如上：主线程定义了anInt，子线程对其修改。我们再在主线程打印，能得到修改后的anInt = 2 吗？ 答案：不确定 原因：线程争夺cup使用权顺序不确定，可能,子线程先获得使用权，则两个Log都打印2。当然主线程先获得使用权时主线程的log打印数值为1。 解决方案1、让子线程先执行。 比如主线程设置低优先级、主线程休息等等（不靠谱，提供一种想法吧） 2、安卓中的Handler机制 子线程发送消息，主线程接受消息，只有主线程收到消息再打印处理数值。 handler使用略。。。。。。 3、接口回调机制 原理图 各组件作用 Handler：事件的发送及处理者，在构造方法中可以设置其 async，默认为 false。若 async 为 true 则该 Handler 发送的 Message 均为异步消息，有同步屏障的情况下会被优先处理。 Looper：一个用于遍历 MessageQueue 的类，每个线程有一个独有的 Looper，它会在所处的线程开启一个死循环，不断从 MessageQueue 中拿出消息，并将其发送给 target 进行处理 MessageQueue：在主线程,用于存储 Message，内部维护了 Message 的链表，每次拿取 Message 时，若该 Message 离真正执行还需要一段时间，会通过 nativePollOnce 进入阻塞状态，避免资源的浪费。若存在消息屏障，则会忽略同步消息优先拿取异步消息，从而实现异步消息的优先消费。 消息入队算法https://www.jianshu.com/p/9efe3b48b730 https://juejin.cn/post/6844904113470177293 https://www.bilibili.com/video/BV1VE411Z7Ay?p=4 ThreadLocal存取算法 ThreadLocal是一个线程内部的数据存储类，它可以指定线程的存储数据，数据存储后只有在指定的线程种裁可以获取到存储的数据, 其他线程无法获取。 验证: private ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;(); mStringThreadLocal.set(&quot;我是主线程&quot;); Log.d(TAG, &quot;mStringThreadLocal 主线程 : &quot; + mStringThreadLocal.get()); exec.submit(new Runnable() &#123; @Override public void run() &#123; mStringThreadLocal.set(&quot;我是线程１&quot;); Log.d(TAG, &quot;mStringThreadLocal 线程１: &quot; + mStringThreadLocal.get()); &#125; &#125;); exec.submit(new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, &quot;mStringThreadLocal 线程2: &quot; + mStringThreadLocal.get()); &#125; &#125;); 运行结果: D/MainActivity: mStringThreadLocal 主线程 : 我是主线程 D/MainActivity: mStringThreadLocal 线程１: 我是线程１ D/MainActivity: mStringThreadLocal 线程2: null 从日志可以看到，虽然在不同线程访问的同一个ThreadLocal对象，但是他们通过ThreadLocal获取到的值确不一样 结论： 对ThreadLocal所做的 读写操作仅限于各自线程的内部，ThreadLocal可以在多个线程互不干扰的存储和修改数据。 !!!任务： 分析ThreadLocal存取算法 [^参考：Android开发艺术探索 p377] 消息同步消息 来个简单的例子 12345678new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); handler = new Handler(); Looper.loop(); &#125; &#125;).start();把 Looper.prepare();注释，报错日志 : java.lang.RuntimeException: Can&#39;t create handler inside thread that has not called Looper.prepare() 从报错信息入手看原因，初始化Handler (API = 25) 12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;); //报错信息 &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; mLooper为空,所以报错，看下Looper.myLooper(); 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 注释可以看到，当前线程没有Looper对象, 那么Looper对象是怎么创建的呢，很显然就是上面例子里的 Looper.prepare(); 12345678910111213141516/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 如果没有Looper 则new 一个，由此也看到每个线程最多一个Looper对象,接着看初始化的Looper 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; MesageQueue也是通过Looper创建的，看到private 构造方法,一个Looper管理一个 ＭesageQueue,但是我们通常在UI线程初始化Handler不需要调用 Looper.prepare();,这是因为应用启动后,主线程ActivityThread main方法为我们做了工作。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; 这样初始化Handler操作分析好了，接着就开始发消息了 handler.sendMessage(message);,经过层层调用来到这个方法 12345678910 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 第二个参数时间是可以添加延时的参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 这要Mesage消息就添加到 MesageQueue中了，按事件顺序添加，然后就是取消息了，通过调用Looper.loop(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&#x27;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 通过 Message msg = queue.next(); 获取消息，然后用 msg.target.dispatchMessage(msg);把消息往哪发呢 ? 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 点开 handleMesage(msg),msg.target 就是Handler 12345/** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; &#125; 这里就清楚了，消息就传到了 Hanlder里面handleMessage的实现方法从上面分析handler消息传递基本了解了，借张图看下整片森林 异步消息Android系统16ms会刷新一次屏幕，如果主线程的消息过多，在16ms之内没有执行完，必然会造成卡顿或者掉帧。那怎么才能不排队，没有延时的处理呢？这个时候就需要异步消息，在处理异步消息的时候，我们就需要同步屏障，让异步消息不用排队等候处理。可以理解为同步屏障是一堵墙，把同步消息队列拦住，先处理异步消息，等异步消息处理完了，这堵墙就会取消，然后继续处理同步消息。 https://blog.csdn.net/ly502541243/article/details/109091386 查找异步消息方法 MessageQueue.java 12345678910111213141516171819202122Message next() &#123; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); //循环查找 直到找到异步消息为止. &#125; &#125; &#125; https://blog.csdn.net/ly502541243/article/details/109091386 发送延时消息看下面问题:handler如何实现延时发消息postdelay() https://zhuanlan.zhihu.com/p/260661053 https://blog.csdn.net/thh159/article/details/103644489 IdleHandler使用当消息队列空闲时会执行IdleHandler的queueIdle()方法，该方法返回一个boolean值，如果为false则执行完毕之后移除这条消息，如果为true则保留，等到下次空闲时会再次执行，下面看下MessageQueue的next()方法可以发现确实是这样 12345Message next() &#123; // Run the idle handlers. // We only ever reach this code block during the first iteration. keep = idler.queueIdle();&#125; Activity启动优化：onCreate，onStart，onResume中耗时较短但非必要的代码可以放到IdleHandler中执行，减少启动时间 想要在一个View绘制完成之后添加其他依赖于这个View的View，当然这个用View#post()也能实现，区别就是前者会在消息队列空闲时执行 一些第三方库中有使用，比如LeakCanary，Glide中有使用到，具体可以自行去查看 以前我们在Activity中获取某个控件的宽高的时候总是得到的是0，那是因为view的测量还未完成。通常的做法是监听ViewTreeObserver，它是在ViewRootImpl测量完成之后调用ViewTreeObserver.dispatchOnGlobalLayout()方法，这时候在onGlobalLayout回调中获取的控件宽高都是正确的数据。 1234Looper.myQueue().addIdleHandler &#123; Log.i(&quot;HandlerActivity&quot;, &quot;width $&#123;btFive.width&#125; height $&#123;btFive.height&#125;&quot;) false&#125; https://blog.csdn.net/ZYJWR/article/details/103086664 https://www.wanandroid.com/wenda/show/8723 问题handler的是怎样实现的？新线程中执行了一个耗时操作，然后把该结果塞给message，handler将发送这个messageQueue，Loop不停的从消息队列中取出消息。Handler 分发给Ui. Handler是怎么切换线程的我们在不同的线程发送消息，线程之间的资源是共享的 Handler机制了解吗？一个线程有几个Looper？为什么？只能有一个，不然调用Looper.prepare()会抛出运行时异常，提示“Only one Looper may be created per thread” handler如何实现延时发消息postdelay(),可以看到这里也是一个for循环遍历队列，核心变量就是nextPollTimeoutMillis。可以看到，计算出nextPollTimeoutMillis后就调用nativiePollOnce这个native方法。这里的话大概可以猜到他的运行机制，因为他是根据执行时间进行排序的，那传入的这个nextPollTimeoutMillis应该就是休眠时间，类似于java的sleep(time)。休眠到下一次message的时候就执行。那如果我在这段时间又插入了一个新的message怎么办，所以handler每次插入message都会唤醒线程，重新计算插入后，再走一次这个休眠流程。 值得注意的是这个方法没有开启子线程，只是调用了run(), 在 msg.target.dispatchMessage(msg)可以看到，接着调用了handleCallback(). https://www.jianshu.com/p/68083d432b3f 如果移除一个延时消息会解除休眠吗主线程死循环不会卡死吗从前面的主线程、子线程的分析可以看出，Looper会在线程中不断的检索消息，如果是子线程的Looper死循环，一旦任务完成，用户应该手动退出，而不是让其一直休眠等待。（引用自Gityuan）线程其实就是一段可执行的代码，当可执行的代码执行完成后，线程的生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder 线程也是采用死循环的方法，通过循环方式不同与 Binder 驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。Android是基于消息处理机制的，用户的行为都在这个Looper循环中，我们在休眠时点击屏幕，便唤醒主线程继续进行工作。 主线程的死循环一直运行是不是特别消耗 CPU 资源呢？ 其实不然，这里就涉及到 Linux pipe/epoll机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 https://www.jianshu.com/p/a7969d73c120 handler内存泄露问题说说你对Handler机制的了解，同步消息，异步消息等IdleHandler用过吗,IdleHandler应用场景？ 见上面IdleHandler使用 handler如何实现延时发消息postdelay()。callback，runnable，msg的执行优先级。阻塞是怎么实现的？为什么不会阻塞主线程？ Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？Handler内存泄漏的GCRoot是什么？ epoll的时候算是卡顿吗 怎么样算是卡顿了 怎么利用消息机制检测卡顿 除了这种方式还有别的监测卡顿的方式吗 Android中为什么主线程不会因为Looper.loop()里的死循环卡死？对于线程即是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。 主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 Gityuan–Handler(Native层) Handler通信，Binder通信 Handler同步屏障Handler发送的消息分为普通消息、屏障消息、异步消息，一旦Looper在处理消息时遇到屏障消息，那么就不再处理普通的消息，而仅仅处理异步的消息。不再使用屏障后，需要撤销屏障，不然就再也执行不到普通消息了。 为什么需要这样？它是设计来为了让某些特殊的消息得以更快被执行的机制。比如绘制界面，这种消息可能会明显的被用户感知到，稍有不慎就会引起卡顿、掉帧之类的，所以需要及时处理（可能消息队列中有大量的消息，如果像平时一样挨个进行处理，那绘制界面这个消息就得等很久，这是不想看到的）。 屏障消息仅仅是起一个屏障的作用，本身一般不附带其他东西，它需要配合其他Handler组件才能发挥作用。 1、Handler问题三连：是什么？有什么用？为什么要用，不用行不行？ 2、Android UI更新机制(GUI) 为何设计成了单线程的？ 3、真的只能在主(UI)线程中更新UI吗？ 4、真的不能在主(UI)线程中执行网络操作吗？ 6、为什么建议使用Message.obtain()来创建Message实例？ 7、为什么子线程中不可以直接new Handler()而主线程中可以？ 8、主线程给子线程的Handler发送消息怎么写？ 9、HandlerThread实现的核心原理？ 10、当你用Handler发送一个Message，发生了什么？ 11、Looper是怎么拣队列里的消息的？ 12、分发给Handler的消息是怎么处理的？ 14、Looper在主线程中死循环，为啥不会ANR？ 15、Handler泄露的原因及正确写法 16、Handler中的同步屏障机制 17、Android 11 Handler相关变更 https://juejin.cn/post/6844904150140977165 handler post和handleMesage区别 ​ post的runnable会直接在callback中调用run方法执行，而sendMessage方法要用户主动重写mCallback或者handleMessage方法来处理 https://www.bilibili.com/video/BV1A7411M7zQ?from=search&amp;seid=14693797999095810218 https://juejin.im/post/6844904150140977165 http://blog.csdn.net/guolin_blog/article/details/9991569 https://xiaozhuanlan.com/topic/0843791256 glide handler https://www.bilibili.com/video/BV1FU4y1V7HE https://segmentfault.com/a/1190000039809784","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"AnimationResource","slug":"AnimationResource","date":"2017-08-16T03:22:57.000Z","updated":"2021-08-19T11:11:43.675Z","comments":true,"path":"2017/08/16/AnimationResource/","link":"","permalink":"https://noteforme.github.io/2017/08/16/AnimationResource/","excerpt":"","text":"https://developer.android.com/guide/topics/resources/animation-resource.html Android动画简介,直接copy了 The Android framework provides two animation systems: property animation and view animation. Both animation systems are viable options, but the property animation system, in general, is the preferred method to use, because it is more flexible and offers more features. In addition to these two systems, you can utilize Drawable animation, which allows you to load drawable resources and display them one frame after another. 可以看出官方更推崇 Property Animiation,更灵活而且提供更多的功能,看下３种动画方式 Drawable Animation (Frame动画，帧动画) Drawable animation involves displaying Drawable resources one after another, like a roll of film. This method of animation is useful if you want to animate things that are easier to represent with Drawable resources, such as a progression of bitmaps. 通过人视觉的延迟，把图片一张连接一张，类似放电影 View Animation(Tween动画) View Animation is the older system and can only be used for Views. It is relatively easy to setup and offers enough capabilities to meet many application’s needs. Property Animation Introduced in Android 3.0 (API level 11), the property animation system lets you animate properties of any object, including ones that are not rendered to the screen. The system is extensible and lets you animate properties of custom types as well. view动画示例: 文件位置放哪呢？ 在官网确认了了位置 The animation XML file belongs in the res/anim/ directory of your Android project. The file must have a single root element: this will be either a single , , , , interpolator element, or element that holds groups of these elements (which may include another ). By default, all animation instructions are applied simultaneously. To make them occur sequentially, you must specify the startOffset attribute, as shown in the example below. 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:fillAfter=&quot;true&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:shareInterpolator=&quot;true&quot;&gt; &lt;!-- 位置移动--&gt; &lt;translate android:fromXDelta=&quot;0.0&quot; android:fromYDelta=&quot;0.0&quot; android:toXDelta=&quot;500.0&quot; android:toYDelta=&quot;500.0&quot; /&gt; &lt;!-- 放大或缩小 --&gt; &lt;scale android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;30.0&quot; /&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;0.5&quot; /&gt;&lt;/set&gt; 演示代码:参考：http://www.jianshu.com/p/b7aa2a4a9787http://blog.csdn.net/yanbober/article/details/46481171 跑完代码后，点击动画结束后的图片，没反应，实际上按钮还是停留在屏幕左上角，只不过view动画把图片绘制到了新的位置。所以说 View动画是对View的影像做操作，它并不能改变View的位置参数 Property Animation 属性动画就是对 对象的属性进行实质的改变了，而不只是投影了，比如刚才的图片修改后是可以点击的 ValueAnimator: 通过不断的对值进行操作来实现的，初始值盒结束值之间的动画过渡就是由ValueAnimator来负责计算的，除此之外，还负责管理动画的播放次数，播放模式，以及监听等。 /** * 300 ms内,value值从0 平滑的过渡到了1 */ // ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);// anim.setDuration(300); /** * value值从0过渡到５，再到３最后到10的过程 */ // ValueAnimator anim = ValueAnimator.ofFloat(0f, 5f, 3f, 10f); //整形数从 0到 100 ValueAnimator anim = ValueAnimator.ofInt(0, 100); anim.setDuration(5000); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; Object currentValue = valueAnimator.getAnimatedValue(); Log.d(TAG, &quot; current value is &quot; + currentValue); &#125; &#125;); anim.start(); ObjectAnimatorObjectAnimator继承ValueAnimator，它可以直接对任意对象的任意属性进行动画操作演示示例 /** * 透明: ５秒内从常规变换成全 透明,再从透明变成常规 */ // ObjectAnimator animator = ObjectAnimator.ofFloat(v, “alpha”, 1f, 0f, 1f); /** * 旋转 : 对按钮进行旋转 360 */ // ObjectAnimator animator = ObjectAnimator.ofFloat(v, “rotation”, 0f, 360f); /** * 位置移动: Button向左移动再回来 */ // float curTranslationX = v.getTranslationX(); //获取当前Button的translationX位置// ObjectAnimator animator = ObjectAnimator.ofFloat(v, “translationX”,// curTranslationX, -500f, curTranslationX); //传入translationX，后面３个参数告诉它怎么移动 /** * 缩放： 参数改为 scaleY,表示再垂直方向上放大３倍再还原 */ ObjectAnimator animator = ObjectAnimator.ofFloat(v, &quot;scaleY&quot;, 1f, 3f, 1f); animator.setDuration(5000); animator.start(); ObjectAnimator传入参数是根据Ｖiew的属性进行操作的，如setRotation()、getRotation()、setTranslationX()、getTranslationX()、setScaleY()、getScaleY() ＃ 组合动画 : 就是属性动画组合起来,借助AnimatorSet 微风吹着，飘来周传雄的音乐… 敲着键盘 人生不过如此～～ after(Animator anim) : 现有动画放在传入动画之后执行 after(long delay) : 將现有动画延迟 “delay” 后执行 before(Animator anim) :参考楼上 with(Animator anim) : 现有动画盒传入动画同时执行 示例 ObjectAnimator moveIn = ObjectAnimator.ofFloat(v, “translationX”, -500f, 0f); ObjectAnimator rotation = ObjectAnimator.ofFloat(v, “rotation”, 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(v, “alpha”, 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotation).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.addListener(new Animator.AnimatorListener() { @Override public void onAnimationStart(Animator animation) { Log.d(TAG, “ onAnimationStart “); } @Override public void onAnimationEnd(Animator animation) &#123; Log.d(TAG, &quot; onAnimationEnd &quot;); &#125; @Override public void onAnimationCancel(Animator animation) &#123; Log.d(TAG, &quot; onAnimationCancel &quot;); &#125; @Override public void onAnimationRepeat(Animator animation) &#123; Log.d(TAG, &quot; onAnimationRepeat &quot;); &#125; &#125;); animSet.start(); 下面是监听器，也可以用AnimatorListenerAdapter 选择想要重写的方法 XML支持的Property Animation tags 对应代码中的ValueAnimator - ObjectAnimator - AnimatorSet - 这里也需要建个文件夹存放 The property animation system lets you declare property animations with XML instead of doing it programmatically. By defining your animations in XML, you can easily reuse your animations in multiple activities and more easily edit the animation sequence. To distinguish animation files that use the new property animation APIs from those that use the legacy view animation framework, starting with Android 3.1, you should save the XML files for property animations in the **res/animator/ **directory. 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;100&quot; android:valueType=&quot;intType&quot; /&gt;加载Animator anim = AnimatorInflater.loadAnimator(this, R.animator.propery_first); anim.setTarget(v); anim.start(); 根据官方例子,也可以强转ValueAnimator，添加监听器,其他形式的xml文件也类似 设置动画参数 12345678910111213141516// ValueAnimator采用&lt;animator&gt; 标签&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:valueFrom=&quot;0&quot; // 初始值 android:valueTo=&quot;100&quot; // 结束值 android:valueType=&quot;intType&quot; // 变化值类型 ：floatType &amp; intType android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲/&gt; https://blog.csdn.net/carson_ho/article/details/72909894 参考：http://blog.csdn.net/guolin_blog/article/details/43536355","categories":[{"name":"anim","slug":"anim","permalink":"https://noteforme.github.io/categories/anim/"}],"tags":[]},{"title":"PerformancePatterns","slug":"PerformancePatterns","date":"2017-08-16T01:56:08.000Z","updated":"2022-06-12T03:17:58.718Z","comments":true,"path":"2017/08/16/PerformancePatterns/","link":"","permalink":"https://noteforme.github.io/2017/08/16/PerformancePatterns/","excerpt":"","text":"https://developer.android.com/topic/performance/vitals Vitals根据vitas提示确认解决方案 https://support.google.com/googleplay/android-developer/answer/9844486?visit_id=637902898856761718-3795427085&amp;rd=1&amp;hl=zh-Hans#zippy= https://play.google.com/console/u/0/developers/5313279702199603526/app/4975846927718251228/vitals/metrics/overview?days=30 https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE Vitals vs firebasehttps://developer.android.google.cn/distribute/best-practices/launch/debug-crashes?hl=zh-cn 红橙https://www.jianshu.com/p/888d959683a4 https://juejin.cn/post/6950608825942868004 图片处理 https://developer.android.com/topic/performance/graphics/index.htmlhttps://developer.android.com/topic/performance/graphics/load-bitmap.html#read-bitmap 性能优化 https://mp.weixin.qq.com/s/ceXsH06fUFa7y4lzi4uXzw https://mp.weixin.qq.com/s/xqrGukIqA2zpGsGzah2EzA 包体积优化 https://juejin.im/post/6854573210408189960 https://mp.weixin.qq.com/s/jnZpgaRFQT5ULk9tHWMAGg https://www.jianshu.com/p/fba7b43bdc9c 布局优化https://www.jianshu.com/p/ee9e4b8cb95f strict mode https://www.bilibili.com/video/BV1wh411H78Z?p=7 Troubleshooting app performance issues with System Trace in Android Studio https://www.youtube.com/watch?v=EjmIit_amnE 硬件加速原理 相信经常看到有的文章说开启硬件加速解决卡的问题，但硬件加速是什么呢？ 硬件加速的主要原理是通多底层逻辑，将CPU不擅长的图形计算转换成GPU专用指令，让更擅长图形计算的GPU来完成渲染。 硬件加速过程中包含两个步骤 ： 构建阶段 ： 遍历所有视图，将需要绘制的操作缓存下来，交给单独的Render线程使用GPU进行硬件加速渲染。(这一阶段在主线程中使用CPU构建) 绘制阶段 ： 调用OpenGL（即使用GPU）对构建好的视图进行绘制渲染，绘制的内容保存在Graphic Buffer 并交由 SurfaceFlinger 显示。(Android 5.0+ 使用Render Thread线程，专门负责 UI 渲染和动画显示。) 以上证得硬件加速具有不错的优点，但它不是万能的。 我们平时用的时候可能是直接在Application中用，一锅端，这并不严谨，因为硬件加速还没法做到支持所有的绘制操作（比如复杂的自定义View），这样的话就会造成一定的影响： \\1. 像素错位等视觉问题 \\2. 不同设备版本API兼容问题 https://segmentfault.com/a/1190000041325538 Apk瘦身 https://blog.csdn.net/qq_32175491/article/details/80071987 也有不建议删SO库的说法 http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems/ Code CheckCode Review之前可以做的事情. https://developer.android.google.cn/studio/write/annotations https://www.jianshu.com/p/cf1b97941856 https://www.cnblogs.com/endv/p/12541442.html","categories":[],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://noteforme.github.io/tags/Performance/"}]},{"title":"TouchEvent2","slug":"TouchEvent2","date":"2017-08-13T14:01:04.000Z","updated":"2021-08-19T11:11:44.255Z","comments":true,"path":"2017/08/13/TouchEvent2/","link":"","permalink":"https://noteforme.github.io/2017/08/13/TouchEvent2/","excerpt":"","text":"Android touch Event 事件分发其实就是对MotionEvent事件得分发过程,当MotionEvet产生后，系统需要把这个事件传递给一个具体得View,而这个传递得过程就是分发过程 概述 为什么会有事件分发机制? Android得View是树形结构，绘制得时候遍历子View,他们必定是会重合分布，那么当我们点击得时候，是应该谁来响应这个事件呢? 然后才有事件分发 Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; … －&gt; View 整个分发的宏观过程,Android群英传 这本书描述的很清晰,然后配合 Android开发艺术探索，的源码分析，简直天作之合． 主要方法 method事件分发机制事由 Activity -&gt; ViewGroup -&gt; View 方向上得传递通过三个很重要得方法共同完成 dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent dispatchTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 事件分发 onInterceptTouchEvent() 属性 介绍 作用 拦截事件 调用时刻 在ViewGroup的dispatchTouchEvent()内部调用 onTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 事件消费 调用时刻 在dispatchTouchEvent()内部调用 三个方法的关系 可以用 singwhatiwanna 写的伪代码表示: 123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean consume = false; if(onInterceptTouchEvent(ev))&#123; consume = onTouchEvent(ev); &#125;else&#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; dispatchTouchEvent ：对于ViewGroup，点击事件产生后首先会传递给它， onInterceptTouchEvent(ev）: 如果方法返回true,则拦截事件,事件就交给当前ViewGroup处理,接着调用当前 ViewGroup的onTouchEvent.如果返回flase,就交给它的子元素,子元素的dispatchTouchEvent就会调用 onTouchEvent : 如果返回false，那么父容器的onTouchEvent将会被调用. Activity ViewGroup Viewsource code Activity 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; ViewGroup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&#x27;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; View 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don&#x27;t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 图ACTION_DOWN分析1.MotionEvent.ACTION_DOWN 都不拦截 Activity dispatchTouchEvent() 1 =&gt; 5 RootView dispatchTouchEvent() 29 =&gt; (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT)==0 ​ =&gt; 33 =&gt; 58 =&gt; 68 =&gt; 122 =&gt; dispatchTransformedTouchEvent有子view重复上面流程 =&gt; dispatchTransformedTouchEvent没有子View =&gt; View1 dispatchTouchEvent() 36 =&gt; 54 result=false =&gt;事件开始往回传=&gt; ViewGroupA 122=&gt;163=&gt; 164 dispatchTransformedTouchEvent child传null =&gt;开始调用View dispatchTouchEvent()=false =&gt; 事件继续回传=&gt; RootView =&gt;重复上面ViewGroupA的流程 =&gt; 164 handled=false =&gt; Activity =&gt;5 getWindow().superDispatchTouchEvent(ev) =&gt; onTouchEvent(ev); 图ACTION_MOVE UP分析 RootView onInterceptTouchEvent =true Activity dispatchTouchEvent() 1 =&gt; 5 RootView dispatchTouchEvent() 29 =&gt; (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT)==0 =&gt; 164 &gt;handler = false =&gt; Activity =&gt;5 getWindow().superDispatchTouchEvent(ev) =&gt; onTouchEvent(ev); 图ACTION_MOVE UP分析 View touchevent = true Activity dispatchTouchEvent() 1 =&gt; 5 RootView dispatchTouchEvent() 29 =&gt; 41 =&gt; 170 =&gt; 183 遍历查找消费event的View =&gt; handled = true Activity =&gt;5 getWindow().superDispatchTouchEvent(ev) =&gt; onTouchEvent(ev); View点击事件处理(不是ViewGroup) onTouch返回false 1234567891011121314button2.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(TAG, &quot;执行 button2 onTouch() 动作&quot; + event.getAction()); return false; &#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d(TAG, &quot;you clicked button2&quot;); &#125; &#125;); 打印结果: D/DispatchActivity: 执行 button2 onTouch() 动作0 D/DispatchActivity: 执行 button2 onTouch() 动作1 D/DispatchActivity: you clicked button2 onTouch返回trueLog打印结果: D/DispatchActivity: 执行 button2 onTouch() 动作0D/DispatchActivity: 执行 button2 onTouch() 动作1 不同得返回值,得到不同得结果 看下为什么看下 View的dispatchTouchEvent（） API 23 源码的事件分发流程点击 Button寻找dispatchTouchEvent() Button -&gt; dispatchTouchEvent() -&gt; TextView-&gt;View (点击Button后就会找 dispatchTouchEvent()，Button没有，然后就去父类TextView还是没找到，最后在View找到了) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */ public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don&#x27;t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 分析第34行,result默认为false,li.mOnTouchListener.onTouch(this, event))默认也是false,接着第40行,onTouchEvent(event)) 方法也会得到执行 -&gt; performClick()会给点击事件 一个回调; 以下内容参考: gcssloopViewGroup的 dispatchTouchEvent()解析http://blog.csdn.net/guolin_blog/article/details/9097463 https://mp.weixin.qq.com/s/KU32XpwDFBOl8ueXIaA8Tw","categories":[{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"}],"tags":[{"name":"TouchEvent","slug":"TouchEvent","permalink":"https://noteforme.github.io/tags/TouchEvent/"}]},{"title":"AndroidStudioTool","slug":"AndroidStudioTool","date":"2017-08-13T10:20:17.000Z","updated":"2022-06-12T03:17:58.589Z","comments":true,"path":"2017/08/13/AndroidStudioTool/","link":"","permalink":"https://noteforme.github.io/2017/08/13/AndroidStudioTool/","excerpt":"","text":"降低 compileSdkVersion 版本 有时候需要看低版本的源码，就要修改compileSdkVersion版本 修改编译版本 targetSdkVersion版本修改成 21 然后 compile ‘com.android.support:appcompat-v7:21.+’ 继承的AppCompatActivity改成Activity 编译后报错 Error:(11) No resource identifier found for attribute ‘roundIcon’ in package ‘android’ 根据错误删除 android:roundIcon ,然后编译 参考：http://blog.csdn.net/hyr83960944/article/details/39941683 android stuido代理普通代理修改Gradle配置文件后就一直卡在那，在 build.gradle值修改下面如果用了ss代理，在ubuntu设置http没用，可以在 工程根目录下 gradle.properties 添加 org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080 参考: https://www.zhihu.com/question/37810416 平常github下载项目导入AndroidStudio直接卡死，心里真不是…., 目前实验一种方式应该会快点修改 gradle\\wrapper\\gradle-wrapper.properties下的 distributionUrl=https://services.gradle.org/distributions/gradle-3.3-all.zip， 我的AndroidStudio默认是这个 所以就修改成这样的. jcenter库代理 (这几句话花了关键得一天时间)前天升级了系统，之前下得Demo一直跑不起来，’https://jitpack.io&#39;得文件一直下载不下来 ＞错误： jcenter.bintray.com:443 failed to respond 折腾了一天终于弄好了,需要设置proxy代理,把socket流量转为http 然后在 Ｍanual proxy configuration下面选择HTTP 填上 127.0.0.1 8118 就可以下载jitpack里面得文件了 阿里云镜像 /Users/john/.gradle/init.gradle 下载gradle 有时候想用新的的gradle，但是新的更新几十M的文件，一天都不一定能下下来 直接去官网下载 https://gradle.org/releases/ ，对应版本的zip文件，放到相应目录 比如我的就是 C:\\Users\\Administrator.gradle\\wrapper\\dists\\gradle-3.3-all\\55gk2rcmfc6p2dg9u9ohc3hw9\\ 还一个是在${home}/.gradle目录下得gradle.properties文件配置应该也是可以的 快捷键 Ctrl＋F12，可以显示当前文件的结构Ctrl＋Shift＋F7 可以高亮当前元素在当前文件中的使用Ctrl＋E，可以显示最近编辑的文件列表 Alt＋Up 和 Alt＋Down可在方法间快速移动 Shift＋Click可以关闭文件 Ctrl+ H 查看类的继承关系 Ctrl＋Alt＋B可以跳转到抽象方法的实现 Ctrl＋Q可以看JavaDoc 全局修改快捷键Shift+F6 想要将里面的cardName全部替换成userName，则选中其中一个，按shift+f6回车即可批量修改。 参考：https://github.com/1sters/Android-Studio-Guide/blob/master/tips-shortcuts.md 常用快捷键:https://mp.weixin.qq.com/s/lYBHtg342-t3NkPPY9E-YQ Build Variants 设置成debug 12345debug &#123; debuggable false minifyEnabled false signingConfig signingConfigs.debug &#125; debuggable设置成 true SVN分支合并 主干,主干新增文件被删除弄了两个多小时，说多了都是泪 https://www.jianshu.com/p/e50af339259f 无线调试https://juejin.im/entry/5a6a7e69518825733b0f1635 设置侦听断开 : 123adb tcpip 8888adb connect 192.168.31.76:8888 安装包安装 adb -s acac34d7 install /e/JYWORK/ win10 jdk环境变量设置在系统变量中设置 ,注意要点开编辑文本是不是之前输入的有 “” Android stuido发布项目Jcenter12gradlew clean build bintrayUpload -PbintrayUser&#x3D;blogforme -PbintrayKey&#x3D;4c7511bba437157d77baeb5c17d339ce92c2bee7 -PdryRun&#x3D;false https://github.com/novoda/bintray-release https://www.jianshu.com/p/9f81d5b5a451 https://blog.csdn.net/qq_32452623/article/details/79282605 依赖其他moudlehttps://mp.weixin.qq.com/s/trAxRzz573TFyJk2klKdag android stuido 日志过滤不需要的日志123^(?!.*(eglMakeCurrent|OpenGLRenderer)).*$eglMakeCurrent OpenGLRenderer两个包含需要过滤的字段 留下需要的日志 https://www.jianshu.com/p/11e56991ff28 Emulator显示","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"BroadcastReceiver","slug":"BroadcastReceiver","date":"2017-08-12T07:44:53.000Z","updated":"2021-08-19T11:11:43.750Z","comments":true,"path":"2017/08/12/BroadcastReceiver/","link":"","permalink":"https://noteforme.github.io/2017/08/12/BroadcastReceiver/","excerpt":"","text":"BroadcastReceiver https://developer.android.com/guide/components/broadcasts.html 广播使应用程序间传输传输信息的机制，主要用来监听系统或者应用发出的广播信息。 BroadcastReceiver使用注意 当系统或应用发出广播时，扫描系统所有广播接收者(无论时静态注册还是动态注册方式)，通过action匹配將广播发给相应接收者，接收者收到 广播后会产生一个广播实例，执行onReceiver()，这个实例生命周期只有10秒,10秒内没执行结束onReceiver，系统会报错,所以不能再onReceiver()执行耗时操作,onReceiver结束后，实例被销毁. BroadcastReceiver注册方式Context-registered receivers (动态注册)注册 12345678910private UpdateBroadcastReceiver updateBr;@Overrideprotected void onStart() &#123; super.onStart(); updateBr = new UpdateBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(ACTION_UPDATE); registerReceiver(updateBr, intentFilter);&#125; 发送注销广播 123456789101112131415//点击发送广播public void btBroadcast(View v) &#123; Intent intentBroad = new Intent(); intentBroad.setAction(ACTION_UPDATE); sendBroadcast(intentBroad);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (updateBr != null) &#123; unregisterReceiver(updateBr); &#125;&#125; 注意:这种注册方式 AndroidManifest.xml不用做任何操作 静态注册Android 8.0之后，静态注册是无法接收隐式广播的，而默认情况下，我们发出的广播都是隐式广播，因此一定要调用setPackage()方法，指定这条广播是发送给哪个应用程序的，从而让它变成一条显示广播。（第一行代码） AndroidManifest.xml添加 12345&lt;receiver android:name=&quot;.broadcastservice.UpdateBroadcastReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.UpdateBroadcastReceiver&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 注意 为了杜绝APP滥用资源,官方对有的广播做了限制 Note: If your app targets API level 26 or higher, you cannot use the manifest to declare a receiver for implicit broadcasts (broadcasts that do not target your app specifically), except for a few implicit broadcasts that are exempted from that restriction. In most cases, you can use scheduled jobs instead. 1intent.setPackage(&quot;com.comm.util&quot;) Sending broadcasts方式普通广播有序广播FirstOrderBroadCast 12345678910class FirstOrderBroadCast : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; Log.e(&quot;receive&quot;, &quot;Low&quot;); val code = 1 val data = &quot;hello I am FirstOrderBroadCast&quot; val bundle: Bundle? = Bundle() bundle?.putString(&quot;first&quot;,&quot;from FirstOrderBroadCast&quot;) setResult(code, data, bundle) &#125;&#125; SecondOrderBroadCast 1234567891011class SecondOrderBroadCast : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; Log.e(&quot;receive&quot;, &quot;Mid&quot;) //获取上一个广播接收器结果 val code = resultCode val data = resultData var bundleResult = getResultExtras(true).get(&quot;first&quot;); Log.e(&quot;receive&quot;, &quot;获取到上一个广播接收器结果：code= $code data= $data bundleResult $bundleResult&quot;) &#125;&#125; ThirdOrderBroadCast 12345678910class ThirdOrderBroadCast : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; Log.e(&quot;receive&quot;, &quot;High&quot;) //传递结果到下一个广播接收器 val code = 3 val data = &quot;hello&quot; val bundle: Bundle? = null setResult(code, data, bundle) &#125;&#125; AndroidMnifest.xml 123456789101112131415&lt;receiver android:name=&quot;.component.broadcastservice.FirstOrderBroadCast&quot;&gt; &lt;intent-filter android:priority=&quot;3000&quot;&gt; &lt;action android:name=&quot;com.broadcast.android&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.component.broadcastservice.SecondOrderBroadCast&quot;&gt; &lt;intent-filter android:priority=&quot;2000&quot;&gt; &lt;action android:name=&quot;com.broadcast.android&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.component.broadcastservice.ThirdOrderBroadCast&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;com.broadcast.android&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; or 1234updateBr = UpdateBroadcastReceiver()val intentFilter = IntentFilter()intentFilter.addAction(UpdateBroadcastReceiver.ACTION_UPDATE)registerReceiver(updateBr, intentFilter) 使用 BroadcastReceiverActivity 123456val intent = Intent()intent.action = &quot;com.broadcast.android&quot;bt_order_broadcast.setOnClickListener &#123; sendOrderedBroadcast(intent,null)&#125; 运行结果 1234E/receive: LowE/receive: MidE/receive: 获取到上一个广播接收器结果：code= 1 data= hello I am FirstOrderBroadCast bundleResult from FirstOrderBroadCastE/receive: High LocalBroadcastManager.sendBroadcastmethod sends broadcasts to receivers that are in the same app as the sender. If you don’t need to send broadcasts across apps, use local broadcasts.he implementation is much more efficient (no interprocess communication needed) and you don’t need to worry about any security issues related to other apps being able to receive or send your broadcasts.(应用内发送广播) 发送 123val intentBroad = Intent()intentBroad.action = UpdateBroadcastReceiver.ACTION_UPDATELocalBroadcastManager.getInstance(this).sendBroadcast(intentBroad) 注册 1234567updateBr = UpdateBroadcastReceiver()val intentFilter = IntentFilter()intentFilter.addAction(UpdateBroadcastReceiver.ACTION_UPDATE)registerReceiver(updateBr, intentFilter)updateBr?.let &#123; LocalBroadcastManager.getInstance(this).registerReceiver(it,intentFilter)&#125; https://blog.csdn.net/qq_30379689/article/details/53341313","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"SERVICE","slug":"SERVICE","date":"2017-08-11T10:21:06.000Z","updated":"2025-01-04T13:47:06.100Z","comments":true,"path":"2017/08/11/SERVICE/","link":"","permalink":"https://noteforme.github.io/2017/08/11/SERVICE/","excerpt":"","text":"Servicehttps://developer.android.com/guide/components/services https://developer.android.com/reference/android/app/Service Service启动服务两种方式 startService bindService startService一个Service被startService多次启动,那么onCreate只会调用一次,onstart()会被调用多次, StartServcie:一旦启动，服务即可在后台无限期运行，即使启动服务的Ａctivity已被销毁也不受影响,直到调用stipService，或自身的stopSelf方法。内存不足系统也会结束服务。 bindService客户端通过IBinder接口于服务进行通信,客户端可以调用unbindServie关闭连接,当所有客户端关闭连接后系统会销毁服务.启动Log日志I&#x2F;LearnService: – onCreate() –I&#x2F;LearnService: – onBind() – 一个Service被某个Activity调用Context.bindService绑定启动，不管bindService调用几次，onCreate方法只会调用一次,onStart不会调用. service 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class BluetoothService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); Timber.i(&quot; onCreate()&quot;); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Timber.i(&quot; onStartCommand()&quot;); String param = intent.getStringExtra(PARRAM); Timber.i(&quot;接受 &quot; + param); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Timber.i(&quot; onDestroy()&quot;); &#125; @Override public void onLowMemory() &#123; super.onLowMemory(); Timber.i(&quot;onLowMemory()&quot;); &#125; @Override public boolean onUnbind(Intent intent) &#123; Timber.i(&quot;onUnbind(intent)()&quot;); return super.onUnbind(intent); &#125; @Override public void onRebind(Intent intent) &#123; super.onRebind(intent); Timber.i(&quot;onRebind(intent)()&quot;); &#125; public class LocalBinder extends Binder &#123; public BluetoothService getService() &#123; return BluetoothService.this; &#125; &#125; private final IBinder mBinder = new LocalBinder(); @Nullable @Override public IBinder onBind(Intent intent) &#123; Timber.i(&quot;onBind(intent)()&quot;); return mBinder; &#125;&#125; 启动 bindService(intent,mServiceConnection,BIND_AUTO_CREATE); 回调 123456789101112ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBlueService = ((BluetoothService.LocalBinder)service).getService(); Timber.i(&quot;onServiceConnected(ComponentName name, IBinder service)&quot;); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Timber.i(&quot;onServiceDisconnected(ComponentName name)&quot;); &#125; &#125;; 先startService创建服务，然后bindService绑定，这时候调用stopService或stopSelf(),不会停止，只能使unbindService()停止服务 IntentService 通过HandlerThread单独开启一个线程一次处理所有的任务 不需要调用stopSelft()关闭服务，任务结束后自动关闭 1234567808-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onCreate() --08-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onStartCommand() --08-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onStartCommand() --08-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onStartCommand() --08-12 13:38:26.601 30532-30655/com.hyhy.lern I/MyIntentService: do task108-12 13:38:26.601 30532-30655/com.hyhy.lern I/MyIntentService: do task208-12 13:38:26.601 30532-30655/com.hyhy.lern I/MyIntentService: do task108-12 13:38:26.617 30532-30532/com.hyhy.lern I/MyIntentService: -- onDestroy() -- https://developer.android.com/training/run-background-service/create-service.html onStartCommand()1. onStartCommand方式中，返回START_STICKY 首先我们来看看onStartCommand都可以返回哪些值： 调用Context.startService方式启动Service时，如果Android面临内存匮乏，可能会销毁当前运行的Service，待内存充足时可以重建Service。而Service被Android系统强制销毁并再次重建的行为依赖于Service的onStartCommand()方法的返回值。 START_NOT_STICKY 如果返回START_NOT_STICKY，表示当Service运行的进程被Android系统强制杀掉之后，不会重新创建该Service。当然如果在其被杀掉之后一段时间又调用了startService，那么该Service又将被实例化。那什么情境下返回该值比较恰当呢？ 如果我们某个Service执行的工作被中断几次无关紧要或者对Android内存紧张的情况下需要被杀掉且不会立即重新创建这种行为也可接受，那么我们便可将 onStartCommand的返回值设置为START_NOT_STICKY。 举个例子，某个Service需要定时从服务器获取最新数据：通过一个定时器每隔指定的N分钟让定时器启动Service去获取服务端的最新数据。当执行到Service的onStartCommand时，在该方法内再规划一个N分钟后的定时器用于再次启动该Service并开辟一个新的线程去执行网络操作。假设Service在从服务器获取最新数据的过程中被Android系统强制杀掉，Service不会再重新创建，这也没关系，因为再过N分钟定时器就会再次启动该Service并重新获取数据 START_STICKY 如果返回START_STICKY，表示Service运行的进程被Android系统强制杀掉之后，Android系统会将该Service依然设置为started状态（即运行状态），但是不再保存onStartCommand方法传入的intent对象，然后Android系统会尝试再次重新创建该Service，并执行onStartCommand回调方法，但是onStartCommand回调方法的Intent参数为null，也就是onStartCommand方法虽然会执行但是获取不到intent信息。如果你的Service可以在任意时刻运行或结束都没什么问题，而且不需要intent信息，那么就可以在onStartCommand方法中返回START_STICKY，比如一个用来播放背景音乐功能的Service就适合返回该值。 START_REDELIVER_INTENT 如果返回START_REDELIVER_INTENT，表示Service运行的进程被Android系统强制杀掉之后，与返回START_STICKY的情况类似，Android系统会将再次重新创建该Service，并执行onStartCommand回调方法，但是不同的是，Android系统会再次将Service在被杀掉之前最后一次传入onStartCommand方法中的Intent再次保留下来并再次传入到重新创建后的Service的onStartCommand方法中，这样我们就能读取到intent参数。只要返回START_REDELIVER_INTENT，那么onStartCommand重的intent一定不是null。如果我们的Service需要依赖具体的Intent才能运行（需要从Intent中读取相关数据信息等），并且在强制销毁后有必要重新创建运行，那么这样的Service就适合返回START_REDELIVER_INTENT。 https://juejin.im/post/5b1747e5e51d45069a39ef45 https://developer.android.com/guide/components/bound-services#kotlin bindService callback 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BindingActivity : Activity() &#123; private lateinit var mService: LocalService private var mBound: Boolean = false /** Defines callbacks for service binding, passed to bindService() */ private val connection = object : ServiceConnection &#123; override fun onServiceConnected(className: ComponentName, service: IBinder) &#123; // We&#x27;ve bound to LocalService, cast the IBinder and get LocalService instance val binder = service as LocalService.LocalBinder mService = binder.getService() mBound = true &#125; override fun onServiceDisconnected(arg0: ComponentName) &#123; mBound = false &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.main) &#125; override fun onStart() &#123; super.onStart() // Bind to LocalService Intent(this, LocalService::class.java).also &#123; intent -&gt; bindService(intent, connection, Context.BIND_AUTO_CREATE) &#125; &#125; override fun onStop() &#123; super.onStop() unbindService(connection) mBound = false &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ fun onButtonClick(v: View) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. val num: Int = mService.randomNumber Toast.makeText(this, &quot;number: $num&quot;, Toast.LENGTH_SHORT).show() &#125; &#125;&#125; get Service object in this place 12val binder = service as LocalService.LocalBindermService = binder.getService() Using a Messenger If you need your service to communicate with remote processes, then you can use a Messenger to provide the interface for your service. stopself()​ 目前测试只有在onStartCommand()有效，多次点击startService(intent),startId持续递增. onRebind()什么情况下执行 验证方法: startService(intent) 启动Service - bindService() 绑定Service - unBindService()解绑- bindService() 继续绑定 就会执行onRebind() 多个acitivty与service通信https://www.jianshu.com/p/9885acf65405 https://blog.csdn.net/pihailailou/article/details/78588496 foreground servicehttps://developer.android.com/develop/background-work/services/fgs A foreground service performs some operation that is noticeable to the user. For example, an audio app would use a foreground service to play an audio track. Foreground services must display a Notification. Foreground services continue running even when the user isn’t interacting with the app. When you use a foreground service, you must display a notification so that users are actively aware that the service is running. This notification cannot be dismissed unless the service is either stopped or removed from the foreground. https://developer.android.com/develop/background-work/services#Types-of-services https://www.jianshu.com/p/5505390503fa background serviceA background service performs an operation that isn’t directly noticed by the user. For example, if an app used a service to compact its storage, that would usually be a background service. Note: If your app targets API level 26 or higher, the system imposes restrictions on running background services when the app itself isn’t in the foreground. In most situations, for example, you shouldn’t access location information from the background. Instead, schedule tasks using WorkManager. codelab https://github.com/android/codelab-android-workmanager/blob/master/app/src/main/java/com/example/background/BlurActivity.kt https://developer.android.com/codelabs/basic-android-kotlin-compose-workmanager#12 JobIntentServiceThe Android framework also provides the IntentService subclass of Service that uses a worker thread to handle all of the start requests, one at a time. Using this class is not recommended for new apps as it will not work well starting with Android 8 Oreo, due to the introduction of Background execution limits. Moreover, it’s deprecated starting with Android 11. You can use JobIntentService as a replacement for IntentService that is compatible with newer versions of Android. https://developer.android.com/develop/background-work/services#Types-of-services In most cases, apps can work around these limitations by using JobScheduler jobs. This approach lets an app arrange to perform work when the app isn’t actively running, but still gives the system the leeway to schedule these jobs in a way that doesn’t affect the user experience https://developer.android.com/develop/background-work/background-tasks WorkMangerUse WorkManager for reliable work,WorkManager handles three types of persistent work: Immediate: Tasks that must begin immediately and complete soon. May be expedited. Long Running: Tasks which might run for longer, potentially longer than 10 minutes. Deferrable: Scheduled tasks that start at a later time and can run periodically. Figure 1 outlines how the different types of persistent work relate to one another. https://developer.android.com/topic/libraries/architecture/workmanager https://medium.com/androiddevelopers/introducing-workmanager-2083bcfc4712 https://android-developers.googleblog.com/2018/10/modern-background-execution-in-android.html OneTimeWork123456789101112// Create and enqueue the workerval workRequest = OneTimeWorkRequestBuilder&lt;LogWorker&gt;().build()workManager.enqueue(workRequest)class LogWorker(context: Context, workerParams: WorkerParameters) : Worker(context, workerParams) &#123; override fun doWork(): Result &#123; Log.d(&quot;LogWorker&quot;, &quot;Background task executed!&quot;) return Result.success() &#125;&#125; https://github.com/android/codelab-android-workmanager https://developer.android.com/codelabs/basic-android-kotlin-compose-workmanager#12 Schedule expedited workStarting in WorkManager 2.7, your app can call setExpedited() to declare that a WorkRequest should run as quickly as possible using an expedited job. 123456private fun scheduleExpeditedWork() &#123; val workRequest: WorkRequest = OneTimeWorkRequestBuilder&lt;LogWorker&gt;() .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST) .build() WorkManager.getInstance(this).enqueue(workRequest)&#125; PeriodicWorkPeriodic work has a minimum interval of 15 minutes. https://developer.android.com/reference/androidx/work/PeriodicWorkRequest 1234567private fun schedulePeriodicWork() &#123; val periodicWorkRequest = PeriodicWorkRequestBuilder&lt;LogWorker&gt;(15, TimeUnit.MINUTES) // every 15 minutes .build() // Enqueue the work request WorkManager.getInstance(this).enqueue(periodicWorkRequest)&#125; &#x2F;&#x2F; The code is not verified by the log. migrateMigrating from Firebase JobDispatcher to WorkManager https://developer.android.com/develop/background-work/background-tasks/persistent/migrate-from-legacy/firebase https://medium.com/androiddevelopers/introducing-workmanager-2083bcfc4712","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"Accessibility","slug":"Accessibility","date":"2017-08-09T13:27:05.000Z","updated":"2022-05-06T11:24:51.146Z","comments":true,"path":"2017/08/09/Accessibility/","link":"","permalink":"https://noteforme.github.io/2017/08/09/Accessibility/","excerpt":"","text":"先上官网地址 https://developer.android.com/guide/topics/ui/accessibility/services.html下面的是例子 https://developer.android.com/training/accessibility/index.html 然后是codelab 看看 https://codelabs.developers.google.com/codelabs/developing-android-a11y-service/index.html?index=..%2F..%2Findex#0 这是codelab github上的地址 https://github.com/googlecodelabs/android-accessibility一、简单实现1、创建一个 MyAccessibilityService类 继承 AccessibilityService … public class MyAccessibilityService extends AccessibilityService &#123; @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; &#125; @Override public void onInterrupt() &#123; &#125; }… 2、创建一个values下创建XML文件夹 3、 实现 onServiceConnected() @Override public void onServiceConnected() &#123; // Set the type of events that this service wants to listen to. Others // won&#39;t be passed to this service. info.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED | AccessibilityEvent.TYPE_VIEW_FOCUSED; // If you only want this service to work with specific applications, set their // package names here. Otherwise, when the service is activated, it will listen // to events from all applications. info.packageNames = new String[] &#123;&quot;com.example.android.myFirstApp&quot;, &quot;com.example.android.mySecondApp&quot;&#125;; // Set the type of feedback your service will provide. info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN; // Default services are invoked only if no package-specific ones are present // for the type of AccessibilityEvent generated. This service *is* // application-specific, so the flag isn&#39;t necessary. If this was a // general-purpose service, it would be worth considering setting the // DEFAULT flag. // info.flags = AccessibilityServiceInfo.DEFAULT; info.notificationTimeout = 100; this.setServiceInfo(info); Log.i(&quot;test&quot;,&quot;测试&quot;); &#125; 4、实现 onAccessibilityEvent方法 @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; final int eventType = event.getEventType(); String eventText = null; switch(eventType) &#123; case AccessibilityEvent.TYPE_VIEW_CLICKED: eventText = &quot;Focused: &quot;; break; case AccessibilityEvent.TYPE_VIEW_FOCUSED: eventText = &quot;Focused: &quot;; break; &#125; eventText = eventText + event.getContentDescription(); // Do something nifty with this text, like speak the composed string // back to the user. speakToUser(eventText); &#125; ... 然后就可以开启辅助功能，看下log","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"OKHTTP","slug":"OKHTTP","date":"2017-08-07T02:04:29.000Z","updated":"2024-09-15T10:08:39.154Z","comments":true,"path":"2017/08/07/OKHTTP/","link":"","permalink":"https://noteforme.github.io/2017/08/07/OKHTTP/","excerpt":"","text":"Okhttp优势https://square.github.io/okhttp/ OkHttp is an HTTP client that’s efficient by default: HTTP&#x2F;2 support allows all requests to the same host to share a socket. Connection pooling reduces request latency (if HTTP&#x2F;2 isn’t available). Transparent GZIP shrinks download sizes. Response caching avoids the network completely for repeat requests. okhttp的请求原理 OkHttp的内部实现通过一个责任链模式完成，将网络请求的各个阶段封装到各个链条中，实现了各层的解耦。 OKHttp请求整体流程介绍整个网络请求过程大致如上所示 通过建造者模式构建 OKHttpClient 与 Request OKHttpClient 通过 newCall 发起一个新的请求 通过分发器维护请求队列与线程池，完成请求调配 通过五大默认拦截器完成请求重试，缓存处理，建立连接等一系列操作得到网络请求结果 OKHttp分发器是怎样工作的分发器的主要作用是维护请求队列与线程池,比如我们有100个异步请求，肯定不能把它们同时请求，而是应该把它们排队分个类，分为正在请求中的列表和正在等待的列表， 等请求完成后，即可从等待中的列表中取出等待的请求，从而完成所有的请求 而这里同步请求各异步请求又略有不同 同步请求123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; 因为同步请求不需要线程池，也不存在任何限制。所以分发器仅做一下记录。后续按照加入队列的顺序同步请求即可 异步请求最新的master分支 12345678910111213141516171819private fun promoteAndExecute(): Boolean &#123; this.assertThreadDoesntHoldLock() val executableCalls = mutableListOf&lt;AsyncCall&gt;() val isRunning: Boolean synchronized(this) &#123; val i = readyAsyncCalls.iterator() // 取出待执行的任务，根据条件添加到runningAsyncCalls while (i.hasNext()) &#123; val asyncCall = i.next() println(&quot;runningAsyncCalls $&#123;runningAsyncCalls.size&#125;&quot;) if (runningAsyncCalls.size &gt;= this.maxRequests) break // Max capacity. if (asyncCall.callsPerHost.get() &gt;= this.maxRequestsPerHost) continue // Host max capacity. i.remove() asyncCall.callsPerHost.incrementAndGet() executableCalls.add(asyncCall) runningAsyncCalls.add(asyncCall) &#125; isRunning = runningCallsCount() &gt; 0 &#125; 所有的请求都会先添加到readyAsyncCalls，当正在执行的任务未超过最大限制64，并且同一 Host 的请求不超过5个，则会添加到正在执行队列，同时提交给线程池。每个任务完成后，都会调用分发器的 finished 方法,这里面会取出等待队列中的任务继续执行. &#x2F;&#x2F; 可以尝试修改 maxRequestsPerHost &#x3D;12,maxRequests &#x3D; 10 123for (int i =0 ; i &lt; 20;i++)&#123; client.newCall(request).enqueue(callback);&#125; 根据请求runningAsyncCalls.size 打印结果。可以看到运行状态 okhttp线程使用方式 根据线程池执行流程： 一开始看了网上视频，就说Okhttp是自驱动循环调用，相对于AsyncTask的优势就是 并发执行，但是这两条不就矛盾了吗，既然环形链式调用，怎么能并发呢。就从源码中找答案。 看了bi站的视频，超过5个在队列中的请求，应该是完成一个网络请求,继续从队列中取出，任务继续执行。 Dispatcher 最大请求数量 runningAsyncCalls 运行时的最大请求数量64,只有多个不同的host请求才能可能让走到下面代码.因为还有 if (asyncCall.callsPerHost.get() &gt;&#x3D; this.maxRequestsPerHost)这个条件限制. 1234if (runningAsyncCalls.size &gt;= this.maxRequests)&#123; println(&quot;promoteAndExecute &gt;= maxRequests&quot; ) break &#125; Okhttp 异步请求维护的两个队列 Dispatcher.java 1234567891011121314151617181920212223242526272829303132333435363738 /** Ready async calls in the order they&#x27;ll be run. */ private val readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;() /** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */ private val runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()private int maxRequests = 64;private int maxRequestsPerHost = 5;synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125;可以看到提交任务 &gt;5时，才会被添加到readyAsyncCalls队列中。&lt;5的任务直接提交。 private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); Log.i(&quot;Dispatcher&quot;, &quot;promoteCalls: 准备队列 &quot;+call.request().tag+&quot; 执行&quot;); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125; &#125;readyAsyncCalls不为空，然后取出一条，再执行，可以看到，默认情况下会有5条环形任务链。 if (asyncCall.callsPerHost.get() &gt;&#x3D; this.maxRequestsPerHost) 这个条件时如何判断的呢? 主要是下面的方法,默认forWebSocket&#x3D;&#x3D;true,走到条件里.如果AsyncCall已经存在队列中,那么就直接返回，把callsPerHost数值叠加.从而实现，上面的条件判断. 12345678910 // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.call.forWebSocket) &#123; val existingCall = findExistingCallWithHost(call.host) if (existingCall != null) call.reuseCallsPerHostFrom(existingCall) &#125;fun reuseCallsPerHostFrom(other: AsyncCall) &#123; this.callsPerHost = other.callsPerHost&#125; 问题 OkHttpThreadPool.java 123456789101112131415161718ThreadPoolExecutor executor = new ThreadPoolExecutor( 0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;());executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread()); while (true) &#123; &#125;&#125;);executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread());&#125;);executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread());&#125;); 运行结果: 任务1 Thread[pool-1-thread-1,5,main] 如果 new LinkedBlockingDeque&lt;&gt;(1)能正常执行，因为LinkedBlockingDeque加入 任务1 就满了，后面的任务创建非核心线程 但是有点疑惑，我这里核心线程是0，任务都加入到LinkedBlockingDeque, 按照线程池流程，非核心就不应该创建呀？怎么任务1就执行了呢 https://www.bilibili.com/video/BV15y4y1B7Rw?p=5https://mp.weixin.qq.com/s/BHDrSgwUVXkzvswK1khidQhttps://github.com/Snailclimb/programmer-advancementhttps://juejin.im/post/6855586076132655118https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485441&amp;idx=1&amp;sn=303a25ab02fa9f14a319923e6b0d9759&amp;chksm=cea247caf9d5cedc3a5e1d31f26c08d8ae4c11c349fbdc91ac1d90d8b35807517accb5f5d527&amp;token=2128752750&amp;lang=zh_CN#rd OkHttp里面设计模式？责任链模式OKHttp 的核心就是责任链模式，通过5个默认拦截器构成的责任链完成请求的配置 . 拦截器 12345678910111213141516+----------------------------------+| OkHttpInterceptor |+----------------------------------+| - configuration: Configuration || - enabled: boolean |+----------------------------------+| + intercept(chain: Chain): Response || + enable(): void || + disable(): void |+----------------------------------+| &lt;&lt;interface&gt;&gt; || Chain |+----------------------------------+| + request(): Request || + proceed(request: Request): Response |+----------------------------------+ OkHttp的拦截器：interceptor 12345678910111213141516171819internal fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain( call = this, interceptors = interceptors, index = 0, request = originalRequest, ) val response = chain.proceed(originalRequest) return response &#125; RetryAndFollowUpInterceptor：失败和重定向拦截器； BridgeInterceptor：负责将http协议必备的请求头加入其中(host),并添加一些默认的行为(gzip),获得结果后，调用cookie接口并解析GZIP数据。 CacheInterceptor：缓存处理相关的拦截器； ConnectInterceptor： 负责找到或者新建一个连接，并获取对应的socket流；在获得结果后不进行额外的处理。 CallServerInterceptor：进行真正的与服务器的通信，向服务器请求和读响应的拦截器； 最终网络返回的数据请求 1234567fun openResponseBody(response: Response): ResponseBody &#123; try &#123; val contentType = response.header(&quot;Content-Type&quot;) val contentLength = codec.reportedContentLength(response) val rawSource = codec.openResponseBodySource(response) val source = ResponseBodySource(rawSource, contentLength) return RealResponseBody(contentType, contentLength, source.buffer()) 构造者模式 : OkHttpClient ,Request,CacheControl 外观模式 : OkHttp使用了外观模式,将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端 OkHttpClient 统一暴露出来 工厂模式 : （在 Call 接口中，有一个内部工厂 Factory 接口）,只有一个实现RealCall， 而且这个RealCall在okhttp 代码中深度耦合，感觉这个工厂没什么用。 享元模式 : Dispatcher 的线程池中，不限量的线程池实现了对象复用,这个只是线程池的特性,线程池对线程的操作，没有什么代码的问题. 策略模式 : CacheInterceptor ,在响应数据的选择中使用了策略模式，选择缓存数据还是选择网络访问。 https://www.cnblogs.com/jimuzz/p/13935677.htmlhttps://www.codetd.com/article/4354895https://www.jianshu.com/p/d85e556b8da6 Okhttp Cachehttps://web.dev/articles/http-cache The app requests an API for the first time. 在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中： 缓存规则 这张图描述了整个缓存策略，其中有缓存 模块，代表了 强制缓存模块. 缓存应用假设缓存数据库存在缓存数据，仅基于强制缓存，请求数据的流程如下： 12345678910111213141516171819202122232425262728293031323334val client: OkHttpClient = OkHttpClient.Builder() .cache( Cache( directory = context.cacheDir, maxSize = 10L * 1024L * 1024L // 10 MiB ) ) .build() val request = Request.Builder() .url(&quot;https://publicobject.com/helloworld.txt&quot;) .build() val response1Body = client.newCall(request).execute().use &#123; if (!it.isSuccessful) throw IOException(&quot;Unexpected code $it&quot;) println(&quot;Response 1 response: $it&quot;) println(&quot;Response 1 cache response: $&#123;it.cacheResponse&#125;&quot;) println(&quot;Response 1 network response: $&#123;it.networkResponse&#125;&quot;) return@use it.body?.string() &#125; println(&quot;Response 1 response: $response1Body&quot;) val response2Body = client.newCall(request).execute().use &#123; if (!it.isSuccessful) throw IOException(&quot;Unexpected code $it&quot;) println(&quot;Response 2 response: $it&quot;) println(&quot;Response 2 cache response: $&#123;it.cacheResponse&#125;&quot;) println(&quot;Response 2 network response: $&#123;it.networkResponse&#125;&quot;) return@use it.body?.string() &#125; println(&quot;Response 2 response: $response2Body&quot;) println(&quot;Response 2 equals Response 1? &quot; + (response1Body == response2Body)) Response 1 cache response: null Response 1 network response: Response{protocol&#x3D;http&#x2F;1.1, code&#x3D;200, message&#x3D;OK, url&#x3D;https://publicobject.com/helloworld.txt} Response 2 cache response: Response{protocol&#x3D;http&#x2F;1.1, code&#x3D;200, message&#x3D;OK, url&#x3D;https://publicobject.com/helloworld.txt} Response 2 network response: null 强制缓存假设缓存数据库存在缓存数据，仅基于强制缓存，请求数据的流程如下： flowchart LR A[Start] --> B{private or public ?} B -- Yes --> C[max-age or Expires] B -- No ----> E[End] C -- No ----> D[no-cache ?] 强制缓存，类似这种图示。 可以看出，强制缓存如果生效，就不需要再和服务器发生交互。 强制缓存的实现依靠于Expires和Cache-Control这两个Header。 Expires&#x2F;Cache-Control Expires 是 HTTP&#x2F;1.0 所提供的对缓存的支持，通过这个 Header ，服务端可以告诉客户端缓存的过期时间，表示在过期时间内该资源都不会被更改，可以不用再向自己请求了。 例如：Expires: Mon, 22 Nov 2021 16:21:00 GMT 就标明了缓存的过期时间。 可以发现，它是由服务端生成的一个具体时间，浏览器之类的客户端应用会根据本地的时间与该具体时间对比，而客户端的时间可能跟服务端的时间有误差，这就会导致缓存命中的误差。 由于 Expires 存在上述的问题，因此在 HTTP&#x2F;1.1 协议中引入了 Cache-Control 机制，通过这个 Header 可以在服务端与客户端之间沟通缓存信息。常见的缓存指令如下 private 客户端可以缓存 public 客户端和代理服务器都可以缓存 max-age&#x3D;xxx 缓存数据在xxx秒后过期 no-cache 需要使用对比缓存来验证缓存数据 其中private是默认值。 在Http&#x2F;1.0版本，如果同时出现了 Cache-Control:max-age&#x3D; 以及 Expires，max-age指令会被忽略，以Expires为准； 在Http&#x2F;1.1版本，如果同时出现了 Cache-Control:max-age&#x3D; 以及 Expires，Expires会被忽略，以 max-age 为准。 如果有no-cache就考虑使用对比缓存 对比缓存假设缓存数据库存在缓存数据，仅基于对比缓存，请求数据的流程如下： 可以看出， 都需要请求服务器验证缓存标识对应的数据是否失效,对比缓存不管是否生效，所以都需要与服务端发生交互。 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。 再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，若缓存资源仍有效，服务器会返回304状态码，通知客户端比较成功，可以使用缓存数据。 分为两种标识传递，分别是Last-Modified &#x2F; If-Modified-Since和Etag &#x2F; If-None-Match，下面我们分别介绍。 Last-Modified &#x2F; If-Modified-Since这两个字段需要配合 Cache-Control 进行使用，If-Modified-Since 位于请求头,Last-Modified 位于响应头，。它们的含义分别是： If-Modified-Since： 客户端缓存过期时（max-age 时间到期），发现该资源具有 Last-Modified 字段，可以在 Header 中填入 If-Modified-Since 字段，并填入Last-Modified记录的时间,(If-Modified-Since &#x3D; Last-Modified time)。服务端收到该时间后会与该资源的最后修改时间进行比较。 Last-Modified： 该响应资源最后的修改时间，服务器在响应请求的时候可以填入该字段。 若该资源已经被修改 ，则会返回状态码200，并对整个资源响应。 否则说明该资源在访问时未被修改，则会响应状态码 304，告知客户端可以使用缓存的资源。 Etag &#x2F; If-None-Match同样需要配合 Cache-Control 使用，Etag 位于响应头，If-None-Match 位于请求头。并且它们的优先级高于 Last-Modified&#x2F;If-Modified-Since。 它们的含义分别是： Etag： 请求的资源在服务器中的唯一标识，规则由服务器决定。 If-None-Match： 若客户端在缓存过期时（max-age 到期），发现该资源具有 Etag 字段，就可以添加 If-None-Match Header，并传入 Etag 中的值 (If-None-Match &#x3D; Etag value)，服务器收到请求后就会将If-None-Match的值与被请求资源的唯一标识进行比对 若比对不同，说明资源有被改动过，则会返回状态码200，并响应整个资源内容 若比对相同，说明资源没有新的修改，则会返回状态码 304，告知客户端可以继续使用缓存的资源。 对于强制缓存，服务端通知客户端一个缓存时间，在缓存时间内客户端可以直接使用缓存的资源，不在缓存时间内，若客户端需要获取数据，则需要执行对比缓存策略。 对于比较缓存，客户端将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，若返回304状态码，则客户端可以使用缓存中的资源。 网络请求缓存处理，okhttp如何处理网络缓存的 总结 强制缓存和对比缓存可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 当强制缓存和对比缓存同时存在时： 对于强制缓存，服务端通知客户端一个缓存时间，在缓存时间内客户端可以直接使用缓存的资源，不在缓存时间内，若客户端需要获取数据，则需要执行对比缓存策略。 对于比较缓存，客户端将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，若返回304状态码，则客户端可以使用缓存中的资源。 offline cache Cached responses can be served even when the device is offline or has limited connectivity, ensuring that your app remains functional in challenging network conditions. 遗留的问题，sprintboot弄好后，mock服务端的head请求，再验证CacheInterceptor 策略。 https://www.cnblogs.com/giagor/p/15706508.htm https://www.bilibili.com/video/BV12Q4y1d7uDOKHTTP之缓存配置详解 CacheInterceptorBy default, OkHttp’s CacheInterceptor only supports caching for GET requests. 123456789101112131415161718 internal fun put(response: Response): CacheRequest? &#123; val requestMethod = response.request.method if (HttpMethod.invalidatesCache(response.request.method)) &#123; //This method determines whether it is not a get request try &#123; remove(response.request) &#125; catch (_: IOException) &#123; // The cache cannot be written. &#125; return null &#125; if (requestMethod != &quot;GET&quot;) &#123; // Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache HEAD requests and some // POST requests, but the complexity of doing so is high and the benefit is low. return null &#125;&#125; RequestRequestBodyThe RequestBody is a basic request for OkHttp. It also provides FormBody and MultipartBody to construct the request body. 12345678910111213141516171819202122 RequestBody body = RequestBody.create(json, JSON); Request request = new Request.Builder() .url(url) .post(body) .build();fun ByteArray.commonToRequestBody( contentType: MediaType?, offset: Int, byteCount: Int,): RequestBody &#123; return object : RequestBody() &#123; override fun writeTo(sink: BufferedSink) &#123; sink.write(this@commonToRequestBody, offset, byteCount) &#125; &#125;&#125;actual sealed interface BufferedSink : Sink, WritableByteChannel &#123; fun buffer(): Buffer actual val buffer: Buffer&#125; 针对这一开始不理解， sink.write 是怎么写入的,它只有一个方法，没法执行,中间以为acual字段会构造对象，其实不是的，后来写了个demo。 其实是在 CallServerInterceptor中createRequestBody,创建了bufferedRequestBody,然后把之前RequestBody的数据写入。 12val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()requestBody.writeTo(bufferedRequestBody) FormBodyFormBody 重写了writeto方法，上面解析后，走的就是 123override fun writeTo(sink: BufferedSink) &#123; writeOrCountBytes(sink, false)&#125; OkHttp怎么实现连接池OkHttp对于网络请求都有哪些优化Okhttp demoWebSocketEcho https://juejin.cn/post/6844904102669844493https://juejin.im/post/5f0452615188252e5522b747 连接池配置maxIdleConnections 和 keepAliveDuration 是影响连接池行为的重要参数，你可以根据你的应用程序需求和服务器配置进行适当的设置。 maxIdleConnections（最大空闲连接数）这个参数表示连接池中允许存在的最大空闲连接数。空闲连接是指当前没有正在使用的连接。如果连接池中的空闲连接数达到了这个最大值，那么新的连接将不再被创建，而是会被关闭。较大的空闲连接数可以提高连接的复用性和请求响应速度，但也会占用更多的系统资源。对于具体的值，可以根据你的应用程序负载和服务器负载进行评估和调整。 keepAliveDuration（保持活动连接的时间） 这个参数表示连接的最大空闲时间。如果一个连接在这段时间内处于空闲状态（没有被使用），它将被关闭并从连接池中移除。较长的 keep-alive 时间可以减少频繁创建和关闭连接的开销，并提高连接的复用性，但也会增加服务器端资源的占用。在设置这个值时，可以考虑服务器的 keep-alive 配置和网络延迟等因素。 在连接池中找连接的时候会对比连接池中相同host的连接。 如果在连接池中找不到连接的话，会创建连接，创建完后会存储到连接池中。 在把连接放入连接池中时，会把清除操作的任务放入到线程池中执行，删除任务中会判断当前连接有没有在使用中，有没有正在使用通过RealConnection的transmitters集合的size是否为0来判断，如果不在使用中，找出空闲时间最长的连接，如果空闲时间最长的连接超过了keep-alive默认的5分钟或者空闲的连接数超过了最大的keep-alive连接数5个的话，会把存活时间最长的连接从连接池中删除。保证keep-alive的最大空闲时间和最大的连接数 连接复用实现1234567891011121314151617181920fun callAcquirePooledConnection( connectionUser: ConnectionUser, routes: List&lt;Route&gt;?,): RealConnection? &#123; for (connection in connections) &#123; // In the first synchronized block, acquire the connection if it can satisfy this call. val acquired = synchronized(connection) &#123; when &#123; requireMultiplexed &amp;&amp; !connection.isMultiplexed -&gt; false !connection.isEligible(address, routes) -&gt; false else -&gt; &#123; connectionUser.acquireConnectionNoEvents(connection) &#125; &#125; &#125; // Confirm the connection is healthy and return it. if (connection.isHealthy(doExtensiveHealthChecks)) return connection &#125;&#125; OkHttp 对连接池的优化思路：cleanup 根据连接池中的连接对象闲置了多久 指定闲置时间限制：超过了，就清理掉默认为5 min 连接池中存放了大量的空闲连接对象 此时没有正在使用，将闲置时间最长的清理掉，知道不超过5 个连接(LRU 思想) cleanup 具体的业务逻辑 遍历所有的连接，记录正在使用的连接数与空闲的连接数(会记录空闲时间) https://juejin.cn/post/7126235541917401119 okhttp怎么支持http2.0Handshake则会把服务端支持的Tls版本，加密方式等都带回来，然后会把这个没有验证过的HandShake用X509Certificate去验证证书的有效性。然后会通过Platform去从SSLSocket去获取ALPN的协议支持信息，当后端支持的协议内包含Http2.0时，则就会把请求升级到Http2.0阶段。 glide和OkHttp的任务调度是怎么实现的（比如同时发起很多请求） 4.问第三方库如okhttp、picasso等底层原理如缓存机制等（一个也没答上来，literally Http1 Http2是怎么切换的okhttp 是如何支持 Http2 的？ Handshake则会把服务端支持的Tls版本，加密方式等都带回来，然后会把这个没有验证过的HandShake用X509Certificate去验证证书的有效性。然后会通过Platform去从SSLSocket去获取ALPN的协议支持信息，当后端支持的协议内包含Http2.0时，则就会把请求升级到Http2.0阶段。 13.Retrofit中的Call对象如何转换成okhttp的call对象(这个题目是埋坑的) Interview Questions 汇总 https://www.jianshu.com/p/dfdfd45b076e 分析 https://juejin.cn/post/6873476209737629709/ OKHTTP 抓包如果要，需要设置Okhttp证书 123456789101112131415161718192021222324252627282930fun disableCertificateVerification(): OkHttpClient &#123; val trustAllCerts = arrayOf&lt;TrustManager&gt;(object : X509TrustManager &#123; override fun checkClientTrusted( chain: Array&lt;out java.security.cert.X509Certificate&gt;?, authType: String?, ) &#123; &#125; override fun checkServerTrusted( chain: Array&lt;out java.security.cert.X509Certificate&gt;?, authType: String?, ) &#123; &#125; override fun getAcceptedIssuers(): Array&lt;java.security.cert.X509Certificate&gt; &#123; return arrayOf() &#125; &#125;) val sslContext = SSLContext.getInstance(&quot;TLS&quot;) sslContext.init(null, trustAllCerts, java.security.SecureRandom()) val sslSocketFactory = sslContext.socketFactory val trustAllHostnames = HostnameVerifier &#123; _, _ -&gt; true &#125; return OkHttpClient.Builder() .sslSocketFactory(sslSocketFactory, trustAllCerts[0] as X509TrustManager) .hostnameVerifier(trustAllHostnames) .build() &#125; 验证证书 123456789101112131415161718192021222324252627282930 private fun connectTls( sslSocket: SSLSocket, connectionSpec: ConnectionSpec, ) &#123; if (connectionSpec.supportsTlsExtensions) &#123; Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols) &#125; // Force handshake. This can throw! sslSocket.startHandshake() // Verify that the socket&#x27;s certificates are acceptable for the target host. if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123; val peerCertificates = unverifiedHandshake.peerCertificates if (peerCertificates.isNotEmpty()) &#123; val cert = peerCertificates[0] as X509Certificate throw SSLPeerUnverifiedException( &quot;&quot;&quot; |Hostname $&#123;address.url.host&#125; not verified: | certificate: $&#123;CertificatePinner.pin(cert)&#125; | DN: $&#123;cert.subjectDN.name&#125; | subjectAltNames: $&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125; &quot;&quot;&quot;.trimMargin(), ) val certificatePinner = address.certificatePinner!! // Check that the certificate pinner is satisfied by the certificates presented. certificatePinner.check(address.url.host) &#123; handshake.peerCertificates.map &#123; it as X509Certificate &#125; &#125; &#125;&#125; 应用拦截器和网络拦截器有什么区别从下面的代码可以看到 interceptors和networkInterceptors的区别. interceptors 是在最前面 12345678910111213141516171819202122internal fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) &#123; interceptors += client.networkInterceptors &#125; interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain( call = this, interceptors = interceptors, index = 0, request = originalRequest ) val response = chain.proceed(originalRequest) return response&#125; 应用拦截器 仅调用一次，即使 http 响应是从缓存中获取的结果。主要关注应用程序的原始意图，不关心 okhttp 注入的头，如 If-None-Match …允许短路操作，即 不调用 Chain.proceed()。允许重试并多次调用 Chain.proceed()可以使用 withConnectTimeout, withReadTimeout, withWriteTimeout 来调整 Call 超时时间。 网络拦截器 能够操作中间处理过程，如重定向和重试。不关注 cache 层拦截的短路操作关注网络层数据传输执行 Connection 请求 https://juejin.cn/post/7151761448757264415 OKHttp 如何复用 TCP 连接ChatGptResuming TCP connections in OkHttp is not straightforward because TCP connection resumption at the application level is generally managed by the underlying operating system and network stack rather than by application-level code. However, you can manage HTTP request retries and connection pooling to effectively handle network interruptions and failures. Here are a few steps and strategies to handle TCP connection issues and retries in OkHttp: Connection PoolingOkHttp manages connections in a connection pool, which can be reused for multiple requests. This reduces latency by avoiding the need to establish a new TCP connection for each request. Ensure your connection pool is properly configured. 1234ConnectionPool connectionPool = new ConnectionPool(5, 5, TimeUnit.MINUTES);OkHttpClient client = new OkHttpClient.Builder() .connectionPool(connectionPool) .build(); 这个link 详细介绍了物理层面 连接复用规则Keep-Alivehttps://juejin.cn/post/6844904037167415310#heading-8 OKHttp 空闲连接如何清除 Find the longest-idle connections in 2 categories: 1. OLD: Connections that have been idle for at least keepAliveDurationNs. We close these if we find them, regardless of what the address policies need. 2. EVICTABLE: Connections not required by any address policy. This matches connections that don&#39;t participate in any policy, plus connections whose policies won&#39;t be violated if the connection is closed. We only close these if the idle connection limit is exceeded. Also count the evictable connections to find out if we must close an EVICTABLE connection 在将连接加入连接池时就会启动定时任务 RealConenctionPool 123456fun put(connection: RealConnection) &#123;connection.assertThreadHoldsLock()connections.add(connection)// connection.queueEvent &#123; connectionListener.connectEnd(connection) &#125;scheduleCloser()&#125; 有空闲连接的话，如果最长的空闲时间大于5分钟 或 空闲数 大于5，就移除关闭这个最长空闲连接；如果 空闲数 不大于5 且 最长的空闲时间不大于5分钟，就返回到5分钟的剩余时间，然后等待这个时间再来清理。 RealConnectionPool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112fun closeConnections(now: Long): Long &#123; // Compute the concurrent call capacity for each address. We won&#x27;t close a connection if doing // so would violate a policy, unless it&#x27;s OLD. val addressStates = this.addressStates for (state in addressStates.values) &#123; state.concurrentCallCapacity = 0 &#125; for (connection in connections) &#123; val addressState = addressStates[connection.route.address] ?: continue synchronized(connection) &#123; addressState.concurrentCallCapacity += connection.allocationLimit &#125; &#125; // Find the longest-idle connections in 2 categories: // // 1. OLD: Connections that have been idle for at least keepAliveDurationNs. We close these if // we find them, regardless of what the address policies need. // // 2. EVICTABLE: Connections not required by any address policy. This matches connections that // don&#x27;t participate in any policy, plus connections whose policies won&#x27;t be violated if the // connection is closed. We only close these if the idle connection limit is exceeded. // // Also count the evictable connections to find out if we must close an EVICTABLE connection // before its keepAliveDurationNs is reached. var earliestOldIdleAtNs = (now - keepAliveDurationNs) + 1 var earliestOldConnection: RealConnection? = null var earliestEvictableIdleAtNs = Long.MAX_VALUE var earliestEvictableConnection: RealConnection? = null var inUseConnectionCount = 0 var evictableConnectionCount = 0 for (connection in connections) &#123; synchronized(connection) &#123; // If the connection is in use, keep searching. 如果该连接正在被使用，则继续遍历，使用连接数+1 if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; inUseConnectionCount++ return@synchronized &#125; // 记录最长空闲时长，以及最长空闲时长对应的连接 val idleAtNs = connection.idleAtNs if (idleAtNs &lt; earliestOldIdleAtNs) &#123; earliestOldIdleAtNs = idleAtNs earliestOldConnection = connection &#125; if (isEvictable(addressStates, connection)) &#123; evictableConnectionCount++ if (idleAtNs &lt; earliestEvictableIdleAtNs) &#123; // 当连接最长空闲时长大于配置的时长 earliestEvictableIdleAtNs = idleAtNs earliestEvictableConnection = connection &#125; &#125; &#125; &#125; val toEvict: RealConnection? val toEvictIdleAtNs: Long when &#123; // We had at least one OLD connection. Close the oldest one. earliestOldConnection != null -&gt; &#123; toEvict = earliestOldConnection toEvictIdleAtNs = earliestOldIdleAtNs &#125; // We have too many EVICTABLE connections. Close the oldest one. evictableConnectionCount &gt; maxIdleConnections -&gt; &#123; //空闲连接个是&gt; 配置的个数 toEvict = earliestEvictableConnection toEvictIdleAtNs = earliestEvictableIdleAtNs &#125; else -&gt; &#123; toEvict = null toEvictIdleAtNs = -1L &#125; &#125; when &#123; toEvict != null -&gt; &#123; // We&#x27;ve chosen a connection to evict. Confirm it&#x27;s still okay to be evicted, then close it. synchronized(toEvict) &#123; if (toEvict.calls.isNotEmpty()) return 0L // No longer idle. if (toEvict.idleAtNs != toEvictIdleAtNs) return 0L // No longer oldest. toEvict.noNewExchanges = true connections.remove(toEvict) &#125; addressStates[toEvict.route.address]?.scheduleOpener() toEvict.socket().closeQuietly() connectionListener.connectionClosed(toEvict) if (connections.isEmpty()) cleanupQueue.cancelAll() // Clean up again immediately. return 0L &#125; earliestEvictableConnection != null -&gt; &#123; // A connection will be ready to evict soon. return earliestEvictableIdleAtNs + keepAliveDurationNs - now &#125; inUseConnectionCount &gt; 0 -&gt; &#123; // All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again. return keepAliveDurationNs &#125; else -&gt; &#123; // No connections, idle or in use. return -1 &#125; &#125;&#125; close OkhttpClient立即关闭空闲连接，maxIdle、keepAliveDuration限制 12345678910111213141516171819202122232425fun evictAll() &#123; val i = connections.iterator() while (i.hasNext()) &#123; val connection = i.next() val socketToClose = synchronized(connection) &#123; if (connection.calls.isEmpty()) &#123; i.remove() connection.noNewExchanges = true // 只有连接空闲，先标记，防止close前又被复用. return@synchronized connection.socket() &#125; else &#123; return@synchronized null &#125; &#125; if (socketToClose != null) &#123; socketToClose.closeQuietly() connectionListener.connectionClosed(connection) &#125; &#125; if (connections.isEmpty()) cleanupQueue.cancelAll() for (policy in addressStates.values) &#123; policy.scheduleOpener() &#125;&#125; https://juejin.cn/post/6844904054095790087 没有空闲连接就等5分钟后再尝试清理。 没有连接不清理。","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"HexoConfigure","slug":"HexoConfigure","date":"2017-08-01T06:03:52.000Z","updated":"2024-10-01T12:01:45.494Z","comments":true,"path":"2017/08/01/HexoConfigure/","link":"","permalink":"https://noteforme.github.io/2017/08/01/HexoConfigure/","excerpt":"","text":"基本配置select theme Best Hexo Themes (Hand-picked) | Statichunt 安装出问题 更换镜像源 https://www.lemonneko.cn/win10%E6%90%AD%E5%BB%BAhexo%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/ 上传到分支 // git初始化 git init // 添加仓库地址 git remote add origin https://github.com/用户名/仓库名.git // 新建分支并切换到新建的分支 git checkout -b 分支名 // 添加所有本地文件到git git add . // git提交 git commit -m &quot;&quot; // 文件推送到hexo分支 git push origin hexo 其他设备安装好环境(支持跨平台)，先clone hexo分支到本地 git clone -b hexo git@github.com:noteforme/noteforme.github.io.git // 安装hexo , 下不下来就用privoxy npm install hexo // 注意这里不需要hexo初始化：hexo init；否则之前的hexo配置参数会重置 // 安装依赖库 npm install // 安装部署相关配置 npm install hexo-deployer-git //如果出错执行下面的 npm install -g hexo-cli 这要就完成同步了(上面的流程还不是很规范，不过执行上面几个命令基本都能解决) 如果有这些不用管了 npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\\chokidar\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for &#x66;&#115;&#x65;&#118;&#101;&#x6e;&#x74;&#115;&#x40;&#49;&#46;&#49;&#x2e;&#x32;: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64” 问题:在ubuntu上，执行hexo d部署后每次都要输入github用户名和密码，在这里也找到了答案，就是根目录下的 _config.yml文件没有配置成ssh,之前是这样的 repository:https://github.com/noteforme/noteforme.github.io.git Deployment Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: &#x67;&#105;&#116;&#x40;&#x67;&#105;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#109;:noteforme&#x2F;noteforme.github.io.git branch: master 参考：http://www.jianshu.com/p/6fb0b287f950 https认证:Cloudflare免费的ssl创建账户注册 https://www.cloudflare.com/a/sign-up 登录后输入域名,点击扫描 如图 一直continue，到了Selet a Cloudflare Plan 选择Free Website 解析域名的地方，修改域名服务器,我这里是在godaddy修改，然后continue 点击Preview on your site instantly－&gt; 点击Overview(显示Ａctive即可)－&gt;点击Crypto(选择Ｆlexible) 参考：http://www.jianshu.com/p/92b6d4a6ecd5 mac install hero1sudo npm install -g hero-cli theme didn’t commit to GitHub ,so you could clone theme hexo next theme修改主题 git clone git@github.com:ppoffice/hexo-theme-icarus.git themes/icarus里面都有介绍，主要石npm安装不了插件就需要这篇文章 的polipo工具，最有名的Privoxy反而不起作用 分类只要在 博客头部加 categories: “BLOG” 就会自动展示分类了，如果觉得每次添加麻烦的话，修改scaffolds&#x2F;post.md 模板 title: HexoConfigure date: 1501567432000 tags: categories: comments: true 然后hexo n “yourblog”,就会有这些了，接下里就是在首页分类进行关联了 生成 分类（默认已有分类） 1hexo new page &quot;categories&quot; 新建page: $ hexo new page “categories” ，在 hexo &gt; source 文件夹中会出现一个categories文件夹 打开categories文件夹中的index.md页面，在头部添加 – type: “categories” （为了点击的时候链接生效） 在hexo &gt; theme &gt; next &gt; _config.yml 中修改menu下的categorues,去掉前面井号注释。 然后就可以看到分类页面了 参考：https://lannly.github.io/2016/11/16/Hexo-Next-%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E5%88%86%E7%B1%BB/ next 添加头像新建uploads文件夹，放入图片 找到themes&#x2F;next 下的 -config.yml,修改如下图所示 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg avatar: /uploads/author.png https://github.com/iissnan/hexo-theme-next/wiki/%E8%AE%BE%E7%BD%AE%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%A4%B4%E5%83%8F Mac Hexo安装command not found: hexo的解决方法 $ npm root -g获取node_modules地址&#x2F;Users&#x2F;guo&#x2F;.npm-global&#x2F;lib&#x2F;node_modules 1$export PATH=$PATH:/Users/m/.npm-global/lib/node_modules/hexo-cli/bin 也可以去修改&#x2F;.zshrc 或者&#x2F;.bashrc，在里面添加上述命令，然后 source ~&#x2F;.zshrc 图片不显示这个图片怎么弄也没用，最终把资源包从旧的电脑，复制到新电脑解决了 打开&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js，将内容更换为下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); https://moeci.com/posts/hexo-typora/ https://juejin.cn/post/7006594302604214280 https://www.bilibili.com/video/BV1D7411U7Yk/ 卸载插件12npm listnpm uninstall &lt;你的插件名&gt; 安装插件 1npm install https://github.com/fulsun/hexo-asset-image-master.git --save https://carolinelh.github.io/2019/11/20/hexo%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E5%9D%91/ _config.yml 12## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://noteforme.github.io // 之前这个地址不对,多加了东西 hexo node 升级1234567搜索现有node版本brew search node安装指定版本brew install node@x https://blog.csdn.net/lvqinglou/article/details/115858349 npm-check 检查升级 https://ephen.me/2022/blog-updates-plus/ wordpress on mac How to Install WordPress Locally (Windows, Mac, Linux) database name : mysql","categories":[],"tags":[{"name":"BLOG","slug":"BLOG","permalink":"https://noteforme.github.io/tags/BLOG/"}]},{"title":"ContentProvider","slug":"ContentProvider","date":"2017-07-31T01:35:40.000Z","updated":"2021-08-19T11:11:43.768Z","comments":true,"path":"2017/07/31/ContentProvider/","link":"","permalink":"https://noteforme.github.io/2017/07/31/ContentProvider/","excerpt":"","text":"https://developer.android.com/guide/topics/providers/content-provider-basics.html?hl=zh-cn 还需要完善单条记录 查询 修改等一、新建数据库 https://github.com/BlogForMe/AndroidProject/blob/master/ContentProvider/mylibrary/src/main/java/com/hyhy/mylibrary/ArticleDbHelper.java二、创建ContentProvider public class ArticlesProvider extends ContentProvider &#123; public static final String AUTHORITY = &quot;com.hyhy.contenttest.db.ArticlesProvider&quot;; //标识特定ContentProvider,使用包名使他唯一 private static final Uri NOTIFY_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot; + TABLE_NAME); private static final UriMatcher uriMatcher; /** * Match Code */ public static final int ARTICLE_ALL = 0; public static final int ARTICLE_SINGLE = 1; /** * MIME */ public static final String CONTENT_TYPE = &quot;vnd.android.cursor.dir/vnd.com.hyhy.article&quot;; private static final String CONTENT_ITEM_TYPE = &quot;vnd.android.cursor.item/vnd.com.hyhy.article&quot;; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, TABLE_NAME, ARTICLE_ALL); //匹配记录集合 uriMatcher.addURI(AUTHORITY, TABLE_NAME + &quot;/#&quot;, ARTICLE_SINGLE); //匹配单条记录 &#125; private ArticleDbHelper helper; private SQLiteDatabase db; private ContentResolver resolver; @Override public boolean onCreate() &#123; resolver = getContext().getContentResolver(); helper = new ArticleDbHelper(getContext()); return false; &#125; @Nullable @Override public String getType(@NonNull Uri uri) &#123; int match = uriMatcher.match(uri); switch (match) &#123; case ARTICLE_ALL: return CONTENT_TYPE; case ARTICLE_SINGLE: return CONTENT_ITEM_TYPE; default: throw new IllegalArgumentException(&quot;Unknown URI: &quot; + uri); &#125; &#125; @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; db = helper.getReadableDatabase(); int match = uriMatcher.match(uri); switch (match) &#123; case ARTICLE_ALL: //doesn&#39;t need any code in my provider. break; case ARTICLE_SINGLE: // long _id = ContentUris.parseId() break; default: throw new IllegalArgumentException(&quot;Unknown URI: &quot; + uri); &#125; return db.query(TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder); &#125; @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123; int match = uriMatcher.match(uri); if (match != ARTICLE_ALL) &#123; throw new IllegalArgumentException(&quot;Wrong URI:&quot; + uri); &#125; db = helper.getWritableDatabase(); long rowId = db.insert(TABLE_NAME, null, values); if (rowId &gt; 0) &#123; notifyDataChanged(); return ContentUris.withAppendedId(uri, rowId); &#125; return null; &#125; @Override public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125; @Override public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125; private void notifyDataChanged() &#123; getContext().getContentResolver().notifyChange(NOTIFY_URI, null); &#125; &#125; 配置Androidmanifest.xml &lt;provider android:name=&quot;.db.ArticlesProvider&quot; android:authorities=&quot;com.hyhy.contenttest.db.ArticlesProvider&quot; android:exported=&quot;true&quot; /&gt; 三、操作ContentProvider public class MainActivity extends AppCompatActivity &#123; private static final String AUTHORITY = &quot;com.hyhy.contenttest.db.ArticlesProvider&quot;; private static final Uri ARTICLE_ALL_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot; + TABLE_NAME); private ContentResolver resolver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); resolver = getContentResolver(); &#125; public void addDb(View v) &#123; ContentValues values; for (int i = 1; i &lt; 5; i++) &#123; values = new ContentValues(); values.put(ArticleReaderContract.Articles.COLUMN_NAME_ENTRY_ID, i); values.put(ArticleReaderContract.Articles.COLUMN_NAME_TITLE, &quot;heh &quot; + i); values.put(ArticleReaderContract.Articles.COLUMN_NAME_SUBTITLE, &quot;describe &quot; + i); resolver.insert(ARTICLE_ALL_URI, values); &#125; Toast.makeText(MainActivity.this, &quot;插入成功&quot;, Toast.LENGTH_SHORT).show(); &#125; public void btQueryAll(View v) &#123; Cursor c = resolver.query(ARTICLE_ALL_URI, null, null, null, null); while (c.moveToNext()) &#123; System.out.println(c.getString(c.getColumnIndex(COLUMN_NAME_TITLE))); &#125; &#125; &#125; 参考 ： http://blog.csdn.net/liuhe688/article/details/7050868 这一块还不熟悉","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"EclipseIdeaWeb","slug":"EclipseIdeaWeb","date":"2017-07-23T11:16:39.000Z","updated":"2021-08-19T11:11:43.802Z","comments":true,"path":"2017/07/23/EclipseIdeaWeb/","link":"","permalink":"https://noteforme.github.io/2017/07/23/EclipseIdeaWeb/","excerpt":"","text":"Eclipse导入web项目1、src并入包导入项目后可以看这种情况 ​ 处理方法：VideoServer右键－&gt;Build Path-&gt;Configure Build Path-&gt;Source-&gt;Brower-&gt;src-&gt;Apply;接着就可以看到 ,点击Yes后，项目目录正常了，但是发现这是一个Ｊava项目,没有javax.相关的包 ２、Java项目转Ｗeb项目VideoServer右键－&gt;Properties-&gt;Project Facets 在这里勾选 Dynamic Web Module:下面会有个提示 Ｄynamic Web Module 3.0 Requires Java 1.6 or newer. 勾选 Ｊava 勾选 ＪavaScript点击Apply Idea安装http://justcode.ikeepstudying.com/2017/12/%E6%9B%B4%E6%96%B0-intellij-idea-2017-3-1-%E6%B3%A8%E5%86%8C%E7%A0%81-%EF%BC%88%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%89/ http://idea.lanyus.com/ https://www.jetbrains.com/help/idea/developing-a-java-ee-application.html","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]},{"title":"String","slug":"String","date":"2017-07-21T06:54:53.000Z","updated":"2021-08-19T11:11:44.238Z","comments":true,"path":"2017/07/21/String/","link":"","permalink":"https://noteforme.github.io/2017/07/21/String/","excerpt":"","text":"字符串连接有两种方式，一种时 “ + “,另一种是 StringBuilder方式 命令行运行java 平常用开发工具习惯了，都忘了怎么用命令行运行，特此记录下 新建 Concatenation.java文件，cmd到该目录下，写入代码 public class Concatenation&#123; public static void main(String[] args)&#123; String mango = &quot;mango&quot;; String s = &quot;abc&quot; + mango + &quot;def&quot; + 47; System.out.print(s); &#125; &#125; 生成 Concatenation.calss 文件 D:\\DemoExo&gt;javac Concatenation.java 运行Concatenation.class文件,后面是运行结果 D:\\DemoExo&gt;java Concatenation abcmangodef47 String字符串连接方式回到主题 查看JDK文档（不知道在哪），String 类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象,以包含修改后的字符串内容. public class Immutable&#123; public static String upcase(String s)&#123; return s.toUpperCase(); &#125; public static void println(String q)&#123; System.out.println(q); &#125; public static void main(String[] args)&#123; String q = &quot;howdy&quot;; print(q); // howdy String qq= upcase(q); print(qq); //HOWDY print(q); //howdy &#125; &#125; 运行结果：howdyHOWDYhowdy当把q传给upcase()时，实际传递的是引用的拷贝 编译器运行过程反编译Concatenation,生成JVM字节码 javap -c Concatenation.class 字节码是这样的 C:\\DemoExo&gt;javap -c Concatenation.class Compiled from &quot;Concatenation.java&quot; public class Concatenation &#123; public Concatenation(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String mango 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 10: ldc #5 // String abc 12: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 15: aload_1 16: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: ldc #7 // String def 21: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 24: bipush 47 26: invokevirtual #8 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 29: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 32: astore_2 33: getstatic #10 // Field java/lang/System.out:Ljava/io/PrintStream; 36: aload_2 37: invokevirtual #11 // Method java/io/PrintStream.print:(Ljava/lang/String;)V 40: return &#125; 可以看到，编译器创建了一个StringBuilder对象,用以构造最终的String，并四次调用了append(),最后使用命令astore_2生成 s对象。这样来看，使用 “+” 连接符，是不会影响性能的咯，接着往下 “+”连接符 和 StringBuilder对比运行javap -c WhitherStringBuilder.class 看到两个方法对象的字节码，先看前半部分implicit() public class WhitherStringBuilder &#123; public WhitherStringBuilder(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public java.lang.String implicit(java.lang.String[]); Code: 0: ldc #2 // String 2: astore_2 3: iconst_0 4: istore_3 5: iload_3 6: aload_1 7: arraylength 8: if_icmpge 38 11: new #3 // class java/lang/StringBuilder 14: dup 15: invokespecial #4 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 18: aload_2 19: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 22: aload_1 23: iload_3 24: aaload 25: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #6 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_2 32: iinc 3, 1 35: goto 5 38: aload_2 39: areturn 第8到35行，在for循环体内，每一次循环就创建了一个StringBuilder对象，接着看看explicit() public java.lang.String explicit(java.lang.String[]); Code: 0: new #3 // class java/lang/StringBuilder 3: dup 4: invokespecial #4 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 7: astore_2 8: iconst_0 9: istore_3 10: iload_3 11: aload_1 12: arraylength 13: if_icmpge 30 16: aload_2 17: aload_1 18: iload_3 19: aaload 20: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 23: pop 24: iinc 3, 1 27: goto 10 30: aload_2 31: invokevirtual #6 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 第13到27行在for循环体内，StringBuilder只会生成一个对象 总结： 由此来看，如果字符串操作比较简单，就可以用“+”连接让编译器处理字符串如果在循环中，那么自己创建一个StringBuilder对象 参考：摘自ThinkInJava4 P286 避免创建不必要的对象创建 String对象 最好能重用对象而不是每次需要的时候就创建一个功能相同的新对象，重用方式即快速又流行。如果对象是不可变的，它始终可以被重用。 极端的反面例子 ｀Ｓtring s = new String(“stringette”); //DON’T DO THIS ! ｀该语句每次被执行的时候都创建一个新的String实例，传递给String构造器的参数”stringette’本身就是一个String实例，如果这种用法在一个循环中，或者在一个频繁调用的方法中，就会创建出成千上万不必要的String 实例。 改进后的版本如下所示 1String s = &quot;stringette&#x27;; 这个版本只用了一个String实例，而且它可以保证，对于所有的同一台虚拟机中运行的代码，只要包含相同的字符串字面常量，该对象就会被重用. 返回数据处理对于同时提供静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法，而不是构造器以避免创建不必要的对象，例如，静态工厂方法Boolean.valueof(String)由于构造器Boolean(String),构造器每次调用的时候都会创建一个新的对象，而静态工厂方法则不会 我们平常解析回来后非String类型的数据，需要转换成String对象 看到这里后就需要使用String.valueof(String) 123456789101112/** * Returns the string representation of the &#123;@code Object&#125; argument. * * @param obj an &#123;@code Object&#125;. * @return if the argument is &#123;@code null&#125;, then a string equal to * &#123;@code &quot;null&quot;&#125;; otherwise, the value of * &#123;@code obj.toString()&#125; is returned. * @see java.lang.Object#toString() */ public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString(); &#125; 从源码中看到对形参 做了 null判断，所以用这种方式页不用担心闪退的情况了参考 Effective Java page17 java 8 获取对象数据 12345678910111213private WchatMobile decodeMobile(String encryptedData, String iv, String unionid) &#123; WchatMiniAppSession miniAppSession = getWchatMiniAppSession(unionid); String sessionKey = Optional.ofNullable(miniAppSession) .orElseThrow(() -&gt; new ServiceExecutionException(&quot;用户小程序登录信息为空&quot;)) .getSessionKey(); return Optional.ofNullable(wchatMiniAppService) .map(as -&gt; as.getWxMaService()) .map(s -&gt; s.getUserService()) .map(se -&gt; se.getPhoneNoInfo(sessionKey, encryptedData, iv)) .map(num -&gt; WchatMobile.from(num)) .orElse(null); &#125; https://time.geekbang.org/column/article/209343 亨元模式Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g ==(a+b)); System.out.println(g.equals(a+b));","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"}],"tags":[]},{"title":"linux","slug":"linux","date":"2017-07-19T07:03:07.000Z","updated":"2025-02-15T09:15:02.138Z","comments":true,"path":"2017/07/19/linux/","link":"","permalink":"https://noteforme.github.io/2017/07/19/linux/","excerpt":"","text":"Linux使用 find ： $ find . -name ‘my*’ 搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。 http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html ubuntu wifi热点http://blog.csdn.net/sunmc1204953974/article/details/45740853 删除build文件find . -name &quot;build&quot; | xargs rm -rf VIMcommentOnce you’ve selected the lines, press : to bring up the command line, and Vim will automatically prepend the :&#39;&lt;,&#39;&gt; range (which represents the selected lines). 1:s/^/\\/\\/ / uncomment 1:s/^\\/\\/ // Search1. Move to the Next Match:After the first match is found, to move to the next match, press: 1n This will move the cursor to the next occurrence of the search pattern. 2. Move to the Previous Match:If you want to move to the previous match, press: 1N 3. Search Backwards:If you want to search backward (from your current cursor position toward the beginning of the file), use: 1?your_pattern Then, use n to move to the previous match (in the reverse direction) and N to move in the opposite direction.","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://noteforme.github.io/categories/LINUX/"}],"tags":[]},{"title":"ubuntu-mariaDb","slug":"ubuntu-mariaDb","date":"2017-07-18T07:31:21.000Z","updated":"2021-08-19T11:11:44.318Z","comments":true,"path":"2017/07/18/ubuntu-mariaDb/","link":"","permalink":"https://noteforme.github.io/2017/07/18/ubuntu-mariaDb/","excerpt":"","text":"数据库常用用法W3C教程 : https://www.w3cschool.cn/mariadb/1、创建/删除 数据库：CREATE DATABASE 数据库名 / drop database 数据库名;2、建表/删除表 ： h_id为主键 /DROP TABLE table_name ; MariaDB [person]&gt; CREATE TABLE home_recycler( h_id INT NOT NULL AUTO_INCREMENT, h_title VARCHAR(100) NOT NULL, h_describe VARCHAR(100) NOT NULL, h_imgurl VARCHAR(40) NOT NULL, PRIMARY KEY(h_id) ); Query OK, 0 rows affected (0.29 sec) 3、 插入数据 MariaDB [person]&gt; INSERT INTO home_recycler(h_title,h_describable,h_imgurl) VALUES(&#39;1&#39;,&#39;D&#39;,&#39;m&#39;); 删除数据,删除全部表的数据就不需要条件了 DELETE FROM home_recycler WHERE product_id=133; 注意：插入数据乱码： 在命令行也是插入数据也是中文乱码，解决方法 https://my.oschina.net/u/1011130/blog/864540 重启数据库：http://www.cnblogs.com/anseey/archive/2013/04/28/3049785.html 、 Ubuntu数据库安装 更新系统 $ sudo apt update $ sudo apt upgrade 安装MariaDB： $ sudo apt install mariadb-server 登陆MariaDB命令行 $ sudo mysql -u root -p 参考：http://blog.topspeedsnail.com/archives/6323 https://linux.cn/article-6210-1.html 、 数据库操作 登录 ：mysql -u root -p 数据库导出 导入在网上查了下，导出命令 千遍一律 都是这样的 mysqldump -u username -p dbname &gt; filename.sql ，按照这个操作，语法错误， 在我的惯性思维中，觉得是命令行登录数据库后再导出，其实是不需要登录的，首先Win + r 输入cmd,进入命令行 输入 mysqldump，如果看到下面这个 C:\\Users\\Administrator&gt;mysqldump&#39; mysqldump&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件。 说明需要配置环境变量了，类似我的就需要 D:\\install\\Mariadb\\bin；加入path路径后面 然后输入mysqldump ， C:\\Users\\Administrator&gt;mysqldump Usage: mysqldump [OPTIONS] database [tables] OR mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...] OR mysqldump [OPTIONS] --all-databases [OPTIONS] For more options, use mysqldump --help 然后主题来了 mysqldump -u root -p person &gt; &quot;C:\\mysql.sql&quot; root是用户名 ， person是数据库，&gt;后面是存放位置 ，标准格式是这样的 mysqldump -u username -p dbname &gt; filename.sql 然后导入：mysql -u username -p dbname &lt; filename.sql 但是我在vps导入后数据库为空 参考： https://www.youtube.com/watch?v=2hsOk0XcYC4 https://john-dugan.com/dump-and-restore-mysql-databases-in-windows/ http://wqss.2008.blog.163.com/blog/static/912428082010102092548409/ MariaDB 配置远程访问 有时候在家也要整整这些玩意儿，代码可以用github同步，每次数据库数据还倒腾来倒腾去的 ，如果在vps直接访问就最好了 找到默认配置文件 : 目的是要找到 my.cnf ， 可以先 “ cd /“ ，到根目录下 ，输入下面命令 root@TrustingDevoted-VM:/# find -name &quot;my.cnf&quot; ./etc/mysql/my.cnf 2.修改my.cnf， 找到【mysqld】 ” bind-address = 127.0.0.1“ ，前面加个” # “就可以了， 教程说 “skip-networking”前面也需要修改，但是我这里没有就作罢了 3 授予权限 ，这里授予的是183.129.133.0/24段的ip GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;183.129.133.%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION; 4 给远程主机给予连接用户，查询已经存在的远程用户 SELECT User, Host FROM mysql.user WHERE Host &lt;&gt; &#39;localhost&#39;; | User | Host | +-----------+--------------------+ | user_name | % | | root | 127.0.0.1 | | root | 183.129.133.% | | root | ::1 | | root | trustingdevoted-vm | +-----------+--------------------+ “user_name” 是给的所有用户授予的 ,”root 暂时不知道怎么删除， | 183.129.133.%”是刚才添加的，然后 sudo reboot 重启下 5 本地远程登录 mysql -h66.168.1.11 -uroot -p123456 注意中间没有空格, -h 后面yourVpsIp ,-u后面 用户名， -p 后面密码 参考：https://mariadb.com/kb/zh-cn/configuring-mariadb-for-remote-client-access/ http://blog.csdn.net/ithomer/article/details/6976148 http://www.jianshu.com/p/9c175e9293e2 安装Navicathttps://www.jianshu.com/p/42a33b0dda9c","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://noteforme.github.io/categories/LINUX/"}],"tags":[]},{"title":"proxy_wall","slug":"proxy_wall","date":"2017-07-18T06:34:53.000Z","updated":"2025-03-22T14:43:55.059Z","comments":true,"path":"2017/07/18/proxy_wall/","link":"","permalink":"https://noteforme.github.io/2017/07/18/proxy_wall/","excerpt":"","text":"自从shadowsocks出来，我们的上网问题算是解决了，通过google查资料确实更便利 shadowsocks安装 对于新手 作者建议安装在ubuntu上，那就用他开始吧 安装软件 sudo apt-get install python-pip pip install shadowsocks 然而我遇到了这样的问题Command “python setup.py egg_info” failed with error code 1 in &#x2F;tmp&#x2F;pip-build-Mlx8an&#x2F;shadowsocks&#x2F;You are using pip version 8.1.1, however version 9.0.1 is available.You should consider upgrading via the ‘pip install –upgrade pip’ command.接着按照他的指示来 pip install –upgrade pip 然而又出问题了，这次是这个 Could not import setuptools which is required to install from a source distribution.Please install setuptools.这时候Google派上用场了，解决方案是 sudo pip install -U setuptools 参考：https://github.com/fredley/play-pi/issues/22 然后执行 pip install shadowsocks ，终于OK，Collecting shadowsocksUsing cached shadowsocks-2.8.2.tar.gzInstalling collected packages: shadowsocksRunning setup.py install for shadowsocks … doneSuccessfully installed shadowsocks-2.8.2 前台运行 软件安装好了，现在可以配置了，先在前台跑下 ssserver -p 8388 -k 123456 -m aes-256-cfb 然后手机或电脑同样配置看下代理是否有用，Ok的话，新建一个文件替代命令 vi /etc/shadowsocks.json &#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;123456&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false &#125; 前台执行 : ssserver -c /etc/shadowsocks.json 后台执行:​​ ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start​ ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d stop 接着就可以愉快的玩耍了 卸载shadowsocks 先停掉服务 sudo ssserver -d stop 然后 pip uninstall shadowsocks shadowsocks-libev安装ubuntu 17 12sudo apt updatesudo apt install shadowsocks-libev 如果是其他版本可以看下面 参考from :https://github.com/shadowsocks/shadowsocks-libev#install-from-repository 启动测试连接 和shadowsocks启动类似 ssserver 换成了 ss-server 启动测试 : ss-server -s 0.0.0.0 -p 8388 -k 123456 -m aes-256-cfb 没有 -d start可能会占用端口 配置文件启动To run in the foreground: ss-server -c /etc/shadowsocks-libev/config.json To run in the background: ｀nohup ss-server -c &#x2F;etc&#x2F;shadowsocks-libev&#x2F;config.json｀ 停止运行: sudo ss-server -d stop simple-obfs(混淆工具)安装 BuildFor Unix-like systems, especially Debian-based systems, e.g. Ubuntu, Debian or Linux Mint, you can build the binary like this: Debian &#x2F; Ubuntu 环境配置sudo apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libc-ares-dev libev-dev asciidoc xmlto automake 下载simple-obfs &#x2F;&#x2F;Debian &#x2F; Ubuntu ​ sudo apt-get install –no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libev-dev asciidoc xmlto automake ​ &#x2F;&#x2F;CentOS &#x2F; Fedora &#x2F; RHEL ​ sudo yum install gcc autoconf libtool automake make zlib-devel openssl-devel asciidoc xmlto ​ &#x2F;&#x2F; Arch ​ sudo pacman -Syu gcc autoconf libtool automake make zlib openssl asciidoc xmlto ​ &#x2F;&#x2F;Alpine ​ apk add gcc autoconf make libtool automake zlib-devel openssl asciidoc xmlto libpcre32 libev-dev g++ linux-headers git clone https://github.com/shadowsocks/simple-obfs.git cd simple-obfs git submodule update --init --recursive ./autogen.sh ./configure &amp;&amp; make sudo make install ​ 注意: Question 问题1autoconf --version需要安装 sudo apt install autoconf 问题2 123456configure.ac:19: error: possibly undefined macro: AC_DISABLE_STATIC If this token and others are legitimate, please use m4_pattern_allow. See the Autoconf documentation.configure.ac:20: error: possibly undefined macro: AC_DISABLE_SHAREDconfigure.ac:44: error: possibly undefined macro: AC_PROG_LIBTOOLautoreconf: /usr/bin/autoconf failed with exit status: 1 sudo apt-get install libtool 问题3sudo apt-get install automakehttp://ask.xmodulo.com/fix-failed-to-run-aclocal.html 混淆 server端: ss-server -c /etc/shadowsocks-libev/config.json --plugin obfs-server --plugin-opts &quot;obfs=http&quot; clinet 端:ss-local -c config.json --plugin obfs-local --plugin-opts &quot;obfs=http;obfs-host=www.baidu.com&quot; 也可以都放在配置文件中 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;plugin&quot;:&quot;/usr/local/bin/obfs-server --obfs http&quot;&#125; 那么服务端直接运行&#96;&#96;ss-server -c &#x2F;etc&#x2F;shadowsocks-libev&#x2F;config.json &#96;就可以了 后台运行就是前面的测试连接 nohup命令 from:https://teddysun.com/511.html 参数: 12插件：obfs-local插件选项：obfs=http;obfs-host=www.baidu.com 客户端连接 client也按照 simple-obfs 服务端安装方式安装 连接命令 ss-local -c /etc/shadowsocks-libev/config.json --plugin obfs-local --plugin-opts &quot;obfs=http;obfs-host=www.biadu.com&quot; 参考:https://github.com/shadowsocks/simple-obfshttps://blog.phpgao.com/shadowsocks_on_linux.htmlhttps://softwaredownload.gitbooks.io/openwrt-fanqiang/content/ebook/03.2.html 配置ubuntu开机启动 home下 新建 run_server.sh输入 123#!/bin/bashcd /home/jon/shadowsocksr/shadowsockspython local.py -c /etc/shadowsocks.json 修改脚本权限一定要让脚本具备可执行权限，可以执行如下指令：$ sudo chmod 755 run_server.sh 将脚本放置在启动路径下将run_server.sh移动到&#x2F;etc&#x2F;init.d路径下，可以直接拷贝，也可以链接过去$ sudo cp run_server.sh /etc/init.d/ 将脚本添加到启动脚本。执行如下指令，在这里90表明一个优先级，越高表示执行的越晚 12$ cd /etc/init.d/$ sudo update-rc.d run_server.sh defaults 90 如何移除该脚本很简单，执行如下指令： sudo update-rc.d -f run_server.sh remove http://jackqdyulei.github.io/2016/03/06/linux-auto-script/ 设置系统全局代理 https://blog.csdn.net/u012810317/article/details/52139361 terminal代理 12export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118 或者 git config –global http.proxy “localhost:1080” git config –global http.proxy “localhost:1080” git clone –recurse-submodules &#103;&#105;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#x6d;:shadowsocks&#x2F;shadowsocks-android.git 修改包名 把apk改成 shadowsocks.apk 1234567![SS_20190DD](E:\\noteforme.github.io\\source\\_posts\\ubuntu_ssr\\SS_20190DD.png)java -jar apktool.jar d shadowsocks.apk //解包 //中间做修改java -jar apktool.jar b shadowsocks //打成apk再dist目录下jarsigner -verbose -keystore androidTest.jks -signedjar signed.apk AndroidTest.apk test //生成签名jarsigner -verbose -keystore androidTest.jks -signedjar signed.apk shadowsockstt.apk test https://blog.csdn.net/huaiyiheyuan/article/details/53114490 windows全局代理https://www.flyzy2005.com/fan-qiang/shadowsocks/proxifier-with-shadowsocks/ win7下使用 首先下载 Microsoft .NET Framework 4.6.2，但是win7系统不支持安装 下载 需要升级为Windows 7 SP1 需要去官网下载 Windows 7 SP1 VR INSTALL 安装 https://toutyrater.github.io/prep/install.html Install wget https://install.direct/go.sh sudo bash go.sh 1234567893. check cat /etc/v2ray/config.json you will see the config,I won&#x27;t be change it4. ff $ sudo systemctl start v2ray 1234567891011121314 sudo: unable to resolve host vm8l5. $ cat /etc/hostname vm8lcxg8.hostflyte.com or you could use this[vr使用](https://github.com/233boy/v2ray/wiki/V2Ray%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B)* macOS useproxyGithub slowly git config --global http.proxy socks5://127.0.0.1:1081 git config –global https.proxy socks5:&#x2F;&#x2F;127.0.0.1:1081 123[终端使用代理加速的正确方式（Clash） | Ln&#x27;s Blog](https://weilining.github.io/294.html) export http_proxy&#x3D;http://127.0.0.1:7890 export https_proxy&#x3D;http://127.0.0.1:7890 123456789https://www.jianshu.com/p/5e74b1042b70GitHub 镜像 https://github.com/Zenquan/quickgitclonegit clone https://github.com.cnpmjs.org/android/media-samples.git sudo dscacheutil -flushcache 123456Terminal```bashexport http_proxy=&quot;http://127.0.0.1:13658&quot;export https_proxy=&quot;http://127.0.0.1:13658&quot; google 搭建vr 查看网络详情 -》防火墙 按照这个教程 https://zelikk.blogspot.com/2019/01/gcp-v2ray-firewall.html 网络标记就选了全部实例 注意复制的端口号 带上了逗号 ​ root身份运行 -bash: sudo: command not found 123dpkg -l|grep sudoapt-get install sudosudo apt-get install wget root运行 1sudo -i 安装 123wget https://install.direct/go.shsudo bash go.shsudo systemctl start v2ray 设置mac终端走ssr或者是v2ray代理 http://www.xiaosuiyin.com/2020/02/15/%E8%AE%BE%E7%BD%AEmac%E7%BB%88%E7%AB%AF%E8%B5%B0ssr%E6%88%96%E8%80%85%E6%98%AFv2ray%E4%BB%A3%E7%90%86/ https://github.com/233boy/v2ray/wiki/V2Ray%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B https://github.com/v2fly/fhs-install-v2ray/blob/master/README.zh-Hans-CN.md 注意配置 tcp端口 https://justmysocks3.net wordpress backup - YouTube bridge modehttps://www.bilibili.com/video/BV1wa411H7NJ/ - YouTube V2rayU 需要全局的才起作用 [https://pagespr.pages.dev/trojan] [https://workerpr.huaiyiheyuan.workers.dev/trojan123] [https://pagespr.pages.dev/trojan] client needs fragments 分片feature ws 端口(port)：7个http端口可任意选择(80、8080、8880、2052、2082、2086、2095) tls 端口(port)：6个https端口可任意选择(443、8443、2053、2083、2087、2096)","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://noteforme.github.io/categories/LINUX/"}],"tags":[]},{"title":"RecyclerView","slug":"RecyclerView","date":"2017-07-17T03:30:18.000Z","updated":"2024-12-24T11:35:45.102Z","comments":true,"path":"2017/07/17/RecyclerView/","link":"","permalink":"https://noteforme.github.io/2017/07/17/RecyclerView/","excerpt":"","text":"Question https://www.bilibili.com/video/BV1Fi4y1x7p5?from=search&amp;seid=3244755609076396172 RecycleView复用机制 无 问题3 适配不同类型的View布局，将用户界面显示与逻辑代码分离 无 基本使用https://github.com/googlesamples/android-RecyclerView http://blog.csdn.net/lmj623565791/article/details/51854533 http://blog.csdn.net/qibin0506/article/details/49716795 滑动RecyclerView系列_苏火火丶的博客-CSDN博客 我们在拖动DependencyView的时候，ImageView也跟随着DependencyView移动。当然这种依赖并非只有一对一的关系，也可能是一对多或者多对多。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_head&quot; app:layout_behavior=&quot;com.antiphon.recyclerviewdemo.weight.MyBehavior&quot; /&gt; &lt;com.antiphon.recyclerviewdemo.weight.DependencyView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorAccent&quot; android:padding=&quot;4dp&quot; android:text=&quot;DependencyView&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;18sp&quot; /&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 复用分析分析onCreateViewHolder onBindViewHolder和 view是怎么复用的 https://www.jianshu.com/p/ec6585e5220d 滑动坐标第一个左边 - 第二个坐标 所以负值 一定是往下滑 用栈数组保存不同类型回收的view 回收情况ScrollY 第一个可见Item的左上顶点 距离屏幕左上角的距离。 顶部item回收 往上滑动 ​ 当顶部item滑出屏幕，ScrollY的高度等于第一个item高度时，就被滑出了屏幕。 ​ 底部item再添加 网上滑动 ​ 当 屏幕显示的几个Item 长度 - ScrollY 刚好等于 屏幕高度，底部item之下再开始添加item。 ​ 因为ScrollY变大. 顶部item添加向下滑动 ScrollY &#x3D; 顶部item高度，顶部添加item 底部item回收 ScrollY &#x3D; 底部item高度，底部回收。 Jectpack Paginghttps://developer.android.com/topic/libraries/architecture/paging https://www.youtube.com/watch?v=BE5bsyGGLf4&amp;t=841s https://codelabs.developers.google.com/codelabs/android-paging/index.html?index=..%2F..%2Findex#1 ItemKeyedDataSource的子类需要实现loadInitial、loadAfter、loadBefore和getKey方法。它们分别的作用如下： loadInitial：此方法之后在用DataSource构建PageList的时候才会调用一次。用于进行加载初始化。 loadAfter：在每次RecyclerView滑动到底部没有数据的时候就会调用此方法进行数据的加载。 loadBefore：在每次RecyclerView滑动到顶部没有数据的时候就会调用此方法进行数据的加载。 getKey: 这返回下一个loadAfter调用所需要用到的key。就相当于链表的指针。 https://anriku.top/2018/09/25/Android%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD-Paging%E7%9A%84%E4%BD%BF%E7%94%A8/ https://github.com/fmtjava/Jetpack_GitHub https://github.com/Hankkin/JetPack_Note 解释 paging diff http://www.jeepxie.net/article/25492.html https://www.jianshu.com/p/bbb96fc62bcd https://www.jianshu.com/p/10bf4bf59122 https://juejin.im/post/5db06bb6518825646d79070b Item分类前面添加header, footer就用到了item分类reclverview也有很多分类方式 使用adapter 组合设计模式，进行组装，代码简洁，比较好操作多adapter分类 https://github.com/luizgrp/SectionedRecyclerViewAdapterhttp://blog.csdn.net/wzlyd1/article/details/52292548https://github.com/luizgrp/SectionedRecyclerViewAdapter https://github.com/donkingliang/GroupedRecyclerViewAdapter https://mp.weixin.qq.com/s/oCl4BQ8uB9ZDSOEKESM7hA 复杂布局: https://github.com/385841539/RecycleviewStaggered 竖直嵌套水平:https://github.com/drakeet/MultiType/issues/67 previewhttps://medium.com/aubergine-solutions/creating-recyclerview-layout-in-android-no-pain-only-gain-404280471003 12tools:itemCount=&quot;5&quot;tools:listitem=&quot;@layout/adapter_red_pack&quot; 1tools:src=&quot;@sample/RedPack.json/dataList/redEnvelopeMoney&quot; 问题使用recycleView中会遇到一些问题,总结一下 问题1下拉刷新 滑动列表 crash 使用下拉刷新的时候 往上滑动item会出现这样的错误 1234567891011121314151617E/CrashReport: sys default last handle start!FATAL EXCEPTION: main Process: com.huifu, PID: 22865 java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid item position 4(offset:4).state:10 at android.support.v7.widget.RecyclerView$Recycler.tryGetViewHolderForPositionByDeadline(RecyclerView.java:5504) at android.support.v7.widget.GapWorker.prefetchPositionWithDeadline(GapWorker.java:282) at android.support.v7.widget.GapWorker.flushTaskWithDeadline(GapWorker.java:336) at android.support.v7.widget.GapWorker.flushTasksWithDeadline(GapWorker.java:349) at android.support.v7.widget.GapWorker.prefetch(GapWorker.java:356) at android.support.v7.widget.GapWorker.run(GapWorker.java:387) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5417) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) 刷新之后数据清空，再滑动数据和item不一致, 情况数据应该在拿到数据之后, 使用下面这种方式解决问题， 123456789101112131415 @Override public void onRefresh() &#123;// if (!mProjectList.isEmpty()) &#123;// mProjectList.clear();// &#125; start = 0; loadData(); &#125;//拿到数据后 public void onSuccess(List&lt;Project&gt; projects) &#123; swipeInvest.setRefreshing(false); isloading = false; if (start == 0) mProjectList.clear(); &#125; http://blog.csdn.net/weixiao_812/article/details/78138075 下拉刷新时快速滑动崩溃的问题解决 问题2 界面不能展示 ,和ListView 不同的是RecyclerView不同,没设置下面的参数是不显示的 12mLayoutManager = new LinearLayoutManager(getActivity());rcvRrecord.setLayoutManager(mLayoutManager); 如果还是没有就看看 recycleview布局是否显示 https://blog.csdn.net/mjb00000/article/details/106014544 不用等数据来了后再显示 https://github.com/leobert-lan/Pandora RecyclerView拖拽功能https://www.jianshu.com/p/9605d14ddcc2 https://www.jianshu.com/p/b9a22f0c537d https://medium.com/@ipaulpro/drag-and-swipe-with-recyclerview-b9456d2b1aaf drag禁用 https://github.com/CymChad/BaseRecyclerViewAdapterHelper/issues/3378 BaseRecyclerViewAdapterHelpergetLayoutPosition getAdapterPosition区别 如果界面在notifyDataSetChanged()刷新所有数据,获取的adapterPosition 有可能会是-1,而layoutPosition获取到的还是旧的值. 如果使用但如果用的是notifyItemInserted(0),获取的adapterPosition就能立刻获取到新的值. 作者：JimmyZou92链接：https://juejin.cn/post/6999213411204595720来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 【世纪纠结】Jetpack Compose 和自定义 View，学哪个？","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"VideoAudio","slug":"VideoAudio","date":"2017-07-14T08:50:09.000Z","updated":"2021-08-19T11:11:44.259Z","comments":true,"path":"2017/07/14/VideoAudio/","link":"","permalink":"https://noteforme.github.io/2017/07/14/VideoAudio/","excerpt":"","text":"先安装codelabs把整个流程走一便，对库的使用有了整体的认识，https://codelabs.developers.google.com/codelabs/exoplayer-intro/#1 接着了解基本概念 语音转化 AudioApplication /Applications/VLC.app/Contents/MacOS/VLC –demux=rawaud –rawaud-channels 1 –rawaud-samplerate 44100 /Users/john/Desktop/audio/recording.pcm 声音声音三要素音调 : 音频的快慢 男生 &lt; 女生 &lt; 儿童 音量: 振动的幅度 音色: 谐波 PCM采样大小 ： 一个采样用多少bit存放。常用16bit 采样率 : 采样频率 8k , 16k , 32k, 44.1k 48k 声道数 ： 单声道 ， 双声道 ， 多声道 WAV![](/Users/john/Documents/noteforme.github.io/source/_posts/VideoAudio/Screen Shot 2021-03-07 at 5.21.18 PM.png) ![](/Users/john/Documents/noteforme.github.io/source/_posts/VideoAudio/Screen Shot 2021-03-07 at 5.23.23 PM.png) 采集命令采集12ffmpeg -f avfoundation -i :0 out.wav //采集ffplay out.wav //播放","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"}],"tags":[]},{"title":"MarkdownStnddard","slug":"Markdown-Standard","date":"2017-07-11T02:46:11.000Z","updated":"2025-02-04T13:55:28.241Z","comments":true,"path":"2017/07/11/Markdown-Standard/","link":"","permalink":"https://noteforme.github.io/2017/07/11/Markdown-Standard/","excerpt":"","text":"first blog 第一篇还没写 在CSDN写了一年多的博客也算是自己历程的简单记录，竟然莫名奇妙的就被封了，客服说被系统误封了，接着帮我解封，然而自己建博客就提前排上了日常，接着就是Google了，好在几天就建好了，开始吧 骚年！！！ ** Markdown规范** 1a b . DogsAnatomy of the dogCatsAnatomy of the cat参考: http://einverne.github.io/markdown-style-guide/zh.html","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"}],"tags":[]}],"categories":[{"name":"OS","slug":"OS","permalink":"https://noteforme.github.io/categories/OS/"},{"name":"CPP","slug":"CPP","permalink":"https://noteforme.github.io/categories/CPP/"},{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/categories/TOOL/"},{"name":"Computer Composition principles","slug":"Computer-Composition-principles","permalink":"https://noteforme.github.io/categories/Computer-Composition-principles/"},{"name":"JETPACK","slug":"JETPACK","permalink":"https://noteforme.github.io/categories/JETPACK/"},{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/categories/ANDROID/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/categories/DesignPattern/"},{"name":"Architecture","slug":"Architecture","permalink":"https://noteforme.github.io/categories/Architecture/"},{"name":"test","slug":"Architecture/test","permalink":"https://noteforme.github.io/categories/Architecture/test/"},{"name":"NETWORK","slug":"NETWORK","permalink":"https://noteforme.github.io/categories/NETWORK/"},{"name":"Library","slug":"Library","permalink":"https://noteforme.github.io/categories/Library/"},{"name":"JAVA","slug":"JAVA","permalink":"https://noteforme.github.io/categories/JAVA/"},{"name":"LIFE","slug":"LIFE","permalink":"https://noteforme.github.io/categories/LIFE/"},{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"https://noteforme.github.io/categories/INTERVIEW/"},{"name":"NETWORK","slug":"INTERVIEW/NETWORK","permalink":"https://noteforme.github.io/categories/INTERVIEW/NETWORK/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://noteforme.github.io/categories/Kotlin/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://noteforme.github.io/categories/DataStructure/"},{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/categories/VIEW/"},{"name":"Organization","slug":"Organization","permalink":"https://noteforme.github.io/categories/Organization/"},{"name":"flutter","slug":"flutter","permalink":"https://noteforme.github.io/categories/flutter/"},{"name":"Jetpack","slug":"Jetpack","permalink":"https://noteforme.github.io/categories/Jetpack/"},{"name":"anim","slug":"anim","permalink":"https://noteforme.github.io/categories/anim/"},{"name":"TEST","slug":"TEST","permalink":"https://noteforme.github.io/categories/TEST/"},{"name":"BLE","slug":"BLE","permalink":"https://noteforme.github.io/categories/BLE/"},{"name":"LINUX","slug":"LINUX","permalink":"https://noteforme.github.io/categories/LINUX/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://noteforme.github.io/tags/AOSP/"},{"name":"BE","slug":"BE","permalink":"https://noteforme.github.io/tags/BE/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://noteforme.github.io/tags/DesignPattern/"},{"name":"Library","slug":"Library","permalink":"https://noteforme.github.io/tags/Library/"},{"name":"LIFE","slug":"LIFE","permalink":"https://noteforme.github.io/tags/LIFE/"},{"name":"permission","slug":"permission","permalink":"https://noteforme.github.io/tags/permission/"},{"name":"ANDROID","slug":"ANDROID","permalink":"https://noteforme.github.io/tags/ANDROID/"},{"name":"compose","slug":"compose","permalink":"https://noteforme.github.io/tags/compose/"},{"name":"LEETCODE","slug":"LEETCODE","permalink":"https://noteforme.github.io/tags/LEETCODE/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://noteforme.github.io/tags/RecyclerView/"},{"name":"Fragment","slug":"Fragment","permalink":"https://noteforme.github.io/tags/Fragment/"},{"name":"TOOL","slug":"TOOL","permalink":"https://noteforme.github.io/tags/TOOL/"},{"name":"Performance","slug":"Performance","permalink":"https://noteforme.github.io/tags/Performance/"},{"name":"JVM","slug":"JVM","permalink":"https://noteforme.github.io/tags/JVM/"},{"name":"anim","slug":"anim","permalink":"https://noteforme.github.io/tags/anim/"},{"name":"coroutie","slug":"coroutie","permalink":"https://noteforme.github.io/tags/coroutie/"},{"name":"Assembly","slug":"Assembly","permalink":"https://noteforme.github.io/tags/Assembly/"},{"name":"concurrency","slug":"concurrency","permalink":"https://noteforme.github.io/tags/concurrency/"},{"name":"TouchEvent","slug":"TouchEvent","permalink":"https://noteforme.github.io/tags/TouchEvent/"},{"name":"RxJava","slug":"RxJava","permalink":"https://noteforme.github.io/tags/RxJava/"},{"name":"THINK","slug":"THINK","permalink":"https://noteforme.github.io/tags/THINK/"},{"name":"XML","slug":"XML","permalink":"https://noteforme.github.io/tags/XML/"},{"name":"Activity","slug":"Activity","permalink":"https://noteforme.github.io/tags/Activity/"},{"name":"Test","slug":"Test","permalink":"https://noteforme.github.io/tags/Test/"},{"name":"DB","slug":"DB","permalink":"https://noteforme.github.io/tags/DB/"},{"name":"VIEW","slug":"VIEW","permalink":"https://noteforme.github.io/tags/VIEW/"},{"name":"inter","slug":"inter","permalink":"https://noteforme.github.io/tags/inter/"},{"name":"Operators","slug":"Operators","permalink":"https://noteforme.github.io/tags/Operators/"},{"name":"Drawer","slug":"Drawer","permalink":"https://noteforme.github.io/tags/Drawer/"},{"name":"TabLayout","slug":"TabLayout","permalink":"https://noteforme.github.io/tags/TabLayout/"},{"name":"keyboard","slug":"keyboard","permalink":"https://noteforme.github.io/tags/keyboard/"},{"name":"proguard","slug":"proguard","permalink":"https://noteforme.github.io/tags/proguard/"},{"name":"AndroidNewFeatures","slug":"AndroidNewFeatures","permalink":"https://noteforme.github.io/tags/AndroidNewFeatures/"},{"name":"ENGLISH","slug":"ENGLISH","permalink":"https://noteforme.github.io/tags/ENGLISH/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://noteforme.github.io/tags/ConstraintLayout/"},{"name":"BLOG","slug":"BLOG","permalink":"https://noteforme.github.io/tags/BLOG/"}]}